-- ./docs/liliastackcode.lua


-- ./gamemode/cl_init.lua
DeriveGamemode("sandbox")
include("shared.lua")

-- ./gamemode/core/derma/f1menu/cl_classes.lua
local PANEL = {}
function PANEL:Init()
    lia.gui.classes = self
    local w, h = self:GetParent():GetSize()
    self:SetSize(w, h)
    self.sidebar = self:Add("DScrollPanel")
    self.sidebar:Dock(LEFT)
    self.sidebar:SetWide(200)
    self.sidebar:DockMargin(20, 20, 0, 20)
    self.mainContent = self:Add("DScrollPanel")
    self.mainContent:Dock(FILL)
    self.mainContent:DockMargin(10, 10, 10, 10)
    self.tabList = {}
    self:loadClasses()
end

function PANEL:loadClasses()
    local client = LocalPlayer()
    local list = {}
    for _, cl in pairs(lia.class.list) do
        if cl.faction == client:Team() then list[#list + 1] = cl end
    end

    table.sort(list, function(a, b) return a.name < b.name end)
    self.sidebar:Clear()
    self.tabList = {}
    for _, cl in ipairs(list) do
        local canBe = lia.class.canBe(LocalPlayer(), cl.index)
        local btn = self.sidebar:Add("liaMediumButton")
        btn:SetText(cl.name or L("unnamed"))
        btn:SetTall(50)
        btn:Dock(TOP)
        btn:DockMargin(0, 0, 10, 20)
        btn.DoClick = function()
            for _, b in ipairs(self.tabList) do
                b:SetSelected(b == btn)
            end

            self:populateClassDetails(cl, canBe)
        end

        self.tabList[#self.tabList + 1] = btn
    end
end

function PANEL:populateClassDetails(cl, canBe)
    self.mainContent:Clear()
    local container = self.mainContent:Add("DPanel")
    container:Dock(TOP)
    container:DockMargin(10, 10, 10, 10)
    container:SetTall(800)
    if cl.logo then
        local img = container:Add("DImage")
        img:SetImage(cl.logo)
        img:SetScaledSize(128, 128)
        img.Think = function() img:SetPos(container:GetWide() - img:GetWide() - 10, 10) end
    end

    self:createModelPanel(container, cl)
    self:addClassDetails(container, cl)
    self:addJoinButton(container, cl, canBe)
end

function PANEL:createModelPanel(parent, cl)
    local sizeX, sizeY = 300, 600
    local panel = parent:Add("liaModelPanel")
    panel:SetScaledSize(sizeX, sizeY)
    panel:SetFOV(35)
    local model = istable(cl.model) and cl.model[math.random(#cl.model)] or cl.model or LocalPlayer():GetModel()
    panel:SetModel(model)
    panel.rotationAngle = 45
    local ent = panel.Entity
    ent:SetSkin(cl.skin or 0)
    for _, bg in ipairs(cl.bodyGroups or {}) do
        ent:SetBodygroup(bg.id, bg.value or 0)
    end

    for i, mat in ipairs(cl.subMaterials or {}) do
        ent:SetSubMaterial(i - 1, mat)
    end

    panel.Think = function()
        if IsValid(ent) then
            panel:SetPos(parent:GetWide() - sizeX - 10, 100)
            if input.IsKeyDown(KEY_A) then
                panel.rotationAngle = panel.rotationAngle - 0.5
            elseif input.IsKeyDown(KEY_D) then
                panel.rotationAngle = panel.rotationAngle + 0.5
            end

            ent:SetAngles(Angle(0, panel.rotationAngle, 0))
        end
    end
end

function PANEL:addClassDetails(parent, cl)
    local client = LocalPlayer()
    local maxH, maxA, maxJ = client:GetMaxHealth(), client:GetMaxArmor(), client:GetJumpPower()
    local run, walk = lia.config.get("RunSpeed"), lia.config.get("WalkSpeed")
    local function add(text)
        local lbl = parent:Add("DLabel")
        lbl:SetFont("liaMediumFont")
        lbl:SetText(text)
        lbl:SetTextColor(color_white)
        lbl:SetWrap(true)
        lbl:Dock(TOP)
        lbl:DockMargin(10, 5, 10, 0)
    end

    add(L("name") .. ": " .. (cl.name or L("unnamed")))
    add(L("desc") .. ": " .. (cl.desc or L("noDesc")))
    add(L("faction") .. ": " .. (team.GetName(cl.faction) or L("none")))
    add(L("isDefaultLabel") .. ": " .. (cl.isDefault and L("yes") or L("no")))
    add(L("baseHealth") .. ": " .. tostring(cl.health or maxH))
    add(L("baseArmor") .. ": " .. tostring(cl.armor or maxA))
    local weps = cl.weapons or {}
    add(L("weapons") .. ": " .. (#weps > 0 and table.concat(weps, ", ") or L("none")))
    add(L("modelScale") .. ": " .. tostring(cl.scale or 1))
    local rs = cl.runSpeedMultiplier and math.Round(run * cl.runSpeed) or cl.runSpeed or run
    add(L("runSpeed") .. ": " .. tostring(rs))
    local ws = cl.walkSpeedMultiplier and math.Round(walk * cl.walkSpeed) or cl.walkSpeed or walk
    add(L("walkSpeed") .. ": " .. tostring(ws))
    local jp = cl.jumpPowerMultiplier and math.Round(maxJ * cl.jumpPower) or cl.jumpPower or maxJ
    add(L("jumpPower") .. ": " .. tostring(jp))
    local bloodMap = {
        [-1] = L("bloodNo"),
        [0] = L("bloodRed"),
        [1] = L("bloodYellow"),
        [2] = L("bloodGreenRed"),
        [3] = L("bloodSparks"),
        [4] = L("bloodAntlion"),
        [5] = L("bloodZombie"),
        [6] = L("bloodAntlionBright")
    }

    add(L("bloodColor") .. ": " .. (bloodMap[cl.bloodcolor] or L("bloodRed")))
    if cl.requirements then
        local req = istable(cl.requirements) and table.concat(cl.requirements, ", ") or tostring(cl.requirements)
        add(L("requirements") .. ": " .. req)
    end
end

function PANEL:addJoinButton(parent, cl, canBe)
    local isCurrent = LocalPlayer():getChar() and LocalPlayer():getChar():getClass() == cl.index
    local btn = parent:Add("liaMediumButton")
    btn:SetText(isCurrent and L("alreadyInClass") or canBe and L("joinClass") or L("classRequirementsNotMet"))
    btn:SetTall(40)
    local col = lia.color.ReturnMainAdjustedColors().text
    btn:SetTextColor(col)
    btn:SetFont("liaMediumFont")
    btn:SetExpensiveShadow(1, Color(0, 0, 0, 100))
    btn:SetContentAlignment(5)
    btn:Dock(BOTTOM)
    btn:DockMargin(10, 10, 10, 10)
    btn:SetDisabled(isCurrent or not canBe)
    btn.DoClick = function()
        if canBe and not isCurrent then
            lia.command.send("beclass", cl.index)
            timer.Simple(0.1, function()
                if IsValid(self) then
                    self:loadClasses()
                    self.mainContent:Clear()
                end
            end)
        end
    end
end

vgui.Register("liaClasses", PANEL, "EditablePanel")

-- ./gamemode/core/derma/f1menu/cl_information.lua
local PANEL = {}
function PANEL:Init()
    if IsValid(lia.gui.info) then lia.gui.info:Remove() end
    lia.gui.info = self
    self:SetSize(ScrW(), ScrH() * 0.8)
    self:SetPos(50, 50)
    self.Paint = function() end
    local frame = vgui.Create("DFrame", self)
    frame:SetTitle("")
    frame:SetSize(ScrW() * 0.85, ScrH())
    frame:ShowCloseButton(false)
    frame:SetDraggable(false)
    frame.Paint = function() end
    self.info = frame
    local scroll = vgui.Create("DScrollPanel", frame)
    scroll:Dock(FILL)
    scroll.Paint = function() end
    local content = scroll:GetCanvas()
    content:DockPadding(8, 10, 8, 10)
    content.Paint = function() end
    self.content = content
    hook.Run("LoadCharInformation")
    self:GenerateSections()
    timer.Create("liaCharInfo_UpdateValues", 1, 0, function()
        if IsValid(self) then
            self:setup()
        else
            timer.Remove("liaCharInfo_UpdateValues")
        end
    end)
end

function PANEL:GenerateSections()
    local info = lia.module.list["f1menu"].CharacterInformation
    local sections = {}
    for name, data in pairs(info) do
        sections[#sections + 1] = {
            name = name,
            data = data
        }
    end

    table.sort(sections, function(a, b) return a.data.priority < b.data.priority end)
    for _, sec in ipairs(sections) do
        local data = sec.data
        self:CreateSection(self.content, sec.name, data.color)
        local fields = isfunction(data.fields) and data.fields() or data.fields
        for _, f in ipairs(fields) do
            if f.type == "text" then
                self:CreateTextEntryWithBackgroundAndLabel(self.content, f.name, f.label, 5, f.value)
            elseif f.type == "bar" then
                self:CreateFillableBarWithBackgroundAndLabel(self.content, f.name, f.label, f.min, f.max, 5, f.value)
            end

            self:AddSpacer(self.content, 5)
        end
    end
end

function PANEL:CreateTextEntryWithBackgroundAndLabel(parent, name, labelText, marginBot, valueFunc)
    local entry = parent:Add("DPanel")
    entry:Dock(TOP)
    entry:DockMargin(0, 0, 0, marginBot or 0)
    entry:SetTall(25)
    local lbl = entry:Add("DLabel")
    lbl:Dock(LEFT)
    lbl:SetFont("liaSmallFont")
    lbl:SetText(labelText or "")
    lbl:SizeToContents()
    local lw, _ = lbl:GetSize()
    lbl:SetWide(lw + 20)
    lbl:DockMargin(0, 0, 10, 0)
    lbl:SetContentAlignment(5)
    lbl:SetTextColor(color_white)
    local txt = entry:Add("DTextEntry")
    txt:Dock(FILL)
    txt:SetFont("liaSmallFont")
    txt:SetTall(20)
    txt:SetTextColor(color_white)
    local isDesc = (name or ""):lower() == "desc"
    txt:SetEditable(isDesc)
    if isfunction(valueFunc) then
        local v = valueFunc()
        if isstring(v) then txt:SetText(v) end
    end

    txt.OnLoseFocus = function(selfEntry)
        if isDesc then
            local t = selfEntry:GetValue()
            if isstring(t) then lia.command.send("chardesc", t) end
        end
    end

    self[name] = txt
end

function PANEL:CreateFillableBarWithBackgroundAndLabel(parent, name, labelText, minFunc, maxFunc, margin, valueFunc)
    local entry = parent:Add("DPanel")
    entry:Dock(TOP)
    entry:DockMargin(0, margin or 0, 0, margin or 0)
    entry:SetTall(30)
    local lbl = entry:Add("DLabel")
    lbl:Dock(LEFT)
    lbl:SetFont("liaSmallFont")
    lbl:SetText(labelText or "")
    lbl:SizeToContents()
    lbl:SetWide(lbl:GetWide() + 20)
    lbl:DockMargin(0, 0, 10, 0)
    lbl:SetContentAlignment(5)
    lbl:SetTextColor(color_white)
    local bar = entry:Add("DProgressBar")
    bar:Dock(FILL)
    bar:SetBarColor(Color(45, 45, 45, 255))
    local function updateBar()
        local mn = isfunction(minFunc) and minFunc() or tonumber(minFunc) or 0
        local mx = isfunction(maxFunc) and maxFunc() or tonumber(maxFunc) or 1
        local val = isfunction(valueFunc) and valueFunc() or tonumber(valueFunc) or 0
        local frac = mx > mn and math.Clamp((val - mn) / (mx - mn), 0, 1) or 0
        bar:SetFraction(frac)
        bar:SetText(string.format("%d / %d", math.Round(val), math.Round(mx)))
    end

    function bar:Think()
        updateBar()
    end

    parent[name] = bar
    return bar
end

function PANEL:AddSpacer(parent, height)
    local sp = parent:Add("DPanel")
    sp:Dock(TOP)
    sp:SetTall(height)
    sp.Paint = function() end
end

function PANEL:CreateSection(parent, title, color)
    local sec = parent:Add("DPanel")
    sec:Dock(TOP)
    sec:DockMargin(0, 10, 0, 10)
    sec:SetTall(30)
    sec.Paint = function(_, w, h)
        surface.SetDrawColor(color)
        surface.DrawRect(0, 0, w, h)
        draw.SimpleText(title, "liaSmallFont", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

function PANEL:Refresh()
    self.content:Clear()
    self:GenerateSections()
end

function PANEL:setup()
    local info = lia.module.list["f1menu"].CharacterInformation
    for _, data in pairs(info) do
        local fields = isfunction(data.fields) and data.fields() or data.fields
        for _, f in ipairs(fields) do
            local ctrl = self[f.name]
            if ctrl and f.type == "text" and f.name:lower() ~= "desc" then ctrl:SetText(f.value()) end
        end
    end
end

vgui.Register("liaCharInfo", PANEL, "EditablePanel")

-- ./gamemode/core/derma/f1menu/cl_menu.lua
local PANEL = {}
function PANEL:Init()
    lia.gui.menu = self
    self:SetSize(ScrW(), ScrH())
    self:SetAlpha(0)
    self:AlphaTo(255, 0.25, 0)
    self:SetPopupStayAtBack(true)
    self.noAnchor = CurTime() + 0.4
    self.anchorMode = true
    self.invKey = lia.keybind.get("Open Inventory", KEY_I)
    local sidebar = self:Add("DPanel")
    sidebar:Dock(RIGHT)
    sidebar:SetWide(200)
    sidebar.Paint = function() end
    self.sidebar = sidebar
    local scroll = sidebar:Add("DScrollPanel")
    scroll:Dock(FILL)
    scroll:SetPadding(30)
    scroll:DockMargin(0, 20, 0, 0)
    scroll:SetPaintBackground(false)
    self.scroll = scroll
    local tabs = scroll:Add("DListLayout")
    tabs:Dock(FILL)
    self.tabs = tabs
    local panel = self:Add("EditablePanel")
    panel:Dock(FILL)
    panel:SetAlpha(0)
    panel.Paint = function() end
    self.panel = panel
    local btnDefs = {}
    hook.Run("CreateMenuButtons", btnDefs)
    local keys = {}
    for key in pairs(btnDefs) do
        keys[#keys + 1] = key
    end

    table.sort(keys, function(a, b) return #L(a) < #L(b) end)
    self.tabList = {}
    for _, key in ipairs(keys) do
        local cb = btnDefs[key]
        if type(cb) == "string" then
            local body = cb
            if body:sub(1, 4) == "http" then
                cb = function(p)
                    local html = p:Add("DHTML")
                    html:Dock(FILL)
                    html:OpenURL(body)
                end
            else
                cb = function(p)
                    local html = p:Add("DHTML")
                    html:Dock(FILL)
                    html:SetHTML(body)
                end
            end
        end

        local tab = self:addTab(key, cb, key)
        self.tabList[key] = tab
    end

    self:MakePopup()
    self:setActiveTab(L("status"))
end

function PANEL:addTab(name, callback, uniqueID)
    local colors = lia.color.ReturnMainAdjustedColors()
    local text = L(name)
    local tab = self.tabs:Add("liaSmallButton")
    tab:SetText(text)
    tab:SetFont("liaMediumFont")
    tab:SetTextColor(colors.text)
    tab:SetExpensiveShadow(1, Color(0, 0, 0, 100))
    tab:SetContentAlignment(5)
    tab:Dock(TOP)
    tab:SetTall(50)
    tab:DockMargin(0, 0, 10, 10)
    tab.text_color = colors.text
    tab.DoClick = function()
        if IsValid(lia.gui.info) then lia.gui.info:Remove() end
        for _, t in pairs(self.tabList) do
            t:SetSelected(false)
        end

        tab:SetSelected(true)
        self.activeTab = tab
        lastMenuTab = uniqueID
        self.panel:Clear()
        self.panel:AlphaTo(255, 0.3, 0)
        if callback then callback(self.panel) end
    end
    return tab
end

function PANEL:setActiveTab(key)
    local tab = self.tabList[key]
    if IsValid(tab) then
        tab:DoClick()
        tab:SetSelected(true)
    end
end

function PANEL:remove()
    CloseDermaMenus()
    if not self.closing then
        self:AlphaTo(0, 0.25, 0, function() self:Remove() end)
        self.closing = true
    end
end

function PANEL:OnKeyCodePressed(key)
    self.noAnchor = CurTime() + 0.5
    if key == KEY_F1 or key == self.invKey then self:remove() end
end

function PANEL:Update()
    self:Remove()
    vgui.Create("liaMenu")
end

function PANEL:Think()
    if gui.IsGameUIVisible() or gui.IsConsoleVisible() then
        self:remove()
        return
    end

    if input.IsKeyDown(KEY_F1) and CurTime() > self.noAnchor and self.anchorMode then
        self.anchorMode = false
        surface.PlaySound("buttons/lightswitch2.wav")
    end

    if not self.anchorMode and not input.IsKeyDown(KEY_F1) and not IsValid(self.info) then self:remove() end
end

function PANEL:Paint()
    lia.util.drawBlur(self)
end

vgui.Register("liaMenu", PANEL, "EditablePanel")

-- ./gamemode/core/derma/mainmenu/bg_music.lua
local PANEL = {}
function PANEL:Init()
    if lia.menuMusic then
        lia.menuMusic:Stop()
        lia.menuMusic = nil
    end

    timer.Remove("liaMusicFader")
    self:SetVisible(false)
    local src = lia.config.get("Music", "")
    if not src:match("%S") then return end
    local vol = lia.config.get("MusicVolume", 0.25)
    local function play(music)
        music:SetVolume(vol)
        lia.menuMusic = music
        music:Play()
    end

    if src:match("^https://") then
        http.Fetch(src, function(body)
            local path = "lia_temp_music.mp3"
            file.Write(path, body)
            sound.PlayFile("DATA/" .. path, "noplay", function(m) if m then play(m) end end)
        end)
    elseif src:match("^http") then
        sound.PlayURL(src, "noplay", function(m) if m then play(m) end end)
    else
        sound.PlayFile("sound/" .. src, "noplay", function(m) if m then play(m) end end)
    end
end

function PANEL:OnRemove()
    local music = lia.menuMusic
    if not music then return end
    lia.menuMusic = nil
    timer.Remove("liaMusicFader")
    local vol = lia.config.get("MusicVolume", 0.25)
    local start = RealTime()
    timer.Create("liaMusicFader", 0.1, 0, function()
        if not music then return timer.Remove("liaMusicFader") end
        local frac = math.max(0, 1 - (RealTime() - start) / 5)
        if music.ChangeVolume then
            music:ChangeVolume(frac * vol, 0.1)
        else
            music:SetVolume(frac * vol)
        end

        if frac <= 0 then
            music:Stop()
            timer.Remove("liaMusicFader")
        end
    end)
end

vgui.Register("liaCharBGMusic", PANEL, "DPanel")

-- ./gamemode/core/derma/mainmenu/character.lua
local PANEL = {}
function PANEL:Init()
    local client = LocalPlayer()
    local clientChar = client.getChar and client:getChar()
    self.disableClientModel = false
    self.noBlur = not clientChar
    self.isLoadMode = false
    if IsValid(lia.gui.loading) then lia.gui.loading:Remove() end
    if IsValid(lia.gui.character) then lia.gui.character:Remove() end
    lia.gui.character = self
    if not render.oldDrawBeam then
        render.oldDrawBeam = render.DrawBeam
        render.DrawBeam = function(startPos, endPos, width, textureStart, textureEnd, color)
            if IsValid(lia.gui.character) then return end
            return render.oldDrawBeam(startPos, endPos, width, textureStart, textureEnd, color)
        end
    end

    hook.Add("PreDrawPhysgunBeam", "DisablePhysgunBeam", function() return IsValid(lia.gui.character) end)
    self:Dock(FILL)
    self:MakePopup()
    self:SetAlpha(0)
    self:AlphaTo(255, 0.2)
    self.tabs = self:Add("DPanel")
    self.tabs:Dock(TOP)
    self.tabs:DockMargin(64, 32, 64, 0)
    self.tabs:SetTall(48)
    self.tabs:SetPaintBackground(false)
    self.content = self:Add("DPanel")
    self.content:Dock(FILL)
    self.content:DockMargin(64, 0, 64, 64)
    self.content:SetPaintBackground(false)
    self.music = self:Add("liaCharBGMusic")
    self:createTitle()
    self:loadBackground()
    if clientChar and lia.characters and #lia.characters > 0 then
        for i, charID in ipairs(lia.characters) do
            local charObj = type(charID) == "number" and lia.char.loaded[charID] or charID
            if charObj and charObj.getID and charObj:getID() == clientChar:getID() then
                self.currentIndex = i
                break
            end
        end

        self.currentIndex = self.currentIndex or 1
    end

    self:createStartButton()
end

function PANEL:createTitle()
    if self.tabs then self.tabs:DockMargin(64, 32, 64, 0) end
end

function PANEL:loadBackground()
    if self.isLoadMode then
        hook.Add("PrePlayerDraw", "liaCharacter_StopDrawPlayers", function() return true end)
        self:updateSelectedCharacter()
        if not IsValid(self.leftArrow) and #lia.characters > 1 then self:createArrows() end
        hook.Add("CalcView", "liaCharacterMenuCalcView", function(_, _, _, fov)
            local ent = self.modelEntity
            if not IsValid(ent) then return end
            local center = ent:GetPos() + Vector(0, 0, 60)
            local desired = center + ent:GetForward() * 70
            self.currentCamPos = self.currentCamPos and LerpVector(FrameTime() * 5, self.currentCamPos, desired) or desired
            return {
                origin = self.currentCamPos,
                angles = (center - self.currentCamPos):Angle(),
                fov = fov,
                drawviewer = true
            }
        end)
    else
        if IsValid(self.modelEntity) then self.modelEntity:Remove() end
        if IsValid(self.leftArrow) then
            self.leftArrow:Remove()
            self.leftArrow = nil
        end

        if IsValid(self.rightArrow) then
            self.rightArrow:Remove()
            self.rightArrow = nil
        end

        local url = lia.config.get("BackgroundURL")
        if url and url:find("%S") then
            self.background = self:Add("DHTML")
            self.background:SetSize(ScrW(), ScrH())
            if url:find("http") then
                self.background:OpenURL(url)
            else
                self.background:SetHTML(url)
            end

            self.background.OnDocumentReady = function() if IsValid(self.bgLoader) then self.bgLoader:AlphaTo(0, 2, 1, function() self.bgLoader:Remove() end) end end
            self.background:MoveToBack()
            self.background:SetZPos(-999)
            if lia.config.get("CharMenuBGInputDisabled") then
                self.background:SetMouseInputEnabled(false)
                self.background:SetKeyboardInputEnabled(false)
            end

            self.bgLoader = self:Add("DPanel")
            self.bgLoader:SetSize(ScrW(), ScrH())
            self.bgLoader:SetZPos(-998)
            self.bgLoader.Paint = function(_, w, h)
                surface.SetDrawColor(5, 5, 5)
                surface.DrawRect(0, 0, w, h)
            end
        end
    end
end

function PANEL:createStartButton()
    local client = LocalPlayer()
    if not IsValid(client) then
        timer.Simple(0.1, function() if IsValid(self) then self:createStartButton() end end)
        return
    end

    local clientChar = client.getChar and client:getChar()
    local w, h, s = ScrW() * 0.2, ScrH() * 0.04, ScrH() * 0.01
    local logoPath, discordURL, workshopURL = lia.config.get("CenterLogo"), lia.config.get("DiscordURL"), lia.config.get("Workshop")
    local buttonsData = {}
    if hook.Run("CanPlayerCreateChar", client) ~= false then
        table.insert(buttonsData, {
            id = "create",
            text = L("createCharacter"),
            doClick = function()
                for _, b in pairs(self.buttons) do
                    if IsValid(b) then b:Remove() end
                end

                self:clickSound()
                self.isLoadMode = false
                self:showContent(true)
                self:createCharacterCreation()
            end
        })
    end

    if lia.characters and #lia.characters > 0 then
        table.insert(buttonsData, {
            id = "load",
            text = L("loadCharacter"),
            doClick = function()
                for _, b in pairs(self.buttons) do
                    if IsValid(b) then b:Remove() end
                end

                self:clickSound()
                self.isLoadMode = true
                self:showContent(true)
                self:createCharacterSelection()
            end
        })
    end

    if discordURL ~= "" then
        table.insert(buttonsData, {
            id = "discord",
            text = L("discord"),
            doClick = function()
                self:clickSound()
                gui.OpenURL(discordURL)
            end
        })
    end

    if workshopURL ~= "" then
        table.insert(buttonsData, {
            id = "workshop",
            text = L("steamWorkshop"),
            doClick = function()
                self:clickSound()
                gui.OpenURL(workshopURL)
            end
        })
    end

    table.insert(buttonsData, {
        id = "disconnect",
        text = L("disconnect"),
        doClick = function()
            self:clickSound()
            RunConsoleCommand("disconnect")
        end
    })

    if clientChar then
        table.insert(buttonsData, {
            id = "return",
            text = L("return"),
            doClick = function() self:Remove() end
        })
    end

    self.buttons = {}
    for i, data in ipairs(buttonsData) do
        local x, y = ScrW() / 2 - w / 2, ScrH() * 0.3 + (i - 1) * (h + s)
        local btn = self:Add("liaMediumButton")
        btn:SetSize(w, h)
        btn:SetPos(x, y)
        btn:SetText(string.upper(data.text))
        btn.DoClick = data.doClick
        btn.OnCursorEntered = function() surface.PlaySound("ui/hover.wav") end
        local oldSetPos = btn.SetPos
        btn.SetPos = function(b, nx, ny)
            oldSetPos(b, nx, ny)
            if IsValid(self) then self:UpdateLogoPosition() end
        end

        self.buttons[data.id] = btn
    end

    if logoPath ~= "" then
        local function setLogo(img)
            if not IsValid(self) then return end
            img:SetZPos(9999)
            self:UpdateLogoPosition()
            timer.Simple(0, function() if IsValid(img) then img:MoveToFront() end end)
        end

        if logoPath:sub(1, 8) == "https://" then
            http.Fetch(logoPath, function(body)
                if not IsValid(self) then return end
                file.Write("temp_logo.png", body)
                self.logo = self:Add("DImage")
                self.logo:SetImage("data/temp_logo.png")
                setLogo(self.logo)
            end)
        else
            self.logo = self:Add("DImage")
            self.logo:SetImage(logoPath)
            setLogo(self.logo)
        end
    end
end

function PANEL:addTab(name, callback, justClick, height)
    local btn = self.tabs:Add("liaMediumButton")
    local label = L(name):upper()
    btn:SetText(label)
    surface.SetFont(btn:GetFont())
    local textW, textH = surface.GetTextSize(label)
    btn:SetWide(textW + 40)
    btn:SetTall(height or textH + 20)
    if justClick then
        if isfunction(callback) then btn.DoClick = function() callback(self) end end
        return btn
    end

    btn.DoClick = function(b) b:setSelected(true) end
    if isfunction(callback) then btn:onSelected(function() callback(self) end) end
    return btn
end

function PANEL:createTabs()
    self.tabs:Clear()
    self:addTab(L("return"), function() self:backToMainMenu() end, true)
end

function PANEL:backToMainMenu()
    self:clickSound()
    if IsValid(self.infoFrame) then self.infoFrame:Remove() end
    if IsValid(self.leftArrow) then
        self.leftArrow:Remove()
        self.leftArrow = nil
    end

    if IsValid(self.rightArrow) then
        self.rightArrow:Remove()
        self.rightArrow = nil
    end

    self.isLoadMode = false
    self.disableClientModel = false
    self.content:Clear()
    self.tabs:Clear()
    self:createStartButton()
    self:loadBackground()
end

function PANEL:createCharacterSelection()
    self.isLoadMode = true
    for _, name in ipairs{"background", "logo"} do
        if IsValid(self[name]) then
            self[name]:Remove()
            self[name] = nil
        end
    end

    for _, b in pairs(self.buttons or {}) do
        if IsValid(b) then b:Remove() end
    end

    self.buttons = {}
    if IsValid(self.leftArrow) then
        self.leftArrow:Remove()
        self.leftArrow = nil
    end

    if IsValid(self.rightArrow) then
        self.rightArrow:Remove()
        self.rightArrow = nil
    end

    self.content:Clear()
    self.content:InvalidateLayout(true)
    self:updateSelectedCharacter()
    if #lia.characters > 1 then self:createArrows() end
end

function PANEL:createCharacterCreation()
    for _, name in ipairs{"background", "logo"} do
        if IsValid(self[name]) then
            self[name]:Remove()
            self[name] = nil
        end
    end

    for _, b in pairs(self.buttons or {}) do
        if IsValid(b) then b:Remove() end
    end

    self.buttons = {}
    if IsValid(self.bgLoader) then self.bgLoader:Remove() end
    self.content:Clear()
    self.content:InvalidateLayout(true)
    self.content:Add("liaCharacterCreation")
end

function PANEL:updateSelectedCharacter()
    if not self.isLoadMode then return end
    local chars = lia.characters
    if not chars or #chars == 0 then return end
    self.currentIndex = self.currentIndex or 1
    local sel = chars[self.currentIndex] or chars[1]
    local character = lia.char.loaded[sel]
    if IsValid(self.infoFrame) then self.infoFrame:Remove() end
    self:createSelectedCharacterInfoPanel(character)
    self:updateModelEntity(character)
end

function PANEL:createSelectedCharacterInfoPanel(character)
    if not character then return end
    local info = {L("name") .. ": " .. (character:getName() or ""), L("desc") .. ":", character:getDesc() or "", L("faction") .. ": " .. (team.GetName(character:getFaction()) or "")}
    if character:getClass() then
        local cls = lia.class.list[character:getClass()]
        if cls and cls.name then table.insert(info, L("class") .. ": " .. cls.name) end
    end

    table.insert(info, L("moneyLabel") .. ": " .. lia.currency.get(character:getMoney()))
    hook.Run("LoadMainMenuInformation", info, character)
    self.infoFrame = self:Add("SemiTransparentDFrame")
    self.infoFrame:SetSize(ScrW() * 0.25, ScrH() * 0.45)
    self.infoFrame:SetPos(ScrW() * 0.75 - 50, ScrH() * 0.25)
    self.infoFrame:SetTitle("")
    self.infoFrame:SetDraggable(false)
    self.infoFrame:ShowCloseButton(false)
    local scroll = vgui.Create("DScrollPanel", self.infoFrame)
    scroll:Dock(FILL)
    for _, text in ipairs(info) do
        local lbl = scroll:Add("DLabel")
        lbl:Dock(TOP)
        lbl:DockMargin(10, 10, 10, 0)
        lbl:SetFont("liaMediumFont")
        lbl:SetWrap(true)
        lbl:SetAutoStretchVertical(true)
        lbl:SetTextColor(Color(255, 255, 255))
        lbl:SetText(text)
        lbl:SizeToContentsY()
    end

    local btnCon = self.infoFrame:Add("DPanel")
    btnCon:Dock(BOTTOM)
    btnCon:SetTall(100)
    btnCon:SetPaintBackground(false)
    local frameW, frameH = self.infoFrame:GetWide(), btnCon:GetTall()
    local btnW, btnH = frameW * 0.75, 40
    local padding = 10
    local xPos = (frameW - btnW) / 2
    local topY = padding / 2
    local bottomY = frameH - btnH - padding
    local selectBtn = vgui.Create("liaSmallButton", btnCon)
    selectBtn:SetSize(btnW, btnH)
    selectBtn:SetPos(xPos, topY)
    local clientChar = LocalPlayer().getChar and LocalPlayer():getChar()
    local selectText = L("selectCharacter")
    if clientChar and character:getID() == clientChar:getID() then
        selectText = L("alreadyUsingCharacter")
    elseif character:getData("banned") then
        selectText = L("bannedCharacter")
    end

    selectBtn:SetText(selectText)
    if clientChar and character:getID() == clientChar:getID() or character:getData("banned") then
        selectBtn:SetEnabled(false)
        selectBtn:SetTextColor(Color(255, 255, 255))
    end

    selectBtn.DoClick = function()
        lia.module.list["mainmenu"]:chooseCharacter(character:getID())
        self:Remove()
    end

    local deleteBtn = vgui.Create("liaSmallButton", btnCon)
    deleteBtn:SetSize(btnW, btnH)
    deleteBtn:SetPos(xPos, bottomY)
    deleteBtn:SetText(L("deleteCharacter"))
    deleteBtn.DoClick = function()
        if hook.Run("CanDeleteChar", character:getID()) == false then
            LocalPlayer():notifyLocalized("cannotDeleteChar")
            return
        end

        vgui.Create("liaCharacterConfirm"):setMessage(L("charDeletionCannotUndone")):onConfirm(function() lia.module.list["mainmenu"]:deleteCharacter(character:getID()) end)
    end
end

function PANEL:updateModelEntity(character)
    if IsValid(self.modelEntity) then self.modelEntity:Remove() end
    if not character then return end
    local model = character.getModel and character:getModel() or LocalPlayer():GetModel()
    self.modelEntity = ClientsideModel(model, RENDERGROUP_OPAQUE)
    if not IsValid(self.modelEntity) then return end
    self.modelEntity:SetSkin(character:getData("skin", 0))
    for i = 0, self.modelEntity:GetNumBodyGroups() - 1 do
        local groups = character:getData("groups", {})
        if groups[i] then self.modelEntity:SetBodygroup(i, groups[i]) end
    end

    local pos, ang = hook.Run("GetMainMenuPosition", character)
    if not pos or not ang then
        local spawns = ents.FindByClass("info_player_start")
        pos = #spawns > 0 and spawns[1]:GetPos() or Vector()
        ang = #spawns > 0 and spawns[1]:GetAngles() or Angle()
    end

    ang.pitch, ang.roll = 0, 0
    self.modelEntity:SetPos(pos)
    self.modelEntity:SetAngles(ang)
    for _, seq in ipairs(self.modelEntity:GetSequenceList()) do
        if seq:lower():find("idle") and seq ~= "idlenoise" then
            self.modelEntity:ResetSequence(seq)
            self.modelEntity:SetCycle(0)
            break
        end
    end

    hook.Run("ModifyCharacterModel", self.modelEntity, character)
    hook.Add("PostDrawOpaqueRenderables", self, function()
        if IsValid(self.modelEntity) then
            self.modelEntity:FrameAdvance(RealFrameTime())
            self.modelEntity:DrawModel()
        end
    end)
end

function PANEL:createArrows()
    local size, space = 100, 240
    local function newArrow(sign, xOffset)
        local btn = self:Add("liaBigButton")
        btn:SetSize(size, size)
        btn:SetPos(ScrW() * 0.5 + xOffset, ScrH() * 0.5 - size * 0.5)
        btn:SetFont("liaHugeFont")
        btn:SetText(sign)
        btn.OnCursorEntered = function() surface.PlaySound("ui/hover.wav") end
        btn.DoClick = function()
            if not self.isLoadMode or not lia.characters or #lia.characters == 0 then return end
            self.currentIndex = self.currentIndex + (sign == "<" and -1 or 1)
            if self.currentIndex < 1 then self.currentIndex = #lia.characters end
            if self.currentIndex > #lia.characters then self.currentIndex = 1 end
            self:clickSound()
            self:updateSelectedCharacter()
        end
        return btn
    end

    self.leftArrow = newArrow("<", -size - space)
    self.rightArrow = newArrow(">", space)
end

function PANEL:UpdateLogoPosition()
    if not IsValid(self.logo) then return end
    local pad = ScrH() * 0.01
    local logoW, logoH = ScrW() * 0.13 * 0.95, ScrW() * 0.13 * 0.95
    local left, right, top = math.huge, -math.huge, math.huge
    for _, v in pairs(self.buttons) do
        if IsValid(v) then
            local x, y = v:GetPos()
            left, right, top = math.min(left, x), math.max(right, x + v:GetWide()), math.min(top, y)
        end
    end

    top = top == math.huge and ScrH() / 2 or top
    local center = (left + right) / 2
    self.logo:SetPos(center - logoW * 0.5, top - logoH - pad)
    self.logo:SetSize(logoW, logoH)
end

function PANEL:showContent(disableBg)
    if IsValid(self.infoFrame) then self.infoFrame:Remove() end
    if IsValid(self.leftArrow) then
        self.leftArrow:Remove()
        self.leftArrow = nil
    end

    if IsValid(self.rightArrow) then
        self.rightArrow:Remove()
        self.rightArrow = nil
    end

    if IsValid(self.logo) then
        self.logo:Remove()
        self.logo = nil
    end

    for _, b in pairs(self.buttons or {}) do
        if IsValid(b) then b:Remove() end
    end

    self.buttons = {}
    self.disableClientModel = true
    self:removeClientModelModifications()
    if IsValid(self.modelEntity) then self.modelEntity:Remove() end
    self.tabs:Clear()
    self.content:Clear()
    self:createTabs()
    self.noBlur = self.isLoadMode or false
    if self.isLoadMode or not disableBg then self:loadBackground() end
end

function PANEL:removeClientModelModifications()
    hook.Remove("PrePlayerDraw", "liaCharacter_StopDrawPlayers")
    if not self.isLoadMode then hook.Remove("CalcView", "liaCharacterMenuCalcView") end
    hook.Remove("PostDrawOpaqueRenderables", self)
end

function PANEL:setFadeToBlack(fade)
    local d = deferred.new()
    if fade then
        if IsValid(self.fade) then self.fade:Remove() end
        local p = vgui.Create("DPanel")
        p:SetSize(ScrW(), ScrH())
        p:SetSkin("Default")
        p:SetBackgroundColor(color_black)
        p:SetAlpha(0)
        p:AlphaTo(255, 0.5, 0, function() d:resolve() end)
        p:SetZPos(999)
        p:MakePopup()
        self.fade = p
    else
        if IsValid(self.fade) then
            local p = self.fade
            p:AlphaTo(0, 0.5, 0, function()
                p:Remove()
                d:resolve()
            end)
        end
    end
    return d
end

function PANEL:fadeOut()
    self:AlphaTo(0, 0.1, 0, function() self:Remove() end)
end

function PANEL:Paint(w, h)
    if not self.noBlur then lia.util.drawBlur(self) end
    self:paintBackground(w, h)
end

function PANEL:paintBackground(w, h)
    if not IsValid(self.background) and self.blank then
        surface.SetDrawColor(42, 42, 42, 179)
        surface.DrawRect(0, 0, w, h)
    end
end

function PANEL:hoverSound()
    LocalPlayer():EmitSound("buttons/button15.wav", 35, 250)
end

function PANEL:clickSound()
    LocalPlayer():EmitSound("buttons/button14.wav", 35, 255)
end

function PANEL:warningSound()
    LocalPlayer():EmitSound("friends/friend_join.wav", 40, 255)
end

function PANEL:OnRemove()
    hook.Remove("PrePlayerDraw", "liaCharacter_StopDrawPlayers")
    hook.Remove("CalcView", "liaCharacterMenuCalcView")
    hook.Remove("PostDrawOpaqueRenderables", self)
    hook.Remove("PreDrawPhysgunBeam", "DisablePhysgunBeam")
    if render.oldDrawBeam then
        render.DrawBeam = render.oldDrawBeam
        render.oldDrawBeam = nil
    end

    if IsValid(self.modelEntity) then self.modelEntity:Remove() end
end

function PANEL:Think()
    if IsValid(self.logo) then
        self.logo:SetZPos(9999)
        self.logo:MoveToFront()
        self:UpdateLogoPosition()
    end
end

vgui.Register("liaCharacter", PANEL, "EditablePanel")

-- ./gamemode/core/derma/mainmenu/confirmation.lua
local PANEL = {}
function PANEL:Init()
    if IsValid(lia.gui.charConfirm) then lia.gui.charConfirm:Remove() end
    lia.gui.charConfirm = self
    local w, h = 400, 140
    self:SetSize(w, h)
    self:Center()
    self:SetTitle("")
    self:ShowCloseButton(false)
    self:MakePopup()
    self.Paint = function(_, fw, fh)
        lia.util.drawBlur(_)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, fw, fh)
    end

    self.title = self:Add("DLabel")
    self.title:SetFont("liaBigFont")
    self.title:SetText(L("areYouSure"):upper())
    self.title:SetTextColor(color_white)
    self.title:SizeToContents()
    self.title:CenterHorizontal()
    self.title:SetY(10)
    self.message = self:Add("DLabel")
    self.message:SetFont("liaSmallFont")
    self.message:SetTextColor(color_white)
    self.message:SetSize(w - 20, 20)
    self.message:SetPos(10, 40)
    self.message:SetContentAlignment(5)
    local confirmText, cancelText = L("yes"):upper(), L("no"):upper()
    local cw = surface.GetTextSize(confirmText)
    local aw = surface.GetTextSize(cancelText)
    local padding = 40
    local btnW = math.max(cw, aw) + padding
    local btnH = 30
    local spacing = 20
    local startX = (w - (btnW * 2 + spacing)) * 0.5
    local btnY = h - btnH - 15
    self.confirm = self:Add("liaSmallButton")
    self.confirm:SetText(confirmText)
    self.confirm:SetPaintBackground(false)
    self.confirm:SetSize(btnW, btnH)
    self.confirm:SetPos(startX, btnY)
    self.confirm:SetContentAlignment(5)
    self.confirm.OnCursorEntered = function(btn)
        btn.BaseClass.OnCursorEntered(btn)
        lia.gui.character:hoverSound()
    end

    self.confirm.DoClick = function()
        lia.gui.character:clickSound()
        if isfunction(self.onConfirmCallback) then self.onConfirmCallback() end
        self:Remove()
    end

    self.cancel = self:Add("liaSmallButton")
    self.cancel:SetText(cancelText)
    self.cancel:SetPaintBackground(false)
    self.cancel:SetSize(btnW, btnH)
    self.cancel:SetPos(startX + btnW + spacing, btnY)
    self.cancel:SetContentAlignment(5)
    self.cancel.OnCursorEntered = function(btn)
        btn.BaseClass.OnCursorEntered(btn)
        lia.gui.character:hoverSound()
    end

    self.cancel.DoClick = function()
        lia.gui.character:clickSound()
        if isfunction(self.onCancelCallback) then self.onCancelCallback() end
        self:Remove()
    end

    timer.Simple(0.25, function() lia.gui.character:warningSound() end)
end

function PANEL:setTitle(t)
    self.title:SetText(t)
    self.title:SizeToContentsX()
    self.title:CenterHorizontal()
    return self
end

function PANEL:setMessage(m)
    self.message:SetText(m:upper())
    return self
end

function PANEL:onConfirm(cb)
    self.onConfirmCallback = cb
    return self
end

function PANEL:onCancel(cb)
    self.onCancelCallback = cb
    return self
end

vgui.Register("liaCharacterConfirm", PANEL, "SemiTransparentDFrame")

-- ./gamemode/core/derma/mainmenu/creation.lua
local PANEL = {}
function PANEL:configureSteps()
    self:addStep(vgui.Create("liaCharacterFaction"))
    self:addStep(vgui.Create("liaCharacterBiography"))
    hook.Run("ConfigureCharacterCreationSteps", self)
    local keys = table.GetKeys(self.steps)
    table.sort(keys)
    local ordered = {}
    for i, k in ipairs(keys) do
        ordered[i] = self.steps[k]
    end

    self.steps = ordered
end

function PANEL:updateModel()
    local faction = lia.faction.indices[self.context.faction]
    if not faction then return end
    local info = faction.models[self.context.model or 1]
    local mdl, skin, groups = info, 0, {}
    if istable(info) then mdl, skin, groups = info[1], info[2], info[3] end
    self.model:SetModel(mdl)
    self.model:fitFOV()
    local entity = self.model:GetEntity()
    if not IsValid(entity) then return end
    entity:SetupBones()
    entity:SetSkin(self.context.skin or skin)
    local finalGroups = istable(self.context.groups) and self.context.groups or istable(groups) and groups
    if finalGroups then
        for id, val in pairs(finalGroups) do
            entity:SetBodygroup(id, val)
        end
    end

    hook.Run("ModifyCharacterModel", entity)
end

function PANEL:canCreateCharacter()
    local valid = {}
    for _, team in pairs(lia.faction.teams) do
        if lia.faction.hasWhitelist(team.index) then valid[#valid + 1] = team.index end
    end

    if #valid == 0 then return false, L("unableToJoinFactions") end
    self.validFactions = valid
    local maxChars = hook.Run("GetMaxPlayerChar", LocalPlayer()) or lia.config.get("MaxCharacters", 5)
    if lia.characters and #lia.characters >= maxChars then return false, L("maxCharactersReached") end
    local ok, reason = hook.Run("ShouldMenuButtonShow", "create")
    if ok == false then return false, reason end
    return true
end

function PANEL:onFinish()
    if self.creating then return end
    self.content:SetVisible(false)
    self.buttons:SetVisible(false)
    self:showMessage("creating")
    self.creating = true
    local function finish()
        timer.Remove("liaFailedToCreate")
        if not IsValid(self) then return end
        self.creating = false
        self.content:SetVisible(true)
        self.buttons:SetVisible(true)
        self:showMessage()
    end

    local function fail(err)
        finish()
        self:showError(err)
    end

    local mainMenu = lia.module.list["mainmenu"]
    mainMenu:createCharacter(self.context):next(function()
        finish()
        hook.Run("ResetCharacterPanel")
    end, fail)

    timer.Create("liaFailedToCreate", 60, 1, function()
        if not IsValid(self) or not self.creating then return end
        fail(L("unknownError"))
    end)
end

function PANEL:showError(msg, ...)
    if IsValid(self.error) then self.error:Remove() end
    if not msg or msg == "" then return end
    local text = L(msg, ...)
    assert(IsValid(self.content), "no step is available")
    local err = self.content:Add("DLabel")
    err:SetFont("liaCharSubTitleFont")
    err:SetText(text)
    err:SetTextColor(color_white)
    err:Dock(TOP)
    err:SetTall(32)
    err:DockMargin(0, 0, 0, 8)
    err:SetContentAlignment(5)
    err.Paint = function(box, w, h)
        lia.util.drawBlur(box)
        surface.SetDrawColor(255, 0, 0, 50)
        surface.DrawRect(0, 0, w, h)
    end

    err:SetAlpha(0)
    err:AlphaTo(255, 0.5)
    lia.gui.character:warningSound()
    self.error = err
end

function PANEL:showMessage(msg, ...)
    if not msg or msg == "" then
        if IsValid(self.message) then self.message:Remove() end
        return
    end

    local text = L(msg, ...):upper()
    if IsValid(self.message) then self.message:SetText(text) end
    local lbl = self:Add("DLabel")
    lbl:SetFont("liaCharButtonFont")
    lbl:SetTextColor(lia.gui.character.color)
    lbl:Dock(FILL)
    lbl:SetContentAlignment(5)
    lbl:SetText(text)
    self.message = lbl
end

function PANEL:addStep(step, priority)
    assert(IsValid(step), "Invalid panel for step")
    assert(step.isCharCreateStep, "Panel must inherit liaCharacterCreateStep")
    if isnumber(priority) then
        table.insert(self.steps, priority, step)
    else
        self.steps[#self.steps + 1] = step
    end

    step:SetParent(self.content)
end

function PANEL:nextStep()
    local prevIdx = self.curStep
    local cur = self.steps[prevIdx]
    if IsValid(cur) then
        local ok, err = cur:validate()
        if ok == false then return self:showError(err) end
    end

    self:showError()
    self.curStep = prevIdx + 1
    local nxt = self.steps[self.curStep]
    while IsValid(nxt) and nxt:shouldSkip() do
        self.curStep = self.curStep + 1
        nxt:onSkip()
        nxt = self.steps[self.curStep]
    end

    if not IsValid(nxt) then
        self.curStep = prevIdx
        return self:onFinish()
    end

    self:onStepChanged(cur, nxt)
end

function PANEL:previousStep()
    local idx = self.curStep - 1
    local prev = self.steps[idx]
    while IsValid(prev) and prev:shouldSkip() do
        prev:onSkip()
        idx = idx - 1
        prev = self.steps[idx]
    end

    if not IsValid(prev) then return end
    self.curStep = idx
    self:onStepChanged(self.steps[idx + 1], prev)
end

function PANEL:getPreviousStep()
    local idx = self.curStep - 1
    while IsValid(self.steps[idx]) do
        if not self.steps[idx]:shouldSkip() then return self.steps[idx] end
        idx = idx - 1
    end
end

function PANEL:onStepChanged(oldStep, newStep)
    local finish = self.curStep == #self.steps
    local text = L(finish and "finish" or "next"):upper()
    if IsValid(self:getPreviousStep()) then
        self.prev:AlphaTo(255, 0.5)
    else
        self.prev:AlphaTo(0, 0.5)
    end

    local function sizeButton(btn, txt)
        btn:SetText(txt)
        surface.SetFont(btn:GetFont())
        local w = select(1, surface.GetTextSize(txt))
        btn:SetWide(w + 40)
    end

    if text ~= self.next:GetText() then self.next:AlphaTo(0, 0.5) end
    local function show()
        newStep:SetVisible(true)
        newStep:SetAlpha(0)
        newStep:onDisplay()
        newStep:InvalidateChildren(true)
        newStep:AlphaTo(255, 0.5)
        if text ~= self.next:GetText() then
            self.next:SetAlpha(0)
            sizeButton(self.next, text)
        end

        self.next:AlphaTo(255, 0.5)
    end

    if IsValid(oldStep) then
        oldStep:AlphaTo(0, 0.5, 0, function()
            self:showError()
            oldStep:SetVisible(false)
            oldStep:onHide()
            show()
        end)
    else
        show()
    end
end

function PANEL:Init()
    self:Dock(FILL)
    local ok, reason = self:canCreateCharacter()
    if not ok then return self:showMessage(reason) end
    lia.gui.charCreate = self
    local margin = ScrW() > 1280 and ScrW() * 0.15 or ScrW() > 720 and ScrW() * 0.075 or 0
    self.content = self:Add("DPanel")
    self.content:Dock(FILL)
    self.content:DockMargin(margin, 64, margin, 0)
    self.content:SetPaintBackground(false)
    self.model = self.content:Add("liaModelPanel")
    self.model:SetWide(ScrW() * 0.25)
    self.model:Dock(LEFT)
    self.model:SetModel("models/error.mdl")
    self.model:fitFOV()
    self.buttons = self:Add("DPanel")
    self.buttons:Dock(BOTTOM)
    self.buttons:SetTall(48)
    self.buttons:SetPaintBackground(false)
    local function sizeButton(btn, text)
        btn:SetText(text)
        local font = btn:GetFont()
        surface.SetFont(font)
        local textW, _ = surface.GetTextSize(text)
        local padding = 20
        btn:SetWide(textW + padding * 2)
    end

    self.prev = self.buttons:Add("liaMediumButton")
    sizeButton(self.prev, L("back"):upper())
    self.prev:Dock(LEFT)
    self.prev.DoClick = function() self:previousStep() end
    self.prev:SetAlpha(0)
    self.next = self.buttons:Add("liaMediumButton")
    sizeButton(self.next, L("next"):upper())
    self.next:Dock(RIGHT)
    self.next.DoClick = function() self:nextStep() end
    self.steps = {}
    self.curStep = 0
    self.context = {}
    self:configureSteps()
    if #self.steps == 0 then return self:showError("noCharacterSteps") end
    self:nextStep()
    timer.Simple(0.5, function() hook.Run("ModifyCharacterModel", self.model:GetEntity()) end)
end

vgui.Register("liaCharacterCreation", PANEL, "EditablePanel")

-- ./gamemode/core/derma/mainmenu/step.lua
local PANEL = {}
PANEL.isCharCreateStep = true
function PANEL:Init()
    self:Dock(FILL)
    self:SetPaintBackground(false)
    self:SetVisible(false)
end

function PANEL:onDisplay()
end

function PANEL:next()
    lia.gui.charCreate:nextStep()
end

function PANEL:previous()
    lia.gui.charCreate:previousStep()
end

function PANEL:validateCharVar(name)
    local var = lia.char.vars[name]
    assert(var, "invalid character variable " .. tostring(name))
    return isfunction(var.onValidate) and var.onValidate(self:getContext(name), self:getContext(), LocalPlayer()) or true
end

function PANEL:validate()
    return true
end

function PANEL:setContext(k, v)
    lia.gui.charCreate.context[k] = v
end

function PANEL:clearContext()
    lia.gui.charCreate.context = {}
end

function PANEL:getContext(k, d)
    local ctx = lia.gui.charCreate.context
    if k == nil then return ctx end
    local v = ctx[k]
    return v == nil and d or v
end

function PANEL:getModelPanel()
    return lia.gui.charCreate.model
end

function PANEL:updateModelPanel()
    lia.gui.charCreate:updateModel()
end

function PANEL:shouldSkip()
    return false
end

function PANEL:onSkip()
end

function PANEL:addLabel(text)
    local lbl = self:Add("DLabel")
    lbl:SetFont("liaCharButtonFont")
    lbl:SetText(L(text):upper())
    lbl:SizeToContents()
    lbl:Dock(TOP)
    return lbl
end

function PANEL:onHide()
end

vgui.Register("liaCharacterCreateStep", PANEL, "DScrollPanel")

-- ./gamemode/core/derma/mainmenu/steps/biography.lua
local PANEL = {}
local HIGHLIGHT = Color(255, 255, 255, 50)
function PANEL:Init()
    self:SetSize(400, 600)
    local function makeLabel(key)
        local lbl = self:Add("DLabel")
        lbl:SetFont("liaMediumFont")
        lbl:SetText(L(key):upper())
        lbl:SizeToContents()
        lbl:Dock(TOP)
        lbl:DockMargin(0, 0, 0, 4)
        return lbl
    end

    self.nameLabel = makeLabel("name")
    self.nameEntry = self:makeTextEntry("name")
    self.nameEntry:SetTall(32)
    self.descLabel = makeLabel("desc")
    self.descEntry = self:makeTextEntry("desc")
    self.descEntry:SetTall(32)
    makeLabel("model")
    local faction = lia.faction.indices[self:getContext("faction")]
    if not faction then return end
    local function paintOver(icon, w, h)
        if self:getContext("model") == icon.index then
            local col = lia.config.get("Color", color_white)
            surface.SetDrawColor(col.r, col.g, col.b, 200)
            for i = 1, 3 do
                surface.DrawOutlinedRect(i, i, w - i * 2, h - i * 2)
            end
        end
    end

    self.models = self:Add("DIconLayout")
    self.models:Dock(TOP)
    self.models:DockMargin(0, 4, 0, 4)
    self.models:SetSpaceX(5)
    self.models:SetSpaceY(0)
    local iconW, iconH = 64, 128
    local spacing = 5
    local count = #faction.models
    self.models:SetWide(count * (iconW + spacing) - spacing)
    self.models:SetTall(iconH)
    for idx, data in SortedPairs(faction.models) do
        local icon = self.models:Add("SpawnIcon")
        icon:SetSize(iconW, iconH)
        icon:InvalidateLayout(true)
        icon.index = idx
        icon.PaintOver = paintOver
        icon.DoClick = function()
            self:setContext("model", idx)
            lia.gui.character:clickSound()
            self:updateModelPanel()
        end

        if isstring(data) then
            icon:SetModel(data)
            icon.model, icon.skin, icon.bodyGroups = data, 0, ""
        else
            local m, skin, bg = data[1], data[2] or 0, data[3] or {}
            local groups = {}
            for i = 0, 8 do
                groups[i + 1] = tostring(bg[i] or 0)
            end

            icon:SetModel(m, skin, table.concat(groups))
            icon.model, icon.skin, icon.bodyGroups = m, skin, table.concat(groups)
        end

        if self:getContext("model") == idx then icon:DoClick() end
    end
end

function PANEL:makeTextEntry(key)
    local entry = self:Add("DTextEntry")
    entry:Dock(TOP)
    entry:SetFont("liaMediumFont")
    entry:SetTall(32)
    entry:DockMargin(0, 4, 0, 8)
    entry:SetUpdateOnType(true)
    entry.Paint = function(_, w, h)
        surface.SetDrawColor(0, 0, 0, 100)
        surface.DrawRect(0, 0, w, h)
        entry:DrawTextEntryText(color_white, HIGHLIGHT, HIGHLIGHT)
    end

    entry.OnValueChange = function(_, val) self:setContext(key, string.Trim(val)) end
    local saved = self:getContext(key)
    if saved then entry:SetValue(saved) end
    return entry
end

function PANEL:shouldSkip()
    local faction = lia.faction.indices[self:getContext("faction")]
    return faction and #faction.models == 1 or false
end

function PANEL:onSkip()
    self:setContext("model", 1)
end

function PANEL:validate()
    for _, info in ipairs({{self.nameEntry, "name"}, {self.descEntry, "desc"}}) do
        local val = string.Trim(info[1]:GetValue() or "")
        if val == "" then return false, L("requiredFieldError", info[2]) end
    end
    return true
end

function PANEL:onDisplay()
    local n, d, m = self.nameEntry:GetValue(), self.descEntry:GetValue(), self:getContext("model")
    self:Clear()
    self:Init()
    self.nameEntry:SetValue(n)
    self.descEntry:SetValue(d)
    self:setContext("model", m)
    local children = self.models:GetChildren()
    if children[m] then children[m].DoClick(children[m]) end
end

vgui.Register("liaCharacterBiography", PANEL, "liaCharacterCreateStep")

-- ./gamemode/core/derma/mainmenu/steps/faction.lua
local PANEL = {}
function PANEL:Init()
    self.title = self:addLabel(L("selectFaction"))
    self.faction = self:Add("DComboBox")
    self.faction:SetFont("liaCharButtonFont")
    self.faction:Dock(TOP)
    self.faction:DockMargin(0, 4, 0, 0)
    self.faction:SetTall(40)
    self.faction.Paint = function(p, w, h)
        lia.util.drawBlur(p)
        surface.SetDrawColor(0, 0, 0, 100)
        surface.DrawRect(0, 0, w, h)
    end

    self.faction:SetTextColor(color_white)
    self.faction.OnSelect = function(_, _, _, id) self:onFactionSelected(lia.faction.teams[id]) end
    self.desc = self:addLabel(L("factionDescription"))
    self.desc:DockMargin(0, 8, 0, 0)
    self.desc:SetFont("liaCharSubTitleFont")
    self.desc:SetWrap(true)
    self.desc:SetAutoStretchVertical(true)
    self.skipFirstSelect = true
    for id, fac in SortedPairsByMemberValue(lia.faction.teams, "name") do
        if lia.faction.hasWhitelist(fac.index) then
            self.faction:AddChoice(L(fac.name), id, self.skipFirstSelect)
            self.skipFirstSelect = false
        end
    end
end

function PANEL:onDisplay()
    self.skipFirstSelect = true
    local _, id = self.faction:GetSelected()
    local fac = lia.faction.teams[id]
    if fac then self:onFactionSelected(fac) end
end

function PANEL:onFactionSelected(fac)
    if self:getContext("faction") == fac.index then return end
    self.desc:SetText(L(fac.desc or "noDesc"))
    self:clearContext()
    self:setContext("faction", fac.index)
    self:setContext("model", 1)
    self:updateModelPanel()
    if self.skipFirstSelect then
        self.skipFirstSelect = false
        return
    end

    lia.gui.character:clickSound()
end

function PANEL:shouldSkip()
    return #self.faction.Choices == 1
end

function PANEL:onSkip()
    local _, id = self.faction:GetSelected()
    local fac = lia.faction.teams[id]
    self:setContext("faction", fac and fac.index)
    self:setContext("model", self:getContext("model", 1))
end

vgui.Register("liaCharacterFaction", PANEL, "liaCharacterCreateStep")

-- ./gamemode/core/derma/mainmenu/steps/model.lua
local PANEL = {}
function PANEL:Init()
    self.title = self:addLabel(L("selectModel"))
    self.models = self:Add("DIconLayout")
    self.models:Dock(FILL)
    self.models:SetSpaceX(4)
    self.models:SetSpaceY(4)
    self.models:SetPaintBackground(false)
end

function PANEL:onDisplay()
    self.models:Clear()
    local faction = lia.faction.indices[self:getContext("faction")]
    if not faction then return end
    local paintOver = function(icon, w, h) self:paintIcon(icon, w, h) end
    for idx, data in SortedPairs(faction.models) do
        local icon = self.models:Add("SpawnIcon")
        icon:SetSize(64, 128)
        icon.index = idx
        icon.PaintOver = paintOver
        icon.DoClick = function() self:onModelSelected(icon) end
        local model, skin, bodyGroups = data, 0, ""
        if istable(data) then
            skin = data[2] or 0
            for i = 0, 8 do
                bodyGroups = bodyGroups .. tostring((data[3] or {})[i] or 0)
            end

            model = data[1]
        end

        icon:SetModel(model, skin, bodyGroups)
        icon.model, icon.skin, icon.bodyGroups = model, skin, bodyGroups
        if self:getContext("model") == idx then self:onModelSelected(icon, true) end
    end

    self.models:InvalidateLayout(true)
end

function PANEL:paintIcon(icon, w, h)
    if self:getContext("model") ~= icon.index then return end
    local col = lia.config.get("Color", color_white)
    surface.SetDrawColor(col.r, col.g, col.b, 200)
    for i = 1, 3 do
        local o = i * 2
        surface.DrawOutlinedRect(i, i, w - o, h - o)
    end
end

function PANEL:onModelSelected(icon, noSound)
    self:setContext("model", icon.index or 1)
    if not noSound then lia.gui.character:clickSound() end
    self:updateModelPanel()
end

function PANEL:shouldSkip()
    local faction = lia.faction.indices[self:getContext("faction")]
    return faction and #faction.models == 1 or false
end

function PANEL:onSkip()
    self:setContext("model", 1)
end

vgui.Register("liaCharacterModel", PANEL, "liaCharacterCreateStep")

-- ./gamemode/core/derma/panels/attributes.lua
local PANEL = {}
function PANEL:Init()
    self:SetTall(20)
    self.add = self:Add("DImageButton")
    self.add:SetSize(16, 16)
    self.add:Dock(RIGHT)
    self.add:DockMargin(2, 2, 2, 2)
    self.add:SetImage("icon16/add.png")
    self.add.OnMousePressed = function()
        self.pressing = 1
        self:doChange()
        self.add:SetAlpha(150)
    end

    self.add.OnMouseReleased = function()
        if self.pressing then
            self.pressing = nil
            self.add:SetAlpha(255)
        end
    end

    self.add.OnCursorExited = self.add.OnMouseReleased
    self.sub = self:Add("DImageButton")
    self.sub:SetSize(16, 16)
    self.sub:Dock(LEFT)
    self.sub:DockMargin(2, 2, 2, 2)
    self.sub:SetImage("icon16/delete.png")
    self.sub.OnMousePressed = function()
        self.pressing = -1
        self:doChange()
        self.sub:SetAlpha(150)
    end

    self.sub.OnMouseReleased = function()
        if self.pressing then
            self.pressing = nil
            self.sub:SetAlpha(255)
        end
    end

    self.sub.OnCursorExited = self.sub.OnMouseReleased
    self.t = 0
    self.value = 0
    self.deltaValue = 0
    self.max = 10
    self.bar = self:Add("DPanel")
    self.bar:Dock(FILL)
    self.bar:DockMargin(2, 2, 2, 2)
    self.bar.Paint = function(_, w, h)
        self.t = Lerp(FrameTime() * 10, self.t, 1)
        local v = self.value / self.max * self.t
        if v > 0 then
            local c = lia.config.get("Color")
            surface.SetDrawColor(c)
            surface.DrawRect(0, 0, w * v, h)
        end

        local b = self.boostValue or 0
        if b ~= 0 then
            local bw = math.Clamp(math.abs(b / self.max), 0, 1) * w * self.t + 1
            if b < 0 then
                surface.SetDrawColor(200, 80, 80, 200)
                surface.DrawRect(w * v - bw, 0, bw, h)
            else
                surface.SetDrawColor(80, 200, 80, 200)
                surface.DrawRect(w * v, 0, bw, h)
            end
        end
    end

    self.label = self.bar:Add("DLabel")
    self.label:Dock(FILL)
    self.label:SetExpensiveShadow(1, Color(0, 0, 60))
    self.label:SetContentAlignment(5)
end

function PANEL:Think()
    if self.pressing and (self.nextPress or 0) < CurTime() then self:doChange() end
    self.deltaValue = math.Approach(self.deltaValue, self.value, FrameTime() * 15)
end

function PANEL:doChange()
    if self.value == 0 and self.pressing == -1 or self.value == self.max and self.pressing == 1 then return end
    self.nextPress = CurTime() + 0.2
    if self:onChanged(self.pressing) ~= false then self.value = math.Clamp(self.value + self.pressing, 0, self.max) end
end

function PANEL:onChanged()
end

function PANEL:getValue()
    return self.value
end

function PANEL:setValue(v)
    self.value = v
end

function PANEL:setBoost(v)
    self.boostValue = v
end

function PANEL:setMax(m)
    self.max = m
end

function PANEL:SetText(t)
    self.label:SetText(t)
    self.label:SetTextColor(color_white)
end

function PANEL:setReadOnly()
    self.sub:Remove()
    self.add:Remove()
end

function PANEL:Paint(w, h)
    surface.SetDrawColor(0, 0, 0, 200)
    surface.DrawRect(0, 0, w, h)
end

vgui.Register("liaAttribBar", PANEL, "DPanel")
local PANEL = {}
function PANEL:Init()
    self.title = self:addLabel(L("attributes"))
    self.title:SetTextColor(color_white)
    self.leftLabel = self:addLabel(L("pointsLeft"))
    self.leftLabel:SetFont("liaCharSubTitleFont")
    self.leftLabel:SetTextColor(color_white)
    self.total = hook.Run("GetMaxStartingAttributePoints", LocalPlayer(), self:getContext()) or lia.config.get("MaxAttributePoints")
    self.attribs = {}
    for k, v in SortedPairsByMemberValue(lia.attribs.list, "name") do
        if not v.noStartBonus then self.attribs[k] = self:addAttribute(k, v) end
    end
end

function PANEL:updatePointsLeft()
    self.leftLabel:SetText(L("pointsLeft"):upper() .. ": " .. self.left)
end

function PANEL:onDisplay()
    local t = self:getContext("attribs", {})
    local sum = 0
    for _, q in pairs(t) do
        sum = sum + q
    end

    self.left = math.max(self.total - sum, 0)
    self:updatePointsLeft()
    for k, row in pairs(self.attribs) do
        row.points = t[k] or 0
        row:updateQuantity()
    end
end

function PANEL:addAttribute(k, v)
    local row = self:Add("liaCharacterAttribsRow")
    row:setAttribute(k, v)
    row.parent = self
    return row
end

function PANEL:onPointChange(k, d)
    if not k then return 0 end
    local client = LocalPlayer()
    local t = self:getContext("attribs", {})
    local qty = t[k] or 0
    local nm = hook.Run("GetAttributeStartingMax", client, k)
    local nq = qty + d
    local nl = self.left - d
    if nl < 0 or nl > self.total or nq < 0 or nq > self.total or nm and nq > nm then return qty end
    self.left = nl
    self:updatePointsLeft()
    t[k] = nq
    self:setContext("attribs", t)
    return nq
end

vgui.Register("liaCharacterAttribs", PANEL, "liaCharacterCreateStep")
local PANEL = {}
function PANEL:Init()
    self:Dock(TOP)
    self:DockMargin(0, 0, 0, 4)
    self:SetTall(36)
    self:SetPaintBackground(false)
    self.buttons = self:Add("DPanel")
    self.buttons:Dock(RIGHT)
    self.buttons:SetWide(128)
    self.buttons:SetPaintBackground(false)
    self.sub = self:addButton("", -1):Dock(LEFT)
    self.add = self:addButton("", 1):Dock(RIGHT)
    self.quantity = self.buttons:Add("DLabel")
    self.quantity:SetFont("liaCharSubTitleFont")
    self.quantity:SetTextColor(color_white)
    self.quantity:Dock(FILL)
    self.quantity:SetContentAlignment(5)
    self.name = self:Add("DLabel")
    self.name:SetFont("liaCharSubTitleFont")
    self.name:SetTextColor(color_white)
    self.name:SetContentAlignment(4)
    self.name:Dock(FILL)
    self.name:DockMargin(8, 0, 0, 0)
end

function PANEL:setAttribute(k, v)
    self.key = k
    local nm = hook.Run("GetAttributeStartingMax", LocalPlayer(), k)
    self.name:SetText(L(v.name))
    self:SetTooltip(L(v.desc or "noDesc") .. (nm and " Max: " .. nm or ""))
end

function PANEL:delta(d)
    if IsValid(self.parent) then
        local old = self.points
        self.points = self.parent:onPointChange(self.key, d)
        self:updateQuantity()
        if old ~= self.points then LocalPlayer():EmitSound("buttons/button16.wav", 30, 255) end
    end
end

function PANEL:addButton(sym, d)
    local b = self.buttons:Add("liaMediumButton")
    b:SetFont("liaCharSubTitleFont")
    b:SetWide(32)
    b:SetText(sym)
    b:SetContentAlignment(5)
    b:SetPaintBackground(false)
    b.OnMousePressed = function()
        self.autoDelta = d
        self.nextAuto = CurTime() + 0.4
        self:delta(d)
    end

    b.OnMouseReleased = function() self.autoDelta = nil end
    return b
end

function PANEL:Think()
    if self.autoDelta and (self.nextAuto or 0) < CurTime() then
        self.nextAuto = CurTime() + 0.4
        self:delta(self.autoDelta)
    end
end

function PANEL:updateQuantity()
    self.quantity:SetText(self.points)
end

function PANEL:Paint(w, h)
    lia.util.drawBlur(self)
    surface.SetDrawColor(0, 0, 0, 100)
    surface.DrawRect(0, 0, w, h)
end

vgui.Register("liaCharacterAttribsRow", PANEL, "DPanel")

-- ./gamemode/core/derma/panels/buttons.lua
local animDuration = 0.3
local function PaintButton(self, w, h)
    local r, g, b = lia.config.get("Color")
    if self.Base then
        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawOutlinedRect(0, 0, w, h, 2)
        surface.SetDrawColor(0, 0, 0, 150)
        surface.DrawRect(1, 1, w - 2, h - 2)
    end

    draw.SimpleText(self:GetText(), self:GetFont(), w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    if self:IsHovered() or self:IsSelected() then
        self.startTime = self.startTime or CurTime()
        local elapsed = CurTime() - self.startTime
        local anim = math.min(w, elapsed / animDuration * w) / 2
        surface.SetDrawColor(r, g, b)
        surface.DrawLine(w / 2 - anim, h - 1, w / 2 + anim, h - 1)
    else
        self.startTime = nil
    end
    return true
end

local function RegisterButton(name, defaultFont, useBase)
    local PANEL = {}
    PANEL.DefaultFont = defaultFont or name:match("lia(%w+)Button") .. "Font"
    PANEL.Base = useBase
    function PANEL:Init()
        self:SetFont(self.DefaultFont)
        self.Selected = false
    end

    function PANEL:SetFont(font)
        self.ButtonFont = font
    end

    function PANEL:GetFont()
        return self.ButtonFont
    end

    function PANEL:SetSelected(state)
        self.Selected = state
    end

    function PANEL:IsSelected()
        return self.Selected
    end

    function PANEL:Paint(w, h)
        return PaintButton(self, w, h)
    end

    vgui.Register(name, PANEL, "DButton")
end

RegisterButton("liaHugeButton", "liaHugeFont", true)
RegisterButton("liaBigButton", "liaBigFont", true)
RegisterButton("liaMediumButton", "liaMediumFont", true)
RegisterButton("liaSmallButton", "liaSmallFont", true)
RegisterButton("liaMiniButton", "liaMiniFont", true)
RegisterButton("liaNoBGButton", "liaBigFont", false)

-- ./gamemode/core/derma/panels/chatbox.lua
local PANEL = {}
function PANEL:Init()
    local border = 32
    local w, h = ScrW() * 0.4, ScrH() * 0.375
    lia.gui.chat = self
    self:SetSize(w, h)
    self:SetPos(border, ScrH() - h - border)
    self.active = false
    self.tabs = self:Add("DPanel")
    self.tabs:Dock(TOP)
    self.tabs:SetTall(28)
    self.tabs:DockPadding(4, 4, 4, 4)
    self.tabs:SetVisible(false)
    self.commandIndex = 0
    self.commands = lia.command.list
    self.tabs.Paint = function(_, w, h)
        surface.SetDrawColor(0, 0, 0, 100)
        surface.DrawRect(0, 0, w, h)
    end

    self.arguments = {}
    self.scroll = self:Add("DScrollPanel")
    self.scroll:SetPos(4, 31)
    self.scroll:SetSize(w - 8, h - 66)
    self.scroll:GetVBar():SetWide(0)
    self.lastY = 0
    self.list = {}
    self.filtered = {}
    chat.GetChatBoxPos = function() return self:LocalToScreen(0, 0) end
    chat.GetChatBoxSize = function() return self:GetSize() end
    local buttons = {}
    for _, v in SortedPairsByMemberValue(lia.chat.classes, "filter") do
        if not buttons[v.filter] then
            self:addFilterButton(v.filter)
            buttons[v.filter] = true
        end
    end
end

function PANEL:Paint(w, h)
    if self.active then
        lia.util.drawBlur(self, 10)
        surface.SetDrawColor(250, 250, 250, 2)
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(0, 0, 0, 240)
        surface.DrawOutlinedRect(0, 0, w, h)
    end
end

function PANEL:setActive(state)
    self.active = state
    if state then
        self.entry = self:Add("EditablePanel")
        self.entry:SetPos(self.x + 4, self.y + self:GetTall() - 32)
        self.entry:SetWide(self:GetWide() - 8)
        self.entry.OnRemove = function() hook.Run("FinishChat") end
        self.entry:SetTall(28)
        lia.chat.history = lia.chat.history or {}
        self.text = self.entry:Add("DTextEntry")
        self.text:Dock(FILL)
        self.text.History = lia.chat.history
        self.text:SetHistoryEnabled(true)
        self.text:DockMargin(0, 0, 0, 0)
        self.text:SetFont("liaChatFont")
        self.text.OnEnter = function(this)
            local text = this:GetText()
            this:Remove()
            self.tabs:SetVisible(false)
            self.active = false
            if IsValid(self.commandList) then
                self.commandList:Remove()
                self.commandList = nil
            end

            if IsValid(self.entry) then self.entry:Remove() end
            lia.gui.chat = nil
            if text:find("%S") then
                if not (lia.chat.lastLine or ""):find(text, 1, true) then
                    lia.chat.history[#lia.chat.history + 1] = text
                    lia.chat.lastLine = text
                end

                net.Start("msg")
                net.WriteString(text)
                net.SendToServer()
            end
        end

        self.text:SetAllowNonAsciiCharacters(true)
        self.text.Paint = function(this, w, h)
            surface.SetDrawColor(0, 0, 0, 100)
            surface.DrawRect(0, 0, w, h)
            surface.SetDrawColor(0, 0, 0, 200)
            surface.DrawOutlinedRect(0, 0, w, h)
            this:DrawTextEntryText(Color(255, 255, 255, 200), lia.config.get("Color"), Color(255, 255, 255, 200))
        end

        self.text.OnTextChanged = function(this)
            local text = this:GetText()
            hook.Run("ChatTextChanged", text)
            if text:sub(1, 1) == "/" then
                if IsValid(self.commandList) then
                    self.commandList:Remove()
                    self.commandList = nil
                end

                self.commandList = self:Add("DScrollPanel")
                self.commandList:SetPos(4, 31)
                self.commandList:SetSize(self:GetWide() - 8, self:GetTall() - 66)
                self.commandList:GetVBar():SetWide(8)
                for commandName, commandData in SortedPairs(self.commands) do
                    if not tobool(commandName:find(text:sub(2))) then continue end
                    local commandButton = self.commandList:Add("DButton")
                    commandButton:SetText("/" .. commandName .. " - " .. (commandData.desc or L("noDesc")))
                    commandButton:Dock(TOP)
                    commandButton:DockMargin(0, 0, 0, 2)
                    commandButton:SetTall(20)
                    commandButton.Paint = function(_, w, h)
                        surface.SetDrawColor(ColorAlpha(color_black, 200))
                        surface.DrawRect(0, 0, w, h)
                    end

                    commandButton.DoClick = function()
                        local commandData = self.commands[commandName]
                        local syntaxPreview = commandData and commandData.syntax or ""
                        self.text:SetText("/" .. commandName .. " " .. syntaxPreview)
                        self.text:RequestFocus()
                        self.commandList:Remove()
                        self.commandList = nil
                    end
                end

                self.arguments = lia.command.extractArgs(text:sub(2))
            else
                if IsValid(self.commandList) then
                    self.commandList:Remove()
                    self.commandList = nil
                end

                self.commandIndex = 0
            end
        end

        self.entry:MakePopup()
        self.text:RequestFocus()
        self.tabs:SetVisible(true)
        self.text.OnKeyCodeTyped = function(this, key)
            if key == KEY_ESCAPE then
                if IsValid(self.commandList) then
                    self.commandList:Remove()
                    self.commandList = nil
                    return true
                end
            end

            if this:GetText():sub(1, 1) == "/" and key == KEY_TAB and IsValid(self.commandList) then
                local children = self.commandList:GetCanvas():GetChildren()
                if #children > 0 then
                    self.commandIndex = (self.commandIndex or 0) + 1
                    if self.commandIndex > #children then self.commandIndex = 1 end
                    for i, child in ipairs(children) do
                        child.commandIndex = i
                        if not child.PaintConfigured then
                            child.Paint = function(this, w, h)
                                local isSelected = this.commandIndex == self.commandIndex
                                surface.SetDrawColor(isSelected and ColorAlpha(lia.config.get("Color"), 255) or ColorAlpha(color_black, 200))
                                surface.DrawRect(0, 0, w, h)
                                if IsValid(this.text) then this.text:SetTextColor(isSelected and ColorAlpha(lia.config.get("Color"), 255) or ColorAlpha(color_white, 200)) end
                            end

                            child.PaintConfigured = true
                        end
                    end

                    local selectedCommand = children[self.commandIndex]
                    if IsValid(selectedCommand) then
                        local commandName = selectedCommand:GetText():match("^/([^ ]+)")
                        local commandData = self.commands[commandName]
                        local syntaxPreview = commandData and commandData.syntax or ""
                        self.text:SetText("/" .. commandName .. " " .. syntaxPreview)
                        self.text:SetCaretPos(#self.text:GetText())
                        self.text:RequestFocus()
                    end
                end
                return true
            end
            return DTextEntry.OnKeyCodeTyped(this, key)
        end

        self.text.OnLoseFocus = function(this)
            if IsValid(self.commandList) then
                self.commandList:Remove()
                self.commandList = nil
            end

            this:RequestFocus()
        end

        hook.Run("StartChat")
    end
end

local function OnDrawText(text, font, x, y, color, _, _, alpha)
    alpha = alpha or 255
    surface.SetTextPos(x + 1, y + 1)
    surface.SetTextColor(0, 0, 0, alpha)
    surface.SetFont(font)
    surface.DrawText(text)
    surface.SetTextPos(x, y)
    surface.SetTextColor(color.r, color.g, color.b, alpha)
    surface.SetFont(font)
    surface.DrawText(text)
end

local function PaintFilterButton(this, w, h)
    if this.active then
        surface.SetDrawColor(40, 40, 40)
    else
        local alpha = 120 + math.cos(RealTime() * 5) * 10
        surface.SetDrawColor(ColorAlpha(lia.config.get("Color"), alpha))
    end

    surface.DrawRect(0, 0, w, h)
    surface.SetDrawColor(0, 0, 0, 200)
    surface.DrawOutlinedRect(0, 0, w, h)
end

function PANEL:addFilterButton(filter)
    local name = L(filter)
    local tab = self.tabs:Add("DButton")
    tab:SetFont("liaChatFont")
    tab:SetText(name:upper())
    tab:SizeToContents()
    tab:DockMargin(0, 0, 3, 0)
    tab:SetWide(tab:GetWide() + 32)
    tab:Dock(LEFT)
    tab:SetTextColor(color_white)
    tab:SetExpensiveShadow(1, Color(0, 0, 0, 200))
    tab.Paint = PaintFilterButton
    tab.DoClick = function(this)
        this.active = not this.active
        local filters = LIA_CVAR_CHATFILTER:GetString():lower()
        if filters == "none" then filters = "" end
        if this.active then
            filters = filters .. filter .. ","
        else
            filters = filters:gsub(filter .. "[,]", "")
            if not filters:find("%S") then filters = "none" end
        end

        self:setFilter(filter, this.active)
        RunConsoleCommand("lia_chatfilter", filters)
    end

    if LIA_CVAR_CHATFILTER:GetString():lower():find(filter) then tab.active = true end
end

function PANEL:addText(...)
    local text = "<font=liaChatFont>"
    if CHAT_CLASS then text = "<font=" .. (CHAT_CLASS.font or "liaChatFont") .. ">" end
    text = hook.Run("ChatAddText", text, ...) or text
    for _, v in ipairs({...}) do
        if type(v) == "IMaterial" then
            local ttx = v:GetName()
            text = text .. "<img=" .. ttx .. "," .. v:Width() .. "x" .. v:Height() .. ">"
        elseif IsColor(v) and v.r and v.g and v.b then
            text = text .. "<color=" .. v.r .. "," .. v.g .. "," .. v.b .. ">"
        elseif type(v) == "Player" then
            local color = team.GetColor(v:Team())
            text = text .. "<color=" .. color.r .. "," .. color.g .. "," .. color.b .. ">" .. v:Name():gsub("<", "&lt;"):gsub(">", "&gt;"):gsub("#", "\226\128\139#")
        else
            text = text .. tostring(v):gsub("<", "&lt;"):gsub(">", "&gt;")
            text = text:gsub("%b**", function(value)
                local inner = value:sub(2, -2)
                if inner:find("%S") then return "<font=liaChatFontItalics>" .. value:sub(2, -2) .. "</font>" end
            end)
        end
    end

    text = text .. "</font>"
    local panel = self.scroll:Add("liaMarkupPanel")
    panel:SetWide(self:GetWide() - 8)
    panel:setMarkup(text, OnDrawText)
    panel.start = CurTime() + 15
    panel.finish = panel.start + 20
    panel.Think = function(this)
        if self.active then
            this:SetAlpha(255)
        else
            this:SetAlpha((1 - math.TimeFraction(this.start, this.finish, CurTime())) * 255)
        end
    end

    self.list[#self.list + 1] = panel
    local class = CHAT_CLASS and CHAT_CLASS.filter and CHAT_CLASS.filter:lower() or "ic"
    if LIA_CVAR_CHATFILTER:GetString():lower():find(class) then
        self.filtered[panel] = class
        panel:SetVisible(false)
    else
        panel:SetPos(0, self.lastY)
        self.lastY = self.lastY + panel:GetTall()
        self.scroll:ScrollToChild(panel)
    end

    panel.filter = class
    return panel:IsVisible()
end

function PANEL:setFilter(filter, state)
    if state then
        for _, v in ipairs(self.list) do
            if v.filter == filter then
                v:SetVisible(false)
                self.filtered[v] = filter
            end
        end
    else
        for k, v in pairs(self.filtered) do
            if v == filter then
                k:SetVisible(true)
                self.filtered[k] = nil
            end
        end
    end

    self.lastY = 0
    local lastChild
    for _, v in ipairs(self.list) do
        if v:IsVisible() then
            v:SetPos(0, self.lastY)
            self.lastY = self.lastY + v:GetTall() + 2
            lastChild = v
        end
    end

    if IsValid(lastChild) then self.scroll:ScrollToChild(lastChild) end
end

function PANEL:Think()
    if gui.IsGameUIVisible() and self.active then
        self.tabs:SetVisible(false)
        self.active = false
        if IsValid(self.entry) then self.entry:Remove() end
    end

    if self.active and IsValid(self.text) and not self.text:HasFocus() and IsValid(self.commandList) then
        self.commandList:Remove()
        self.commandList = nil
    end
end

vgui.Register("liaChatBox", PANEL, "DPanel")

-- ./gamemode/core/derma/panels/door.lua
local PANEL = {}
function PANEL:Init()
    self:SetSize(280, 240)
    self:SetTitle(L("doorSettings"))
    self:Center()
    self:MakePopup()
    self.access = self:Add("DListView")
    self.access:Dock(FILL)
    local headerColor = Color(25, 25, 25)
    self.access:AddColumn(L("name")).Header:SetTextColor(headerColor)
    self.access:AddColumn(L("doorAccess")).Header:SetTextColor(headerColor)
    self.access.OnClickLine = function(_, line)
        if not IsValid(line.player) then return end
        local menu = DermaMenu()
        local ply = line.player
        local accessData = self.accessData
        local door = self.door
        menu:AddOption(L("tenant"), function() if accessData[ply] ~= DOOR_TENANT then netstream.Start("doorPerm", door, ply, DOOR_TENANT) end end):SetImage("icon16/user_add.png")
        menu:AddOption(L("guest"), function() if accessData[ply] ~= DOOR_GUEST then netstream.Start("doorPerm", door, ply, DOOR_GUEST) end end):SetImage("icon16/user_green.png")
        menu:AddOption(L("none"), function() if accessData[ply] ~= DOOR_NONE then netstream.Start("doorPerm", door, ply, DOOR_NONE) end end):SetImage("icon16/user_red.png")
        menu:Open()
    end
end

function PANEL:setDoor(door, accessData, fallback)
    door.liaPanel = self
    self.accessData = accessData
    self.door = door
    local client = LocalPlayer()
    for _, ply in ipairs(player.GetAll()) do
        if ply ~= client and ply:getChar() then
            local label = L(ACCESS_LABELS[accessData[ply] or 0])
            local line = self.access:AddLine(ply:Name():gsub("#", "\226\128\139#"), label)
            line.player = ply
        end
    end

    if self:CheckAccess(DOOR_OWNER) then
        local btn = self:Add("DButton")
        btn:Dock(BOTTOM)
        btn:DockMargin(0, 5, 0, 0)
        btn:SetText(L("doorSell"))
        btn:SetTextColor(color_white)
        btn.DoClick = function()
            self:Remove()
            lia.command.send("doorsell")
        end

        self.sell = btn
    end

    if self:CheckAccess(DOOR_TENANT) then
        local entry = self:Add("DTextEntry")
        entry:Dock(TOP)
        entry:DockMargin(0, 0, 0, 5)
        entry.Think = function()
            if not entry:IsEditing() then
                local ent = IsValid(fallback) and fallback or door
                entry:SetText(ent:getNetVar("title", L("doorTitleOwned")))
            end
        end

        entry.OnEnter = function() lia.command.send("doorsettitle", entry:GetText()) end
        self.name = entry
    end
end

function PANEL:CheckAccess(minimum)
    if not self.accessData then return false end
    return (self.accessData[LocalPlayer()] or 0) >= (minimum or DOOR_GUEST)
end

function PANEL:Think()
    if self.accessData and not IsValid(self.door) and self:CheckAccess() then self:Remove() end
end

vgui.Register("liaDoorMenu", PANEL, "DFrame")

-- ./gamemode/core/derma/panels/dprogressbar.lua
local PANEL = {}
function PANEL:Init()
    self.StartTime = CurTime()
    self.EndTime = self.StartTime + 5
    self.Text = L("actionInProgress")
    self.BarColor = lia.config.get("Color")
    self.Fraction = 0
    self.GradientMat = Material("vgui/gradient-d")
    self.Font = "liaSmallFont"
end

function PANEL:SetFraction(fraction)
    self.Fraction = fraction or 0
end

function PANEL:SetProgress(startTime, endTime)
    self.StartTime = startTime or CurTime()
    self.EndTime = endTime or self.StartTime + 5
end

function PANEL:SetText(text)
    self.Text = text or ""
end

function PANEL:SetBarColor(color)
    self.BarColor = color or self.BarColor
end

function PANEL:Paint(w, h)
    local frac = math.Clamp(self.Fraction, 0, 1)
    draw.RoundedBox(0, 0, 0, w, h, Color(35, 35, 35, 100))
    surface.SetDrawColor(0, 0, 0, 120)
    surface.DrawOutlinedRect(0, 0, w, h)
    local fillWidth = (w - 8) * frac
    draw.RoundedBox(0, 4, 4, fillWidth, h - 8, self.BarColor)
    surface.SetMaterial(self.GradientMat)
    surface.SetDrawColor(200, 200, 200, 20)
    surface.DrawTexturedRect(4, 4, fillWidth, h - 8)
    local cx, cy = w * 0.5, h * 0.5
    draw.SimpleText(self.Text, self.Font, cx, cy + 2, Color(20, 20, 20), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    draw.SimpleText(self.Text, self.Font, cx, cy, Color(240, 240, 240), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

vgui.Register("DProgressBar", PANEL, "DPanel")

-- ./gamemode/core/derma/panels/dproperties.lua

local min, clamp = math.min, math.Clamp
local inputGetCursorPos, hookRun, isValid = input.GetCursorPos, hook.Run, IsValid
local timerSimple = timer.Simple
local surfaceSetDrawColor, surfaceDrawRect = surface.SetDrawColor, surface.DrawRect
local PANEL = {}
function PANEL:Init()
    self:SetDrawOnTop(true)
    self.DeleteContentsOnClose = false
    self:SetText("")
    self:SetFont("liaToolTipText")
end

function PANEL:UpdateColours()
    return self:SetTextStyleColor(Color(255, 255, 255))
end

function PANEL:SetContents(panel, bDelete)
    panel:SetParent(self)
    self.Contents = panel
    self.DeleteContentsOnClose = bDelete or false
    panel:SizeToContents()
    self:InvalidateLayout(true)
    panel:SetVisible(false)
end

function PANEL:PerformLayout()
    if hookRun("TooltipLayout", self) then return end
    if self.Contents then
        local w, h = self.Contents:GetWide(), self.Contents:GetTall()
        self:SetSize(w + 8, h + 8)
        self.Contents:SetPos(4, 4)
    else
        local w, h = self:GetContentSize()
        self:SetSize(w + 8, h + 6)
        self:SetContentAlignment(5)
    end
end

function PANEL:PositionTooltip()
    if not isValid(self.TargetPanel) then
        self:Remove()
        return
    end

    self:PerformLayout()
    local x, y = inputGetCursorPos()
    local w, h = self:GetSize()
    local _, ly = self.TargetPanel:LocalToScreen(0, 0)
    y = min(y - 50, ly - h * 1.5)
    if y < 2 then y = 2 end
    self:SetPos(clamp(x - w * 0.5, 0, ScrW() - w), clamp(y, 0, ScrH() - h))
end

function PANEL:Paint(w, h)
    self:PositionTooltip()
    if hookRun("TooltipPaint", self, w, h) then return end
    derma.SkinHook("Paint", "Tooltip", self, w, h)
end

function PANEL:OpenForPanel(panel)
    self.TargetPanel = panel
    self:PositionTooltip()
    hookRun("TooltipInitialize", self, panel)
    self:SetVisible(false)
    timerSimple(0.01, function()
        if not isValid(self) or not isValid(panel) then return end
        self:PositionTooltip()
        self:SetVisible(true)
    end)
end

function PANEL:Close()
    if not self.DeleteContentsOnClose and isValid(self.Contents) then
        self.Contents:SetVisible(false)
        self.Contents:SetParent(nil)
    end

    self:Remove()
end

derma.DefineControl("DTooltip", "", PANEL, "DLabel")
local tblRow = vgui.RegisterTable({
    Init = function(self)
        self:Dock(TOP)
        self.Label = self:Add("DLabel")
        self.Label:Dock(LEFT)
        self.Label:DockMargin(4, 2, 2, 2)
        self.Container = self:Add("Panel")
        self.Container:Dock(FILL)
    end,
    PerformLayout = function(self)
        self:SetTall(20)
        self.Label:SetWide(self:GetWide() * 0.45)
    end,
    Setup = function(self, rowType, vars)
        self.Container:Clear()
        local rt = rowType
        local Name = "DProperty_" .. rt
        if not vgui.GetControlTable(Name) then
            if rt == "Bool" then
                rt = "Boolean"
            elseif rt == "Vector" or rt == "Angle" or rt == "String" then
                rt = "Generic"
            end

            Name = "DProperty_" .. rt
        end

        if vgui.GetControlTable(Name) then
            self.Inner = self.Container:Add(Name)
        else
            print("DProperties: Failed to create panel (" .. Name .. ")")
            self.Inner = self.Container:Add("DProperty_Generic")
        end

        self.Inner:SetRow(self)
        self.Inner:Dock(FILL)
        self.Inner:Setup(vars)
        self.Inner:SetEnabled(self:IsEnabled())
        self.IsEnabled = function() return self.Inner:IsEnabled() end
        self.SetEnabled = function(_, b) self.Inner:SetEnabled(b) end
    end,
    SetValue = function(self, val)
        if self.CacheValue == val then return end
        self.CacheValue = val
        if isValid(self.Inner) then self.Inner:SetValue(val) end
    end,
    Paint = function(self, w, h)
        if not isValid(self.Inner) then return end
        local Skin = self:GetSkin()
        local editing = self.Inner:IsEditing()
        local disabled = not self.Inner:IsEnabled() or not self:IsEnabled()
        if disabled then
            surfaceSetDrawColor(Skin.Colours.Properties.Column_Disabled)
            surfaceDrawRect(w * 0.45, 0, w, h)
        elseif editing then
            surfaceSetDrawColor(Skin.Colours.Properties.Column_Selected)
            surfaceDrawRect(0, 0, w * 0.45, h)
        end

        surfaceSetDrawColor(Skin.Colours.Properties.Border)
        surfaceDrawRect(w - 1, 0, 1, h)
        surfaceDrawRect(w * 0.45, 0, 1, h)
        surfaceDrawRect(0, h - 1, w, 1)
        local col = disabled and Skin.Colours.Properties.Label_Disabled or editing and Skin.Colours.Properties.Label_Selected or Skin.Colours.Properties.Label_Normal
        self.Label:SetTextColor(col)
    end
}, "Panel")

local tblCategory = vgui.RegisterTable({
    Init = function(self)
        self:Dock(TOP)
        self.Rows = {}
        self.Header = self:Add("Panel")
        self.Header:Dock(TOP)
        self.Label = self.Header:Add("DLabel")
        self.Label:Dock(FILL)
        self.Label:SetContentAlignment(4)
        self.Expand = self.Header:Add("DExpandButton")
        self.Expand:Dock(LEFT)
        self.Expand:SetSize(16, 16)
        self.Expand:DockMargin(0, 4, 0, 4)
        self.Expand:SetExpanded(true)
        self.Expand.DoClick = function()
            self.Container:SetVisible(not self.Container:IsVisible())
            self.Expand:SetExpanded(self.Container:IsVisible())
            self:InvalidateLayout()
        end

        self.Container = self:Add("Panel")
        self.Container:Dock(TOP)
        self.Container:DockMargin(16, 0, 0, 0)
        self.Container.Paint = function(_, w, h)
            surfaceSetDrawColor(52, 54, 59, 255)
            surfaceDrawRect(0, 0, w, h)
        end
    end,
    PerformLayout = function(self)
        self.Container:SizeToChildren(false, true)
        self:SizeToChildren(false, true)
        local Skin = self:GetSkin()
        self.Label:SetTextColor(Skin.Colours.Properties.Title)
        self.Label:DockMargin(4, 0, 0, 0)
    end,
    GetRow = function(self, name, bCreate)
        local row = self.Rows[name]
        if isValid(row) then return row end
        if not bCreate then return end
        row = self.Container:Add(tblRow)
        row.Label:SetText(name)
        self.Rows[name] = row
        return row
    end,
    Paint = function(self, w, h)
        local Skin = self:GetSkin()
        surfaceSetDrawColor(Skin.Colours.Properties.Border)
        surfaceDrawRect(0, 0, w, h)
    end
}, "Panel")

local PANEL = {}
function PANEL:Init()
    self.Categories = {}
end

function PANEL:PerformLayout()
    self:SizeToChildren(false, true)
end

function PANEL:Clear()
    if isValid(self.Canvas) then self.Canvas:Clear() end
end

function PANEL:GetCanvas()
    if not isValid(self.Canvas) then
        self.Canvas = self:Add("DScrollPanel")
        self.Canvas:Dock(FILL)
    end
    return self.Canvas
end

function PANEL:GetCategory(name, bCreate)
    local cat = self.Categories[name]
    if isValid(cat) then return cat end
    if not bCreate then return end
    cat = self:GetCanvas():Add(tblCategory)
    cat.Label:SetText(name)
    self.Categories[name] = cat
    return cat
end

function PANEL:CreateRow(category, name)
    return self:GetCategory(category, true):GetRow(name, true)
end

derma.DefineControl("DProperties", "", PANEL, "Panel")

-- ./gamemode/core/derma/panels/horizontal_scroll.lua
local PANEL = {}
AccessorFunc(PANEL, "padding", "Padding")
AccessorFunc(PANEL, "canvas", "Canvas")
function PANEL:Init()
    self.canvas = self:Add("Panel")
    self.canvas.OnMousePressed = function(_, code) self:OnMousePressed(code) end
    self.canvas:SetMouseInputEnabled(true)
    self.canvas.PerformLayout = function()
        self:PerformLayout()
        self:InvalidateParent()
    end

    self.bar = self:Add("liaHorizontalScrollBar")
    self.bar:Dock(BOTTOM)
    self:SetPadding(0)
    self:SetMouseInputEnabled(true)
    self:SetPaintBackgroundEnabled(false)
    self:SetPaintBorderEnabled(false)
end

function PANEL:AddItem(item)
    item:SetParent(self.canvas)
end

function PANEL:OnChildAdded(child)
    self:AddItem(child)
end

function PANEL:SizeToContents()
    self:SetSize(self.canvas:GetSize())
end

function PANEL:GetHBar()
    return self.bar
end

function PANEL:OnMouseWheeled(delta)
    self.bar:OnMouseWheeled(delta)
end

function PANEL:OnHScroll(offset)
    self.canvas:SetPos(offset, 0)
end

function PANEL:ScrollToChild(child)
    self:PerformLayout()
    local x = self.canvas:GetChildPosition(child)
    x = x + (child:GetWide() - self:GetWide()) * 0.5
    self.bar:AnimateTo(x, 0.5, 0, 0.5)
end

function PANEL:PerformLayout()
    local w, h = self:GetWide(), self:GetTall()
    local canvas = self.canvas
    canvas:SizeToChildren(true, false)
    local cw = canvas:GetWide()
    local bar = self.bar
    bar:SetUp(w, cw)
    if bar.Enabled then h = h - bar:GetTall() end
    canvas:SetSize(cw, h)
    local x = bar:GetOffset()
    if cw < w then x = (w - cw) * 0.5 end
    canvas:SetPos(x, 0)
end

function PANEL:Clear()
    self.canvas:Clear()
end

vgui.Register("liaHorizontalScroll", PANEL, "DPanel")
local PANEL = {}
function PANEL:Init()
    self.btnLeft = self.btnUp
    self.btnRight = self.btnDown
    self.btnLeft.Paint = function(p, w, h) derma.SkinHook("Paint", "ButtonLeft", p, w, h) end
    self.btnRight.Paint = function(p, w, h) derma.SkinHook("Paint", "ButtonRight", p, w, h) end
end

function PANEL:SetScroll(offset)
    if self.Enabled then
        self.Scroll = math.Clamp(offset, 0, self.CanvasSize)
        self:InvalidateLayout()
        local parent = self:GetParent()
        if parent.OnHScroll then
            parent:OnHScroll(self.Scroll)
        else
            parent:InvalidateLayout()
        end
    else
        self.Scroll = 0
    end
end

function PANEL:OnCursorMoved()
    if not self.Enabled or not self.Dragging then return end
    local x = self:ScreenToLocal(gui.MouseX(), 0) - self.btnLeft:GetWide() - self.HoldPos
    local btnSize = self:GetHideButtons() and 0 or self:GetTall()
    local track = self:GetWide() - btnSize * 2 - self.btnGrip:GetWide()
    self:SetScroll(x * self.CanvasSize / track)
end

function PANEL:Grip()
    self.BaseClass.Grip(self)
    self.HoldPos = self.btnGrip:ScreenToLocal(gui.MouseX(), 0)
end

function PANEL:PerformLayout()
    local h, w = self:GetTall(), self:GetWide()
    local btnSize = self:GetHideButtons() and 0 or h
    local ratio = self.Scroll / self.CanvasSize
    local grip = math.max(self:BarScale() * (w - btnSize * 2), 10)
    local track = w - btnSize * 2 - grip + 1
    self.btnGrip:SetSize(grip, h)
    self.btnGrip:SetPos(btnSize + ratio * track, 0)
    if btnSize > 0 then
        self.btnLeft:SetSize(btnSize, h)
        self.btnLeft:SetPos(0, 0)
        self.btnLeft:SetVisible(true)
        self.btnRight:SetSize(btnSize, h)
        self.btnRight:SetPos(w - btnSize, 0)
        self.btnRight:SetVisible(true)
    else
        self.btnLeft:SetVisible(false)
        self.btnRight:SetVisible(false)
    end
end

vgui.Register("liaHorizontalScrollBar", PANEL, "DVScrollBar")

-- ./gamemode/core/derma/panels/inventory.lua
local PANEL = {}
local renderedIcons = renderedIcons or {}
function renderNewIcon(panel, itemTable)
    if itemTable.iconCam and not renderedIcons[string.lower(itemTable.model)] or itemTable.forceRender then
        local iconCam = itemTable.iconCam
        iconCam = {
            cam_pos = iconCam.pos,
            cam_ang = iconCam.ang,
            cam_fov = iconCam.fov,
        }

        renderedIcons[string.lower(itemTable.model)] = true
        panel.Icon:RebuildSpawnIconEx(iconCam)
    end
end

local function drawIcon(mat, _, x, y)
    surface.SetDrawColor(color_white)
    surface.SetMaterial(mat)
    surface.DrawTexturedRect(0, 0, x, y)
end

function PANEL:setItemType(itemTypeOrID)
    local item = lia.item.list[itemTypeOrID]
    if isnumber(itemTypeOrID) then
        item = lia.item.instances[itemTypeOrID]
        self.itemID = itemTypeOrID
    else
        self.itemType = itemTypeOrID
    end

    assert(item, "invalid item type or ID " .. tostring(item))
    self.liaToolTip = true
    self.itemTable = item
    self:SetModel(item:getModel(), item:getSkin())
    self:updateTooltip()
    if item.icon then
        self.Icon:SetVisible(false)
        self.ExtraPaint = function(self, w, h) drawIcon(item.icon, self, w, h) end
    else
        renderNewIcon(self, item)
    end
end

function PANEL:updateTooltip()
    self:SetTooltip("<font=liaItemBoldFont>" .. self.itemTable:getName() .. "</font>\n" .. "<font=liaItemDescFont>" .. self.itemTable:getDesc())
end

function PANEL:getItem()
    return self.itemTable
end

function PANEL:ItemDataChanged()
    self:updateTooltip()
end

function PANEL:Init()
    self:Droppable("inv")
    self:SetSize(64, 64)
end

function PANEL:PaintOver(w, h)
    local itemTable = lia.item.instances[self.itemID]
    if itemTable and itemTable.paintOver then
        w, h = self:GetSize()
        itemTable.paintOver(self, itemTable, w, h)
    end

    hook.Run("ItemPaintOver", self, itemTable, w, h)
end

function PANEL:PaintBehind(w, h)
    surface.SetDrawColor(0, 0, 0, 85)
    surface.DrawRect(2, 2, w - 4, h - 4)
end

function PANEL:ExtraPaint()
end

function PANEL:Paint(w, h)
    self:PaintBehind(w, h)
    self:ExtraPaint(w, h)
end

local buildActionFunc = function(action, actionIndex, itemTable, invID, sub)
    return function()
        itemTable.player = LocalPlayer()
        local send = true
        if action.onClick then send = action.onClick(itemTable, sub and sub.data) end
        local snd = action.sound or SOUND_INVENTORY_INTERACT
        if snd then
            if istable(snd) then
                LocalPlayer():EmitSound(unpack(snd))
            elseif isstring(snd) then
                surface.PlaySound(snd)
            end
        end

        if send ~= false then netstream.Start("invAct", actionIndex, itemTable.id, invID, sub and sub.data) end
        itemTable.player = nil
    end
end

function PANEL:openActionMenu()
    local itemTable = self.itemTable
    assert(itemTable, "attempt to open action menu for invalid item")
    itemTable.player = LocalPlayer()
    local menu = DermaMenu()
    local override = hook.Run("OnCreateItemInteractionMenu", self, menu, itemTable)
    if override then
        if IsValid(menu) then menu:Remove() end
        return
    end

    for k, v in SortedPairs(itemTable.functions) do
        if hook.Run("CanRunItemAction", itemTable, k) == false or isfunction(v.onCanRun) and not v.onCanRun(itemTable) then continue end
        if v.isMulti then
            local subMenu, subMenuOption = menu:AddSubMenu(L(v.name or k), buildActionFunc(v, k, itemTable, self.invID))
            subMenuOption:SetImage(v.icon or "icon16/brick.png")
            if not v.multiOptions then return end
            local options = isfunction(v.multiOptions) and v.multiOptions(itemTable, LocalPlayer()) or v.multiOptions
            for _, sub in pairs(options) do
                subMenu:AddOption(L(sub.name or "subOption"), buildActionFunc(v, k, itemTable, self.invID, sub)):SetImage(sub.icon or "icon16/brick.png")
            end
        else
            menu:AddOption(L(v.name or k), buildActionFunc(v, k, itemTable, self.invID)):SetImage(v.icon or "icon16/brick.png")
        end
    end

    menu:Open()
    itemTable.player = nil
end

vgui.Register("liaItemIcon", PANEL, "SpawnIcon")
PANEL = {}
function PANEL:Init()
    self:MakePopup()
    self:Center()
    self:ShowCloseButton(false)
    self:SetDraggable(true)
    self:SetTitle(L("inv"))
end

function PANEL:setInventory(inventory)
    self.inventory = inventory
    self:liaListenForInventoryChanges(inventory)
end

function PANEL:InventoryInitialized()
end

function PANEL:InventoryDataChanged()
end

function PANEL:InventoryDeleted(inventory)
    if self.inventory == inventory then self:Remove() end
end

function PANEL:InventoryItemAdded()
end

function PANEL:InventoryItemRemoved()
end

function PANEL:InventoryItemDataChanged()
end

function PANEL:OnRemove()
    self:liaDeleteInventoryHooks()
end

vgui.Register("liaInventory", PANEL, "DFrame")
PANEL = {}
function PANEL:Init()
    self:MakePopup()
    self.content = self:Add("liaGridInventoryPanel")
    self.content:Dock(FILL)
    self.content:setGridSize(1, 1)
end

function PANEL:setInventory(inventory)
    self.gridW, self.gridH = inventory:getSize()
    self:SetSize(self.gridW * (64 + 2) + 4 * 2, self.gridH * (64 + 2) + 22 + 4 * 2)
    self:InvalidateLayout(true)
    self.content:setGridSize(self.gridW, self.gridH)
    self.content:setInventory(inventory)
    self.content.InventoryDeleted = function(_, deletedInventory) if deletedInventory == inventory then self:InventoryDeleted() end end
end

function PANEL:InventoryDeleted()
    self:Remove()
end

function PANEL:Center()
    local centerX, centerY = ScrW() * 0.5, ScrH() * 0.5
    self:SetPos(centerX - self:GetWide() * 0.5, centerY - self:GetTall() * 0.5)
end

vgui.Register("liaGridInventory", PANEL, "liaInventory")
local PANEL = {}
function PANEL:Init()
    self.size = 64
end

function PANEL:setIconSize(size)
    self.size = size
end

function PANEL:setItem(item)
    self.Icon:SetSize(self.size * (item.width or 1), self.size * (item.height or 1))
    self.Icon:InvalidateLayout(true)
    self:setItemType(item:getID())
    self:centerIcon()
end

function PANEL:centerIcon(w, h)
    w = w or self:GetWide()
    h = h or self:GetTall()
    local iconW, iconH = self.Icon:GetSize()
    self.Icon:SetPos((w - iconW) * 0.5, (h - iconH) * 0.5)
end

function PANEL:PaintBehind(w, h)
    surface.SetDrawColor(0, 0, 0, 150)
    surface.DrawRect(0, 0, w, h)
    surface.DrawOutlinedRect(0, 0, w, h)
end

function PANEL:PerformLayout(w, h)
    self:centerIcon(w, h)
end

vgui.Register("liaGridInvItem", PANEL, "liaItemIcon")
local PANEL = {}
function PANEL:Init()
    self:SetPaintBackground(false)
    self.icons = {}
    self:setGridSize(1, 1)
    self.occupied = {}
end

function PANEL:computeOccupied()
    if not self.inventory then return end
    for y = 0, self.gridH do
        self.occupied[y] = {}
        for x = 0, self.gridW do
            self.occupied[y][x] = false
        end
    end

    for _, item in pairs(self.inventory:getItems(true)) do
        local x, y = item:getData("x"), item:getData("y")
        if not x then continue end
        for offsetX = 0, (item.width or 1) - 1 do
            for offsetY = 0, (item.height or 1) - 1 do
                self.occupied[y + offsetY - 1][x + offsetX - 1] = true
            end
        end
    end
end

function PANEL:setInventory(inventory)
    self:liaListenForInventoryChanges(inventory)
    self.inventory = inventory
    self:populateItems()
end

function PANEL:setGridSize(width, height, iconSize)
    self.size = iconSize or 64
    self.gridW = width
    self.gridH = height
end

function PANEL:getIcons()
    return self.icons
end

function PANEL:removeIcon(icon)
    self.content:RemoveItem(icon)
end

function PANEL:onItemPressed(itemIcon, keyCode)
    if hook.Run("InterceptClickItemIcon", self, itemIcon, keyCode) ~= true then
        if keyCode == MOUSE_RIGHT then
            itemIcon:openActionMenu()
        elseif keyCode == MOUSE_LEFT then
            itemIcon:DragMousePress(keyCode)
            itemIcon:MouseCapture(true)
            lia.item.held = itemIcon
            lia.item.heldPanel = self
        end
    end
end

function PANEL:onItemReleased(itemIcon)
    local item = itemIcon.itemTable
    if not item then return end
    local x, y = self:LocalCursorPos()
    local size = self.size + 2
    local itemW = (item.width or 1) * size - 2
    local itemH = (item.height or 1) * size - 2
    x = math.Round((x - itemW * 0.5) / size) + 1
    y = math.Round((y - itemH * 0.5) / size) + 1
    self.inventory:requestTransfer(item:getID(), self.inventory:getID(), x, y)
    hook.Run("OnRequestItemTransfer", self, item:getID(), self.inventory:getID(), x, y)
end

function PANEL:populateItems()
    for key, icon in pairs(self.icons) do
        if IsValid(icon) then icon:Remove() end
        self.icons[key] = nil
    end

    for _, item in pairs(self.inventory:getItems(true)) do
        self:addItem(item)
    end

    self:computeOccupied()
end

function PANEL:addItem(item)
    local id = item:getID()
    local x, y = item:getData("x"), item:getData("y")
    if not x or not y then return end
    if IsValid(self.icons[id]) then self.icons[id]:Remove() end
    local size = self.size + 2
    local icon = self:Add("liaGridInvItem")
    icon:setItem(item)
    icon:SetPos((x - 1) * size, (y - 1) * size)
    icon:SetSize((item.width or 1) * size - 2, (item.height or 1) * size - 2)
    icon:InvalidateLayout(true)
    icon.OnMousePressed = function(icon, keyCode) self:onItemPressed(icon, keyCode) end
    icon.OnMouseReleased = function(icon, keyCode)
        local heldPanel = lia.item.heldPanel
        if IsValid(heldPanel) then heldPanel:onItemReleased(icon, keyCode) end
        icon:DragMouseRelease(keyCode)
        icon:MouseCapture(false)
        lia.item.held = nil
        lia.item.heldPanel = nil
    end

    self.icons[id] = icon
end

function PANEL:drawHeldItemRectangle()
    local heldItem = lia.item.held
    if not IsValid(heldItem) or not heldItem.itemTable then return end
    local item = heldItem.itemTable
    local size = self.size + 2
    local itemW = (item.width or 1) * size - 2
    local itemH = (item.height or 1) * size - 2
    local x, y = self:LocalCursorPos()
    x = math.Round((x - itemW * 0.5) / size)
    y = math.Round((y - itemH * 0.5) / size)
    local trimX, trimY
    local maxOffsetY = (item.height or 1) - 1
    local maxOffsetX = (item.width or 1) - 1
    local drawTarget = nil
    for itemID, invItem in pairs(self.inventory.items) do
        if item:getID() == itemID then continue end
        local targetX, targetY = invItem:getData("x") - 1, invItem:getData("y") - 1
        local targetW, targetH = invItem.width - 1, invItem.height - 1
        if x + item.width - 1 >= targetX and x <= targetX + targetW and y + item.height - 1 >= targetY and y <= targetY + targetH and (invItem.onCombine or item.onCombineTo) then
            drawTarget = {
                x = targetX,
                y = targetY,
                w = invItem.width,
                h = invItem.height
            }

            break
        end
    end

    if drawTarget then
        surface.SetDrawColor(Color(241, 196, 15, 25))
        surface.DrawRect(drawTarget.x * size, drawTarget.y * size, drawTarget.w * size - 2, drawTarget.h * size - 2)
    else
        for offsetY = 0, maxOffsetY do
            trimY = 0
            for offsetX = 0, maxOffsetX do
                trimX = 0
                if offsetY == maxOffsetY then trimY = 2 end
                if offsetX == maxOffsetX then trimX = 2 end
                local realX, realY = x + offsetX, y + offsetY
                if realX >= self.gridW or realY >= self.gridH or realX < 0 or realY < 0 then continue end
                surface.SetDrawColor(self.occupied[y + offsetY][x + offsetX] and Color(231, 76, 60, 25) or Color(46, 204, 113, 25))
                surface.DrawRect((x + offsetX) * size, (y + offsetY) * size, size - trimX, size - trimY)
            end
        end
    end
end

function PANEL:Center()
    local centerX, centerY = ScrW() * 0.5, ScrH() * 0.5
    self:SetPos(centerX - self:GetWide() * 0.5, centerY - self:GetTall() * 0.5)
end

function PANEL:InventoryItemAdded()
    self:populateItems()
end

function PANEL:InventoryItemRemoved()
    self:populateItems()
end

function PANEL:InventoryItemDataChanged()
    self:populateItems()
end

function PANEL:computeHeldPanel()
    if not lia.item.held or lia.item.held == self then return end
    local cursorX, cursorY = self:LocalCursorPos()
    if cursorX < 0 or cursorY < 0 or cursorX > self:GetWide() or cursorY > self:GetTall() then return end
    lia.item.heldPanel = self
end

function PANEL:Paint()
    surface.SetDrawColor(0, 0, 0, 100)
    local size = self.size
    for y = 0, self.gridH - 1 do
        for x = 0, self.gridW - 1 do
            surface.DrawRect(x * (size + 2), y * (size + 2), size, size)
        end
    end

    self:drawHeldItemRectangle()
    self:computeHeldPanel()
end

function PANEL:OnCursorMoved()
end

function PANEL:OnCursorExited()
    if lia.item.heldPanel == self then lia.item.heldPanel = nil end
end

vgui.Register("liaGridInventoryPanel", PANEL, "DPanel")
local margin = 10
hook.Add("CreateMenuButtons", "liaInventory", function(tabs)
    if hook.Run("CanPlayerViewInventory") == false then return end
    tabs["inv"] = function(panel)
        local inventory = LocalPlayer():getChar():getInv()
        if not inventory then return end
        local mainPanel = inventory:show(panel)
        local sortPanels = {}
        local totalSize = {
            x = 0,
            y = 0,
            p = 0
        }

        table.insert(sortPanels, mainPanel)
        totalSize.x = totalSize.x + mainPanel:GetWide() + margin
        totalSize.y = math.max(totalSize.y, mainPanel:GetTall())
        for _, item in pairs(inventory:getItems()) do
            if item.isBag and hook.Run("CanOpenBagPanel", item) ~= false then
                local inventory = item:getInv()
                local childPanels = inventory:show(mainPanel)
                lia.gui["inv" .. inventory:getID()] = childPanels
                table.insert(sortPanels, childPanels)
                totalSize.x = totalSize.x + childPanels:GetWide() + margin
                totalSize.y = math.max(totalSize.y, childPanels:GetTall())
            end
        end

        local px, py, pw, ph = mainPanel:GetBounds()
        local x, y = px + pw / 2 - totalSize.x / 2, py + ph / 2
        for _, panel in pairs(sortPanels) do
            panel:ShowCloseButton(false)
            panel:SetPos(x, y - panel:GetTall() / 2)
            x = x + panel:GetWide() + margin
        end

        hook.Add("PostRenderVGUI", mainPanel, function() hook.Run("PostDrawInventory", mainPanel) end)
    end
end)

-- ./gamemode/core/derma/panels/itempanel.lua
local PANEL = {}
function PANEL:Init()
    local sw, sh = ScrW(), ScrH()
    self:SetSize(sw * 0.6, sh * 0.8)
    self:Center()
    self:MakePopup()
    lia.gui.itemPanel = self
    self.header = vgui.Create("EditablePanel", self)
    self.header:Dock(TOP)
    self.nameLabel = vgui.Create("DLabel", self.header)
    self.nameLabel:SetFont("liaBigTitle")
    self.nameLabel:SetTextColor(color_white)
    self.nameLabel:SetContentAlignment(5)
    self.nameLabel:Dock(TOP)
    self.infoScroll = vgui.Create("DScrollPanel", self)
    self.infoScroll:Dock(TOP)
    self.infoScroll:SetTall(self:GetTall() * 0.55)
    self.btnArea = vgui.Create("EditablePanel", self)
    self.btnArea:Dock(BOTTOM)
    self.btnArea:SetWide(self:GetWide() * 0.4)
end

local function drawLine(parent, title, val)
    local t = parent:Add("DLabel")
    t:Dock(TOP)
    t:SetFont("liaBigTitle")
    t:SetTextColor(color_white)
    t:SetText(title)
    t:SizeToContentsY()
    local v = parent:Add("DLabel")
    v:Dock(TOP)
    v:DockMargin(0, 2, 0, 10)
    v:SetFont("liaBigText")
    v:SetTextColor(color_white)
    v:SetWrap(true)
    v:SetText(val ~= "" and val or "")
    timer.Simple(0, function()
        if IsValid(v) then
            v:SetWide(parent:GetWide() - 20)
            v:SizeToContentsY()
        end
    end)
end

function PANEL:addBtn(text, cb)
    local btn = vgui.Create("liaMediumButton", self.btnArea)
    btn:SetFont("liaBigBtn")
    btn:SetText(text)
    btn:SetTall(50)
    btn:Dock(TOP)
    btn:DockMargin(0, 0, 0, 8)
    btn.DoClick = cb
end

function PANEL:openInspect()
    if IsValid(self.inspectOverlay) then self.inspectOverlay:Remove() end
    local overlay = vgui.Create("EditablePanel")
    self.inspectOverlay = overlay
    overlay:SetSize(ScrW(), ScrH())
    overlay:MakePopup()
    overlay:SetKeyboardInputEnabled(true)
    local frame = vgui.Create("DFrame", overlay)
    self.inspectFrame = frame
    local fw, fh = ScrW() * 0.45, ScrH() * 0.8
    frame:SetSize(fw, fh)
    frame:Center()
    frame:SetTitle(L("inspect"))
    frame:SetDraggable(false)
    frame:ShowCloseButton(true)
    frame:MakePopup()
    frame.OnClose = function() if IsValid(overlay) then overlay:Remove() end end
    local hint = vgui.Create("DLabel", frame)
    hint:Dock(TOP)
    hint:SetTall(40)
    hint:SetContentAlignment(5)
    hint:SetFont("liaBigText")
    hint:SetTextColor(color_white)
    hint:SetText(L("itemInspectHint"))
    local view = vgui.Create("EditablePanel", frame)
    view:Dock(TOP)
    view:SetTall(fh * 0.5)
    view.Paint = function(_, w, h)
        surface.SetDrawColor(color_black)
        surface.DrawOutlinedRect(0, 0, w, h, 2)
    end

    local model = vgui.Create("DModelPanel", view)
    model:Dock(FILL)
    model:SetModel(self.item.model or "models/props_junk/popcan01a.mdl")
    model.LayoutEntity = function() end
    timer.Simple(0, function()
        if not IsValid(model) then return end
        local mn, mx = model.Entity:GetRenderBounds()
        local c = (mn + mx) * 0.5
        local r = (mx - mn):Length() * 0.5 + 4
        model:SetLookAt(c)
        local d = (model:GetCamPos() - c):Length()
        model:SetFOV(math.Clamp(math.deg(2 * math.asin(r / d)), 20, 80))
    end)

    model.OnMouseWheeled = function(p, d) p:SetFOV(math.Clamp(p:GetFOV() - d * 2, 20, 80)) end
    model.OnMousePressed = function(p, btn)
        if btn == MOUSE_LEFT then
            p.dragging = true
            p.lastX, p.lastY = gui.MousePos()
            p:MouseCapture(true)
        end
    end

    model.OnMouseReleased = function(p)
        p.dragging = false
        p:MouseCapture(false)
    end

    model.Think = function(p)
        if p.dragging then
            local x, y = gui.MousePos()
            local dx, dy = x - p.lastX, y - p.lastY
            p.lastX, p.lastY = x, y
            local off = Vector(-dx, dy, 0) * 0.03
            p:SetCamPos(p:GetCamPos() + off)
            p:SetLookAt(p:GetLookAt() + off)
        end

        if input.IsKeyDown(KEY_A) or input.IsKeyDown(KEY_D) then
            local ang = p.Entity:GetAngles()
            ang.y = ang.y + FrameTime() * 150 * (input.IsKeyDown(KEY_A) and 1 or -1)
            p.Entity:SetAngles(ang)
        end
    end

    local scroll = vgui.Create("DScrollPanel", frame)
    scroll:Dock(FILL)
    drawLine(scroll, L("name"), self.item:getName() or "")
    local extra = {}
    hook.Run("DisplayItemRelevantInfo", extra, LocalPlayer(), self.item)
    for _, info in ipairs(extra) do
        if info.title and info.value then
            local v = type(info.value) == "function" and info.value(LocalPlayer(), self.item) or tostring(info.value)
            drawLine(scroll, info.title, v)
        end
    end

    if LocalPlayer():Team() == FACTION_STAFF or LocalPlayer():hasPrivilege("Staff Permissions - Can Access Item Informations") then
        local cr = self.ent:GetCreator()
        if IsValid(cr) then drawLine(scroll, L("spawner"), cr:Name() .. " - " .. cr:SteamID()) end
    end

    local take = vgui.Create("liaMediumButton", frame)
    take:Dock(BOTTOM)
    take:SetTall(48)
    take:SetFont("liaBigBtn")
    take:SetText(L("take"))
    take.DoClick = function()
        if IsValid(self.ent) then netstream.Start("invAct", "take", self.ent) end
        if IsValid(overlay) then overlay:Remove() end
    end
end

function PANEL:buildButtons()
    self.btnArea:Clear()
    for key, fn in SortedPairs(self.item.functions) do
        if key == "combine" then continue end
        if hook.Run("CanRunItemAction", self.item, key) == false then continue end
        if type(fn.onCanRun) == "function" and not fn.onCanRun(self.item) then continue end
        self:addBtn(L(fn.name or key), function()
            if fn.sound then surface.PlaySound(fn.sound) end
            if not fn.onClick or fn.onClick(self.item) ~= false then netstream.Start("invAct", key, self.ent) end
            self:Remove()
        end)
    end

    self:addBtn(L("inspect"), function()
        self:openInspect()
        self:Remove()
    end)

    self:addBtn(L("exit"), function() self:Remove() end)
    local h = 0
    for _, c in ipairs(self.btnArea:GetChildren()) do
        h = h + c:GetTall() + 8
    end

    self.btnArea:SetTall(h)
    self.btnArea:SetPos((self:GetWide() - self.btnArea:GetWide()) * 0.5, self:GetTall() - h - 20)
end

function PANEL:SetEntity(ent)
    self.ent = ent
    self.item = ent:getItemTable()
    if not self.item then
        self:Remove()
        return
    end

    self.item.player = LocalPlayer()
    self.item.entity = ent
    self.nameLabel:SetText(self.item:getName() or "")
    self.nameLabel:SizeToContentsY()
    self.header:SetTall(self.nameLabel:GetTall())
    self:buildButtons()
end

function PANEL:Think()
    if not IsValid(self.ent) or LocalPlayer():GetPos():DistToSqr(self.ent:GetPos()) > 9216 then self:Remove() end
end

function PANEL:OnRemove()
    if self.item then
        self.item.player = nil
        self.item.entity = nil
    end

    lia.gui.itemPanel = nil
end

vgui.Register("liaItemMenu", PANEL, "EditablePanel")

-- ./gamemode/core/derma/panels/modelpanel.lua
local PANEL = {}

function PANEL:Init()
    self.brightness = 1
    self:SetCursor("none")
end

function PANEL:SetModel(model)
    DModelPanel.SetModel(self, model)
    local ent = self.Entity
    if not IsValid(ent) then return end
    local seq = ent:SelectWeightedSequence(ACT_IDLE)
    if seq <= 0 then seq = ent:LookupSequence("idle_unarmed") end
    if seq > 0 then
        ent:ResetSequence(seq)
        return
    end

    for _, name in ipairs(ent:GetSequenceList()) do
        local n = name:lower()
        if n ~= "idlenoise" and (n:find("idle") or n:find("fly")) then
            ent:ResetSequence(name)
            return
        end
    end

    ent:ResetSequence(4)
end

local mX, mY = gui.MouseX, gui.MouseY
function PANEL:LayoutEntity()
    local xR, yR = mX() / ScrW(), mY() / ScrH()
    local x = select(1, self:LocalToScreen(self:GetWide() / 2))
    local xR2 = x / ScrW()
    local ent = self.Entity
    ent:SetPoseParameter("head_pitch", yR * 90 - 30)
    ent:SetPoseParameter("head_yaw", (xR - xR2) * 90 - 5)
    ent:SetAngles(Angle(0, 45, 0))
    ent:SetIK(false)
    if self.copyLocalSequence then
        local ply = LocalPlayer()
        ent:SetSequence(ply:GetSequence())
        ent:SetPoseParameter("move_yaw", 360 * ply:GetPoseParameter("move_yaw") - 180)
    end

    self:RunAnimation()
end

function PANEL:PreDrawModel(ent)
    local b = self.brightness
    if b then
        local b1, b2 = b * 0.4, b * 1.5
        render.SetModelLighting(0, b2, b2, b2)
        for i = 1, 4 do
            render.SetModelLighting(i, b1, b1, b1)
        end

        local f = b1 * 0.1
        render.SetModelLighting(5, f, f, f)
    end

    if self.enableHook then hook.Run("DrawLiliaModelView", self, ent) end
    return true
end

function PANEL:OnMousePressed()
end

function PANEL:fitFOV()
    local ent = self:GetEntity()
    if not IsValid(ent) then return end
    local mins, maxs = ent:GetRenderBounds()
    local h = math.abs(maxs.z) + math.abs(mins.z) + 8
    local d = self:GetCamPos():Length()
    self:SetFOV(math.deg(2 * math.atan(h / (2 * d))))
end

vgui.Register("liaModelPanel", PANEL, "DModelPanel")
local PANEL = {}
local HEAD_BONE = "ValveBiped.Bip01_Head1"
local DEFAULT_ANGLE = Angle(0, 45, 0)
function PANEL:Init()
    self:SetFOV(15)
end

function PANEL:SetWT(s)
    self:SetSize(s, s)
end

function PANEL:LayoutEntity(ent)
    if not IsValid(ent) then return end
    self.BoneIndex = self.BoneIndex or ent:LookupBone(HEAD_BONE)
    if self.BoneIndex > 0 then self:SetLookAt(ent:GetBonePosition(self.BoneIndex)) end
    ent:SetAngles(DEFAULT_ANGLE)
end

vgui.Register("FacingModelPanel", PANEL, "DModelPanel")

-- ./gamemode/core/derma/panels/notice.lua
local TimeFraction, CurTime = math.TimeFraction, CurTime
local surfaceSetDrawColor, surfaceDrawRect, surfaceDrawOutlinedRect = surface.SetDrawColor, surface.DrawRect, surface.DrawOutlinedRect
local function PaintPanel(_, w, h)
    surfaceSetDrawColor(0, 0, 0, 255)
    surfaceDrawOutlinedRect(0, 0, w, h, 2)
    surfaceSetDrawColor(0, 0, 0, 150)
    surfaceDrawRect(1, 1, w - 2, h - 2)
end

local PANEL = {}
function PANEL:Init()
    self:SetSize(256, 36)
    self:SetContentAlignment(5)
    self:SetExpensiveShadow(1, Color(0, 0, 0, 150))
    self:SetFont("liaNoticeFont")
    self:SetTextColor(color_white)
    self:SetDrawOnTop(true)
end

function PANEL:Paint(w, h)
    lia.util.drawBlur(self, 3, 2)
    PaintPanel(self, w, h)
    if self.start then
        local w2 = TimeFraction(self.start, self.endTime, CurTime()) * w
        surfaceSetDrawColor(lia.config.get("Color"))
        surfaceDrawRect(w2, 0, w - w2, h)
    end

    surfaceSetDrawColor(lia.config.get("Color"))
    surfaceDrawOutlinedRect(0, 0, w, h)
end

vgui.Register("liaNotice", PANEL, "DLabel")
local PANEL = {}
function PANEL:Init()
    self.padding = 80
    self:SetSize(400, 60)
    self:SetContentAlignment(5)
    self.text = self:Add("DLabel")
    self.text:SetText(L("unassignedLabel"))
    self.text:SetExpensiveShadow(1, Color(0, 0, 0, 150))
    self.text:SetFont("liaMediumFont")
    self.text:SetTextColor(color_white)
    self.text:SetDrawOnTop(true)
    function self.text:Think()
        self:SizeToContents()
        self:Center()
    end
end

function PANEL:CalcWidth(padding)
    self.text:SizeToContents()
    self:SetWide(self.text:GetWide() + padding)
end

function PANEL:Paint(w, h)
    lia.util.drawBlur(self, 10)
    PaintPanel(self, w, h)
    if self.start then
        local w2 = TimeFraction(self.start, self.endTime, CurTime()) * w
        surfaceSetDrawColor(lia.config.get("Color"))
        surfaceDrawRect(w2, 0, w - w2, h)
    end

    surfaceSetDrawColor(lia.config.get("Color"))
    surfaceDrawOutlinedRect(0, 0, w, h)
end

vgui.Register("noticePanel", PANEL, "DPanel")

-- ./gamemode/core/derma/panels/panels.lua
local cacheKeys, cache, len = {}, {}, 0
local function PaintPanel(_, w, h)
    surface.SetDrawColor(0, 0, 0, 255)
    surface.DrawOutlinedRect(0, 0, w, h, 2)
    surface.SetDrawColor(0, 0, 0, 150)
    surface.DrawRect(1, 1, w - 2, h - 2)
end

local function PaintFrame(pnl, w, h)
    if not pnl.LaidOut then
        local btn = pnl.btnClose
        if btn and btn:IsValid() then
            btn:SetPos(w - 16, 4)
            btn:SetSize(24, 24)
            btn:SetFont("marlett")
            btn:SetText("r")
            btn:SetTextColor(Color(255, 255, 255))
            btn:PerformLayout()
        end

        pnl.LaidOut = true
    end

    lia.util.drawBlur(pnl, 10)
    surface.SetDrawColor(45, 45, 45, 200)
    surface.DrawRect(0, 0, w, h)
end

local BlurredDFrame = {}
function BlurredDFrame:Init()
    self:SetTitle("")
    self:ShowCloseButton(true)
    self:SetDraggable(true)
    self:MakePopup()
end

function BlurredDFrame:PerformLayout()
    DFrame.PerformLayout(self)
    if IsValid(self.btnClose) then self.btnClose:SetZPos(1000) end
end

function BlurredDFrame:Paint(w, h)
    PaintFrame(self, w, h)
end

vgui.Register("BlurredDFrame", BlurredDFrame, "DFrame")
local TransparentDFrame = {}
function TransparentDFrame:Init()
    self:SetTitle("")
    self:ShowCloseButton(true)
    self:SetDraggable(true)
    self:MakePopup()
end

function TransparentDFrame:PerformLayout()
    DFrame.PerformLayout(self)
    if IsValid(self.btnClose) then self.btnClose:SetZPos(1000) end
end

function TransparentDFrame:Paint(w, h)
    PaintPanel(self, w, h)
end

vgui.Register("SemiTransparentDFrame", TransparentDFrame, "DFrame")
local SimplePanel = {}
function SimplePanel:Paint(w, h)
    PaintPanel(self, w, h)
end

vgui.Register("SemiTransparentDPanel", SimplePanel, "DPanel")
timer.Create("derma_convar_fix", 0.5, 0, function()
    if len == 0 then return end
    local name
    for i = 1, len do
        name = cache[i]
        RunConsoleCommand(name, cacheKeys[name])
        cacheKeys[name] = nil
        cache[i] = nil
    end

    len = 0
end)

function Derma_SetCvar_Safe(name, value)
    if not cacheKeys[name] then
        cacheKeys[name] = tostring(value)
        len = len + 1
        cache[len] = name
    else
        timer.Adjust("derma_convar_fix", 0.5)
        cacheKeys[name] = tostring(value)
    end
end

function Derma_Install_Convar_Functions(PANEL)
    function PANEL:SetConVar(strConVar)
        self.m_strConVar = strConVar
    end

    function PANEL:ConVarChanged(strNewValue)
        local cvar = self.m_strConVar
        if not cvar or string.len(cvar) < 2 then return end
        Derma_SetCvar_Safe(cvar, strNewValue)
    end

    function PANEL:ConVarStringThink()
        local cvar = self.m_strConVar
        if not cvar or string.len(cvar) < 2 then return end
        local strValue = GetConVarString(cvar)
        if self.m_strConVarValue == strValue then return end
        self.m_strConVarValue = strValue
        self:SetValue(strValue)
    end

    function PANEL:ConVarNumberThink()
        local cvar = self.m_strConVar
        if not cvar or string.len(cvar) < 2 then return end
        local numValue = GetConVarNumber(cvar)
        if numValue ~= numValue then return end
        if self.m_strConVarValue == numValue then return end
        self.m_strConVarValue = numValue
        self:SetValue(numValue)
    end
end

-- ./gamemode/core/derma/panels/scoreboard.lua
local PANEL = {}
local staffCount = 0
local staffOnDutyCount = 0

local paintFunctions = {
    [0] = function(_, w, h)
        surface.SetDrawColor(0, 0, 0, 50)
        surface.DrawRect(0, 0, w, h)
    end,
    [1] = function() end
}

local function wrapTextNoBreak(text, maxWidth, font)
    surface.SetFont(font)
    local words = {}
    for word in text:gmatch("%S+") do
        table.insert(words, word)
    end

    local lines = {}
    local currentLine = ""
    for _, word in ipairs(words) do
        local testLine = currentLine == "" and word or currentLine .. " " .. word
        local w = select(1, surface.GetTextSize(testLine))
        if w > maxWidth then
            if currentLine == "" then
                table.insert(lines, word)
                currentLine = ""
            else
                table.insert(lines, currentLine)
                currentLine = word
            end
        else
            currentLine = testLine
        end
    end

    if currentLine ~= "" then table.insert(lines, currentLine) end
    return lines
end

function PANEL:Init()
    if IsValid(lia.gui.score) then lia.gui.score:Remove() end
    lia.gui.score = self
    self:SetSize(ScrW() * lia.config.get("sbWidth", 0.35), ScrH() * lia.config.get("sbHeight", 0.65))
    self:Center()
    if lia.config.get("DisplayServerName", false) then
        self.serverName = self:Add("DLabel")
        self.serverName:SetText(GetHostName())
        self.serverName:SetFont("liaBigFont")
        self.serverName:SetContentAlignment(5)
        self.serverName:SetTextColor(color_white)
        self.serverName:SetExpensiveShadow(1, color_black)
        self.serverName:Dock(TOP)
        self.serverName:SizeToContentsY()
        self.serverName.Paint = function(_, w, h)
            surface.SetDrawColor(0, 0, 0, 150)
            surface.DrawRect(0, 0, w, h)
        end
    end

    self.scroll = self:Add("DScrollPanel")
    self.scroll:Dock(FILL)
    self.scroll:DockMargin(1, 0, 1, 0)
    self.scroll.VBar:SetWide(0)
    self.layout = self.scroll:Add("DListLayout")
    self.layout:Dock(TOP)
    self.teams = {}
    self.slots = {}
    for k, fac in ipairs(lia.faction.indices) do
        local factionColor = team.GetColor(k)
        local r, g, b = factionColor.r, factionColor.g, factionColor.b
        local list = self.layout:Add("DListLayout")
        list:Dock(TOP)
        list:SetTall(ScrH()* 0.08)
        list.Think = function(this)
            for _, client in ipairs(lia.faction.getPlayers(k)) do
                if hook.Run("ShouldShowPlayerOnScoreboard", client) == false then continue end
                if not IsValid(client.liaScoreSlot) or client.liaScoreSlot:GetParent() ~= this then
                    if IsValid(client.liaScoreSlot) then
                        client.liaScoreSlot:SetParent(this)
                    else
                        self:addPlayer(client, this)
                    end
                end
            end
        end

        local header = list:Add("DPanel")
        header:Dock(TOP)
        header:SetTall(56)
        header:SetPaintBackground(false)
        local factionContainer = header:Add("DPanel")
        factionContainer:Dock(FILL)
        factionContainer:SetPaintBackground(false)
        local iconMat = fac.logo
        local iconWidth = ScrH()* 0.05
        local icon
        local factionName = factionContainer:Add("DLabel")
        factionName:Dock(FILL)
        factionName:SetFont("liaBigFont")
        factionName:SetTextColor(color_white)
        factionName:SetExpensiveShadow(1, color_black)
        factionName:SetText(L(fac.name))
        factionName:DockMargin(0, 0, iconMat and iconMat ~= "" and iconWidth or 0, 0)
        factionName:SetContentAlignment(5)
        if iconMat and iconMat ~= "" then
            icon = factionContainer:Add("DImage")
            icon:Dock(LEFT)
            icon:DockMargin(5, 5, 5, 5)
            icon:SetWide(iconWidth)
            icon:SetMaterial(Material(iconMat))
        end

        header.Paint = function(_, w, h)
            surface.SetDrawColor(r, g, b, 30)
            surface.DrawRect(0, 0, w, h)
            surface.SetDrawColor(r, g, b, 140)
            surface.DrawOutlinedRect(0, 0, w, h)
        end

        self.teams[k] = list
    end

    self.staff1 = self:Add("DLabel")
    self.staff1:SetText(L("playersOnline", 0) .. " | " .. L("staffOnDuty", 0) .. " | " .. L("staffOnline", 0))
    self.staff1:SetFont("liaMediumFont")
    self.staff1:SetContentAlignment(5)
    self.staff1:SetTextColor(color_white)
    self.staff1:SetExpensiveShadow(1, color_black)
    self.staff1:Dock(BOTTOM)
    self.staff1:SizeToContentsY()
    self.staff1.Paint = function(_, w, h)
        surface.SetDrawColor(0, 0, 0, 150)
        surface.DrawRect(0, 0, w, h)
    end
end

function PANEL:UpdateStaff()
    staffCount = 0
    staffOnDutyCount = 0
    for _, client in player.Iterator() do
        if client:isStaff() then staffCount = staffCount + 1 end
        if client:isStaffOnDuty() then staffOnDutyCount = staffOnDutyCount + 1 end
    end

    self.staff1:SetText(L("playersOnline", player.GetCount()) .. " | " .. L("staffOnDuty", staffOnDutyCount) .. " | " .. L("staffOnline", staffCount))
end

function PANEL:Think()
    local lp = LocalPlayer()
    if (self.nextUpdate or 0) < CurTime() then
        for k, teamPanel in ipairs(self.teams) do
            local amount = lia.faction.getPlayerCount(k)
            if k == FACTION_STAFF then
                teamPanel:SetVisible(not lia.config.get("ShowStaff", true) and lp:isStaffOnDuty() or amount > 0)
            else
                teamPanel:SetVisible(amount > 0)
            end

            self.layout:InvalidateLayout()
        end

        for _, slot in pairs(self.slots) do
            if IsValid(slot) then slot:update() end
        end

        if system.GetCountry() == "FR" and input.IsKeyDown(KEY_W) or system.GetCountry() ~= "FR" and input.IsKeyDown(KEY_Z) then self:Init() end
        self.nextUpdate = CurTime() + 0.1
        self:UpdateStaff()
    end
end

function PANEL:addPlayer(client, parent)
    local lp = LocalPlayer()
    if not client:getChar() or not IsValid(parent) then return end
    local slot = parent:Add("DPanel")
    slot:Dock(TOP)
    slot:SetTall(ScrH()* 0.07)
    slot:DockMargin(0, 0, 0, 0)
    slot.character = client:getChar()
    client.liaScoreSlot = slot
    local rowHeight = slot:GetTall()
    local modelSize = rowHeight * 0.9
    slot.Paint = function() end
    slot.model = vgui.Create("liaSpawnIcon", slot)
    slot.model:SetPos(5, (rowHeight - modelSize) * 0.5)
    slot.model:SetSize(modelSize, modelSize)
    slot.model:SetModel(client:GetModel(), client:GetSkin())
    slot.model.DoClick = function()
        local menu = DermaMenu()
        local opts = {}
        hook.Run("ShowPlayerOptions", client, opts)
        for _, opt in ipairs(opts) do
            menu:AddOption(L(opt.name), opt.func):SetImage(opt.image)
        end

        menu:Open()
        RegisterDermaMenuForClose(menu)
    end

    local tooltipText = L("sbOptions", client:steamName())
    local displayTooltip = (lp:hasPrivilege("Staff Permissions - Can Access Scoreboard Info Out Of Staff") or lp:hasPrivilege("Staff Permissions - Can Access Scoreboard Admin Options") and lp:isStaffOnDuty()) and tooltipText or ""
    slot.model:SetTooltip(displayTooltip)
    slot.model.OnCursorEntered = function(btn) btn:SetTooltip(displayTooltip) end
    timer.Simple(0, function()
        if not IsValid(slot) then return end
        local ent = slot.model.Entity
        if IsValid(ent) then
            for _, bg in ipairs(client:GetBodyGroups()) do
                ent:SetBodygroup(bg.id, client:GetBodygroup(bg.id))
            end

            for i = 1, #client:GetMaterials() do
                ent:SetSubMaterial(i - 1, client:GetSubMaterial(i - 1))
            end
        end
    end)

    slot.name = vgui.Create("DLabel", slot)
    slot.name:SetFont("liaMediumFont")
    slot.name:SetTextColor(color_white)
    slot.name:SetExpensiveShadow(1, color_black)
    slot.name:SetText("")
    slot.desc = vgui.Create("DLabel", slot)
    slot.desc:SetAutoStretchVertical(true)
    slot.desc:SetWrap(true)
    slot.desc:SetContentAlignment(7)
    slot.desc:SetTextColor(color_white)
    slot.desc:SetExpensiveShadow(1, Color(0, 0, 0, 100))
    slot.desc:SetFont("liaSmallFont")
    slot.ping = slot:Add("DLabel")
    slot.ping:SetSize(48, 64)
    slot.ping:SetText("0")
    slot.ping:SetFont("liaGenericFont")
    slot.ping:SetContentAlignment(6)
    slot.ping:SetTextColor(color_white)
    slot.ping:SetTextInset(16, 0)
    slot.ping.Think = function(p)
        if IsValid(client) then
            local pingStr = tostring(client:Ping())
            if p:GetText() ~= pingStr then
                p:SetText(pingStr)
                p:SizeToContentsX()
            end

            local sw = slot:GetWide()
            p:SetPos(sw - p:GetWide(), 0)
        end
    end

    slot.classLogo = vgui.Create("DImage", slot)
    local logoSize = rowHeight * 0.65
    local logoOffset = 10
    slot.classLogo:SetSize(logoSize, logoSize)
    slot.classLogo:SetMaterial(nil)
    slot.classLogo.Think = function()
        if IsValid(client) then
            local sw = slot:GetWide()
            local pw = slot.ping:GetWide()
            slot.classLogo:SetPos(sw - pw - logoSize - logoOffset, (slot:GetTall() - logoSize) * 0.5)
        end
    end

    slot.classLogo.Paint = function(self, w, h)
        local mat = self:GetMaterial()
        if mat then
            surface.SetMaterial(mat)
            surface.SetDrawColor(255, 255, 255, 255)
            surface.DrawTexturedRect(0, 0, w, h)
        end
    end

    function slot:PerformLayout()
        local pingWidth = self.ping:GetWide()
        local availWidth = self:GetWide() - (modelSize + 10) - (logoSize + logoOffset) - pingWidth - 10
        self.name:SetPos(modelSize + 10, 2)
        self.name:SetWide(availWidth)
        self.desc:SetPos(modelSize + 10, 24)
        self.desc:SetWide(availWidth)
    end

    function slot:update()
        if not IsValid(client) or not client:getChar() or not self.character or self.character ~= client:getChar() or client:Team() ~= client:Team() then
            self:Remove()
            local i = 0
            for _, child in ipairs(parent:GetChildren()) do
                if IsValid(child.model) and child ~= self then
                    i = i + 1
                    local basePaint = paintFunctions[i % 2]
                    child.Paint = function(s, w, h)
                        basePaint(s, w, h)
                        surface.SetDrawColor(255, 255, 255, 50)
                        surface.DrawLine(0, h - 1, w, h - 1)
                    end
                end
            end
            return
        end

        local overrideName = hook.Run("ShouldAllowScoreboardOverride", client, "name") and hook.Run("GetDisplayedName", client) or client:getChar():getName()
        local nameStr = (overrideName or client:Name()):gsub("#", "\226\128\139#")
        local overrideDesc = hook.Run("ShouldAllowScoreboardOverride", client, "desc") and hook.Run("GetDisplayedDescription", client, false) or client:getChar():getDesc()
        local descStr = (overrideDesc or ""):gsub("#", "\226\128\139#")
        local availWidth = self.desc:GetWide()
        local wrapped = wrapTextNoBreak(descStr, availWidth, "liaSmallFont")
        surface.SetFont("liaSmallFont")
        local _, lh = surface.GetTextSize("W")
        local availHeight = self:GetTall() - 24
        local maxLines = math.floor(availHeight / lh)
        if #wrapped > maxLines then
            wrapped[maxLines] = wrapped[maxLines] .. " (...)"
            for i = maxLines + 1, #wrapped do
                wrapped[i] = nil
            end
        end

        local finalText = table.concat(wrapped, "\n")
        local mdl = client:GetModel()
        local skin = client:GetSkin()
        self.model:setHidden(hook.Run("ShouldAllowScoreboardOverride", client, "model"))
        if self.lastName ~= nameStr then
            self.name:SetText(nameStr)
            self.lastName = nameStr
        end

        if self.lastDesc ~= finalText then
            self.desc:SetText(finalText)
            self.desc:SizeToContentsY()
            self.lastDesc = finalText
        end

        if self.lastModel ~= mdl or self.lastSkin ~= skin then
            self.model:SetModel(mdl, skin)
            self.lastModel = mdl
            self.lastSkin = skin
        end

        local char = client:getChar()
        local classData = char and lia.class.list[char:getClass()]
        if classData and classData.logo and not hook.Run("ShouldAllowScoreboardOverride", client, "classlogo") then
            if self.lastClassLogo ~= classData.logo then
                self.classLogo:SetMaterial(Material(classData.logo))
                self.lastClassLogo = classData.logo
            end
        else
            self.classLogo:SetMaterial(nil)
        end

        local ent = self.model.Entity
        timer.Simple(0, function()
            if IsValid(ent) and IsValid(client) then
                for _, bg in ipairs(client:GetBodyGroups()) do
                    ent:SetBodygroup(bg.id, client:GetBodygroup(bg.id))
                end
            end
        end)

        self:PerformLayout()
    end

    self.slots[#self.slots + 1] = slot
    parent:SetVisible(true)
    parent:SizeToChildren(false, true)
    parent:InvalidateLayout(true)
    local i = 0
    for _, child in ipairs(parent:GetChildren()) do
        if IsValid(child.model) then
            i = i + 1
            local basePaint = paintFunctions[i % 2]
            child.Paint = function(s, w, h)
                basePaint(s, w, h)
                surface.SetDrawColor(255, 255, 255, 50)
                surface.DrawLine(0, h - 1, w, h - 1)
            end
        end
    end

    slot:update()
    return slot
end

function PANEL:OnRemove()
    CloseDermaMenus()
end

local borderColorSolid = Color(0, 0, 0, 200)
local borderColorBlur = Color(0, 0, 0, 150)
local backgroundColorFallback = Color(50, 50, 50, 255)
local backgroundColorFallbackNonSolid = Color(30, 30, 30, 100)
function PANEL:Paint(w, h)
    local bgColor = lia.config.get("UseSolidBackground", false) and (lia.config.get("ScoreboardBackgroundColor", Color(255, 100, 100, 255)) or backgroundColorFallback) or backgroundColorFallbackNonSolid
    local bColor = lia.config.get("UseSolidBackground", false) and borderColorSolid or borderColorBlur
    if not lia.config.get("UseSolidBackground", false) then lia.util.drawBlur(self, 10) end
    surface.SetDrawColor(bgColor)
    surface.DrawRect(0, 0, w, h)
    surface.SetDrawColor(bColor.r, bColor.g, bColor.b, bColor.a)
    surface.DrawOutlinedRect(0, 0, w, h)
end

vgui.Register("liaScoreboard", PANEL, "EditablePanel")

-- ./gamemode/core/derma/panels/spawnicon.lua
local PANEL = {}
local function setSequence(entity)
    local seq = entity:SelectWeightedSequence(ACT_IDLE)
    if seq <= 0 then seq = entity:LookupSequence("idle_unarmed") end
    entity:SetIK(false)
    if seq > 0 then
        entity:ResetSequence(seq)
        return
    end

    for _, name in ipairs(entity:GetSequenceList()) do
        local lname = name:lower()
        if lname ~= "idlenoise" and (lname:find("idle") or lname:find("fly")) then
            entity:ResetSequence(name)
            return
        end
    end

    entity:ResetSequence(4)
end

function PANEL:Init()
    self:setHidden(false)
    for i = 0, 5 do
        self:SetDirectionalLight(i, (i == 1 or i == 5) and Color(155, 155, 155) or Color(255, 255, 255))
    end

    local oldSetModel = self.SetModel
    self.SetModel = function(panel, model, skin)
        oldSetModel(panel, model)
        local entity = panel.Entity
        if skin then entity:SetSkin(skin) end
        setSequence(entity)
        local data = PositionSpawnIcon(entity, entity:GetPos())
        if data then
            panel:SetFOV(data.fov)
            panel:SetCamPos(data.origin)
            panel:SetLookAng(data.angles)
        end

        entity:SetEyeTarget(Vector(0, 0, 64))
    end
end

function PANEL:setHidden(hidden)
    if hidden then
        self:SetAmbientLight(color_black)
        self:SetColor(Color(0, 0, 0))
    else
        self:SetAmbientLight(Color(20, 20, 20))
        self:SetAlpha(255)
        self:SetColor(Color(255, 255, 255))
    end

    for i = 0, 5 do
        self:SetDirectionalLight(i, hidden and color_black or (i == 1 or i == 5) and Color(155, 155, 155) or Color(255, 255, 255))
    end
end

function PANEL:LayoutEntity()
    self:RunAnimation()
end

function PANEL:OnMousePressed()
    if self.DoClick then self:DoClick() end
end

vgui.Register("liaSpawnIcon", PANEL, "DModelPanel")

-- ./gamemode/core/derma/panels/vendor.lua
local sw, sh = ScrW(), ScrH()
local EDITOR = include("lilia/modules/utilities/vendor/libs/cl_vendor.lua")
local COLS_MODE = 2
local COLS_PRICE = 3
local COLS_STOCK = 4
local RarityColors = {
    ["Common"] = Color(255, 255, 255),
    ["Uncommon"] = Color(30, 255, 0),
    ["Rare"] = Color(0, 112, 221),
    ["Epic"] = Color(163, 53, 238),
    ["Legendary"] = Color(255, 128, 0),
}

local VendorClick = {"buttons/button15.wav", 30, 250}
local PANEL = {}
function PANEL:Init()
    local ply = LocalPlayer()
    if IsValid(lia.gui.vendor) then
        lia.gui.vendor.noSendExit = true
        lia.gui.vendor:Remove()
    end

    lia.gui.vendor = self
    self:SetSize(sw, sh)
    self:MakePopup()
    self:SetAlpha(0)
    self:AlphaTo(255, 0.2, 0)
    self.buttons = self:Add("DPanel")
    self.buttons:DockMargin(0, 32, 0, 0)
    self.buttons:Dock(TOP)
    self.buttons:SetTall(36)
    self.buttons:SetPaintBackground(false)
    local y0 = 64 + 44
    local panelW = math.max(sw * 0.25, 220)
    local panelH = sh - y0
    self.vendorPanel = self:Add("DPanel")
    self.vendorPanel:SetSize(panelW, panelH)
    self.vendorPanel:SetPos(sw * 0.5 - panelW - 32, y0)
    self.vendorPanel.items = self.vendorPanel:Add("DScrollPanel")
    self.vendorPanel.items:Dock(FILL)
    self.mePanel = self:Add("DPanel")
    self.mePanel:SetSize(panelW, panelH)
    self.mePanel:SetPos(sw * 0.5 + 32, y0)
    self.mePanel.items = self.mePanel:Add("DScrollPanel")
    self.mePanel.items:Dock(FILL)
    self:listenForChanges()
    self:liaListenForInventoryChanges(ply:getChar():getInv())
    self.items = {
        vendor = {},
        me = {}
    }

    self.currentCategory = nil
    local lbl = self:Add("DLabel")
    lbl:SetText(L("vendorYourItems"))
    lbl:SetFont("liaBigFont")
    lbl:SetTextColor(color_white)
    lbl:SetContentAlignment(5)
    lbl:SizeToContents()
    lbl:SetPos(self.mePanel.x + panelW * 0.5 - lbl:GetWide() * 0.5, y0 - lbl:GetTall() - 10)
    local lbl2 = self:Add("DLabel")
    lbl2:SetText(L("vendorItems"))
    lbl2:SetFont("liaBigFont")
    lbl2:SetTextColor(color_white)
    lbl2:SetContentAlignment(5)
    lbl2:SizeToContents()
    lbl2:SetPos(self.vendorPanel.x + panelW * 0.5 - lbl2:GetWide() * 0.5, y0 - lbl2:GetTall() - 10)
    self:populateItems()
    self:createCategoryDropdown()
    self.left = self:Add("DFrame")
    self.left:SetPos(sw * 0.015, sh * 0.35)
    self.left:SetSize(sw * 0.212, sh * 0.24)
    self.left:SetTitle("")
    self.left:ShowCloseButton(false)
    self.left:SetDraggable(false)
    self.left.Paint = function()
        if not IsValid(liaVendorEnt) then return end
        local name = liaVendorEnt:getNetVar("name", "Jane Doe")
        local scale = liaVendorEnt:getNetVar("scale", 0.5)
        local money = liaVendorEnt:getMoney() and lia.currency.get(liaVendorEnt:getMoney()) or ""
        local count = table.Count(self.items.vendor)
        surface.SetDrawColor(30, 30, 30, 190)
        surface.DrawRect(0, 0, sw, ScreenScaleH(215))
        surface.DrawOutlinedRect(0, 0, sw, ScreenScaleH(215))
        surface.SetDrawColor(0, 0, 14, 150)
        surface.DrawRect(0, 0, sw * 0.26, sh * 0.033)
        surface.DrawOutlinedRect(0, 0, sw * 0.26, sh * 0.033)
        draw.DrawText(name, "liaMediumFont", sw * 0.005, sh * 0.003, color_white, TEXT_ALIGN_LEFT)
        draw.DrawText(L("vendorMoney"), "liaSmallFont", sw * 0.1, sh * 0.05, color_white, TEXT_ALIGN_LEFT)
        draw.DrawText(money, "liaSmallFont", sw * 0.2, sh * 0.05, color_white, TEXT_ALIGN_RIGHT)
        draw.DrawText(L("vendorSellScale"), "liaSmallFont", sw * 0.1, sh * 0.07, color_white, TEXT_ALIGN_LEFT)
        draw.DrawText(math.ceil(scale * 100) .. "%", "liaSmallFont", sw * 0.2, sh * 0.07, color_white, TEXT_ALIGN_RIGHT)
        draw.DrawText(L("vendorItemCount"), "liaSmallFont", sw * 0.1, sh * 0.09, color_white, TEXT_ALIGN_LEFT)
        local txt = count == 0 and "No Items" or count == 1 and "1 Item" or count .. " Items"
        draw.DrawText(txt, "liaSmallFont", sw * 0.2, sh * 0.09, color_white, TEXT_ALIGN_RIGHT)
    end

    self.right = self:Add("DFrame")
    self.right:SetPos(sw * 0.78, sh * 0.35)
    self.right:SetSize(sw * 0.212, sh * 0.61)
    self.right:SetTitle("")
    self.right:ShowCloseButton(false)
    self.right:SetDraggable(false)
    self.right.Paint = function()
        surface.SetDrawColor(30, 30, 30, 190)
        surface.DrawRect(0, 0, sw, ScreenScaleH(215))
        surface.DrawOutlinedRect(0, 0, sw, ScreenScaleH(215))
        surface.SetDrawColor(0, 0, 14, 150)
        surface.DrawRect(0, 0, sw * 0.26, sh * 0.033)
        surface.DrawOutlinedRect(0, 0, sw * 0.26, sh * 0.033)
        local char = ply:getChar()
        if not char then return end
        draw.DrawText(char:getName(), "liaMediumFont", sw * 0.005, sh * 0.003, color_white, TEXT_ALIGN_LEFT)
        local faction = team.GetName(ply:Team())
        if #faction > 25 then faction = faction:sub(1, 25) .. "..." end
        draw.DrawText(L("faction"), "liaSmallFont", sw * 0.085, sh * 0.05, color_white, TEXT_ALIGN_LEFT)
        draw.DrawText(faction, "liaSmallFont", sw * 0.201, sh * 0.05, color_white, TEXT_ALIGN_RIGHT)
        local class = char:getClass()
        local invCount = char:getInv():getItemCount()
        local disp = invCount == 0 and "No Items" or invCount == 1 and "1 Item" or invCount .. " Items"
        if lia.class.list[class] then
            draw.DrawText(L("class"), "liaSmallFont", sw * 0.085, sh * 0.07, color_white, TEXT_ALIGN_LEFT)
            draw.DrawText(lia.class.list[class].name, "liaSmallFont", sw * 0.2, sh * 0.07, color_white, TEXT_ALIGN_RIGHT)
            draw.DrawText(L("vendorMoney"), "liaSmallFont", sw * 0.085, sh * 0.09, color_white, TEXT_ALIGN_LEFT)
            draw.DrawText(lia.currency.get(char:getMoney()), "liaSmallFont", sw * 0.2, sh * 0.09, color_white, TEXT_ALIGN_RIGHT)
            draw.DrawText(L("vendorItemCount"), "liaSmallFont", sw * 0.085, sh * 0.11, color_white, TEXT_ALIGN_LEFT)
            draw.DrawText(disp, "liaSmallFont", sw * 0.2, sh * 0.11, color_white, TEXT_ALIGN_RIGHT)
        else
            draw.DrawText(L("vendorMoney"), "liaSmallFont", sw * 0.085, sh * 0.07, color_white, TEXT_ALIGN_LEFT)
            draw.DrawText(lia.currency.get(char:getMoney()), "liaSmallFont", sw * 0.2, sh * 0.07, color_white, TEXT_ALIGN_RIGHT)
            draw.DrawText(L("vendorItemCount"), "liaSmallFont", sw * 0.085, sh * 0.09, color_white, TEXT_ALIGN_LEFT)
            draw.DrawText(disp, "liaSmallFont", sw * 0.2, sh * 0.09, color_white, TEXT_ALIGN_RIGHT)
        end
    end

    local bw, bh = sw * 0.15, sh * 0.05
    if ply:CanEditVendor(self.vendorPanel) then
        local by = self.right:GetY() + self.right:GetTall() - bh - sw * 0.02
        local btn = self:Add("liaSmallButton")
        btn:SetSize(bw, bh)
        btn:SetPos(self.left:GetWide() - bw - sw * 0.02, by)
        btn:SetText(L("vendorEditorButton"))
        btn:SetFont("liaMediumFont")
        btn:SetTextColor(color_white)
        btn.DoClick = function() vgui.Create("VendorEditor"):SetZPos(99) end
    end

    local leave = self.right:Add("liaSmallButton")
    leave:SetSize(bw, bh)
    leave:SetPos(self.right:GetWide() - bw - sw * 0.02, self.right:GetTall() - bh - sw * 0.02)
    leave:SetText(L("leave"))
    leave:SetFont("liaMediumFont")
    leave:SetTextColor(color_white)
    leave.DoClick = function() self:Remove() end
    self:DrawModels()
end

function PANEL:createCategoryDropdown()
    local c = self:GetItemCategoryList()
    if table.Count(c) < 1 then return end
    local btn = self:Add("liaSmallButton")
    btn:SetSize(sw * 0.15, sh * 0.035)
    btn:SetPos(sw * 0.82, 110)
    btn:SetText(L("vendorShowAll"))
    local sorted = {}
    for k in pairs(c) do
        sorted[#sorted + 1] = k
    end

    table.sort(sorted, function(a, b) return a:lower() < b:lower() end)
    local menu
    btn.DoClick = function()
        if IsValid(menu) then
            menu:Remove()
            menu = nil
            return
        end

        menu = vgui.Create("DScrollPanel", self)
        menu:SetSize(btn:GetWide(), #sorted * 24)
        menu:SetPos(btn.x, btn.y + btn:GetTall() + 2)
        for i, cat in ipairs(sorted) do
            local text = cat:gsub("^%l", string.upper)
            local item = menu:Add("liaSmallButton")
            item:SetSize(menu:GetWide(), 22)
            item:SetPos(0, (i - 1) * 24)
            item:SetText(text)
            item.DoClick = function()
                local all = L("vendorShowAll")
                if cat == all then
                    self.currentCategory = nil
                    btn:SetText(all)
                else
                    self.currentCategory = cat
                    btn:SetText(text)
                end

                self:applyCategoryFilter()
                if IsValid(menu) then
                    menu:Remove()
                    menu = nil
                end
            end
        end
    end
end

function PANEL:DrawModels()
    self.vendorModel = self:Add("DModelPanel")
    self.vendorModel:SetSize(ScreenScale(160), ScreenScaleH(170))
    self.vendorModel:SetPos(self:GetWide() * 0.25 - ScreenScale(350) - ScreenScale(100), sh * 0.36 + ScreenScaleH(25))
    local model = liaVendorEnt and liaVendorEnt.GetModel and liaVendorEnt:GetModel() or ""
    if util.IsValidModel(model) then
        self.vendorModel:SetModel(model)
    else
        self.vendorModel:SetModel("")
    end

    self.vendorModel:SetFOV(20)
    self.vendorModel:SetAlpha(0)
    self.vendorModel:AlphaTo(255, 0.2)
    self.vendorModel.LayoutEntity = function(_, ent)
        local bone = ent:LookupBone("ValveBiped.Bip01_Head1")
        if bone and bone >= 0 then
            ent:SetAngles(Angle(0, 45, 0))
            self.vendorModel:SetLookAt(ent:GetBonePosition(bone))
        end
    end

    self.playerModel = self:Add("DModelPanel")
    self.playerModel:SetSize(ScreenScale(160), ScreenScaleH(170))
    self.playerModel:SetPos(self:GetWide() * 0.75 + ScreenScale(110) - ScreenScale(50), sh * 0.36 + ScreenScaleH(25))
    local pm = LocalPlayer():GetModel()
    if util.IsValidModel(pm) then
        self.playerModel:SetModel(pm)
    else
        self.playerModel:SetModel("")
    end

    self.playerModel:SetFOV(20)
    self.playerModel:SetAlpha(0)
    self.playerModel:AlphaTo(255, 0.2)
    self.playerModel.LayoutEntity = function(_, ent)
        local bone = ent:LookupBone("ValveBiped.Bip01_Head1")
        if bone and bone >= 0 then
            ent:SetAngles(Angle(0, 45, 0))
            self.playerModel:SetLookAt(ent:GetBonePosition(bone))
        end
    end
end

function PANEL:buyItemFromVendor(id)
    net.Start("VendorTrade")
    net.WriteString(id)
    net.WriteBool(false)
    net.SendToServer()
end

function PANEL:sellItemToVendor(id)
    net.Start("VendorTrade")
    net.WriteString(id)
    net.WriteBool(true)
    net.SendToServer()
end

function PANEL:populateItems()
    if not IsValid(liaVendorEnt) then return end
    local data = liaVendorEnt.items
    if not istable(data) then data = liaVendorEnt:getNetVar("items", {}) end
    for id in SortedPairs(data) do
        local item = lia.item.list[id]
        local mode = liaVendorEnt:getTradeMode(id)
        if item and mode then
            if mode ~= VENDOR_BUYONLY then self:updateItem(id, "vendor") end
            if mode ~= VENDOR_SELLONLY then
                local pnl = self:updateItem(id, "me")
                if pnl then pnl:setIsSelling(true) end
            end
        end
    end
end

function PANEL:shouldShow(id, which)
    if not IsValid(liaVendorEnt) then return false end
    local mode = liaVendorEnt:getTradeMode(id)
    if not mode then return false end
    if which == "me" and mode == VENDOR_SELLONLY then return false end
    if which == "vendor" and mode == VENDOR_BUYONLY then return false end
    return true
end

function PANEL:updateItem(id, which, qty)
    local container = self.items[which]
    if not container then return end
    if not self:shouldShow(id, which) then
        if IsValid(container[id]) then container[id]:Remove() end
        return
    end

    local parent = which == "me" and self.mePanel or self.vendorPanel
    if not IsValid(parent.items) then
        parent.items = vgui.Create("DPanel", parent)
        parent.items:Dock(FILL)
        parent.items:SetPaintBackground(false)
    end

    local pnl = container[id]
    if not IsValid(pnl) then
        pnl = vgui.Create("VendorItem", parent.items)
        pnl:setItemType(id)
        pnl:setIsSelling(which == "me")
        container[id] = pnl
    end

    if not isnumber(qty) then qty = which == "me" and LocalPlayer():getChar():getInv():getItemCount(id) or liaVendorEnt:getStock(id) end
    pnl:setQuantity(qty)
    return pnl
end

function PANEL:GetItemCategoryList()
    if not IsValid(liaVendorEnt) then return {} end
    local data = liaVendorEnt.items
    if not istable(data) then data = liaVendorEnt:getNetVar("items", {}) end
    local out = {
        [L("vendorShowAll")] = true
    }

    for id in pairs(data) do
        local itm = lia.item.list[id]
        if itm then
            local cat = itm.category or "Misc"
            out[cat:sub(1, 1):upper() .. cat:sub(2)] = true
        end
    end
    return out
end

function PANEL:applyCategoryFilter()
    for _, p in pairs(self.items.vendor) do
        if IsValid(p) then p:Remove() end
    end

    for _, p in pairs(self.items.me) do
        if IsValid(p) then p:Remove() end
    end

    self.items.vendor = {}
    self.items.me = {}
    local data = liaVendorEnt.items
    if not istable(data) then data = liaVendorEnt:getNetVar("items", {}) end
    for id in SortedPairs(data) do
        local itm = lia.item.list[id]
        local cat = itm and itm.category or "Misc"
        cat = cat:sub(1, 1):upper() .. cat:sub(2)
        if not self.currentCategory or self.currentCategory == L("vendorShowAll") or cat == self.currentCategory then
            local mode = liaVendorEnt:getTradeMode(id)
            if mode ~= VENDOR_BUYONLY then self:updateItem(id, "vendor") end
            if mode ~= VENDOR_SELLONLY then
                local pnl = self:updateItem(id, "me")
                if pnl then pnl:setIsSelling(true) end
            end
        end
    end

    if IsValid(self.vendorPanel.items) then self.vendorPanel.items:InvalidateLayout() end
    if IsValid(self.mePanel.items) then self.mePanel.items:InvalidateLayout() end
end

function PANEL:listenForChanges()
    hook.Add("VendorItemPriceUpdated", self, self.onVendorPriceUpdated)
    hook.Add("VendorItemStockUpdated", self, self.onItemStockUpdated)
    hook.Add("VendorItemMaxStockUpdated", self, self.onItemStockUpdated)
    hook.Add("VendorItemModeUpdated", self, self.onVendorModeUpdated)
    hook.Add("VendorEdited", self, self.onVendorPropEdited)
end

function PANEL:InventoryItemAdded(it)
    if it and it.uniqueID then self:updateItem(it.uniqueID, "me") end
end

function PANEL:InventoryItemRemoved(it)
    if it and it.uniqueID then self:InventoryItemAdded(it) end
end

function PANEL:onVendorPropEdited(_, key)
    if not IsValid(liaVendorEnt) then return end
    if key == "model" then
        local m = liaVendorEnt:GetModel() or ""
        if util.IsValidModel(m) then
            self.vendorModel:SetModel(m)
        else
            self.vendorModel:SetModel("")
        end
    elseif key == "scale" then
        for _, v in pairs(self.items.vendor) do
            if IsValid(v) then v:updateLabel() end
        end

        for _, v in pairs(self.items.me) do
            if IsValid(v) then v:updateLabel() end
        end
    end

    self:applyCategoryFilter()
end

function PANEL:onVendorPriceUpdated(_, id)
    if IsValid(self.items.vendor[id]) then self.items.vendor[id]:updateLabel() end
    if IsValid(self.items.me[id]) then self.items.me[id]:updateLabel() end
    self:applyCategoryFilter()
end

function PANEL:onVendorModeUpdated(_, id)
    self:updateItem(id, "vendor")
    self:updateItem(id, "me")
    self:applyCategoryFilter()
end

function PANEL:onItemStockUpdated(_, id)
    self:updateItem(id, "vendor")
    self:applyCategoryFilter()
end

function PANEL:Paint()
    lia.util.drawBlur(self, 15)
end

function PANEL:OnRemove()
    if not self.noSendExit then
        net.Start("VendorExit")
        net.SendToServer()
        self.noSendExit = true
    end

    if IsValid(lia.gui.vendorEditor) then lia.gui.vendorEditor:Remove() end
    if IsValid(lia.gui.vendorFactionEditor) then lia.gui.vendorFactionEditor:Remove() end
    self:liaDeleteInventoryHooks()
end

function PANEL:OnKeyCodePressed()
    if input.LookupBinding("+use", true) then self:Remove() end
end

vgui.Register("Vendor", PANEL, "EditablePanel")
local PANEL = {}
function PANEL:Init()
    self:SetSize(600, 200)
    self:Dock(TOP)
    self:SetPaintBackground(false)
    self:SetCursor("hand")
    self.background = self:Add("DPanel")
    self.background:Dock(FILL)
    self.background:DockMargin(0, 0, 0, 10)
    self.iconFrame = self.background:Add("DPanel")
    self.iconFrame:SetSize(96, 96)
    self.iconFrame:Dock(LEFT)
    self.iconFrame:DockMargin(10, 10, 10, 10)
    self.icon = self.iconFrame:Add("liaItemIcon")
    self.icon:SetSize(96, 96)
    self.icon:Dock(FILL)
    self.icon.Paint = function() end
    self.textContainer = self.background:Add("DPanel")
    self.textContainer:Dock(FILL)
    self.textContainer:DockMargin(0, 10, 10, 10)
    self.textContainer:SetPaintBackground(false)
    self.name = self.textContainer:Add("DLabel")
    self.name:SetFont("VendorItemNameFont")
    self.name:SetExpensiveShadow(1, color_black)
    self.name:Dock(TOP)
    self.name:DockMargin(0, 0, 0, 8)
    self.name:SetContentAlignment(5)
    self.name:SetText("")
    self.description = self.textContainer:Add("DLabel")
    self.description:SetFont("VendorItemDescFont")
    self.description:SetTextColor(Color(200, 200, 200))
    self.description:Dock(TOP)
    self.description:DockMargin(0, 12, 0, 0)
    self.description:SetWrap(true)
    self.description:SetContentAlignment(1)
    self.description:SetAutoStretchVertical(true)
    self.description:SetText("")
    self.spacer = self.textContainer:Add("DPanel")
    self.spacer:Dock(FILL)
    self.spacer:SetPaintBackground(false)
    self.action = self.textContainer:Add("liaSmallButton")
    self.action:SetHeight(40)
    self.action:Dock(BOTTOM)
    self.action:DockMargin(0, 10, 0, 0)
    self.action:SetFont("VendorItemDescFont")
    self.action:SetTextColor(color_white)
    self.isSelling = false
    self.suffix = ""
end

local function clickEffects()
    local client = LocalPlayer()
    client:EmitSound(unpack(VendorClick))
end

function PANEL:sellItemToVendor()
    local item = self.item
    if not item then return end
    if IsValid(lia.gui.vendor) then
        lia.gui.vendor:sellItemToVendor(item.uniqueID)
        clickEffects()
    end
end

function PANEL:buyItemFromVendor()
    local item = self.item
    if not item then return end
    if IsValid(lia.gui.vendor) then
        lia.gui.vendor:buyItemFromVendor(item.uniqueID)
        clickEffects()
    end
end

function PANEL:updateAction()
    if not self.action or not self.item then return end
    local price = liaVendorEnt:getPrice(self.item.uniqueID, self.isSelling)
    local priceSuffix
    if price == 0 then
        priceSuffix = L("vendorFree")
    elseif price > 1 then
        priceSuffix = string.format("%s %s", price, lia.currency.plural)
    else
        priceSuffix = string.format("%s %s", price, lia.currency.singular)
    end

    local actionText = self.isSelling and L("vendorSellAction", priceSuffix) or L("vendorBuyAction", priceSuffix)
    self.action:SetText(actionText)
    self.action.DoClick = function()
        if self.isSelling then
            self:sellItemToVendor()
        else
            self:buyItemFromVendor()
        end
    end
end

function PANEL:setQuantity(quantity)
    if not self.item then return end
    if quantity then
        if quantity <= 0 then
            self:Remove()
            return
        end

        self.suffix = tostring(quantity) .. "x "
    else
        self.suffix = ""
    end

    self:updateLabel()
end

function PANEL:setItemType(itemType)
    local item = lia.item.list[itemType]
    assert(item, tostring(itemType) .. " is not a valid item")
    self.item = item
    self.icon:SetModel(item.model, item.skin or 0)
    self:updateLabel()
    self:updateAction()
    local rarity = item.rarity or "Common"
    local nameColor = RarityColors[rarity] or color_white
    self.name:SetTextColor(nameColor)
end

function PANEL:setIsSelling(isSelling)
    self.isSelling = isSelling
    self:updateLabel()
    self:updateAction()
end

function PANEL:updateLabel()
    if not self.item then return end
    local nameText = (self.suffix ~= "" and self.suffix or "") .. self.item:getName()
    self.name:SetText(nameText)
    self.description:SetText(self.item:getDesc() or L("noDesc"))
    local price = liaVendorEnt:getPrice(self.item.uniqueID, self.isSelling)
    local priceSuffix
    if price == 0 then
        priceSuffix = L("vendorFree")
    elseif price > 1 then
        priceSuffix = string.format("%s %s", price, lia.currency.plural)
    else
        priceSuffix = string.format("%s %s", price, lia.currency.singular)
    end

    local actionText = self.isSelling and L("vendorSellAction", priceSuffix) or L("vendorBuyAction", priceSuffix)
    self.action:SetText(actionText)
end

vgui.Register("VendorItem", PANEL, "DPanel")
local PANEL = {}
function PANEL:Init()
    if IsValid(lia.gui.vendorEditor) then lia.gui.vendorEditor:Remove() end
    lia.gui.vendorEditor = self
    local entity = liaVendorEnt
    local width = math.min(ScrW() * 0.75, 480)
    local height = math.min(ScrH() * 0.75, 640)
    self:SetSize(width, height)
    self:MakePopup()
    self:Center()
    self:SetTitle(L("vendorEditor"))
    self.name = self:Add("DTextEntry")
    self.name:Dock(TOP)
    self.name:SetTooltip(L("name"))
    self.name:SetText(entity:getName())
    self.name.OnEnter = function(this) if entity:getNetVar("name") ~= this:GetText() then EDITOR.name(this:GetText()) end end
    self.model = self:Add("DTextEntry")
    self.model:Dock(TOP)
    self.model:SetTooltip(L("model"))
    self.model:DockMargin(0, 4, 0, 0)
    self.model:SetText(entity:GetModel())
    self.model.OnEnter = function(this)
        local modelText = this:GetText():lower()
        if entity:GetModel():lower() ~= modelText then EDITOR.model(modelText) end
    end

    self.flag = self:Add("DTextEntry")
    self.flag:Dock(TOP)
    self.flag:DockMargin(0, 4, 0, 0)
    self.flag:SetText(entity:getNetVar("flag") or L("flag"))
    self.flag.OnEnter = function(this)
        local value = this:GetText()
        if value:match("^%a$") then
            EDITOR.flag(value)
        else
            local correctedValue = value:sub(1, 1):match("^%a$") and value:sub(1, 1) or "F"
            this:SetText(correctedValue)
            EDITOR.flag(correctedValue)
        end
    end

    self.welcome = self:Add("DTextEntry")
    self.welcome:Dock(TOP)
    self.welcome:DockMargin(0, 4, 0, 0)
    self.welcome:SetText(entity:getWelcomeMessage())
    self.welcome:SetTooltip(L("vendorEditorWelcomeMessage"))
    self.welcome.OnEnter = function(this)
        local msg = this:GetText()
        if msg ~= entity:getWelcomeMessage() then EDITOR.welcome(msg) end
    end

    self.money = self:Add("DTextEntry")
    self.money:Dock(TOP)
    self.money:SetTooltip(lia.currency.plural)
    self.money:DockMargin(0, 4, 0, 0)
    self.money:SetNumeric(true)
    self.money.OnEnter = function(this)
        local value = tonumber(this:GetText()) or entity:getMoney()
        value = math.Round(value)
        value = math.max(value, 0)
        if value ~= entity:getMoney() then EDITOR.money(value) end
    end

    self.useMoney = self:Add("DCheckBoxLabel")
    self.useMoney:SetText(L("vendorUseMoney"))
    self.useMoney:Dock(TOP)
    self.useMoney:SetTextColor(Color(255, 255, 255))
    self.useMoney:DockMargin(0, 4, 0, 0)
    self.useMoney.OnChange = function(_, value) EDITOR.useMoney(value) end
    self.sellScale = self:Add("DNumSlider")
    self.sellScale:Dock(TOP)
    self.sellScale:DockMargin(0, 4, 0, 0)
    self.sellScale:SetText(L("vendorSellScale"))
    self.sellScale.Label:SetTextColor(color_white)
    self.sellScale.TextArea:SetTextColor(color_white)
    self.sellScale:SetDecimals(2)
    self.sellScale.OnValueChanged = function(_, value)
        timer.Create("VendorScale", 0.5, 1, function()
            if IsValid(self) and IsValid(self.sellScale) then
                value = self.sellScale:GetValue()
                local diff = math.abs(value - entity:getSellScale())
                if diff > 0.05 then EDITOR.scale(value) end
            end
        end)
    end

    self.faction = self:Add("DButton")
    self.faction:SetText(L("vendorFaction"))
    self.faction:Dock(TOP)
    self.faction:SetTextColor(color_white)
    self.faction:DockMargin(0, 4, 0, 0)
    self.faction.DoClick = function() vgui.Create("VendorFactionEditor"):MoveLeftOf(self, 4) end
    self.items = self:Add("DListView")
    self.items:Dock(FILL)
    self.items:DockMargin(0, 4, 0, 0)
    self.items:AddColumn(L("name")).Header:SetTextColor(color_white)
    self.items:AddColumn(L("vendorMode")).Header:SetTextColor(color_white)
    self.items:AddColumn(L("price")).Header:SetTextColor(color_white)
    self.items:AddColumn(L("stock")).Header:SetTextColor(color_white)
    self.items:AddColumn(L("vendorCategory")).Header:SetTextColor(color_white)
    self.items:SetMultiSelect(false)
    self.items.OnRowRightClick = function(_, _, line) self:OnRowRightClick(line) end
    self.searchBar = self:Add("DTextEntry")
    self.searchBar:Dock(TOP)
    self.searchBar:DockMargin(0, 4, 0, 0)
    self.searchBar:SetUpdateOnType(true)
    self.searchBar:SetPlaceholderText(L("search"))
    self.searchBar.OnValueChange = function(_, value) self:ReloadItemList(value) end
    self.lines = {}
    self:ReloadItemList()
    self:listenForUpdates()
    self:updateMoney()
    self:updateSellScale()
end

function PANEL:getModeText(mode)
    return mode and L(VENDOR_TEXT[mode]) or L("none")
end

function PANEL:OnRemove()
    if IsValid(lia.gui.editorFaction) then lia.gui.editorFaction:Remove() end
end

function PANEL:updateVendor(key, value)
    netstream.Start("vendorEdit", key, value)
end

function PANEL:OnFocusChanged(gained)
    if not gained then
        timer.Simple(0, function()
            if not IsValid(self) then return end
            self:MakePopup()
        end)
    end
end

function PANEL:updateMoney()
    local money = liaVendorEnt:getMoney()
    local useMoney = isnumber(money)
    if money then
        self.money:SetText(money)
    else
        self.money:SetText("")
    end

    self.money:SetDisabled(not useMoney)
    self.money:SetEnabled(useMoney)
    self.useMoney:SetChecked(useMoney)
end

function PANEL:updateSellScale()
    self.sellScale:SetValue(liaVendorEnt:getSellScale())
end

function PANEL:onNameDescChanged(key)
    local entity = liaVendorEnt
    if key == "name" then
        self.name:SetText(entity:getName())
    elseif key == "model" then
        self.model:SetText(entity:GetModel())
    elseif key == "scale" then
        self:updateSellScale()
    elseif key == "welcome" and entity.getWelcomeMessage then
        self.welcome:SetText(entity:getWelcomeMessage())
    end
end

function PANEL:onItemModeUpdated(_, itemType, value)
    local line = self.lines[itemType]
    if not IsValid(line) then return end
    line:SetColumnText(COLS_MODE, self:getModeText(value))
end

function PANEL:onItemPriceUpdated(vendor, itemType)
    local line = self.lines[itemType]
    if not IsValid(line) then return end
    line:SetColumnText(COLS_PRICE, vendor:getPrice(itemType))
end

function PANEL:onItemStockUpdated(vendor, itemType)
    local line = self.lines[itemType]
    if not IsValid(line) then return end
    local current, max = vendor:getStock(itemType)
    line:SetColumnText(COLS_STOCK, max and current .. "/" .. max or "-")
end

function PANEL:listenForUpdates()
    hook.Add("VendorEdited", self, self.onNameDescChanged)
    hook.Add("VendorMoneyUpdated", self, self.updateMoney)
    hook.Add("VendorItemModeUpdated", self, self.onItemModeUpdated)
    hook.Add("VendorItemPriceUpdated", self, self.onItemPriceUpdated)
    hook.Add("VendorItemStockUpdated", self, self.onItemStockUpdated)
    hook.Add("VendorItemMaxStockUpdated", self, self.onItemStockUpdated)
end

function PANEL:OnRowRightClick(line)
    local entity = liaVendorEnt
    if IsValid(menu) then menu:Remove() end
    local uniqueID = line.item
    local itemTable = lia.item.list[uniqueID]
    menu = DermaMenu()
    local mode, panel = menu:AddSubMenu(L("mode"))
    panel:SetImage("icon16/key.png")
    mode:AddOption(L("none"), function() EDITOR.mode(uniqueID, nil) end):SetImage("icon16/cog_error.png")
    mode:AddOption(L("buyOnlynSell"), function() EDITOR.mode(uniqueID, VENDOR_SELLANDBUY) end):SetImage("icon16/cog.png")
    mode:AddOption(L("buyOnly"), function() EDITOR.mode(uniqueID, VENDOR_BUYONLY) end):SetImage("icon16/cog_delete.png")
    mode:AddOption(L("sellOnly"), function() EDITOR.mode(uniqueID, VENDOR_SELLONLY) end):SetImage("icon16/cog_add.png")
    menu:AddOption(L("price"), function()
        Derma_StringRequest(itemTable:getName(), L("vendorPriceReq"), entity:getPrice(uniqueID), function(text)
            text = tonumber(text)
            EDITOR.price(uniqueID, text)
        end)
    end):SetImage("icon16/coins.png")

    local stock, panel = menu:AddSubMenu(L("stock"))
    panel:SetImage("icon16/table.png")
    stock:AddOption(L("disable"), function() EDITOR.stockDisable(uniqueID) end):SetImage("icon16/table_delete.png")
    stock:AddOption(L("edit"), function()
        local _, max = entity:getStock(uniqueID)
        Derma_StringRequest(itemTable:getName(), L("vendorStockReq"), max or 1, function(text)
            text = math.max(math.Round(tonumber(text) or 1), 1)
            EDITOR.stockMax(uniqueID, text)
        end)
    end):SetImage("icon16/table_edit.png")

    stock:AddOption(L("vendorEditCurStock"), function()
        Derma_StringRequest(itemTable:getName(), L("vendorStockCurReq"), entity:getStock(uniqueID) or 0, function(text)
            text = math.Round(tonumber(text) or 0)
            EDITOR.stock(uniqueID, text)
        end)
    end):SetImage("icon16/table_edit.png")

    menu:Open()
end

function PANEL:ReloadItemList(filter)
    local entity = liaVendorEnt
    self.lines = {}
    self.items:Clear()
    for k, v in SortedPairsByMemberValue(lia.item.list, "name") do
        local itemName = v.getName and v:getName() or L(v.name)
        if filter and not itemName:lower():find(filter:lower(), 1, true) then continue end
        local mode = entity.items[k] and entity.items[k][VENDOR_MODE]
        local current, max = entity:getStock(k)
        local category = v.category or L("none")
        local panel = self.items:AddLine(itemName, self:getModeText(mode), entity:getPrice(k), max and current .. "/" .. max or "-", category)
        panel.item = k
        self.lines[k] = panel
    end
end

vgui.Register("VendorEditor", PANEL, "DFrame")
local PANEL = {}
local function onFactionStateChanged(checkBox, state)
    EDITOR.faction(checkBox.factionID, state)
end

local function onClassStateChanged(checkBox, state)
    EDITOR.class(checkBox.classID, state)
end

function PANEL:Init()
    if IsValid(lia.gui.vendorFactionEditor) then lia.gui.vendorFactionEditor:Remove() end
    lia.gui.vendorFactionEditor = self
    self:SetSize(256, 360)
    self:Center()
    self:MakePopup()
    self:SetTitle(L("vendorFaction"))
    self.scroll = self:Add("DScrollPanel")
    self.scroll:Dock(FILL)
    self.scroll:DockPadding(0, 0, 0, 4)
    self.factions = {}
    self.classes = {}
    for k, v in ipairs(lia.faction.indices) do
        local panel = self.scroll:Add("DPanel")
        panel:Dock(TOP)
        panel:DockPadding(4, 4, 4, 4)
        panel:DockMargin(0, 0, 0, 4)
        local faction = panel:Add("DCheckBoxLabel")
        faction:Dock(TOP)
        faction:SetTextColor(color_white)
        faction:SetText(L(v.name))
        faction:DockMargin(0, 0, 0, 4)
        faction.factionID = k
        faction.OnChange = onFactionStateChanged
        self.factions[k] = faction
        for k2, v2 in ipairs(lia.class.list) do
            if v2.faction == k then
                local class = panel:Add("DCheckBoxLabel")
                class:Dock(TOP)
                class:DockMargin(16, 0, 0, 4)
                class:SetText(L(v2.name))
                class:SetTextColor(color_white)
                class.classID = k2
                class.factionID = faction.factionID
                class.OnChange = onClassStateChanged
                self.classes[k2] = class
                panel:SetTall(panel:GetTall() + class:GetTall() + 4)
            end
        end
    end

    self:updateChecked()
    hook.Add("VendorFactionUpdated", self, self.updateChecked)
    hook.Add("VendorClassUpdated", self, self.updateChecked)
end

function PANEL:updateChecked()
    local entity = liaVendorEnt
    for id, panel in pairs(self.factions) do
        panel:SetChecked(entity:isFactionAllowed(id))
    end

    for id, panel in pairs(self.classes) do
        panel:SetChecked(entity:isClassAllowed(id))
    end
end

vgui.Register("VendorFactionEditor", PANEL, "DFrame")

-- ./gamemode/core/derma/scaling.lua
local PANEL = FindMetaTable("Panel")
local baseW, baseH = 1920, 1080
local scaleW, scaleH
local cache = {
    width = {},
    height = {}
}

local function updateScale()
    scaleW = ScrW() / baseW
    scaleH = ScrH() / baseH
    cache.width = {}
    cache.height = {}
end

updateScale()
hook.Add("OnScreenSizeChanged", "CachedScreenScale_Update", updateScale)
hook.Add("OnReloaded", "CachedScreenScale_Update_Reload", updateScale)
function ScreenScale(v)
    cache.width[v] = cache.width[v] or v * scaleW
    return cache.width[v]
end

function ScreenScaleH(v)
    cache.height[v] = cache.height[v] or v * scaleH
    return cache.height[v]
end

function PANEL:SetScaledPos(x, y)
    self:SetPos(ScreenScale(x), ScreenScaleH(y))
end

function PANEL:SetScaledSize(w, h)
    self:SetSize(ScreenScale(w), ScreenScaleH(h))
end

-- ./gamemode/core/derma/skin.lua
local surface = surface
local Color = Color
local SKIN = {}
SKIN.fontFrame = "BudgetLabel"
SKIN.fontTab = "liaSmallFont"
SKIN.fontButton = "liaSmallFont"
SKIN.Colours = table.Copy(derma.SkinList.Default.Colours)
SKIN.Colours.Window.TitleActive = Color(255, 255, 255)
SKIN.Colours.Window.TitleInactive = Color(255, 255, 255)
SKIN.Colours.Label.Dark = Color(200, 200, 200)
SKIN.Colours.Button.Normal = Color(200, 200, 200)
SKIN.Colours.Button.Hover = Color(255, 255, 255)
SKIN.Colours.Button.Down = Color(180, 180, 180)
SKIN.Colours.Button.Disabled = Color(0, 0, 0, 100)
function SKIN:PaintFrame(panel, w, h)
    if not panel.LaidOut then
        if panel.btnClose and panel.btnClose:IsValid() then
            panel.btnClose:SetPos(panel:GetWide() - 16, 4)
            panel.btnClose:SetScaledSize(24, 24)
            panel.btnClose:SetFont("marlett")
            panel.btnClose:SetText("r")
            panel.btnClose:SetTextColor(Color(255, 255, 255))
            panel.btnClose:PerformLayout()
        end

        panel.LaidOut = true
    end

    surface.SetDrawColor(0, 0, 0, 255)
    surface.DrawOutlinedRect(0, 0, w, h, 2)
    surface.SetDrawColor(0, 0, 0, 150)
    surface.DrawRect(1, 1, w - 2, h - 2)
end

function SKIN:PaintTooltip(_, w, h)
    surface.SetDrawColor(45, 45, 45, 240)
    surface.DrawRect(0, 0, w, h)
    surface.SetDrawColor(0, 0, 0, 180)
    surface.DrawOutlinedRect(0, 0, w, h)
    surface.SetDrawColor(100, 100, 100, 25)
    surface.DrawOutlinedRect(1, 1, w - 2, h - 2)
end

function SKIN:DrawGenericBackground(x, y, w, h)
    surface.SetDrawColor(45, 45, 45, 240)
    surface.DrawRect(x, y, w, h)
    surface.SetDrawColor(0, 0, 0, 180)
    surface.DrawOutlinedRect(x, y, w, h)
    surface.SetDrawColor(100, 100, 100, 25)
    surface.DrawOutlinedRect(x + 1, y + 1, w - 2, h - 2)
end

function SKIN:PaintPanel(panel)
    if not panel.m_bBackground or panel.GetPaintBackground and not panel:GetPaintBackground() then return end
    local w, h = panel:GetWide(), panel:GetTall()
    surface.SetDrawColor(0, 0, 0, 255)
    surface.DrawOutlinedRect(0, 0, w, h, 2)
    surface.SetDrawColor(0, 0, 0, 150)
    surface.DrawRect(1, 1, w - 2, h - 2)
end

local function DrawButton(panel, w, h)
    if not panel.m_bBackground or panel.GetPaintBackground and not panel:GetPaintBackground() then return end
    local alpha = 50
    if panel:GetDisabled() then
        alpha = 10
    elseif panel.Depressed then
        alpha = 180
    elseif panel.Hovered then
        alpha = 75
    end

    surface.SetDrawColor(20, 20, 20, alpha)
    surface.DrawRect(0, 0, w, h)
    surface.SetDrawColor(100, 100, 100, alpha)
    surface.DrawRect(2, 2, w - 4, h - 4)
end

function SKIN:PaintButton(panel)
    local w, h = panel:GetWide(), panel:GetTall()
    DrawButton(panel, w, h)
end

function SKIN:PaintWindowCloseButton(panel, w, h)
    local base = derma.GetDefaultSkin()
    base.PaintWindowCloseButton(base, panel, w, h)
end

function SKIN:PaintWindowMinimizeButton(panel, w, h)
    local base = derma.GetDefaultSkin()
    base.PaintWindowMinimizeButton(base, panel, w, h)
end

function SKIN:PaintWindowMaximizeButton(panel, w, h)
    local base = derma.GetDefaultSkin()
    base.PaintWindowMaximizeButton(base, panel, w, h)
end

function SKIN:PaintComboBox(panel, w, h)
    DrawButton(panel, w, h)
end

function SKIN:PaintTextEntry(panel, w, h)
    if panel.m_bBackground then
        local alpha = 50
        if panel:GetDisabled() then
            alpha = 10
        elseif panel.Depressed then
            alpha = 180
        elseif panel.Hovered then
            alpha = 75
        end

        surface.SetDrawColor(20, 20, 20, alpha)
        surface.DrawRect(0, 0, w, h)
        surface.SetDrawColor(100, 100, 100, alpha)
        surface.DrawRect(2, 2, w - 4, h - 4)
    end

    if panel.GetPlaceholderText and panel.GetPlaceholderColor and panel:GetPlaceholderText() and panel:GetPlaceholderText():Trim() ~= "" and panel:GetPlaceholderColor() and (not panel:GetText() or panel:GetText() == "") then
        local oldText = panel:GetText()
        local str = panel:GetPlaceholderText()
        if str:StartWith("#") then str = str:sub(2) end
        str = language.GetPhrase(str)
        panel:SetText(str)
        panel:DrawTextEntryText(panel:GetPlaceholderColor(), panel:GetHighlightColor(), panel:GetCursorColor())
        panel:SetText(oldText)
        return
    end

    panel:DrawTextEntryText(Color(255, 255, 255), panel:GetHighlightColor(), panel:GetCursorColor())
end

function SKIN:PaintWindowCloseButton()
end

function SKIN:PaintWindowMinimizeButton()
end

function SKIN:PaintWindowMaximizeButton()
end

function SKIN:PaintListView(_, w, h)
    surface.SetDrawColor(20, 20, 20, 100)
    surface.DrawRect(0, 0, w, h)
end

function SKIN:PaintListViewLine(panel, w, h)
    surface.SetDrawColor((panel:IsHovered() or panel:IsLineSelected()) and lia.config.get("Color", Color(255, 255, 255)) or Color(0, 0, 0, 0))
    surface.DrawRect(0, 0, w, h)
end

function SKIN:PaintScrollBarGrip(_, w, h)
    surface.SetDrawColor(lia.config.get("Color", Color(255, 255, 255)))
    surface.DrawRect(0, 0, w, h)
end

function SKIN:PaintButtonUp(_, w, h)
    surface.SetDrawColor(lia.config.get("Color", Color(255, 255, 255)))
    surface.DrawRect(0, 0, w, h)
    surface.SetTextColor(255, 255, 255, 255)
    surface.SetFont("marlett")
    surface.SetTextPos(1, 1)
    surface.DrawText("5")
end

function SKIN:PaintButtonDown(_, w, h)
    surface.SetDrawColor(lia.config.get("Color", Color(255, 255, 255)))
    surface.DrawRect(0, 0, w, h)
    surface.SetTextColor(255, 255, 255, 255)
    surface.SetFont("marlett")
    surface.SetTextPos(1, 0)
    surface.DrawText("6")
end

function SKIN:PaintVScrollBar(_, w, h)
    surface.SetDrawColor(20, 20, 20, 200)
    surface.DrawRect(0, 0, w, h)
end

function SKIN:PaintMenu(_, w, h)
    local odd = true
    for i = 0, h, 22 do
        if odd then
            surface.SetDrawColor(40, 40, 40, 255)
            surface.DrawRect(0, i, w, 22)
        else
            surface.SetDrawColor(50, 50, 50, 255)
            surface.DrawRect(0, i, w, 22)
        end

        odd = not odd
    end
end

function SKIN:PaintPopupMenu(panel, w, h)
    local bg = panel:IsHovered() and Color(70, 70, 70, 240) or Color(45, 45, 45, 240)
    surface.SetDrawColor(bg)
    surface.DrawRect(0, 0, w, h)
    surface.SetDrawColor(0, 0, 0, 180)
    surface.DrawOutlinedRect(0, 0, w, h)
end

function SKIN:PaintMenuOption(panel, w, h)
    if not panel.LaidOut then
        panel.LaidOut = true
        panel:SetTextColor(Color(200, 200, 200, 255))
    end

    if panel.m_bBackground and (panel.Hovered or panel.Highlight) then
        surface.SetDrawColor(70, 70, 70, 255)
        surface.DrawRect(0, 0, w, h)
    end

    local skin = derma.GetDefaultSkin()
    skin.MenuOptionOdd = not skin.MenuOptionOdd
    if panel:GetChecked() then skin.tex.Menu_Check(5, h / 2 - 7, 15, 15) end
end

derma.DefineSkin("lilia", "The base skin for the Lilia framework.", SKIN)
derma.RefreshSkins()

-- ./gamemode/core/hooks/client.lua
local GM = GM or GAMEMODE
local RealTime, FrameTime = RealTime, FrameTime
local mathApproach = math.Approach
local IsValid = IsValid
local toScreen = FindMetaTable("Vector").ToScreen
local paintedEntitiesCache = {}
local lastTrace = {
    mins = Vector(-4, -4, -4),
    maxs = Vector(4, 4, 4),
    mask = MASK_SHOT_HULL,
    filter = nil,
    start = nil,
    endpos = nil
}

local hidden = {
    CHUDAutoAim = true,
    CHudHealth = true,
    CHudCrosshair = true,
    CHudBattery = true,
    CHudAmmo = true,
    CHudSecondaryAmmo = true,
    CHudHistoryResource = true,
    CHudChat = true,
    CHudDamageIndicator = true,
    CHudVoiceStatus = true
}

local lastEntity
local nextUpdate = 0
local healthPercent = {
    {
        threshold = 0.2,
        text = L("criticalCondition"),
        color = Color(192, 57, 43)
    },
    {
        threshold = 0.4,
        text = L("seriousInjury"),
        color = Color(231, 76, 60)
    },
    {
        threshold = 0.6,
        text = L("moderateInjury"),
        color = Color(255, 152, 0)
    },
    {
        threshold = 0.8,
        text = L("minorInjury"),
        color = Color(255, 193, 7)
    },
    {
        threshold = 1.0,
        text = L("healthyStatus"),
        color = Color(46, 204, 113)
    }
}

local NoDrawCrosshairWeapon = {
    weapon_crowbar = true,
    weapon_stunstick = true,
    weapon_bugbait = true
}

local function canDrawAmmo(wpn)
    if IsValid(wpn) and wpn.DrawAmmo ~= false and lia.config.get("AmmoDrawEnabled", false) then return true end
end

local function drawAmmo(wpn)
    local client = LocalPlayer()
    if not IsValid(wpn) then return end
    local clip = wpn:Clip1()
    local count = client:GetAmmoCount(wpn:GetPrimaryAmmoType())
    local sec = client:GetAmmoCount(wpn:GetSecondaryAmmoType())
    local x, y = ScrW() - 80, ScrH() - 80
    if sec > 0 then
        lia.util.drawBlurAt(x, y, 64, 64)
        surface.SetDrawColor(255, 255, 255, 5)
        surface.DrawRect(x, y, 64, 64)
        surface.SetDrawColor(255, 255, 255, 3)
        surface.DrawOutlinedRect(x, y, 64, 64)
        lia.util.drawText(sec, x + 32, y + 32, nil, 1, 1, "liaBigFont")
    end

    if wpn:GetClass() ~= "weapon_slam" and (clip > 0 or count > 0) then
        x = x - (sec > 0 and 144 or 64)
        lia.util.drawBlurAt(x, y, 128, 64)
        surface.SetDrawColor(255, 255, 255, 5)
        surface.DrawRect(x, y, 128, 64)
        surface.SetDrawColor(255, 255, 255, 3)
        surface.DrawOutlinedRect(x, y, 128, 64)
        lia.util.drawText(clip == -1 and count or clip .. "/" .. count, x + 64, y + 32, nil, 1, 1, "liaBigFont")
    end
end

local function canDrawCrosshair()
    local client = LocalPlayer()
    local rag = Entity(client:getLocalVar("ragdoll", 0))
    local wpn = client:GetActiveWeapon()
    if not client:getChar() then return false end
    if IsValid(wpn) then
        local cl = wpn:GetClass()
        if cl == "gmod_tool" or string.find(cl, "lia_") or string.find(cl, "detector_") then return true end
        if not NoDrawCrosshairWeapon[cl] and lia.config.get("CrosshairEnabled", true) and client:Alive() and not IsValid(rag) and not (g_ContextMenu:IsVisible() or IsValid(lia.gui.character) and lia.gui.character:IsVisible()) then return true end
    end
end

local function drawCrosshair()
    local client = LocalPlayer()
    local trace = util.QuickTrace(client:GetShootPos(), client:GetAimVector() * 15000, client)
    if trace.HitPos then
        local p = trace.HitPos:ToScreen()
        if p then
            local s = 3
            draw.RoundedBox(0, math.Round(p.x - s / 2), math.Round(p.y - s / 2), s, s, color_white)
            s = s - 2
            draw.RoundedBox(0, math.Round(p.x - s / 2), math.Round(p.y - s / 2), s, s, color_white)
        end
    end
end

local function RenderEntities()
    local client = LocalPlayer()
    if client.getChar and client:getChar() then
        local ft = FrameTime()
        local rt = RealTime()
        if nextUpdate < rt then
            nextUpdate = rt + 0.5
            lastTrace.start = client:GetShootPos()
            lastTrace.endpos = lastTrace.start + client:GetAimVector() * 160
            lastTrace.filter = client
            lastTrace.mins = Vector(-4, -4, -4)
            lastTrace.maxs = Vector(4, 4, 4)
            lastTrace.mask = MASK_SHOT_HULL
            lastEntity = util.TraceHull(lastTrace).Entity
            if IsValid(lastEntity) and hook.Run("ShouldDrawEntityInfo", lastEntity) then paintedEntitiesCache[lastEntity] = true end
        end

        for ent, drawing in pairs(paintedEntitiesCache) do
            if IsValid(ent) then
                local goal = drawing and 255 or 0
                local a = mathApproach(ent.liaAlpha or 0, goal, ft * 1000)
                if lastEntity ~= ent then paintedEntitiesCache[ent] = false end
                if a > 0 then
                    local netPlayer = ent.getNetVar and ent:getNetVar("player")
                    if IsValid(netPlayer) then
                        local p = toScreen(ent:LocalToWorld(ent:OBBCenter()))
                        hook.Run("DrawEntityInfo", netPlayer, a, p)
                    elseif ent.onDrawEntityInfo then
                        ent.onDrawEntityInfo(ent, a)
                    else
                        hook.Run("DrawEntityInfo", ent, a)
                    end
                end

                ent.liaAlpha = a
                if a == 0 and goal == 0 then paintedEntitiesCache[ent] = nil end
            else
                paintedEntitiesCache[ent] = nil
            end
        end
    end
end

function GM:ShouldDrawEntityInfo(e)
    if IsValid(e) then
        if e:IsPlayer() and e:getChar() then
            if e:isNoClipping() or e:GetNoDraw() then return false end
            return true
        end

        if e.getNetVar then
            local ply = e:getNetVar("player")
            if IsValid(ply) then return e == LocalPlayer() and not LocalPlayer():ShouldDrawLocalPlayer() end
        end

        if e.DrawEntityInfo then return true end
        if e.onShouldDrawEntityInfo and e:onShouldDrawEntityInfo() then return true end
        return true
    end
    return false
end

function GM:GetInjuredText(c)
    local h = c:Health()
    local mh = c:GetMaxHealth() or 100
    local p = h / mh
    for _, entry in ipairs(healthPercent) do
        if p <= entry.threshold then return {entry.text, entry.color} end
    end

    local last = healthPercent[#healthPercent]
    return {last.text, last.color}
end

function GM:DrawCharInfo(c, _, info)
    local injured = hook.Run("GetInjuredText", c)
    if injured then info[#info + 1] = {L(injured[1]), injured[2]} end
end

function GM:DrawEntityInfo(e, a, pos)
    if not e:IsPlayer() or hook.Run("ShouldDrawPlayerInfo", e) == false then return end
    local ch = e:getChar()
    if not ch then return end
    pos = pos or toScreen(e:GetPos() + (e:Crouching() and Vector(0, 0, 48) or Vector(0, 0, 80)))
    local x, y = pos.x, pos.y
    local charInfo = {}
    local width = lia.config.get("descriptionWidth", 0.5)
    if e.widthCache ~= width then
        e.widthCache = width
        e.liaNameCache = nil
        e.liaDescCache = nil
    end

    local name = hook.Run("GetDisplayedName", e) or ch.getName(ch)
    if name ~= e.liaNameCache then
        e.liaNameCache = name
        if #name > 250 then name = name:sub(1, 250) .. "..." end
        e.liaNameLines = lia.util.wrapText(name, ScrW() * width, "liaSmallFont")
    end

    for i = 1, #e.liaNameLines do
        charInfo[#charInfo + 1] = {e.liaNameLines[i], color_white}
    end

    local desc = hook.Run("GetDisplayedDescription", e, true) or ch.getDesc(ch)
    if desc ~= e.liaDescCache then
        e.liaDescCache = desc
        if #desc > 250 then desc = desc:sub(1, 250) .. "..." end
        e.liaDescLines = lia.util.wrapText(desc, ScrW() * width, "liaSmallFont")
    end

    for i = 1, #e.liaDescLines do
        charInfo[#charInfo + 1] = {e.liaDescLines[i]}
    end

    hook.Run("DrawCharInfo", e, ch, charInfo)
    for i = 1, #charInfo do
        local info = charInfo[i]
        local _, ty = lia.util.drawText(info[1]:gsub("#", "\226\128\139#"), x, y, ColorAlpha(info[2] or color_white, a), 1, 1, "liaSmallFont")
        y = y + ty
    end
end

function GM:HUDPaint()
    local client = LocalPlayer()
    if client:Alive() and client:getChar() then
        local wpn = client:GetActiveWeapon()
        if canDrawAmmo(wpn) then drawAmmo(wpn) end
        if canDrawCrosshair() then drawCrosshair() end
    end
end

function GM:TooltipInitialize(var, panel)
    if panel.liaToolTip or panel.itemID then
        var.markupObject = lia.markup.parse(var:GetText(), ScrW() * 0.15)
        var:SetText("")
        var:SetWide(math.max(ScrW() * 0.15, 200) + 12)
        var:SetHeight(var.markupObject:getHeight() + 12)
        var:SetAlpha(0)
        var:AlphaTo(255, 0.2, 0)
        var.isItemTooltip = true
    end
end

function GM:TooltipPaint(var, w, h)
    if var.isItemTooltip then
        lia.util.drawBlur(var, 2, 2)
        surface.SetDrawColor(0, 0, 0, 230)
        surface.DrawRect(0, 0, w, h)
        var.markupObject:draw(6, 8)
        return true
    end
end

function GM:TooltipLayout(var)
    return var.isItemTooltip
end

function GM:DrawLiliaModelView(_, entity)
    if IsValid(entity.weapon) then entity.weapon:DrawModel() end
end

function GM:OnChatReceived()
    if system.IsWindows() and not system.HasFocus() then system.FlashWindow() end
end

function GM:CreateMove(cmd)
    local client = LocalPlayer()
    if IsValid(client) and client:getLocalVar("bIsHoldingObject", false) and cmd:KeyDown(IN_ATTACK2) then
        cmd:ClearMovement()
        local angle = cmd:GetViewAngles()
        angle.z = 0
        cmd:SetViewAngles(angle)
    end
end

function GM:CalcView(client, origin, angles, fov)
    local view = self.BaseClass:CalcView(client, origin, angles, fov)
    local ragEntity = Entity(client:getLocalVar("ragdoll", 0))
    local ragdoll = client:GetRagdollEntity()
    local ent
    if not client:hasValidVehicle() and client:GetViewEntity() == client and not client:ShouldDrawLocalPlayer() then
        if IsValid(ragEntity) and ragEntity:IsRagdoll() then
            ent = ragEntity
        elseif not client:Alive() and IsValid(ragdoll) then
            ent = ragdoll
        end
    end

    if ent and ent:IsValid() then
        local idx = ent:LookupAttachment("eyes")
        if idx then
            local data = ent:GetAttachment(idx)
            if data then
                view.origin = data.Pos
                view.angles = data.Ang
                view.znear = 1
            end
        end
    end
    return view
end

function GM:PlayerBindPress(client, bind, pressed)
    bind = bind:lower()
    if bind:find("jump") and client:hasRagdoll() then lia.command.send("chargetup") end
    if (bind:find("use") or bind:find("attack")) and pressed then
        local menu, callback = lia.menu.getActiveMenu()
        if menu and lia.menu.onButtonPressed(menu, callback) then return true end
        if bind:find("use") then
            local entity = client:getTracedEntity()
            if IsValid(entity) and (entity:isItem() or entity.hasMenu) then hook.Run("ItemShowEntityMenu", entity) end
        end
    end
end

function GM:ItemShowEntityMenu(entity)
    for k, v in ipairs(lia.menu.list) do
        if v.entity == entity then table.remove(lia.menu.list, k) end
    end

    local itemTable = entity:getItemTable()
    if not itemTable then return end
    if input.IsShiftDown() then
        if IsValid(entity) then netstream.Start("invAct", "take", entity) end
        return
    end

    if IsValid(liaItemMenuInstance) then liaItemMenuInstance:Remove() end
    liaItemMenuInstance = vgui.Create("liaItemMenu")
    liaItemMenuInstance:SetEntity(entity)
end

function GM:HUDPaintBackground()
    lia.menu.drawAll()
    RenderEntities()
    self.BaseClass.PaintWorldTips(self.BaseClass)
    if not lia.util.is64Bits() then draw.SimpleText(L("switchTo64Bit"), "liaSmallFont", ScrW() * 0.5, ScrH() * 0.97, Color(255, 255, 255, 10), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end
end

function GM:OnContextMenuOpen()
    self.BaseClass:OnContextMenuOpen()
end

function GM:OnContextMenuClose()
    self.BaseClass:OnContextMenuClose()
    if IsValid(lia.gui.quick) then lia.gui.quick:Remove() end
end

function GM:CharListLoaded()
    timer.Create("liaWaitUntilPlayerValid", 1, 0, function()
        local client = LocalPlayer()
        if not IsValid(client) then return end
        timer.Remove("liaWaitUntilPlayerValid")
        hook.Run("LiliaLoaded")
    end)
end

function GM:ForceDermaSkin()
    return "lilia"
end

function GM:HUDShouldDraw(element)
    return not hidden[element]
end

function GM:PlayerStartVoice(client)
    if not IsValid(g_VoicePanelList) then return end
    if lia.config.get("IsVoiceEnabled", true) == false then return end
    if client:getNetVar("IsDeadRestricted", false) then return false end
    hook.Run("PlayerEndVoice", client)
    if IsValid(VoicePanels[client]) then
        if VoicePanels[client].fadeAnim then
            VoicePanels[client].fadeAnim:Stop()
            VoicePanels[client].fadeAnim = nil
        end

        VoicePanels[client]:SetAlpha(255)
        return
    end

    if not IsValid(client) then return end
    local pnl = g_VoicePanelList:Add("VoicePanel")
    pnl:Setup(client)
    VoicePanels[client] = pnl
end

function GM:PlayerEndVoice(client)
    if IsValid(VoicePanels[client]) then
        if VoicePanels[client].fadeAnim then return end
        VoicePanels[client].fadeAnim = Derma_Anim("FadeOut", VoicePanels[client], VoicePanels[client].FadeOut)
        VoicePanels[client].fadeAnim:Start(2)
    end
end

function GM:SpawnMenuOpen()
    local client = LocalPlayer()
    if lia.config.get("SpawnMenuLimit", false) and not (client:getChar():hasFlags("pet") or client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn Props")) then return end
    return true
end

-- ./gamemode/core/hooks/server.lua
local GM = GM or GAMEMODE
function GM:CharPreSave(character)
    local client = character:getPlayer()
    if not character:getInv() then return end
    for _, v in pairs(character:getInv():getItems()) do
        if v.OnSave then v:call("OnSave", client) end
    end

    if IsValid(client) then
        local ammoTable = {}
        for _, ammoType in pairs(game.GetAmmoTypes()) do
            if ammoType then
                local ammoCount = client:GetAmmoCount(ammoType)
                if isnumber(ammoCount) and ammoCount > 0 then ammoTable[ammoType] = ammoCount end
            end
        end

        character:setData("ammo", ammoTable)
    end
end

function GM:PlayerLoadedChar(client, character)
    local timeStamp = os.date("%Y-%m-%d %H:%M:%S", os.time())
    lia.db.updateTable({
        _lastJoinTime = timeStamp
    }, nil, "characters", "_id = " .. character:getID())

    client:removeRagdoll()
    character:setData("loginTime", os.time())
    hook.Run("PlayerLoadout", client)
    local ammoTable = character:getData("ammo", {})
    if table.IsEmpty(ammoTable) then return end
    timer.Simple(0.25, function()
        if not IsValid(ammoTable) then return end
        for ammoType, ammoCount in pairs(ammoTable) do
            if IsValid(ammoCount) or IsValid(ammoCount) then client:GiveAmmo(ammoCount, ammoType, true) end
        end

        character:setData("ammo", nil)
    end)
end

function GM:LiliaTablesLoaded()
    local ignore = function() end
    lia.db.query("ALTER TABLE IF EXISTS lia_players ADD COLUMN _firstJoin DATETIME"):catch(ignore)
    lia.db.query("ALTER TABLE IF EXISTS lia_players ADD COLUMN _lastJoin DATETIME"):catch(ignore)
    lia.db.query("ALTER TABLE IF EXISTS lia_items ADD COLUMN _quantity INTEGER"):catch(ignore)
end

function GM:PlayerDeath(client, inflictor, attacker)
    local character = client:getChar()
    if not character then return end
    local inventory = character:getInv()
    if inventory then
        for _, item in pairs(inventory:getItems()) do
            if item.isWeapon and item:getData("equip") then item:setData("ammo", nil) end
        end
    end

    local pkWorld = lia.config.get("PKWorld", false)
    local playerKill = IsValid(attacker) and attacker:IsPlayer() and attacker ~= client
    local selfKill = attacker == client
    local worldKill = not IsValid(attacker) or attacker:GetClass() == "worldspawn"
    if (playerKill or pkWorld and selfKill or pkWorld and worldKill) and hook.Run("PlayerShouldPermaKill", client, inflictor, attacker) then character:ban() end
end

function GM:PlayerShouldPermaKill(client)
    local character = client:getChar()
    return character:getData("markedForDeath", false)
end

function GM:CharLoaded(id)
    local character = lia.char.loaded[id]
    if character then
        local client = character:getPlayer()
        if IsValid(client) then
            local uniqueID = "liaSaveChar" .. client:SteamID64()
            timer.Create(uniqueID, lia.config.get("CharacterDataSaveInterval"), 0, function()
                if IsValid(client) and client:getChar() then
                    client:getChar():save()
                else
                    timer.Remove(uniqueID)
                end
            end)
        end
    end
end

function GM:PrePlayerLoadedChar(client)
    client:SetBodyGroups("000000000")
    client:SetSkin(0)
    client:ExitVehicle()
    client:Freeze(false)
end

function GM:OnPickupMoney(client, moneyEntity)
    if moneyEntity and IsValid(moneyEntity) then
        local amount = moneyEntity:getAmount()
        client:notifyLocalized("moneyTaken", lia.currency.get(amount))
        lia.log.add(client, "moneyPickedUp", amount)
    end
end

function GM:CanItemBeTransfered(item, curInv, inventory)
    if item.isBag and curInv ~= inventory and item.getInv and item:getInv() and table.Count(item:getInv():getItems()) > 0 then
        local character = lia.char.loaded[curInv.client]
        character:getPlayer():notifyLocalized("forbiddenActionStorage")
        return false
    end

    if item.OnCanBeTransfered then
        local itemHook = item:OnCanBeTransfered(curInv, inventory)
        return itemHook ~= false
    end
end

function GM:CanPlayerInteractItem(client, action, item)
    action = string.lower(action)
    if not client:Alive() then return false, L("forbiddenActionStorage") end
    if client:getLocalVar("ragdoll", false) then return false, L("forbiddenActionStorage") end
    if action == "drop" then
        if hook.Run("CanPlayerDropItem", client, item) ~= false then
            if not client.dropDelay then
                client.dropDelay = true
                timer.Create("DropDelay." .. client:SteamID64(), lia.config.get("DropDelay"), 1, function() if IsValid(client) then client.dropDelay = nil end end)
                return true
            else
                client:notifyLocalized("waitDrop")
                return false
            end
        else
            return false
        end
    end

    if action == "take" then
        if hook.Run("CanPlayerTakeItem", client, item) ~= false then
            if not client.takeDelay then
                client.takeDelay = true
                timer.Create("TakeDelay." .. client:SteamID64(), lia.config.get("TakeDelay"), 1, function() if IsValid(client) then client.takeDelay = nil end end)
                return true
            else
                client:notifyLocalized("waitPickup")
                return false
            end
        else
            return false
        end
    end

    if action == "equip" then
        if hook.Run("CanPlayerEquipItem", client, item) ~= false then
            if not client.equipDelay then
                client.equipDelay = true
                timer.Create("EquipDelay." .. client:SteamID64(), lia.config.get("EquipDelay"), 1, function() if IsValid(client) then client.equipDelay = nil end end)
                return true
            else
                client:notifyLocalized("waitEquip")
                return false
            end
        else
            return false
        end
    end

    if action == "unequip" then
        if hook.Run("CanPlayerUnequipItem", client, item) ~= false then
            if not client.unequipDelay then
                client.unequipDelay = true
                timer.Create("UnequipDelay." .. client:SteamID64(), lia.config.get("UnequipDelay"), 1, function() if IsValid(client) then client.unequipDelay = nil end end)
                return true
            else
                client:notifyLocalized("waitUnequip")
                return false
            end
        else
            return false
        end
    end
end

function GM:CanPlayerEquipItem(client, item)
    local inventory = lia.inventory.instances[item.invID]
    if client.equipDelay ~= nil then
        client:notifyLocalized("waitEquip")
        return false
    elseif inventory and (inventory.isBag or inventory.isExternalInventory) then
        client:notifyLocalized("forbiddenActionStorage")
        return false
    end
end

function GM:CanPlayerTakeItem(client, item)
    local inventory = lia.inventory.instances[item.invID]
    if client.takeDelay ~= nil then
        client:notifyLocalized("waitPickup")
        return false
    elseif inventory and (inventory.isBag or inventory.isExternalInventory) then
        client:notifyLocalized("forbiddenActionStorage")
        return false
    elseif IsValid(item.entity) then
        local character = client:getChar()
        if item.entity.SteamID64 == client:SteamID64() and item.entity.liaCharID ~= character:getID() then
            client:notifyLocalized("playerCharBelonging")
            return false
        end
    end
end

function GM:CanPlayerDropItem(client, item)
    local inventory = lia.inventory.instances[item.invID]
    if client.dropDelay ~= nil then
        client:notifyLocalized("waitDrop")
        return false
    elseif item.isBag and item:getInv() then
        local items = item:getInv():getItems()
        for _, otheritem in pairs(items) do
            if not otheritem.ignoreEquipCheck and otheritem:getData("equip", false) then
                client:notifyLocalized("cantDropBagHasEquipped")
                return false
            end
        end
    elseif inventory and (inventory.isBag or inventory.isExternalInventory) then
        client:notifyLocalized("forbiddenActionStorage")
        return false
    end
end

local logTypeMap = {
    ooc = "chatOOC",
    looc = "chatLOOC"
}

function GM:PlayerSay(client, message)
    local chatType, message, anonymous = lia.chat.parse(client, message, true)
    if chatType == "ic" and lia.command.parse(client, message) then return "" end
    if utf8.len(message) > lia.config.get("MaxChatLength") then
        client:notifyLocalized("tooLongMessage")
        return ""
    end

    local logType = logTypeMap[chatType] or "chat"
    lia.chat.send(client, chatType, message, anonymous)
    if logType == "chat" then
        lia.log.add(client, logType, chatType and chatType:upper() or "??", message)
    else
        lia.log.add(client, logType, message)
    end

    hook.Run("PostPlayerSay", client, message, chatType, anonymous)
    return ""
end

local allowedHoldableClasses = {
    ["prop_physics"] = true,
    ["prop_physics_override"] = true,
    ["prop_physics_multiplayer"] = true,
    ["prop_ragdoll"] = true
}

function GM:CanPlayerHoldObject(_, entity)
    return allowedHoldableClasses[entity:GetClass()] or entity.Holdable
end

function GM:EntityTakeDamage(entity, dmgInfo)
    if entity:IsPlayer() and entity:isStaffOnDuty() and lia.config.get("StaffHasGodMode", true) then return true end
    if IsValid(entity.liaPlayer) then
        if dmgInfo:IsDamageType(DMG_CRUSH) then
            if (entity.liaFallGrace or 0) < CurTime() then
                if dmgInfo:GetDamage() <= 10 then dmgInfo:SetDamage(0) end
                entity.liaFallGrace = CurTime() + 0.5
            else
                return
            end
        end

        entity.liaPlayer:TakeDamageInfo(dmgInfo)
    end
end

function GM:KeyPress(client, key)
    if key == IN_JUMP then
        local traceStart = client:GetShootPos() + Vector(0, 0, 15)
        local traceEndHi = traceStart + client:GetAimVector() * 30
        local traceEndLo = traceStart + client:GetAimVector() * 30
        local trHi = util.TraceLine({
            start = traceStart,
            endpos = traceEndHi,
            filter = client
        })

        local trLo = util.TraceLine({
            start = client:GetShootPos(),
            endpos = traceEndLo,
            filter = client
        })

        if trLo.Hit and not trHi.Hit then
            local dist = math.abs(trHi.HitPos.z - client:GetPos().z)
            client:SetVelocity(Vector(0, 0, 50 + dist * 3))
        end
    end
end

function GM:InitializedSchema()
    local persistString = GetConVar("sbox_persist"):GetString()
    if persistString == "" or string.StartWith(persistString, "lia_") then
        local newValue = "lia_" .. SCHEMA.folder
        game.ConsoleCommand("sbox_persist " .. newValue .. "\n")
    end
end

function GM:GetGameDescription()
    return istable(SCHEMA) and tostring(SCHEMA.name) or "A Lilia Gamemode"
end

function GM:PostPlayerLoadout(client)
    local character = client:getChar()
    if not character then return end
    client:Give("lia_hands")
    client:SetupHands()
end

function GM:ShouldSpawnClientRagdoll(client)
    if client:IsBot() then
        client:Spawn()
        return false
    end
end

function GM:DoPlayerDeath(client, attacker)
    client:AddDeaths(1)
    if hook.Run("ShouldSpawnClientRagdoll", client) ~= false then client:createRagdoll(false, true) end
    if IsValid(attacker) and attacker:IsPlayer() then
        if client == attacker then
            attacker:AddFrags(-1)
        else
            attacker:AddFrags(1)
        end
    end

    client:SetDSP(31)
end

function GM:PlayerSpawn(client)
    client:SetNoDraw(false)
    client:UnLock()
    client:SetNotSolid(false)
    client:stopAction()
    client:SetDSP(1)
    client:removeRagdoll()
    hook.Run("PlayerLoadout", client)
end

function GM:PreCleanupMap()
    lia.shuttingDown = true
    hook.Run("SaveData")
    hook.Run("PersistenceSave")
end

function GM:PostCleanupMap()
    lia.shuttingDown = false
    hook.Run("LoadData")
    hook.Run("PostLoadData")
end

function GM:ShutDown()
    if hook.Run("ShouldDataBeSaved") == false then return end
    lia.shuttingDown = true
    hook.Run("SaveData")
    for _, v in player.Iterator() do
        v:saveLiliaData()
        if v:getChar() then v:getChar():save() end
    end
end

function GM:PlayerDisconnected(client)
    client:saveLiliaData()
    local character = client:getChar()
    if character then
        hook.Run("OnCharDisconnect", client, character)
        character:save()
    end

    client:removeRagdoll()
    lia.char.cleanUpForPlayer(client)
    for _, entity in ents.Iterator() do
        if entity:GetCreator() == client and not string.StartsWith(entity:GetClass(), "lia_") then SafeRemoveEntity(entity) end
    end
end

function GM:PlayerInitialSpawn(client)
    if client:IsBot() then
        hook.Run("SetupBotPlayer", client)
        return
    end

    lia.config.send(client)
    client.liaJoinTime = RealTime()
    client:loadLiliaData(function(data)
        if not IsValid(client) then return end
        local address = client:IPAddress()
        client:setLiliaData("lastIP", address)
        netstream.Start(client, "liaDataSync", data, client.firstJoin, client.lastJoin)
        for _, v in pairs(lia.item.instances) do
            if v.entity and v.invID == 0 then v:sync(client) end
        end

        hook.Run("PlayerLiliaDataLoaded", client)
    end)

    hook.Run("PostPlayerInitialSpawn", client)
end

function GM:PlayerLoadout(client)
    local character = client:getChar()
    if client.liaSkipLoadout then
        client.liaSkipLoadout = nil
        return
    end

    if not character then
        client:SetNoDraw(true)
        client:Lock()
        client:SetNotSolid(true)
        return
    end

    client:SetWeaponColor(Vector(0.30, 0.80, 0.10))
    client:StripWeapons()
    client:setLocalVar("blur", nil)
    client:SetModel(character:getModel())
    client:SetWalkSpeed(lia.config.get("WalkSpeed"))
    client:SetRunSpeed(lia.config.get("RunSpeed"))
    client:SetJumpPower(160)
    hook.Run("FactionOnLoadout", client)
    hook.Run("ClassOnLoadout", client)
    lia.flag.onSpawn(client)
    hook.Run("PostPlayerLoadout", client)
    hook.Run("FactionPostLoadout", client)
    hook.Run("ClassPostLoadout", client)
    client:SelectWeapon("lia_hands")
end

function GM:SetupBotPlayer(client)
    local botID = os.time()
    local index = math.random(1, table.Count(lia.faction.indices))
    local faction = lia.faction.indices[index]
    local inventory = lia.inventory.new("grid")
    local character = lia.char.new({
        name = client:Name(),
        faction = faction and faction.uniqueID or "unknown",
        desc = "This is a bot. BotID is " .. botID .. ".",
        model = "models/gman.mdl",
    }, botID, client, client:SteamID64())

    local defaultClass = lia.faction.getDefaultClass(faction.index)
    if defaultClass then character:joinClass(defaultClass.index) end
    character.isBot = true
    character.vars.inv = {}
    inventory.id = "bot" .. character:getID()
    character.vars.inv[1] = inventory
    lia.inventory.instances[inventory.id] = inventory
    lia.char.loaded[botID] = character
    character:setup()
    client:Spawn()
end

function GM:PlayerShouldTakeDamage(client)
    return client:getChar() ~= nil
end

function GM:CanDrive()
    return false
end

function GM:PlayerDeathThink()
    return false
end

local function makeKey(ent)
    local pos = ent.pos or ent:GetPos()
    local tol = 1
    return string.format("%s_%.0f_%.0f_%.0f", ent.class or ent:GetClass(), pos.x / tol, pos.y / tol, pos.z / tol)
end

function GM:SaveData()
    local seen = {}
    local data = {
        entities = {},
        items = {}
    }

    for _, ent in ents.Iterator() do
        if ent:isLiliaPersistent() then
            local key = makeKey(ent)
            if not seen[key] then
                seen[key] = true
                data.entities[#data.entities + 1] = {
                    pos = ent:GetPos(),
                    class = ent:GetClass(),
                    model = ent:GetModel(),
                    angles = ent:GetAngles(),
                }
            end
        end
    end

    for _, item in ipairs(ents.FindByClass("lia_item")) do
        if item.liaItemID and not item.temp then data.items[#data.items + 1] = {item.liaItemID, item:GetPos()} end
    end

    lia.data.set("persistance", data.entities, true)
    lia.data.set("itemsave", data.items, true)
end

function GM:OnEntityCreated(ent)
    if not IsValid(ent) or not ent:isLiliaPersistent() then return end
    local saved = lia.data.get("persistance", {}, true) or {}
    local seen = {}
    for _, e in ipairs(saved) do
        seen[makeKey(e)] = true
    end

    local key = makeKey(ent)
    if not seen[key] then
        saved[#saved + 1] = {
            pos = ent:GetPos(),
            class = ent:GetClass(),
            model = ent:GetModel(),
            angles = ent:GetAngles(),
        }

        lia.data.set("persistance", saved, true)
    end
end

function GM:LoadData()
    local function IsEntityNearby(pos, class)
        for _, ent in ipairs(ents.FindByClass(class)) do
            if ent:GetPos():Distance(pos) <= 50 then return true end
        end
        return false
    end

    local entities = lia.data.get("persistance", {}, true)
    for _, ent in ipairs(entities or {}) do
        if not IsEntityNearby(ent.pos, ent.class) then
            local createdEnt = ents.Create(ent.class)
            if IsValid(createdEnt) then
                if ent.pos then createdEnt:SetPos(ent.pos) end
                if ent.angles then createdEnt:SetAngles(ent.angles) end
                if ent.model then createdEnt:SetModel(ent.model) end
                createdEnt:Spawn()
                createdEnt:Activate()
            end
        else
            lia.error(string.format("Entity creation aborted: An entity of class '%s' is already nearby at position (%.2f, %.2f, %.2f).", ent.class, ent.pos.x, ent.pos.y, ent.pos.z))
        end
    end

    local items = lia.data.get("itemsave", {}, true)
    if items then
        local idRange = {}
        local positions = {}
        for _, item in ipairs(items) do
            idRange[#idRange + 1] = item[1]
            positions[item[1]] = item[2]
        end

        if #idRange > 0 then
            local range = "(" .. table.concat(idRange, ", ") .. ")"
            if hook.Run("ShouldDeleteSavedItems") == true then
                lia.db.query("DELETE FROM lia_items WHERE _itemID IN " .. range)
                lia.information("Server Deleted Server Items (does not include Logical Items)")
            else
                lia.db.query("SELECT _itemID, _uniqueID, _data FROM lia_items WHERE _itemID IN " .. range, function(data)
                    if data then
                        local loadedItems = {}
                        for _, item in ipairs(data) do
                            local itemID = tonumber(item._itemID)
                            local itemData = util.JSONToTable(item._data or "[]")
                            local uniqueID = item._uniqueID
                            local itemTable = lia.item.list[uniqueID]
                            local position = positions[itemID]
                            if itemTable and itemID then
                                local itemCreated = lia.item.new(uniqueID, itemID)
                                itemCreated.data = itemData or {}
                                itemCreated:spawn(position).liaItemID = itemID
                                itemCreated:onRestored()
                                itemCreated.invID = 0
                                table.insert(loadedItems, itemCreated)
                            end
                        end

                        hook.Run("OnSavedItemLoaded", loadedItems)
                    end
                end)
            end
        end
    end
end

local function DatabaseQuery()
    if not DatabaseQueryRan then
        local typeMap = {
            string = function(d) return ("%s VARCHAR(%d)"):format(d.field, d.length or 255) end,
            integer = function(d) return ("%s INT"):format(d.field) end,
            float = function(d) return ("%s FLOAT"):format(d.field) end,
            boolean = function(d) return ("%s TINYINT(1)"):format(d.field) end,
            datetime = function(d) return ("%s DATETIME"):format(d.field) end,
            text = function(d) return ("%s TEXT"):format(d.field) end
        }

        local dbModule = lia.db.module or "sqlite"
        local getColumnsQuery = dbModule == "sqlite" and "SELECT sql FROM sqlite_master WHERE type='table' AND name='lia_characters'" or "DESCRIBE lia_characters"
        lia.db.query(getColumnsQuery, function(results)
            local existing = {}
            if results and #results > 0 then
                if dbModule == "sqlite" then
                    local createSQL = results[1].sql or ""
                    for def in createSQL:match("%((.+)%)"):gmatch("([^,]+)") do
                        local col = def:match("^%s*`?(%w+)`?")
                        if col then existing[col] = true end
                    end
                else
                    for _, row in ipairs(results) do
                        existing[row.Field] = true
                    end
                end
            end

            for _, v in pairs(lia.char.vars) do
                if v.field and not existing[v.field] and typeMap[v.fieldType] then
                    local colDef = typeMap[v.fieldType](v)
                    if v.default ~= nil then colDef = colDef .. " DEFAULT '" .. tostring(v.default) .. "'" end
                    local alter = ("ALTER TABLE lia_characters ADD COLUMN %s"):format(colDef)
                    lia.db.query(alter, function() MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database] ", Color(255, 255, 255), string.format("Added missing column `%s`.\n", v.field)) end)
                end
            end
        end)

        DatabaseQueryRan = true
    end
end

function GM:InitializedModules()
    timer.Simple(5, function() DatabaseQuery() end)
    if not lia.module.versionChecks and not lia.module.privateVersionChecks then return end
    local publicURL = "https://raw.githubusercontent.com/LiliaFramework/Modules/main/modules.json"
    local privateURL = "https://raw.githubusercontent.com/bleonheart/bleonheart.github.io/main/modules.json"
    http.Fetch(publicURL, function(body, _, _, code)
        if code ~= 200 then
            lia.updater("Error fetching module list (HTTP " .. code .. ")")
            return
        end

        local remote = util.JSONToTable(body)
        if not remote then
            lia.updater("Error parsing module data")
            return
        end

        for _, info in ipairs(lia.module.versionChecks or {}) do
            local match
            for _, m in ipairs(remote) do
                if m.uniqueID == info.uniqueID then
                    match = m
                    break
                end
            end

            if not match then
                lia.updater("Module with uniqueID '" .. info.uniqueID .. "' not found")
            elseif not match.version then
                lia.updater("Module '" .. info.name .. "' has no remote version info")
            elseif match.version ~= info.localVersion then
                lia.updater("Module '" .. info.name .. "' is outdated. Update to version " .. match.version .. " at " .. match.source)
            end
        end

        http.Fetch(privateURL, function(body2, _, _, code2)
            if code2 ~= 200 then
                lia.updater("Error fetching private module list (HTTP " .. code2 .. ")")
                return
            end

            local remote2 = util.JSONToTable(body2)
            if not remote2 then
                lia.updater("Error parsing private module data")
                return
            end

            for _, info in ipairs(lia.module.privateVersionChecks or {}) do
                local match2
                for _, m2 in ipairs(remote2) do
                    if m2.uniqueID == info.uniqueID then
                        match2 = m2
                        break
                    end
                end

                if match2 and match2.version and match2.version ~= info.localVersion then lia.updater("Module '" .. info.name .. "' is outdated, please report back to the author to get an updated copy.") end
            end
        end, function(err2) lia.updater("HTTP.Fetch error: " .. err2) end)
    end, function(err) lia.updater("HTTP.Fetch error: " .. err) end)
end

function ClientAddText(client, ...)
    if not client or not IsValid(client) then
        lia.error("Invalid client provided to chat.AddText")
        return
    end

    local args = {...}
    net.Start("ServerChatAddText")
    net.WriteTable(args)
    net.Send(client)
end

local networkStrings = {"liaItemDelete", "liaItemInstance", "liaTransferItem", "liaInventoryAdd", "liaInventoryRemove", "liaInventoryData", "liaInventoryInit", "liaInventoryDelete", "NetStreamDS", "liaCharChoose", "liaCharacterInvList", "liaCharCreate", "liaCharList", "liaCharDelete",}
for _, netString in ipairs(networkStrings) do
    util.AddNetworkString(netString)
end

-- ./gamemode/core/hooks/shared.lua
local GM = GM or GAMEMODE
function GM:Move(client, moveData)
    local character = client:getChar()
    if not character then return end
    local runSpeed = lia.config.get("RunSpeed", 235)
    local runSpeedNoModifier = runSpeed
    local runSpeedModifier = runSpeed / 2.5
    if client:KeyDown(IN_FORWARD) then
        moveData:SetMaxSpeed(runSpeedNoModifier)
    elseif client:KeyDown(IN_MOVELEFT) or client:KeyDown(IN_MOVERIGHT) or client:KeyDown(IN_BACK) then
        moveData:SetMaxSpeed(runSpeedModifier)
    end

    if client:GetMoveType() == MOVETYPE_WALK and moveData:KeyDown(IN_WALK) then
        local forwardMult, sideMult = 0, 0
        local speed = client:GetWalkSpeed()
        local ratio = lia.config.get("WalkRatio")
        if moveData:KeyDown(IN_FORWARD) then
            forwardMult = ratio
        elseif moveData:KeyDown(IN_BACK) then
            forwarwMult = -ratio
        end

        if moveData:KeyDown(IN_MOVELEFT) then
            sideMult = -ratio
        elseif moveData:KeyDown(IN_MOVERIGHT) then
            sideMult = ratio
        end

        moveData:SetForwardSpeed(forwardMult * speed)
        moveData:SetSideSpeed(sideMult * speed)
    end
end

function GM:InitPostEntity()
    if SERVER then
        lia.faction.formatModelData()
        timer.Simple(2, function() lia.entityDataLoaded = true end)
        lia.db.waitForTablesToLoad():next(function()
            hook.Run("LoadData")
            hook.Run("PostLoadData")
        end)
    else
        lia.joinTime = RealTime() - 0.9716
        if system.IsWindows() and not system.HasFocus() then system.FlashWindow() end
    end
end

function GM:OnCharVarChanged(character, varName, oldVar, newVar)
    if lia.char.varHooks[varName] then
        for _, v in pairs(lia.char.varHooks[varName]) do
            v(character, oldVar, newVar)
        end
    end
end

function GM:CreateDefaultInventory(character)
    local charID = character:getID()
    return lia.inventory.instance("grid", {
        char = charID
    })
end

local GamemodeFunctions = {
    server = {
        {
            name = "PlayerSpray",
            returnValue = true
        },
        {
            name = "PlayerDeathSound",
            returnValue = true
        },
        {
            name = "CanPlayerSuicide",
            returnValue = false
        },
        {
            name = "AllowPlayerPickup",
            returnValue = false
        },
        {
            name = "CharacterLoaded",
            args = {"id"},
            replacement = "CharLoaded"
        },
        {
            name = "PreCharacterDelete",
            args = {"id"},
            replacement = "PreCharDelete"
        },
        {
            name = "OnCharacterDelete",
            args = {"client", "id"},
            replacement = "OnCharDelete"
        },
        {
            name = "onCharCreated",
            args = {"client", "character", "data"},
            replacement = "OnCharCreated"
        },
        {
            name = "onTransferred",
            args = {"client"},
            replacement = "OnTransferred"
        },
        {
            name = "CharacterPreSave",
            args = {"character"},
            replacement = "CharPreSave"
        }
    },
    client = {
        {
            name = "HUDDrawTargetID",
            returnValue = false
        },
        {
            name = "HUDDrawPickupHistory",
            returnValue = false
        },
        {
            name = "HUDAmmoPickedUp",
            returnValue = false
        },
        {
            name = "DrawDeathNotice",
            returnValue = false
        },
        {
            name = "CanDisplayCharacterInfo",
            args = {"client", "id"},
            replacement = "CanDisplayCharInfo"
        },
        {
            name = "KickedFromCharacter",
            args = {"id", "isCurrentChar"},
            replacement = "KickedFromChar"
        },
        {
            name = "CharacterListLoaded",
            args = {"newCharList"},
            replacement = "CharListLoaded"
        },
        {
            name = "CharacterListUpdated",
            args = {"oldCharList", "newCharList"},
            replacement = "CharListUpdated"
        }
    },
    shared = {
        {
            name = "CharacterMaxStamina",
            args = {"character"},
            replacement = "CharMaxStamina"
        },
        {
            name = "GetMaxPlayerCharacter",
            args = {"client"},
            replacement = "GetMaxPlayerChar"
        },
        {
            name = "LoadFonts",
            args = {"..."},
            replacement = "PostLoadFonts"
        },
        {
            name = "CanPlayerCreateCharacter",
            args = {"client"},
            replacement = "CanPlayerCreateChar"
        }
    }
}

local function registerFunctions(scope)
    for _, f in ipairs(GamemodeFunctions[scope]) do
        if f.returnValue ~= nil then
            GM[f.name] = function() return f.returnValue end
        elseif f.replacement then
            GM[f.name] = function(...)
                local args = {...}
                lia.deprecated(f.name, function() hook.Run(f.replacement, unpack(args)) end)
            end
        end
    end
end

if SERVER then registerFunctions("server") end
if CLIENT then registerFunctions("client") end
registerFunctions("shared")

-- ./gamemode/core/libraries/attributes.lua
lia.attribs = lia.attribs or {}
lia.attribs.list = lia.attribs.list or {}
--[[
    lia.attribs.loadFromDir(directory)

    Description:
        Loads attribute definitions from all Lua files in the given directory.
        Files beginning with "sh_" are treated as shared and loaded on both client and server.
        Each file must return an ATTRIBUTE table, which is then stored in lia.attribs.list
        under a key derived from the filename (without the "sh_" prefix or ".lua" extension).

    Parameters:
        directory (string)  Path to the folder containing attribute Lua files.

    Realm:
        Shared

    Returns:
        None
]]
function lia.attribs.loadFromDir(directory)
    for _, v in ipairs(file.Find(directory .. "/*.lua", "LUA")) do
        local niceName = v:sub(1, 3) == "sh_" and v:sub(4, -5):lower() or v:sub(1, -5)
        ATTRIBUTE = lia.attribs.list[niceName] or {}
        if MODULE then ATTRIBUTE.module = MODULE.uniqueID end
        lia.include(directory .. "/" .. v, "shared")
        ATTRIBUTE.name = ATTRIBUTE.name or l("unknown")
        ATTRIBUTE.desc = ATTRIBUTE.desc or L("noDesc")
        lia.attribs.list[niceName] = ATTRIBUTE
        ATTRIBUTE = nil
    end
end

if SERVER then
    --[[
        lia.attribs.setup(client)

        Description:
            Initializes attributes for a given clients character.
            Iterates over all entries in lia.attribs.list, retrieves the characters
            attribute value, and calls the attributes OnSetup callback if it exists.

        Parameters:
            client (Player)  The player whose character attributes should be set up.

        Realm:
            Server

        Returns:
            None
    ]]
    function lia.attribs.setup(client)
        local character = client:getChar()
        if not character then return end
        for attribID, attribData in pairs(lia.attribs.list) do
            local value = character:getAttrib(attribID, 0)
            if attribData.OnSetup then attribData:OnSetup(client, value) end
        end
    end
end

-- ./gamemode/core/libraries/bars.lua
local surfaceSetDrawColor, surfaceDrawRect, surfaceDrawOutlinedRect = surface.SetDrawColor, surface.DrawRect, surface.DrawOutlinedRect
lia.bar = lia.bar or {}
lia.bar.delta = lia.bar.delta or {}
lia.bar.list = {}
local function findIndexByIdentifier(identifier)
    for idx, bar in ipairs(lia.bar.list) do
        if bar.identifier == identifier then return idx end
    end
end

--[[
    lia.bar.get(identifier)

    Description:
        Retrieves a bar object from the list by its unique identifier.

    Parameters:
        identifier (string)  The unique identifier of the bar to retrieve.

    Realm:
        Client

    Returns:
        table or nil  The bar table if found, or nil if not found.
]]
function lia.bar.get(identifier)
    for _, bar in ipairs(lia.bar.list) do
        if bar.identifier == identifier then return bar end
    end
end

--[[
    lia.bar.add(getValue, color, priority, identifier)

    Description:
        Adds a new bar or replaces an existing one in the bar list.
        If the identifier matches an existing bar, the old bar is removed first.
        Bars are drawn in order of ascending priority.

    Parameters:
        getValue (function)  A callback that returns the current value of the bar.
        color (Color)  The fill color for the bar. Defaults to a random pastel color.
        priority (number)  Determines drawing order; lower values draw first. Defaults to end of list.
        identifier (string)  Optional unique identifier for the bar.

    Realm:
        Client

    Returns:
        number  The priority assigned to the added bar.
]]
function lia.bar.add(getValue, color, priority, identifier)
    if identifier then
        local existingIdx = findIndexByIdentifier(identifier)
        if existingIdx then table.remove(lia.bar.list, existingIdx) end
    end

    priority = priority or #lia.bar.list + 1
    table.insert(lia.bar.list, {
        getValue = getValue,
        color = color or Color(math.random(150, 255), math.random(150, 255), math.random(150, 255)),
        priority = priority,
        lifeTime = 0,
        identifier = identifier
    })
    return priority
end

--[[
    lia.bar.remove(identifier)

    Description:
        Removes a bar from the list based on its unique identifier.

    Parameters:
        identifier (string)  The unique identifier of the bar to remove.

    Realm:
        Client

    Returns:
        None
]]
function lia.bar.remove(identifier)
    local idx = findIndexByIdentifier(identifier)
    if idx then table.remove(lia.bar.list, idx) end
end

--[[
    lia.bar.drawBar(x, y, w, h, pos, max, color)

    Description:
        Draws a single horizontal bar at the specified screen coordinates,
        filling it proportionally based on pos and max.

    Parameters:
        x (number)  The x-coordinate of the bar's top-left corner.
        y (number)  The y-coordinate of the bar's top-left corner.
        w (number)  The total width of the bar (including padding).
        h (number)  The total height of the bar.
        pos (number)  The current value to display (will be clamped to max).
        max (number)  The maximum possible value for the bar.
        color (Color)  The color to fill the bar.

    Realm:
        Client

    Returns:
        None
]]
local function PaintPanel(x, y, w, h)
    surfaceSetDrawColor(0, 0, 0, 255)
    surfaceDrawOutlinedRect(x, y, w, h)
    surfaceSetDrawColor(0, 0, 0, 150)
    surfaceDrawRect(x + 1, y + 1, w - 2, h - 2)
end

function lia.bar.drawBar(x, y, w, h, pos, max, color)
    pos = math.min(pos, max)
    local usable = math.max(w - 6, 0)
    local fill = usable * pos / max
    PaintPanel(x, y, w + 6, h)
    surfaceSetDrawColor(color.r, color.g, color.b)
    surfaceDrawRect(x + 3, y + 3, fill, h - 6)
end

--[[
    lia.bar.drawAction(text, time)

    Description:
        Displays a temporary action progress bar with accompanying text
        for the specified duration on the HUD.

    Parameters:
        text (string)  The text to display above the progress bar.
        time (number)  Duration in seconds for which the bar is displayed.

    Realm:
        Client

    Returns:
        None
]]
function lia.bar.drawAction(text, duration)
    local startTime, endTime = CurTime(), CurTime() + duration
    hook.Remove("HUDPaint", "liaDrawAction")
    hook.Add("HUDPaint", "liaDrawAction", function()
        local curTime = CurTime()
        if curTime >= endTime then
            hook.Remove("HUDPaint", "liaDrawAction")
            return
        end

        local frac = 1 - math.TimeFraction(startTime, endTime, curTime)
        local w, h = ScrW() * 0.35, 28
        local x, y = ScrW() * 0.5 - w * 0.5, ScrH() * 0.725 - h * 0.5
        lia.util.drawBlurAt(x, y, w, h)
        PaintPanel(x, y, w, h)
        surfaceSetDrawColor(lia.config.get("Color"))
        surfaceDrawRect(x + 4, y + 4, w * frac - 8, h - 8)
        surfaceSetDrawColor(200, 200, 200, 20)
        surface.SetMaterial(lia.util.getMaterial("vgui/gradient-d"))
        surface.DrawTexturedRect(x + 4, y + 4, w * frac - 8, h - 8)
        draw.SimpleText(text, "liaMediumFont", x + 2, y - 22, Color(20, 20, 20))
        draw.SimpleText(text, "liaMediumFont", x, y - 24, Color(240, 240, 240))
    end)
end

--[[
    lia.bar.drawAll()

    Description:
        Iterates through all registered bars, applies smoothing to their values,
        and draws them on the HUD according to their priority and visibility rules.

    Parameters:
        None

    Realm:
        Client

    Returns:
        None
]]
function lia.bar.drawAll()
    if hook.Run("ShouldHideBars") then return end
    table.sort(lia.bar.list, function(a, b) return a.priority < b.priority end)
    local w, h = ScrW() * 0.35, 14
    local x, y = 4, 4
    local deltas = lia.bar.delta
    local update = FrameTime() * 0.6
    local now = CurTime()
    local always = lia.option.get("BarsAlwaysVisible")
    for i, bar in ipairs(lia.bar.list) do
        local target = bar.getValue()
        deltas[i] = deltas[i] or target
        deltas[i] = math.Approach(deltas[i], target, update)
        local value = deltas[i]
        if value ~= target then bar.lifeTime = now + 5 end
        if always or bar.lifeTime >= now or bar.visible or hook.Run("ShouldBarDraw", bar) then
            lia.bar.drawBar(x, y, w, h, value, 1, bar.color)
            y = y + h + 2
        end
    end
end

lia.bar.add(function()
    local client = LocalPlayer()
    return client:Health() / client:GetMaxHealth()
end, Color(200, 50, 40), 1, "health")

lia.bar.add(function()
    local client = LocalPlayer()
    return client:Armor() / client:GetMaxArmor()
end, Color(30, 70, 180), 3, "armor")

hook.Add("HUDPaintBackground", "liaDrawBars", lia.bar.drawAll)

-- ./gamemode/core/libraries/character.lua
local characterMeta = lia.meta.character or {}
lia.char = lia.char or {}
lia.char.loaded = lia.char.loaded or {}
lia.char.names = lia.char.names or {}
lia.char.varHooks = lia.char.varHooks or {}
lia.char.vars = lia.char.vars or {}
characterMeta.__index = characterMeta
characterMeta.id = characterMeta.id or 0
characterMeta.vars = characterMeta.vars or {}
debug.getregistry().Character = lia.meta.character
if SERVER and #lia.char.names < 1 then
    lia.db.query("SELECT _id, _name FROM lia_characters", function(data)
        if data and #data > 0 then
            for _, v in pairs(data) do
                lia.char.names[v._id] = v._name
            end
        end
    end)
end

--[[
    lia.char.new(data, id, client, steamID)

    Description:
        Creates a new character instance with default variables and metatable.

    Parameters:
        data (table)  Table of character variables.
        id (number)  Character ID.
        client (Player)  Player entity.
        steamID (string)  SteamID64 string if client is not valid.

    Realm:
        Shared

    Returns:
        character (table)  New character object.
]]
function lia.char.new(data, id, client, steamID)
    local character = setmetatable({
        vars = {}
    }, lia.meta.character)

    for k, v in pairs(lia.char.vars) do
        local value = data[k]
        if value == nil then
            value = v.default
            if istable(value) then value = table.Copy(value) end
        end

        character.vars[k] = value
    end

    character.id = id or 0
    character.player = client
    if IsValid(client) or steamID then character.steamID = IsValid(client) and client:SteamID64() or steamID end
    return character
end

--[[
    lia.char.hookVar(varName, hookName, func)

    Description:
        Registers a hook function for when a character variable changes.

    Parameters:
        varName (string)  Variable name to hook.
        hookName (string)  Unique hook identifier.
        func (function)  Function to call on variable change.

    Realm:
        Shared

    Returns:
        None
]]
function lia.char.hookVar(varName, hookName, func)
    lia.char.varHooks[varName] = lia.char.varHooks[varName] or {}
    lia.char.varHooks[varName][hookName] = func
end

--[[
    lia.char.registerVar(key, data)

    Description:
        Registers a character variable with metadata and generates accessor methods.

    Parameters:
        key (string)  Variable key.
        data (table)  Variable metadata including default, validation, networking, etc.

    Realm:
        Shared

    Returns:
        None
]]
function lia.char.registerVar(key, data)
    lia.char.vars[key] = data
    data.index = data.index or table.Count(lia.char.vars)
    local upperName = key:sub(1, 1):upper() .. key:sub(2)
    if SERVER and not data.isNotModifiable then
        if data.onSet then
            characterMeta["set" .. upperName] = data.onSet
        elseif data.noNetworking then
            characterMeta["set" .. upperName] = function(self, value) self.vars[key] = value end
        elseif data.isLocal then
            characterMeta["set" .. upperName] = function(self, value)
                local curChar = self:getPlayer() and self:getPlayer():getChar()
                local sendID = true
                if curChar and curChar == self then sendID = false end
                local oldVar = self.vars[key]
                self.vars[key] = value
                netstream.Start(self.player, "charSet", key, value, sendID and self:getID() or nil)
                hook.Run("OnCharVarChanged", self, key, oldVar, value)
            end
        else
            characterMeta["set" .. upperName] = function(self, value)
                local oldVar = self.vars[key]
                self.vars[key] = value
                netstream.Start(nil, "charSet", key, value, self:getID())
                hook.Run("OnCharVarChanged", self, key, oldVar, value)
            end
        end
    end

    if data.onGet then
        characterMeta["get" .. upperName] = data.onGet
    else
        characterMeta["get" .. upperName] = function(self, default)
            local value = self.vars[key]
            if value ~= nil then return value end
            if default == nil then return lia.char.vars[key] and lia.char.vars[key].default or nil end
            return default
        end
    end

    characterMeta.vars[key] = data.default
end

lia.char.registerVar("name", {
    field = "_name",
    default = "John Doe",
    index = 1,
    onValidate = function(value, data, client)
        local name, override = hook.Run("GetDefaultCharName", client, data.faction, data)
        if isstring(name) and override then return true end
        if not isstring(value) or not value:find("%S") then return false, "invalid", "name" end
        local allowExistNames = lia.config.get("AllowExistNames", true)
        if CLIENT and #lia.char.names < 1 and not allowExistNames then
            netstream.Start("liaCharFetchNames")
            netstream.Hook("liaCharFetchNames", function(data) lia.char.names = data end)
        end

        if not lia.config.get("AllowExistNames", true) then
            for _, v in pairs(lia.char.names) do
                if v == value then return false, "A character with this name already exists." end
            end
        end
        return true
    end,
    onAdjust = function(client, data, value, newData)
        local name, override = hook.Run("GetDefaultCharName", client, data.faction, data)
        if isstring(name) and override then
            newData.name = name
        else
            newData.name = string.Trim(value):sub(1, 70)
        end
    end,
})

lia.char.registerVar("desc", {
    field = "_desc",
    default = "Please enter your description with a minimum of " .. lia.config.get("MinDescLen", 16) .. " characters!",
    index = 2,
    onValidate = function(value, data, client)
        local desc, override = hook.Run("GetDefaultCharDesc", client, data.faction)
        local minLength = lia.config.get("MinDescLen", 16)
        if isstring(desc) and override then return true end
        if not value or #value:gsub("%s", "") < minLength then return false, "descMinLen", minLength end
        return true
    end,
    onAdjust = function(client, data, value, newData)
        local desc, override = hook.Run("GetDefaultCharDesc", client, data.faction)
        if isstring(desc) and override then
            newData.desc = desc
        else
            newData.desc = value
        end
    end,
})

lia.char.registerVar("model", {
    field = "_model",
    default = "models/error.mdl",
    onSet = function(character, value)
        local oldVar = character:getModel()
        local client = character:getPlayer()
        if IsValid(client) and client:getChar() == character then client:SetModel(value) end
        character.vars.model = value
        netstream.Start(nil, "charSet", "model", character.vars.model, character:getID())
        hook.Run("PlayerModelChanged", client, value)
        hook.Run("OnCharVarChanged", character, "model", oldVar, value)
    end,
    onGet = function(character, default) return character.vars.model or default end,
    index = 3,
    onValidate = function(_, data)
        local faction = lia.faction.indices[data.faction]
        if faction then
            if not data.model or not faction.models[data.model] then return false, "needModel" end
        else
            return false, "needModel"
        end
    end,
    onAdjust = function(_, data, value, newData)
        local faction = lia.faction.indices[data.faction]
        if faction then
            local model = faction.models[value]
            if isstring(model) then
                newData.model = model
            elseif istable(model) then
                newData.model = model[1]
                newData.data = newData.data or {}
                newData.data.skin = model[2] or 0
                local groups = {}
                if isstring(model[3]) then
                    local i = 0
                    for digit in model[3]:gmatch("%d") do
                        groups[i] = tonumber(digit)
                        i = i + 1
                    end
                elseif istable(model[3]) then
                    for groupIndex, groupValue in pairs(model[3]) do
                        groups[tonumber(groupIndex)] = tonumber(groupValue)
                    end
                end

                newData.data.groups = groups
            end
        end
    end
})

lia.char.registerVar("class", {
    noDisplay = true,
})

lia.char.registerVar("faction", {
    field = "_faction",
    default = "Citizen",
    onSet = function(character, value)
        local oldVar = character:getFaction()
        local faction = lia.faction.indices[value]
        assert(faction, tostring(value) .. " is an invalid faction index")
        local client = character:getPlayer()
        client:SetTeam(value)
        character.vars.faction = faction.uniqueID
        netstream.Start(nil, "charSet", "faction", character.vars.faction, character:getID())
        hook.Run("OnCharVarChanged", character, "faction", oldVar, value)
        return true
    end,
    onGet = function(character, default)
        local faction = lia.faction.teams[character.vars.faction]
        return faction and faction.index or default or 0
    end,
    onValidate = function(value, _, client)
        if not lia.faction.indices[value] then return false, "invalid", "faction" end
        if not client:hasWhitelist(value) then return false, "illegalAccess" end
        return true
    end,
    onAdjust = function(_, _, value, newData) newData.faction = lia.faction.indices[value].uniqueID end
})

lia.char.registerVar("money", {
    field = "_money",
    default = 0,
    isLocal = true,
    noDisplay = true
})

lia.char.registerVar("data", {
    default = {},
    isLocal = true,
    noDisplay = true,
    field = "_data",
    onSet = function(character, key, value, noReplication, receiver)
        local data = character:getData()
        local client = character:getPlayer()
        data[key] = value
        if not noReplication and IsValid(client) then netstream.Start(receiver or client, "charData", character:getID(), key, value) end
        character.vars.data = data
    end,
    onGet = function(character, key, default)
        local data = character.vars.data or {}
        if key then
            if not data then return default end
            local value = data[key]
            return value == nil and default or value
        else
            return default or data
        end
    end
})

lia.char.registerVar("var", {
    default = {},
    noDisplay = true,
    onSet = function(character, key, value, noReplication, receiver)
        local data = character:getVar()
        local client = character:getPlayer()
        data[key] = value
        if not noReplication and IsValid(client) then
            local id
            if client:getChar() and client:getChar():getID() == character:getID() then
                id = client:getChar():getID()
            else
                id = character:getID()
            end

            netstream.Start(receiver or client, "charVar", key, value, id)
        end

        character.vars.vars = data
    end,
    onGet = function(character, key, default)
        character.vars.vars = character.vars.vars or {}
        local data = character.vars.vars or {}
        if key then
            if not data then return default end
            local value = data[key]
            return value == nil and default or value
        else
            return default or data
        end
    end
})

lia.char.registerVar("inv", {
    noNetworking = true,
    noDisplay = true,
    onGet = function(character, index)
        if index and not isnumber(index) then return character.vars.inv or {} end
        return character.vars.inv and character.vars.inv[index or 1]
    end,
    onSync = function(character, recipient)
        net.Start("liaCharacterInvList")
        net.WriteUInt(character:getID(), 32)
        net.WriteUInt(#character.vars.inv, 32)
        for i = 1, #character.vars.inv do
            net.WriteType(character.vars.inv[i].id)
        end

        if recipient == nil then
            net.Broadcast()
        else
            net.Send(recipient)
        end
    end
})

lia.char.registerVar("attribs", {
    field = "_attribs",
    default = {},
    isLocal = true,
    index = 4,
    onValidate = function(value, _, client)
        if value ~= nil then
            if istable(value) then
                local count = 0
                for k, v in pairs(value) do
                    local max = hook.Run("GetAttributeStartingMax", client, k)
                    if max and v > max then return false, lia.attribs.list[k].name .. " too high" end
                    count = count + v
                end

                local points = hook.Run("GetMaxStartingAttributePoints", client, count)
                if count > points then return false, "unknownError" end
            else
                return false, "unknownError"
            end
        end
    end,
    shouldDisplay = function() return table.Count(lia.attribs.list) > 0 end
})

lia.char.registerVar("RecognizedAs", {
    field = "recognized_as",
    default = {},
    noDisplay = true
})

--[[
    lia.char.getCharData(charID, key)

    Description:
        Retrieves character data JSON from the database as a Lua table.

    Parameters:
        charID (number|string)  Character ID.
        key (string)  Specific data key to return (optional).

    Realm:
        Shared

    Returns:
        value (any)  Data value or full table if no key provided.
]]
function lia.char.getCharData(charID, key)
    local charIDsafe = tonumber(charID)
    if not charIDsafe then return end
    local findData = sql.Query("SELECT * FROM lia_characters WHERE _id=" .. charIDsafe)
    if not findData or not findData[1] then return false end
    local data = util.JSONToTable(findData[1]._data) or {}
    if key then return data[key] end
    return data
end

--[[
    lia.char.getCharDataRaw(charID, key)

    Description:
        Retrieves raw character database row or specific column.

    Parameters:
        charID (number|string)  Character ID.
        key (string)  Specific column name to return (optional).

    Realm:
        Shared

    Returns:
        row (table|any)  Full row table or column value.
]]
function lia.char.getCharDataRaw(charID, key)
    local charIDsafe = tonumber(charID)
    if not charIDsafe then return end
    local findData = sql.Query("SELECT * FROM lia_characters WHERE _id=" .. charIDsafe)
    if not findData or not findData[1] then return false end
    if key then return findData[1][key] end
    return findData[1]
end

--[[
    lia.char.getOwnerByID(ID)

    Description:
        Finds the player entity that owns the character with the given ID.

    Parameters:
        ID (number|string)  Character ID.

    Realm:
        Shared

    Returns:
        Player  Player entity or nil if not found.
]]
function lia.char.getOwnerByID(ID)
    ID = tonumber(ID)
    for client, character in pairs(lia.char.getAll()) do
        if character and character:getID() == ID then return client end
    end
end

--[[
    lia.char.getBySteamID(steamID)

    Description:
        Retrieves a character object by SteamID or SteamID64.

    Parameters:
        steamID (string)  SteamID or SteamID64.

    Realm:
        Shared

    Returns:
        Character  Character object or nil.
]]
function lia.char.getBySteamID(steamID)
    if not isstring(steamID) or steamID == "" then return end
    for _, client in player.Iterator() do
        local sid = client:SteamID()
        local sid64 = client:SteamID64()
        if (sid == steamID or sid64 == steamID) and client:getChar() then return client:getChar() end
    end
end

--[[
    lia.char.getAll()

    Description:
        Returns a table mapping all players to their loaded character objects.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        table  Map of Player to Character.
]]
function lia.char.getAll()
    local charTable = {}
    for _, client in player.Iterator() do
        if client:getChar() then charTable[client] = client:getChar() end
    end
    return charTable
end

--[[
    lia.char.GetTeamColor(client)

    Description:
        Determines the team color for a client based on their character class or default team.

    Parameters:
        client (Player)  Player entity.

    Realm:
        Shared

    Returns:
        Color  Team or class color.
]]
function lia.char.GetTeamColor(client)
    local char = client:getChar()
    if not char then return team.GetColor(client:Team()) end
    local classIndex = char:getClass()
    if not classIndex then return team.GetColor(client:Team()) end
    local classTbl = lia.class.list[classIndex]
    if not classTbl then return team.GetColor(client:Team()) end
    return classTbl.Color or team.GetColor(client:Team())
end

if SERVER then
    --[[
        lia.char.create(data, callback)

        Description:
            Inserts a new character into the database and sets up default inventory.

        Parameters:
            data (table)  Character creation data.
            callback (function)  Callback receiving new character ID.

        Realm:
            Server

        Returns:
            None
    ]]
    function lia.char.create(data, callback)
        local timeStamp = os.date("%Y-%m-%d %H:%M:%S", os.time())
        data.money = data.money or lia.config.get("DefaultMoney")
        lia.db.insertTable({
            _name = data.name or "",
            _desc = data.desc or "",
            _model = data.model or "models/error.mdl",
            _schema = SCHEMA and SCHEMA.folder or "lilia",
            _createTime = timeStamp,
            _lastJoinTime = timeStamp,
            _steamID = data.steamID,
            _faction = data.faction or L("unknown"),
            _money = data.money,
            recognized_as = "",
            _data = data.data
        }, function(_, charID)
            local client
            for _, v in player.Iterator() do
                if v:SteamID64() == data.steamID then
                    client = v
                    break
                end
            end

            local character = lia.char.new(data, charID, client, data.steamID)
            character.vars.inv = {}
            hook.Run("CreateDefaultInventory", character):next(function(inventory)
                character.vars.inv[1] = inventory
                lia.char.loaded[charID] = character
                if callback then callback(charID) end
            end)
        end)
    end

    --[[
        lia.char.restore(client, callback, id)

        Description:
            Loads characters for a client from the database, optionally filtering by ID.

        Parameters:
            client (Player)  Player entity.
            callback (function)  Callback receiving list of character IDs.
            id (number)  Specific character ID to restore (optional).

        Realm:
            Server

        Returns:
            None
    ]]
    function lia.char.restore(client, callback, id)
        local steamID64 = client:SteamID64()
        local fields = {"_id"}
        for _, var in pairs(lia.char.vars) do
            if var.field then fields[#fields + 1] = var.field end
        end

        fields = table.concat(fields, ", ")
        local condition = "_schema = '" .. lia.db.escape(SCHEMA.folder) .. "' AND _steamID = " .. steamID64
        if id then condition = condition .. " AND _id = " .. id end
        local query = "SELECT " .. fields .. " FROM lia_characters WHERE " .. condition
        lia.db.query(query, function(data)
            local characters = {}
            local results = data or {}
            local done = 0
            if #results == 0 then
                if callback then callback(characters) end
                return
            end

            for _, v in ipairs(results) do
                local id = tonumber(v._id)
                if not id then
                    ErrorNoHalt("[Lilia] Attempt to load character '" .. (data._name or "nil") .. "' with invalid ID!")
                    continue
                end

                local data = {}
                for k2, v2 in pairs(lia.char.vars) do
                    if v2.field and v[v2.field] then
                        local value = tostring(v[v2.field])
                        if isnumber(v2.default) then
                            value = tonumber(value) or v2.default
                        elseif isbool(v2.default) then
                            value = tobool(value)
                        elseif istable(v2.default) then
                            value = util.JSONToTable(value)
                        end

                        data[k2] = value
                    end
                end

                characters[#characters + 1] = id
                local character = lia.char.new(data, id, client)
                hook.Run("CharRestored", character)
                character.vars.inv = {}
                lia.inventory.loadAllFromCharID(id):next(function(inventories)
                    if #inventories == 0 then
                        local promise = hook.Run("CreateDefaultInventory", character)
                        assert(promise ~= nil, "No default inventory available")
                        return promise:next(function(inventory)
                            assert(inventory ~= nil, "No default inventory available")
                            return {inventory}
                        end)
                    end
                    return inventories
                end, function(err)
                    lia.information("Failed to load inventories for " .. tostring(id))
                    lia.information(err)
                    if IsValid(client) then client:ChatPrint("A server error occured while loading your" .. " inventories. Check server log for details.") end
                end):next(function(inventories)
                    character.vars.inv = inventories
                    lia.char.loaded[id] = character
                    done = done + 1
                    if done == #results and callback then callback(characters) end
                end)
            end
        end)
    end

    --[[
        lia.char.cleanUpForPlayer(client)

        Description:
            Cleans up loaded characters and inventories for a player on disconnect.

        Parameters:
            client (Player)  Player entity.

        Realm:
            Server

        Returns:
            None
    ]]
    function lia.char.cleanUpForPlayer(client)
        for _, charID in pairs(client.liaCharList or {}) do
            local character = lia.char.loaded[charID]
            if not character then return end
            lia.inventory.cleanUpForCharacter(character)
            lia.char.loaded[charID] = nil
            hook.Run("CharCleanUp", character)
        end
    end

    local function removePlayer(client)
        if client:getChar() then
            client:KillSilent()
            client:setNetVar("char", nil)
            client:Spawn()
            netstream.Start(client, "charKick", nil, true)
        end
    end

    --[[
        lia.char.delete(id, client)

        Description:
            Deletes a character by ID from the database, cleans up and notifies players.

        Parameters:
            id (number)  Character ID to delete.
            client (Player)  Player entity reference.

        Realm:
            Server

        Returns:
            None
    ]]
    function lia.char.delete(id, client)
        assert(isnumber(id), "id must be a number")
        if IsValid(client) then
            removePlayer(client)
        else
            for _, target in player.Iterator() do
                if not table.HasValue(target.liaCharList or {}, id) then continue end
                table.RemoveByValue(target.liaCharList, id)
                removePlayer(target)
            end
        end

        hook.Run("PreCharDelete", id)
        for index, charID in pairs(client.liaCharList) do
            if charID == id then
                table.remove(client.liaCharList, index)
                break
            end
        end

        lia.char.loaded[id] = nil
        lia.db.query("DELETE FROM lia_characters WHERE _id = " .. id)
        lia.db.query("SELECT _invID FROM lia_inventories WHERE _charID = " .. id, function(data)
            if data then
                for _, inventory in ipairs(data) do
                    lia.inventory.deleteByID(tonumber(inventory._invID))
                end
            end
        end)

        hook.Run("OnCharDelete", client, id)
    end

    --[[
        lia.char.setCharData(charID, key, val)

        Description:
            Updates a character's JSON data field in the database and loaded object.

        Parameters:
            charID (number|string)  Character ID.
            key (string)  Data key.
            val (any)  New value.

        Realm:
            Server

        Returns:
            boolean  True on success, false on failure.
    ]]
    function lia.char.setCharData(charID, key, val)
        local charIDsafe = tonumber(charID)
        if not charIDsafe then return end
        local data = lia.char.getCharData(charID)
        if not data then return false end
        data[key] = val
        local setQ = "UPDATE lia_characters SET _data=" .. sql.SQLStr(util.TableToJSON(data)) .. " WHERE _id=" .. charIDsafe
        if not sql.Query(setQ) then
            lia.information("lia.char.setCharData SQL Error, q=" .. setQ .. ", Error = " .. sql.LastError())
            return false
        end

        if lia.char.loaded[charIDsafe] then lia.char.loaded[charIDsafe]:setData(key, val) end
        return true
    end

    --[[
        lia.char.setCharName(charID, name)

        Description:
            Updates the character's name in the database and loaded object.

        Parameters:
            charID (number|string)  Character ID.
            name (string)  New character name.

        Realm:
            Server

        Returns:
            boolean  True on success, false on failure.
    ]]
    function lia.char.setCharName(charID, name)
        local charIDsafe = tonumber(charID)
        if not name or not charID then return end
        local setQ = "UPDATE lia_characters SET _name=" .. sql.SQLStr(name) .. " WHERE _id=" .. charIDsafe
        if not sql.Query(setQ) then
            print("lia.char.setCharName SQL Error, q=" .. setQ .. ", Error = " .. sql.LastError())
            return false
        end

        if lia.char.loaded[charIDsafe] then lia.char.loaded[charIDsafe]:setName(name) end
        return true
    end

    --[[
        lia.char.setCharModel(charID, model, bg)

        Description:
            Updates the character's model and bodygroups in the database and in-game.

        Parameters:
            charID (number|string)  Character ID.
            model (string)  Model path.
            bg (table)  Bodygroup table list.

        Realm:
            Server

        Returns:
            boolean  True on success, false on failure.
    ]]
    function lia.char.setCharModel(charID, model, bg)
        local charIDsafe = tonumber(charID)
        if not model or not charID then return end
        local setQ = "UPDATE lia_characters SET _model=" .. sql.SQLStr(model) .. " WHERE _id=" .. charIDsafe
        if not sql.Query(setQ) then
            print("lia.char.setCharModel SQL Error, q=" .. setQ .. ", Error = " .. sql.LastError())
            return false
        end

        local groups = {}
        for _, v in pairs(bg or {}) do
            groups[v.id] = v.value
        end

        lia.char.setCharData(charID, "groups", groups)
        if lia.char.loaded[charIDsafe] then
            lia.char.loaded[charIDsafe]:setModel(model)
            local client = lia.char.loaded[charIDsafe]:getPlayer()
            if IsValid(client) and client:getChar() == lia.char.loaded[charIDsafe] then
                for _, v in pairs(bg or {}) do
                    client:SetBodygroup(v.id, v.value)
                end

                client:SetupHands()
            end
        end
        return true
    end
end

-- ./gamemode/core/libraries/chatbox.lua
lia.chat = lia.chat or {}
lia.chat.classes = lia.char.classes or {}
--[[
    lia.char.new(data, id, client, steamID)

    Description:
        Creates a new character instance with default variables and metatable.

    Parameters:
        data (table)  Table of character variables.
        id (number)  Character ID.
        client (Player)  Player entity.
        steamID (string)  SteamID64 string if client is not valid.

    Realm:
        Shared

    Returns:
        character (table)  New character object.
]]
function lia.chat.timestamp(ooc)
    return lia.option.ChatShowTime and (ooc and " " or "") .. "(" .. lia.time.GetHour() .. ")" .. (ooc and "" or " ") or ""
end

--[[
    lia.char.new(data, id, client, steamID)

    Description:
        Creates a new character instance with default variables and metatable.

    Parameters:
        data (table)  Table of character variables.
        id (number)  Character ID.
        client (Player)  Player entity.
        steamID (string)  SteamID64 string if client is not valid.

    Realm:
        Shared

    Returns:
        character (table)  New character object.
]]
function lia.chat.register(chatType, data)
    data.syntax = data.syntax or ""
    data.desc = data.desc or ""
    if not data.onCanHear then
        if isfunction(data.radius) then
            data.onCanHear = function(speaker, listener) return (speaker:GetPos() - listener:GetPos()):LengthSqr() <= data.radius() ^ 2 end
        elseif isnumber(data.radius) then
            local range = data.radius ^ 2
            data.onCanHear = function(speaker, listener) return (speaker:GetPos() - listener:GetPos()):LengthSqr() <= range end
        else
            data.onCanHear = function() return true end
        end
    elseif isnumber(data.onCanHear) then
        local range = data.onCanHear ^ 2
        data.onCanHear = function(speaker, listener) return (speaker:GetPos() - listener:GetPos()):LengthSqr() <= range end
    end

    data.onCanSay = data.onCanSay or function(speaker)
        if not data.deadCanChat and not speaker:Alive() then
            speaker:notifyLocalized("noPerm")
            return false
        end
        return true
    end

    data.color = data.color or Color(242, 230, 160)
    data.format = data.format or "%s: \"%s\""
    data.onChatAdd = data.onChatAdd or function(speaker, text, anonymous)
        local name = anonymous and L("someone") or hook.Run("GetDisplayedName", speaker, chatType) or IsValid(speaker) and speaker:Name() or "Console"
        chat.AddText(lia.chat.timestamp(false), data.color, string.format(data.format, name, text))
    end

    if CLIENT and data.prefix then
        local rawPrefixes = istable(data.prefix) and data.prefix or {data.prefix}
        local aliases = {}
        for _, prefix in ipairs(rawPrefixes) do
            local cmd = prefix:gsub("^/", ""):lower()
            if cmd ~= "" then table.insert(aliases, cmd) end
        end

        if #aliases > 0 then
            lia.command.add(chatType, {
                syntax = data.syntax,
                desc = data.desc,
                alias = aliases,
                onRun = function(_, args) lia.chat.parse(LocalPlayer(), table.concat(args, " ")) end
            })
        end
    end

    data.filter = data.filter or "ic"
    lia.chat.classes[chatType] = data
end

--[[
    lia.char.new(data, id, client, steamID)

    Description:
        Creates a new character instance with default variables and metatable.

    Parameters:
        data (table)  Table of character variables.
        id (number)  Character ID.
        client (Player)  Player entity.
        steamID (string)  SteamID64 string if client is not valid.

    Realm:
        Shared

    Returns:
        character (table)  New character object.
]]
function lia.chat.parse(client, message, noSend)
    local anonymous = false
    local chatType = "ic"
    for k, v in pairs(lia.chat.classes) do
        local isChosen = false
        local chosenPrefix = ""
        local noSpaceAfter = v.noSpaceAfter
        if istable(v.prefix) then
            for _, prefix in ipairs(v.prefix) do
                if message:sub(1, #prefix + (noSpaceAfter and 0 or 1)):lower() == (prefix .. (noSpaceAfter and "" or " ")):lower() then
                    isChosen = true
                    chosenPrefix = prefix .. (v.noSpaceAfter and "" or " ")
                    break
                end
            end
        elseif isstring(v.prefix) then
            isChosen = message:sub(1, #v.prefix + (noSpaceAfter and 0 or 1)):lower() == (v.prefix .. (v.noSpaceAfter and "" or " ")):lower()
            chosenPrefix = v.prefix .. (v.noSpaceAfter and "" or " ")
        end

        if isChosen then
            chatType = k
            message = message:sub(#chosenPrefix + 1)
            if lia.chat.classes[k].noSpaceAfter and message:sub(1, 1):match("%s") then message = message:sub(2) end
            break
        end
    end

    if not message:find("%S") then return end
    if SERVER and not noSend then lia.chat.send(client, chatType, hook.Run("PlayerMessageSend", client, chatType, message, anonymous) or message, anonymous) end
    return chatType, message, anonymous
end

if SERVER then
    --[[
    lia.char.new(data, id, client, steamID)

    Description:
        Creates a new character instance with default variables and metatable.

    Parameters:
        data (table)  Table of character variables.
        id (number)  Character ID.
        client (Player)  Player entity.
        steamID (string)  SteamID64 string if client is not valid.

    Realm:
        Shared

    Returns:
        character (table)  New character object.
]]
    function lia.chat.send(speaker, chatType, text, anonymous, receivers)
        local class = lia.chat.classes[chatType]
        if class and class.onCanSay(speaker, text) ~= false then
            if class.onCanHear and not receivers then
                receivers = {}
                for _, v in player.Iterator() do
                    if v:getChar() and class.onCanHear(speaker, v) ~= false then receivers[#receivers + 1] = v end
                end

                if #receivers == 0 then return end
            end

            netstream.Start(receivers, "cMsg", speaker, chatType, hook.Run("PlayerMessageSend", speaker, chatType, text, anonymous, receivers) or text, anonymous)
        end
    end
end

-- ./gamemode/core/libraries/classes.lua
lia.class = lia.class or {}
lia.class.list = lia.class.list or {}
--[[
   lia.class.loadFromDir

   Description:
      Loads class definitions from Lua files located in the specified directory.
      For each valid Lua file, the function includes the file and adds a class table
      to the class list. It also validates that each class has a valid faction.

   Parameters:
      directory (string) - The directory path containing the class Lua files.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.class.loadFromDir("classes")
]]
function lia.class.loadFromDir(directory)
   for _, v in ipairs(file.Find(directory .. "/*.lua", "LUA")) do
      local index = #lia.class.list + 1
      local halt
      local niceName
      if v:sub(1, 3) == "sh_" then
         niceName = v:sub(4, -5):lower()
      else
         niceName = v:sub(1, -5)
      end

      for _, class in ipairs(lia.class.list) do
         if class.uniqueID == niceName then halt = true end
      end

      if halt then continue end
      CLASS = {
         index = index,
         uniqueID = niceName
      }

      CLASS.name = L("unknown")
      CLASS.desc = L("noDesc")
      CLASS.limit = 0
      if MODULE then CLASS.module = MODULE.uniqueID end
      lia.include(directory .. "/" .. v, "shared")
      if not CLASS.faction or not team.Valid(CLASS.faction) then
         ErrorNoHalt("Class '" .. niceName .. "' does not have a valid faction!\n")
         CLASS = nil
         continue
      end

      if not CLASS.OnCanBe then CLASS.OnCanBe = function() return true end end
      lia.class.list[index] = CLASS
      CLASS = nil
   end
end

--[[
   lia.class.canBe

   Description:
      Determines whether the specified client is allowed to join the given class.
      It checks team alignment, if the client already belongs to the class, class capacity,
      and any additional custom conditions via hooks and OnCanBe callback.

   Parameters:
      client (Player) - The player attempting to join the class.
      class (string/number) - The identifier of the class to check.

   Returns:
      boolean, string (optional) - Returns false with an error message if access is denied,
      or the default status (info.isDefault) of the class if allowed.

   Realm:
      Shared

   Example Usage:
      local allowed, reason = lia.class.canBe(client, "warrior")
]]
function lia.class.canBe(client, class)
   local info = lia.class.list[class]
   if not info then return false, L("classNoInfo") end
   if client:Team() ~= info.faction then return false, L("classWrongTeam") end
   if client:getChar():getClass() == class then return false, L("classAlreadyIn") end
   if info.limit > 0 and #lia.class.getPlayers(info.index) >= info.limit then return false, L("classFull") end
   if hook.Run("CanPlayerJoinClass", client, class, info) == false then return false end
   if info.OnCanBe and not info:OnCanBe(client) then return false end
   return info.isDefault
end

--[[
   lia.class.get

   Description:
      Retrieves the class information table from the class list using the provided identifier.

   Parameters:
      identifier (string/number) - The unique identifier for the class.

   Returns:
      table/nil - The class table if found, or nil if it does not exist.

   Realm:
      Shared

   Example Usage:
      local classInfo = lia.class.get("mage")
]]
function lia.class.get(identifier)
   return lia.class.list[identifier]
end

--[[
   lia.class.getPlayers

   Description:
      Returns a list of players whose characters belong to the specified class.

   Parameters:
      class (string/number) - The identifier of the class to filter players by.

   Returns:
      table - A table containing player objects in the specified class.

   Realm:
      Shared

   Example Usage:
      local playersInClass = lia.class.getPlayers("archer")
]]
function lia.class.getPlayers(class)
   local players = {}
   for _, v in player.Iterator() do
      local character = v:getChar()
      if character and character:getClass() == class then table.insert(players, v) end
   end
   return players
end

--[[
   lia.class.getPlayerCount

   Description:
      Counts the number of players whose characters belong to the specified class.

   Parameters:
      class (string/number) - The identifier of the class to count players in.

   Returns:
      number - The total count of players in the class.

   Realm:
      Shared

   Example Usage:
      local count = lia.class.getPlayerCount("healer")
]]
function lia.class.getPlayerCount(class)
   local count = 0
   for _, v in player.Iterator() do
      local character = v:getChar()
      if character and character:getClass() == class then count = count + 1 end
   end
   return count
end

--[[
   lia.class.retrieveClass

   Description:
      Searches through the class list to find a class that matches the provided search string.
      The function checks both the uniqueID and the name of each class for a match.

   Parameters:
      class (string) - The search string to match against class uniqueID or name.

   Returns:
      string/nil - The key (identifier) of the matching class, or nil if no match is found.

   Realm:
      Shared

   Example Usage:
      local classKey = lia.class.retrieveClass("warrior")
]]
function lia.class.retrieveClass(class)
   for key, classTable in pairs(lia.class.list) do
      if lia.util.stringMatches(classTable.uniqueID, class) or lia.util.stringMatches(classTable.name, class) then return key end
   end
   return nil
end

--[[
   lia.class.hasWhitelist

   Description:
      Checks if the specified class requires a whitelist for access.
      Default classes do not require a whitelist.

   Parameters:
      class (string/number) - The identifier of the class to check.

   Returns:
      boolean - True if the class is whitelisted, false otherwise.

   Realm:
      Shared

   Example Usage:
      local isWhitelisted = lia.class.hasWhitelist("rogue")
]]
function lia.class.hasWhitelist(class)
   local info = lia.class.list[class]
   if not info then return false end
   if info.isDefault then return false end
   return info.isWhitelisted
end

hook.Add("CreateMenuButtons", "ClassesMenuButtons", function(tabs) if #lia.faction.getClasses(LocalPlayer():getChar():getFaction()) > 1 then tabs["classes"] = function(panel) panel:Add("liaClasses") end end end)

-- ./gamemode/core/libraries/color.lua
lia = lia or {}
lia.color = lia.color or {}
lia.color.stored = lia.color.stored or {}
local clamp = math.Clamp
local configGet = lia.config.get
local unpack = unpack
--[[
   lia.color.register

   Description:
      Registers a named color for later lookup in the color storage.

   Parameters:
      name  (string)  - The key to assign to the color (case-insensitive).
      color (Color)   - A Color object (or table with r, g, b, a fields).

   Returns:
      None

   Realm:
      Shared

   Example Usage:
      local red = Color(255, 0, 0, 255)
      lia.color.register("alert", red)
]]
function lia.color.register(name, color)
   lia.color.stored[name:lower()] = color
end

--[[
   lia.color.Adjust

   Description:
      Creates a new Color by applying channel offsets to an existing color,
      clamping each channel between 0 and 255.

   Parameters:
      color   (Color)  - The base color to adjust.
      rOffset (number) - Amount to add to the red channel.
      gOffset (number) - Amount to add to the green channel.
      bOffset (number) - Amount to add to the blue channel.
      aOffset (number) - Amount to add to the alpha channel (optional; defaults to 0).

   Returns:
      Color - A new Color object with adjusted channels.

   Realm:
      Shared

   Example Usage:
      local base   = Color(100, 150, 200, 255)
      local lighter = lia.color.Adjust(base, 20, 20, 20, 0)
]]
function lia.color.Adjust(color, rOffset, gOffset, bOffset, aOffset)
   return Color(clamp(color.r + rOffset, 0, 255), clamp(color.g + gOffset, 0, 255), clamp(color.b + bOffset, 0, 255), clamp((color.a or 255) + (aOffset or 0), 0, 255))
end

--[[
   lia.color.ReturnMainAdjustedColors

   Description:
      Retrieves the base UI color from configuration and returns a table of
      standardized interface colors with predefined adjustments.

   Parameters:
      None

   Returns:
      table - A mapping of UI element keys to Color objects:
         background, sidebar, accent, text, hover, border, highlight

   Realm:
      Shared

   Example Usage:
      local uiColors = lia.color.ReturnMainAdjustedColors()
      panel:SetBackgroundColor(uiColors.background)
]]
function lia.color.ReturnMainAdjustedColors()
   local base = configGet("Color")
   return {
      background = lia.color.Adjust(base, -20, -10, -50, 0),
      sidebar = lia.color.Adjust(base, -30, -15, -60, -55),
      accent = base,
      text = Color(245, 245, 220, 255),
      hover = lia.color.Adjust(base, -40, -25, -70, -35),
      border = Color(255, 255, 255, 255),
      highlight = Color(255, 255, 255, 30)
   }
end

lia.color.register("black", {0, 0, 0})
lia.color.register("white", {255, 255, 255})
lia.color.register("gray", {128, 128, 128})
lia.color.register("dark_gray", {64, 64, 64})
lia.color.register("light_gray", {192, 192, 192})
lia.color.register("red", {255, 0, 0})
lia.color.register("dark_red", {139, 0, 0})
lia.color.register("light_red", {255, 99, 71})
lia.color.register("green", {0, 255, 0})
lia.color.register("dark_green", {0, 100, 0})
lia.color.register("light_green", {144, 238, 144})
lia.color.register("blue", {0, 0, 255})
lia.color.register("dark_blue", {0, 0, 139})
lia.color.register("light_blue", {173, 216, 230})
lia.color.register("cyan", {0, 255, 255})
lia.color.register("dark_cyan", {0, 139, 139})
lia.color.register("magenta", {255, 0, 255})
lia.color.register("dark_magenta", {139, 0, 139})
lia.color.register("yellow", {255, 255, 0})
lia.color.register("dark_yellow", {139, 139, 0})
lia.color.register("orange", {255, 165, 0})
lia.color.register("dark_orange", {255, 140, 0})
lia.color.register("purple", {128, 0, 128})
lia.color.register("dark_purple", {75, 0, 130})
lia.color.register("pink", {255, 192, 203})
lia.color.register("dark_pink", {199, 21, 133})
lia.color.register("brown", {165, 42, 42})
lia.color.register("dark_brown", {139, 69, 19})
lia.color.register("maroon", {128, 0, 0})
lia.color.register("dark_maroon", {139, 28, 98})
lia.color.register("navy", {0, 0, 128})
lia.color.register("dark_navy", {0, 0, 139})
lia.color.register("olive", {128, 128, 0})
lia.color.register("dark_olive", {85, 107, 47})
lia.color.register("teal", {0, 128, 128})
lia.color.register("dark_teal", {0, 105, 105})
lia.color.register("peach", {255, 218, 185})
lia.color.register("dark_peach", {255, 218, 185})
lia.color.register("lavender", {230, 230, 250})
lia.color.register("dark_lavender", {148, 0, 211})
lia.color.register("aqua", {0, 255, 255})
lia.color.register("dark_aqua", {0, 206, 209})
lia.color.register("beige", {245, 245, 220})
lia.color.register("dark_beige", {139, 131, 120})
lia.color.register("aquamarine", {127, 255, 212})
lia.color.register("bisque", {255, 228, 196})
lia.color.register("blanched_almond", {255, 235, 205})
lia.color.register("blue_violet", {138, 43, 226})
lia.color.register("burlywood", {222, 184, 135})
lia.color.register("cadet_blue", {95, 158, 160})
lia.color.register("chartreuse", {127, 255, 0})
lia.color.register("chocolate", {210, 105, 30})
lia.color.register("coral", {255, 127, 80})
lia.color.register("cornflower_blue", {100, 149, 237})
lia.color.register("cornsilk", {255, 248, 220})
lia.color.register("crimson", {220, 20, 60})
lia.color.register("dark_goldenrod", {184, 134, 11})
lia.color.register("dark_khaki", {189, 183, 107})
lia.color.register("dark_orchid", {153, 50, 204})
lia.color.register("dark_salmon", {233, 150, 122})
lia.color.register("deep_pink", {255, 20, 147})
lia.color.register("deep_sky_blue", {0, 191, 255})
lia.color.register("dodger_blue", {30, 144, 255})
lia.color.register("fire_brick", {178, 34, 34})
lia.color.register("forest_green", {34, 139, 34})
lia.color.register("gainsboro", {220, 220, 220})
lia.color.register("ghost_white", {248, 248, 255})
lia.color.register("gold", {255, 215, 0})
lia.color.register("goldenrod", {218, 165, 32})
lia.color.register("green_yellow", {173, 255, 47})
lia.color.register("hot_pink", {255, 105, 180})
lia.color.register("indian_red", {205, 92, 92})
lia.color.register("indigo", {75, 0, 130})
lia.color.register("ivory", {255, 255, 240})
lia.color.register("khaki", {240, 230, 140})
lia.color.register("lavender_blush", {255, 240, 245})
lia.color.register("lawn_green", {124, 252, 0})
lia.color.register("lemon_chiffon", {255, 250, 205})
lia.color.register("light_coral", {240, 128, 128})
lia.color.register("light_goldenrod_yellow", {250, 250, 210})
lia.color.register("light_pink", {255, 182, 193})
lia.color.register("light_sea_green", {32, 178, 170})
lia.color.register("light_sky_blue", {135, 206, 250})
lia.color.register("light_slate_gray", {119, 136, 153})
lia.color.register("light_steel_blue", {176, 196, 222})
lia.color.register("lime", {0, 255, 0})
lia.color.register("lime_green", {50, 205, 50})
lia.color.register("linen", {250, 240, 230})
lia.color.register("medium_aquamarine", {102, 205, 170})
lia.color.register("medium_blue", {0, 0, 205})
lia.color.register("medium_orchid", {186, 85, 211})
lia.color.register("medium_purple", {147, 112, 219})
lia.color.register("medium_sea_green", {60, 179, 113})
lia.color.register("medium_slate_blue", {123, 104, 238})
lia.color.register("medium_spring_green", {0, 250, 154})
lia.color.register("medium_turquoise", {72, 209, 204})
lia.color.register("medium_violet_red", {199, 21, 133})
lia.color.register("midnight_blue", {25, 25, 112})
lia.color.register("mint_cream", {245, 255, 250})
lia.color.register("misty_rose", {255, 228, 225})
lia.color.register("moccasin", {255, 228, 181})
lia.color.register("navajo_white", {255, 222, 173})
lia.color.register("old_lace", {253, 245, 230})
lia.color.register("olive_drab", {107, 142, 35})
lia.color.register("orange_red", {255, 69, 0})
lia.color.register("orchid", {218, 112, 214})
lia.color.register("pale_goldenrod", {238, 232, 170})
lia.color.register("pale_green", {152, 251, 152})
lia.color.register("pale_turquoise", {175, 238, 238})
lia.color.register("pale_violet_red", {219, 112, 147})
lia.color.register("papaya_whip", {255, 239, 213})
lia.color.register("peach_puff", {255, 218, 185})
lia.color.register("peru", {205, 133, 63})
lia.color.register("plum", {221, 160, 221})
lia.color.register("powder_blue", {176, 224, 230})
lia.color.register("rosy_brown", {188, 143, 143})
lia.color.register("royal_blue", {65, 105, 225})
lia.color.register("saddle_brown", {139, 69, 19})
lia.color.register("salmon", {250, 128, 114})
lia.color.register("sandy_brown", {244, 164, 96})
lia.color.register("sea_green", {46, 139, 87})
lia.color.register("sea_shell", {255, 245, 238})
lia.color.register("sienna", {160, 82, 45})
lia.color.register("sky_blue", {135, 206, 235})
lia.color.register("slate_blue", {106, 90, 205})
lia.color.register("slate_gray", {112, 128, 144})
lia.color.register("snow", {255, 250, 250})
lia.color.register("spring_green", {0, 255, 127})
lia.color.register("steel_blue", {70, 130, 180})
lia.color.register("tan", {210, 180, 140})
lia.color.register("thistle", {216, 191, 216})
lia.color.register("tomato", {255, 99, 71})
lia.color.register("turquoise", {64, 224, 208})
lia.color.register("violet", {238, 130, 238})
lia.color.register("wheat", {245, 222, 179})
lia.color.register("white_smoke", {245, 245, 245})
lia.color.register("yellow_green", {154, 205, 50})
local oldColor = Color
function Color(r, g, b, a)
   if isstring(r) then
      local c = lia.color.stored[r:lower()]
      if c then return oldColor(unpack(c), g or 255) end
      return oldColor(255, 255, 255, 255)
   end
   return oldColor(r, g, b, a)
end

-- ./gamemode/core/libraries/commands.lua
lia.command = lia.command or {}
lia.command.list = lia.command.list or {}
--[[
   lia.command.add

   Description:
      Registers a new command with the specified name and configuration data.
      This includes callback functions, privilege requirements, aliases, etc.

   Parameters:
      command (string) - The name of the command to register.
      data (table) - A table containing configuration for the command (onRun, adminOnly, etc.).

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.command.add("mycommand", {
         onRun = function(client, arguments)
            -- Do something here
         end,
         adminOnly = true
      })
]]
function lia.command.add(command, data)
    data.syntax = data.syntax or ""
    data.desc = data.desc or ""
    local superAdminOnly = data.superAdminOnly
    local adminOnly = data.adminOnly
    if not data.onRun then
        ErrorNoHalt("Command '" .. command .. "' does not have a callback, not adding!\n")
        return
    end

    if data.group then
        ErrorNoHalt("Command '" .. (data.name or command) .. "' tried to use the deprecated field 'group'!\n")
        return
    end

    if superAdminOnly or adminOnly then
        local privilegeName = "Commands - " .. (isstring(data.privilege) and data.privilege or command)
        if not CAMI.GetPrivilege(privilegeName) then
            CAMI.RegisterPrivilege({
                Name = privilegeName,
                MinAccess = superAdminOnly and "superadmin" or "admin",
                Description = data.description
            })
        end
    end

    local onRun = data.onRun
    data._onRun = data.onRun
    data.onRun = function(client, arguments)
        local hasAccess, _ = lia.command.hasAccess(client, command, data)
        if hasAccess then
            return onRun(client, arguments)
        else
            return "noPerm"
        end
    end

    local alias = data.alias
    if alias then
        if istable(alias) then
            for _, v in ipairs(alias) do
                lia.command.list[v:lower()] = data
            end
        elseif isstring(alias) then
            lia.command.list[alias:lower()] = data
        end
    end

    if command == command:lower() then
        lia.command.list[command] = data
    else
        data.realCommand = command
        lia.command.list[command:lower()] = data
    end
end

--[[
   lia.command.hasAccess

   Description:
      Checks if the specified player has access to a given command based on
      privilege checks, superadmin/admin requirements, and any additional hooks.

   Parameters:
      client (Player) - The player attempting to use the command.
      command (string) - The command name.
      data (table) - The command's data table (optional if already stored).

   Returns:
      (boolean) - Whether the player has access.
      (string) - The privilege name used for checking.

   Realm:
      Shared

   Example Usage:
      local canUse, privilege = lia.command.hasAccess(client, "mycommand")
      if canUse then
         print("Player has access to command:", privilege)
      end
]]
function lia.command.hasAccess(client, command, data)
    if not data then data = lia.command.list[command] end
    local privilege = data.privilege
    local superAdminOnly = data.superAdminOnly
    local adminOnly = data.adminOnly
    local accessLevels = superAdminOnly and "superadmin" or adminOnly and "admin" or "user"
    if not privilege then privilege = accessLevels == "user" and "Global" or command end
    local hasAccess = true
    if accessLevels ~= "user" then
        local privilegeName = "Commands - " .. privilege
        hasAccess = client:hasPrivilege(privilegeName)
    end

    if hook.Run("CanPlayerUseCommand", client, command) == false then hasAccess = false end
    return hasAccess, privilege
end

--[[
   lia.command.extractArgs

   Description:
      Splits the provided text into arguments, respecting quotes.
      Quoted sections are treated as single arguments.

   Parameters:
      text (string) - The raw input text to parse.

   Returns:
      table - A list of arguments extracted from the text.

   Realm:
      Shared

   Example Usage:
      local args = lia.command.extractArgs('/mycommand "quoted arg" anotherArg')
      -- args = {"quoted arg", "anotherArg"}
]]
function lia.command.extractArgs(text)
    local skip = 0
    local arguments = {}
    local curString = ""
    for i = 1, #text do
        if i <= skip then continue end
        local c = text:sub(i, i)
        if c == "\"" then
            local match = text:sub(i):match("%b" .. c .. c)
            if match then
                curString = ""
                skip = i + #match
                arguments[#arguments + 1] = match:sub(2, -2)
            else
                curString = curString .. c
            end
        elseif c == " " and curString ~= "" then
            arguments[#arguments + 1] = curString
            curString = ""
        else
            if c == " " and curString == "" then continue end
            curString = curString .. c
        end
    end

    if curString ~= "" then arguments[#arguments + 1] = curString end
    return arguments
end

if SERVER then
    --[[
      lia.command.run

      Description:
         Executes a command by its name, passing the provided arguments.
         If the command returns a string, it notifies the client (if valid).

      Parameters:
         client (Player) - The player or console running the command.
         command (string) - The name of the command to run.
         arguments (table) - A list of arguments for the command.

      Returns:
         nil

      Realm:
         Server

      Example Usage:
         lia.command.run(player, "mycommand", {"arg1", "arg2"})
   ]]
    function lia.command.run(client, command, arguments)
        local commandTbl = lia.command.list[command:lower()]
        if commandTbl then
            local results = {commandTbl.onRun(client, arguments or {})}
            local result = results[1]
            if isstring(result) then
                if IsValid(client) then
                    if result:sub(1, 1) == "@" then
                        client:notifyLocalized(result:sub(2), unpack(results, 2))
                    else
                        client:notify(result)
                    end
                else
                    print(result)
                end
            end
        end
    end

    --[[
      lia.command.parse

      Description:
         Attempts to parse the input text as a command, optionally using realCommand
         and arguments if provided. If parsed successfully, the command is executed.

      Parameters:
         client (Player) - The player or console issuing the command.
         text (string) - The raw text that may contain the command name and arguments.
         realCommand (string) - If provided, use this as the command name instead of parsing text.
         arguments (table) - If provided, use these as the command arguments instead of parsing text.

      Returns:
         boolean - True if the text was parsed as a valid command, false otherwise.

      Realm:
         Server

      Example Usage:
         lia.command.parse(player, "/mycommand arg1 arg2")
   ]]
    function lia.command.parse(client, text, realCommand, arguments)
        if realCommand or utf8.sub(text, 1, 1) == "/" then
            local match = realCommand or text:lower():match("/" .. "([_%w]+)")
            if not match then
                local post = string.Explode(" ", text)
                local len = string.len(post[1])
                match = utf8.sub(post[1], 2, len)
            end

            match = match:lower()
            local command = lia.command.list[match]
            if command then
                if not arguments then arguments = lia.command.extractArgs(text:sub(#match + 3)) end
                lia.command.run(client, match, arguments)
                if not realCommand then lia.log.add(client, "command", text) end
            else
                if IsValid(client) then
                    client:notifyLocalized("cmdNoExist")
                else
                    lia.information("Sorry, that command does not exist.")
                end
            end
            return true
        end
        return false
    end
else
    --[[
      lia.command.send

      Description:
         Sends a command (and optional arguments) from the client to the server using netstream.
         The server will then execute the command.

      Parameters:
         command (string) - The name of the command to send.
         ... (vararg) - Any additional arguments to pass to the command.

      Returns:
         nil

      Realm:
         Client

      Example Usage:
         lia.command.send("mycommand", "arg1", "arg2")
   ]]
    function lia.command.send(command, ...)
        netstream.Start("cmd", command, {...})
    end
end

hook.Add("CreateInformationButtons", "CreateInformationMenuCommands", function(pages)
    local client = LocalPlayer()
    table.insert(pages, {
        name = L("commands"),
        drawFunc = function(panel)
            local searchEntry = vgui.Create("DTextEntry", panel)
            searchEntry:Dock(TOP)
            searchEntry:SetTall(30)
            searchEntry:SetPlaceholderText(L("searchCommands"))
            local scroll = vgui.Create("DScrollPanel", panel)
            scroll:Dock(FILL)
            local iconLayout = vgui.Create("DIconLayout", scroll)
            iconLayout:Dock(FILL)
            iconLayout:SetSpaceY(5)
            iconLayout:SetSpaceX(5)
            iconLayout.PerformLayout = function(self)
                local y = 0
                local w = self:GetWide()
                for _, child in ipairs(self:GetChildren()) do
                    child:SetPos((w - child:GetWide()) / 2, y)
                    y = y + child:GetTall() + self:GetSpaceY()
                end

                self:SetTall(y)
            end

            local function refresh()
                iconLayout:Clear()
                local filter = searchEntry:GetValue():lower()
                for cmdName, cmdData in SortedPairs(lia.command.list) do
                    if isnumber(cmdName) then continue end
                    local nameLower = cmdName:lower()
                    local descLower = (cmdData.desc or ""):lower()
                    if filter ~= "" and not (nameLower:find(filter) or descLower:find(filter)) then continue end
                    local hasAccess, privilege = lia.command.hasAccess(client, cmdName, cmdData)
                    if not hasAccess then continue end
                    local hasDesc = cmdData.desc and cmdData.desc ~= ""
                    local height = hasDesc and 80 or 40
                    local commandPanel = vgui.Create("DPanel", iconLayout)
                    commandPanel:SetSize(panel:GetWide(), height)
                    commandPanel.Paint = function(_, w, h)
                        draw.RoundedBox(4, 0, 0, w, h, Color(40, 40, 40, 200))
                        local baseX = 20
                        local text = "/" .. cmdName
                        local syntax = cmdData.syntax or ""
                        if syntax ~= "" then text = text .. " " .. syntax end
                        if hasDesc then
                            draw.SimpleText(text, "liaMediumFont", baseX, 5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
                            draw.SimpleText(cmdData.desc, "liaSmallFont", baseX, 45, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
                            draw.SimpleText(privilege or L("none"), "liaSmallFont", w - 20, 45, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
                        else
                            draw.SimpleText(text, "liaMediumFont", baseX, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                            draw.SimpleText(privilege or L("none"), "liaSmallFont", w - 20, h / 2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
                        end
                    end
                end

                iconLayout:InvalidateLayout(true)
            end

            searchEntry.OnTextChanged = function() refresh() end
            refresh()
        end
    })
end)

lia.command.findPlayer = lia.util.findPlayer

-- ./gamemode/core/libraries/compatibility/pac.lua
local playerMeta = FindMetaTable("Entity")
function playerMeta:getParts()
    return self:getNetVar("parts", {})
end

if SERVER then
    function playerMeta:syncParts()
        net.Start("liaPACSync")
        net.Send(self)
    end

    function playerMeta:addPart(partID)
        if self:getParts()[partID] then return end
        net.Start("liaPACPartAdd")
        net.WriteEntity(self)
        net.WriteString(partID)
        net.Broadcast()
        local parts = self:getParts()
        parts[partID] = true
        self:setNetVar("parts", parts)
    end

    function playerMeta:removePart(partID)
        net.Start("liaPACPartRemove")
        net.WriteEntity(self)
        net.WriteString(partID)
        net.Broadcast()
        local parts = self:getParts()
        parts[partID] = nil
        self:setNetVar("parts", parts)
    end

    function playerMeta:resetParts()
        net.Start("liaPACPartReset")
        net.WriteEntity(self)
        net.Broadcast()
        self:setNetVar("parts", {})
    end

    hook.Add("PostPlayerInitialSpawn", "PAC_HOOKID", function(client) timer.Simple(1, function() client:syncParts() end) end)
    hook.Add("PlayerLoadout", "PAC_HOOKID", function(client) client:resetParts() end)
    hook.Add("ModuleLoaded", "PAC_HOOKID", function() game.ConsoleCommand("sv_pac_webcontent_limit 35840\n") end)
else
    local partData = {}
    hook.Add("AdjustPACPartData", "PAC_HOOKID", function(wearer, id, data)
        local item = lia.item.list[id]
        if item and isfunction(item.pacAdjust) then
            local result = item:pacAdjust(data, wearer)
            if result ~= nil then return result end
        end
    end)

    hook.Add("getAdjustedPartData", "PAC_HOOKID", function(wearer, id)
        if not partData[id] then return end
        local data = table.Copy(partData[id])
        return hook.Run("AdjustPACPartData", wearer, id, data) or data
    end)

    hook.Add("attachPart", "PAC_HOOKID", function(client, id)
        if not pac then return end
        local part = hook.Run("getAdjustedPartData", client, id)
        if not part then return end
        if not client.AttachPACPart then pac.SetupENT(client) end
        client:AttachPACPart(part, client)
        client.liaPACParts = client.liaPACParts or {}
        client.liaPACParts[id] = part
    end)

    hook.Add("removePart", "PAC_HOOKID", function(client, id)
        if not client.RemovePACPart or not client.liaPACParts then return end
        local part = client.liaPACParts[id]
        if part then
            client:RemovePACPart(part)
            client.liaPACParts[id] = nil
        end
    end)

    hook.Add("DrawPlayerRagdoll", "PAC_HOOKID", function(entity)
        local client = entity.objCache
        if IsValid(client) and not entity.overridePAC3 then
            if client.pac_outfits then
                for _, part in pairs(client.pac_outfits) do
                    if IsValid(part.last_owner) then
                        hook.Run("OnPAC3PartTransfered", part)
                        part:SetOwner(entity)
                        part.last_owner = entity
                    end
                end
            end

            client.pac_playerspawn = pac.RealTime
            entity.overridePAC3 = true
        end
    end)

    hook.Add("OnEntityCreated", "PAC_HOOKID", function(entity)
        local class = entity:GetClass()
        timer.Simple(0, function()
            if class == "prop_ragdoll" and entity:getNetVar("player") then
                entity.RenderOverride = function()
                    entity.objCache = entity:getNetVar("player")
                    entity:DrawModel()
                    hook.Run("DrawPlayerRagdoll", entity)
                end
            end

            if class:find("HL2MPRagdoll") then
                for _, v in player.Iterator() do
                    if v:GetRagdollEntity() == entity then entity.objCache = v end
                end

                entity.RenderOverride = function()
                    entity:DrawModel()
                    hook.Run("DrawPlayerRagdoll", entity)
                end
            end
        end)
    end)

    hook.Add("OnPlayerObserve", "PAC_HOOKID", function(client, state)
        local curParts = client:getParts()
        if curParts then client:resetParts() end
        if not state then
            local character = client:getChar()
            local inventory = character:getInv()
            for _, v in pairs(inventory:getItems()) do
                if v:getData("equip", false) and v.pacData then client:addPart(v.uniqueID) end
            end
        end
    end)

    hook.Add("PAC3RegisterEvents", "PAC_HOOKID", function()
        local events = {
            {
                name = "weapon_raised",
                args = {},
                available = function() return playerMeta.isWepRaised ~= nil end,
                func = function(_, _, entity)
                    entity = hook.Run("TryViewModel", entity)
                    return entity.isWepRaised and entity:isWepRaised() or false
                end
            }
        }

        for _, v in ipairs(events) do
            local eventObject = pac.CreateEvent(v.name, v.args)
            eventObject.Think = v.func
            function eventObject:IsAvailable()
                return v.available()
            end

            pac.RegisterEvent(eventObject)
        end
    end)

    hook.Add("TryViewModel", "PAC_HOOKID", function(entity) return entity == pac.LocalPlayer:GetViewModel() and pac.LocalPlayer or entity end)
    hook.Add("InitializedModules", "PAC_HOOKID", function()
        hook.Remove("HUDPaint", "pac_in_editor")
        timer.Simple(1, function() hook.Run("setupPACDataFromItems") end)
        if lia.config.get("BlockPackURLoad") then concommand.Remove("pac_load_url") end
    end)
end

net.Receive("liaPACSync", function()
    for _, client in player.Iterator() do
        for id in pairs(client:getParts()) do
            hook.Run("attachPart", client, id)
        end
    end
end)

net.Receive("liaPACPartAdd", function()
    local client = net.ReadEntity()
    local id = net.ReadString()
    if not IsValid(client) then return end
    hook.Run("attachPart", client, id)
end)

net.Receive("liaPACPartRemove", function()
    local client = net.ReadEntity()
    local id = net.ReadString()
    if not IsValid(client) then return end
    hook.Run("removePart", client, id)
end)

net.Receive("liaPACPartReset", function()
    local client = net.ReadEntity()
    if not IsValid(client) or not client.RemovePACPart then return end
    if client.liaPACParts then
        for _, part in pairs(client.liaPACParts) do
            client:RemovePACPart(part)
        end

        client.liaPACParts = nil
    end
end)

lia.command.add("fixpac", {
    adminOnly = false,
    desc = L("pacFixCommandDesc"),
    onRun = function(client)
        timer.Simple(0, function() if IsValid(client) then client:ConCommand("pac_clear_parts") end end)
        timer.Simple(0.5, function()
            if IsValid(client) then
                client:ConCommand("pac_urlobj_clear_cache")
                client:ConCommand("pac_urltex_clear_cache")
            end
        end)

        timer.Simple(1, function() if IsValid(client) then client:ConCommand("pac_restart") end end)
        timer.Simple(1.5, function() if IsValid(client) then client:notifyLocalized("fixpac_success") end end)
    end
})

lia.command.add("pacenable", {
    adminOnly = false,
    desc = L("pacEnableCommandDesc"),
    onRun = function(client)
        client:ConCommand("pac_enable 1")
        client:notifyLocalized("pacenable_success")
    end
})

lia.command.add("pacdisable", {
    adminOnly = false,
    desc = L("pacDisableCommandDesc"),
    onRun = function(client)
        client:ConCommand("pac_enable 0")
        client:notifyLocalized("pacdisable_message")
    end
})

lia.config.add("BlockPackURLoad", "Block Pack URL Load", true, nil, {
    desc = "Determines whether loading PAC3 packs from a URL should be blocked.",
    category = "PAC3",
    noNetworking = false,
    schemaOnly = false,
    type = "Boolean"
})

CAMI.RegisterPrivilege({
    Name = "Staff Permissions - Can Use PAC3",
    MinAccess = "admin",
    Description = "Allows access to PAC3"
})

lia.flag.add("P", "Access to PAC3.")

-- ./gamemode/core/libraries/compatibility/prone.lua
hook.Add("DoPlayerDeath", "PRONE_DoPlayerDeath", function(client) if client:IsProne() then prone.Exit(client) end end)
hook.Add("PlayerLoadedChar", "PRONE_PlayerLoadedChar", function(client) if client:IsProne() then prone.Exit(client) end end)

-- ./gamemode/core/libraries/compatibility/sam.lua
hook.Add("InitializedModules", "SAM_InitializedModules", function()
    for _, commandInfo in ipairs(sam.command.get_commands()) do
        local customSyntax = ""
        for _, argInfo in ipairs(commandInfo.args) do
            customSyntax = customSyntax == "" and "[" or customSyntax .. " ["
            customSyntax = customSyntax .. (argInfo.default and tostring(type(argInfo.default)) or "string") .. " "
            customSyntax = customSyntax .. argInfo.name .. "]"
        end

        if lia.command.list[commandInfo.name] then continue end
        lia.command.add(commandInfo.name, {
            desc = commandInfo.help,
            adminOnly = commandInfo.default_rank == "admin",
            superAdminOnly = commandInfo.default_rank == "superadmin",
            syntax = customSyntax,
            onRun = function(_, arguments) RunConsoleCommand("sam", commandInfo.name, unpack(arguments)) end
        })
    end
end)

hook.Add("SAM.CanRunCommand", "Check4Staff", function(client, _, _, cmd)
    if type(client) ~= "Player" then return true end
    if lia.config.get("SAMEnforceStaff", false) then
        if cmd.permission and not client:HasPermission(cmd.permission) then
            client:notifyLocalized("staffPermissionDenied")
            return false
        end

        if client:hasPrivilege(client, "Staff Permissions - Can Bypass Staff Faction SAM Command whitelist", nil) or client:isStaffOnDuty() then
            return true
        else
            client:notifyLocalized("staffRestrictedCommand")
            return false
        end
    end
end)

if SERVER then
    sam.command.new("blind"):SetPermission("blind", "superadmin"):AddArg("player"):Help("Blinds the Players"):OnExecute(function(client, targets)
        for i = 1, #targets do
            local target = targets[i]
            net.Start("sam_blind")
            net.WriteBool(true)
            net.Send(target)
        end

        if not sam.is_command_silent then
            client:sam_send_message("{A} Blinded {T}", {
                A = client,
                T = targets
            })
        end
    end):End()

    sam.command.new("unblind"):SetPermission("blind", "superadmin"):AddArg("player"):Help("Unblinds the Players"):OnExecute(function(client, targets)
        for i = 1, #targets do
            local target = targets[i]
            net.Start("sam_blind")
            net.WriteBool(false)
            net.Send(target)
        end

        if not sam.is_command_silent then
            client:sam_send_message("{A} Un-Blinded {T}", {
                A = client,
                T = targets
            })
        end
    end):End()

    hook.Add("InitializedModules", "SAM_InitializedModules", function() hook.Remove("PlayerSay", "SAM.Chat.Asay") end)
else
    net.Receive("sam_blind", function()
        local enabled = net.ReadBool()
        if enabled then
            hook.Add("HUDPaint", "sam_blind", function() draw.RoundedBox(0, 0, 0, ScrW(), ScrH(), Color(0, 0, 0, 255)) end)
        else
            hook.Remove("HUDPaint", "sam_blind")
        end
    end)
end

local function CanReadNotifications(client)
    if not lia.config.get("DisplayStaffCommands") then return false end
    if not lia.config.get("AdminOnlyNotification") then return true end
    return client:hasPrivilege("Staff Permissions - Can See SAM Notifications") or client:isStaffOnDuty()
end

function sam.player.send_message(client, msg, tbl)
    if SERVER then
        if sam.isconsole(client) then
            local result = sam.format_message(msg, tbl)
            sam.print(unpack(result, 1, result.__cnt))
        elseif client then
            return sam.netstream.Start(client, "send_message", msg, tbl)
        end
    else
        if client and CanReadNotifications(client) then
            local prefix_result = sam.format_message(sam.config.get("ChatPrefix", ""))
            local prefix_n = #prefix_result
            local result = sam.format_message(msg, tbl, prefix_result, prefix_n)
            chat.AddText(unpack(result, 1, result.__cnt))
        end
    end
end

lia.command.add("cleardecals", {
    adminOnly = true,
    privilege = "Clear Decals",
    desc = L("cleardecalsDesc"),
    onRun = function()
        for _, v in player.Iterator() do
            v:ConCommand("r_cleardecals")
        end
    end
})

lia.command.add("playtime", {
    adminOnly = false,
    privilege = "View Own Playtime",
    desc = L("playtimeDesc"),
    onRun = function(client)
        local steamID = client:SteamID64()
        local result = sql.QueryRow("SELECT play_time FROM sam_players WHERE steamid = " .. SQLStr(steamID) .. ";")
        if result then
            local secs = tonumber(result.play_time) or 0
            local h = math.floor(secs / 3600)
            local m = math.floor((secs % 3600) / 60)
            local s = secs % 60
            client:ChatPrint(L("playtimeYour", h, m, s))
        else
            client:ChatPrint(L("playtimeError"))
        end
    end
})

lia.command.add("plygetplaytime", {
    adminOnly = true,
    privilege = "View Playtime",
    syntax = "[string charname]",
    AdminStick = {
        Name = L("adminStickGetPlayTimeName"),
        Category = L("displayStaffCommandsDesc"),
        SubCategory = L("misc"),
        Icon = "icon16/time.png"
    },
    desc = L("plygetplaytimeDesc"),
    onRun = function(client, args)
        if not args[1] then
            client:notifyLocalized("specifyPlayer")
            return
        end

        local target = lia.util.findPlayer(client, args[1])
        if not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local secs = target:sam_get_play_time()
        local h = math.floor(secs / 3600)
        local m = math.floor((secs % 3600) / 60)
        local s = secs % 60
        client:ChatPrint(L("playtimeFor", target:Nick(), h, m, s))
    end
})

CAMI.RegisterPrivilege({
    Name = "Staff Permissions - Can See SAM Notifications Outside Staff Character",
    MinAccess = "superadmin",
    Description = "Allows access to Seeing SAM Notifications Outside Staff Character."
})

CAMI.RegisterPrivilege({
    Name = "Staff Permissions - Can Bypass Staff Faction SAM Command whitelist",
    MinAccess = "superadmin",
    Description = "Allows staff to bypass the SAM command whitelist for the Staff Faction."
})

lia.config.add("DisplayStaffCommands", "Display Staff Commands", true, nil, {
    desc = "Controls whether notifications and commands for staff are displayed.",
    category = "Staff",
    type = "Boolean"
})

lia.config.add("AdminOnlyNotification", "Admin Only Notifications", true, nil, {
    desc = "Restricts certain notifications to admins with specific permissions or those on duty.",
    category = "Staff",
    type = "Boolean"
})

lia.config.add("SAMEnforceStaff", "Enforce Staff Rank To SAM", true, nil, {
    desc = "Determines whether staff enforcement for SAM commands is enabled",
    category = "Staff",
    type = "Boolean"
})

-- ./gamemode/core/libraries/compatibility/serverguard.lua
serverguard.plugin:Toggle("restrictions", false)

-- ./gamemode/core/libraries/compatibility/simfphys.lua
if SERVER then
    hook.Add("EntityTakeDamage", "SIMFPHYS_EntityTakeDamage", function(seat, dmgInfo)
        if seat:IsVehicle() and seat:GetClass() == "gmod_sent_vehicle_fphysics_base" then
            local player = seat:GetDriver()
            if IsValid(player) then
                local hitPos = dmgInfo:GetDamagePosition()
                local playerPos = player:GetPos()
                local thresholdDistance = 53
                if hitPos:Distance(playerPos) <= thresholdDistance then
                    local newHealth = player:Health() - dmgInfo:GetDamage() * 0.3
                    if newHealth > 0 then
                        player:SetHealth(newHealth)
                    else
                        player:Kill()
                    end
                end
            end
        end
    end)

    hook.Add("simfphysUse", "SIMFPHYS_simfphysUse", function(entity, client)
        if entity.IsBeingEntered then
            client:notifyLocalized("carOccupiedNotice")
            return true
        end

        local delay = lia.config.get("TimeToEnterVehicle", 5)
        if entity:isSimfphysCar() and delay > 0 then
            entity.IsBeingEntered = true
            client:setAction(L("enteringVehicle"), delay)
            client:doStaredAction(entity, function()
                if IsValid(entity) then
                    entity.IsBeingEntered = false
                    entity:SetPassenger(client)
                end
            end, delay, function()
                if IsValid(entity) then entity.IsBeingEntered = false end
                if IsValid(client) then client:stopAction() end
            end)
        end
        return true
    end)
else
    hook.Remove("HUDPaint", "simfphys_HUD")
end

hook.Add("simfphysPhysicsCollide", "SIMFPHYS_simfphysPhysicsCollide", function() return true end)
lia.config.add("DamageInCars", "Take Damage in Cars", true, nil, {
    desc = "Whether or not you take damage while in cars",
    category = "Simfphys",
    type = "Boolean"
})

lia.config.add("CarEntryDelayEnabled", "Take Damage in Cars", true, nil, {
    desc = "Whether or not you take damage while in cars",
    category = "Simfphys",
    type = "Boolean"
})

lia.config.add("TimeToEnterVehicle", "Inventory Height", 4, nil, {
    desc = "Defines the height of the default inventory.",
    category = "Simfphys",
    type = "Int",
    min = 1,
    max = 20
})

CAMI.RegisterPrivilege({
    Name = "Staff Permissions - Can Edit Simfphys Cars",
    MinAccess = "superadmin",
    Description = "Allows access to Editting Simfphys Cars"
})

hook.Add("CanProperty", "SIMFPHYS_HOOKID", function(client, property, ent) if property == "editentity" and ent:isSimfphysCar() then return client:hasPrivilege("Staff Permissions - Can Edit Simfphys Cars") end end)
hook.Add("IsSuitableForTrunk", "SIMFPHYS_HOOKID", function(vehicle) if IsValid(vehicle) and vehicle:isSimfphysCar() then return true end end)
hook.Add("CheckValidSit", "SIMFPHYS_HOOKID", function(client)
    local vehicle = client:getTracedEntity()
    if IsValid(vehicle) and vehicle:isSimfphysCar() then return false end
end)

-- ./gamemode/core/libraries/compatibility/sitanywhere.lua
local commands = {{"sitting_can_sit_on_players", "1"}, {"sitting_can_sit_on_player_ent", "1"}, {"sitting_can_damage_players_sitting", "1"}, {"sitting_allow_weapons_in_seat", "0"}, {"sitting_admin_only", "0"}, {"sitting_anti_prop_surf", "1"}, {"sitting_anti_tool_abuse", "1"}}
hook.Add("InitializedModules", "SITANYWHERE_InitializedModules", function()
    for _, cmd in ipairs(commands) do
        RunConsoleCommand(cmd[1], cmd[2])
    end
end)

hook.Add("CheckValidSit", "SITANYWHERE_CheckValidSit", function(client)
    local entity = client:getTracedEntity()
    if entity:IsVehicle() or entity:IsPlayer() then return false end
end)

-- ./gamemode/core/libraries/compatibility/vcmod.lua
hook.Add("VC_canAfford", "VCMOD_VC_canAfford", function(client, amount)
    if client:getChar():hasMoney(amount) then return true end
    return false
end)

if SERVER then
    hook.Add("VC_canAddMoney", "VCMOD_VC_canAfford", function(client, amount)
        client:getChar():giveMoney(amount)
        return false
    end)

    hook.Add("VC_canRemoveMoney", "VCMOD_VC_canAfford", function(client, amount)
        client:getChar():takeMoney(amount)
        return false
    end)
end

-- ./gamemode/core/libraries/compatibility/vjbase.lua
local exploitable_nets = {"VJSay", "vj_fireplace_turnon1", "vj_npcmover_sv_create", "vj_npcmover_sv_startmove", "vj_npcmover_removesingle", "vj_npcmover_removeall", "vj_npcspawner_sv_create", "vj_npcrelationship_sr_leftclick", "vj_testentity_runtextsd", "vj_fireplace_turnon2"}
local console_settings = {
    vj_npc_processtime = "1",
    vj_npc_corpsefade = "1",
    vj_npc_corpsefadetime = "5",
    vj_npc_nogib = "1",
    vj_npc_nosnpcchat = "1",
    vj_npc_slowplayer = "1",
    vj_npc_noproppush = "1",
    vj_npc_nothrowgrenade = "1",
    vj_npc_fadegibstime = "5",
    vj_npc_knowenemylocation = "1",
    vj_npc_dropweapon = "0",
    vj_npc_plypickupdropwep = "0"
}

local function handle_exploitable_net(client, name)
    if not IsValid(client) or not client:IsPlayer() then return end
    client:ChatPrint(L("unauthorizedNetMessage", name))
    lia.log.add(client, "unprotectedVJNetCall", {
        netMessage = name
    })
end

for _, name in ipairs(exploitable_nets) do
    net.Receive(name, function(_, client) handle_exploitable_net(client, name) end)
end

timer.Create("vjbase_console_commands", 180, 0, function()
    for cmd, val in pairs(console_settings) do
        RunConsoleCommand(cmd, val)
    end
end)

hook.Add("OnEntityCreated", "vjbase_entity_handler", function(ent)
    timer.Simple(0, function()
        if not IsValid(ent) then return end
        if ent:GetClass() == "obj_vj_spawner_base" then
            SafeRemoveEntity(ent)
        elseif ent:isLiliaPersistent() or ent.noTarget then
            ent:AddFlags(FL_NOTARGET)
        end
    end)
end)

timer.Simple(10, function()
    hook.Remove("PlayerInitialSpawn", "VJBaseSpawn")
    hook.Remove("PlayerInitialSpawn", "drvrejplayerInitialSpawn")
    concommand.Remove("vj_cleanup")
end)

-- ./gamemode/core/libraries/config.lua
lia.config = lia.config or {}
lia.config.stored = lia.config.stored or {}
--[[
   Function: lia.config.add

   Description:
      Registers a new config option with the given key, display name, default value, and optional callback/data.

   Parameters:
      key (string)  The unique key identifying the config.
      name (string)  The display name of the config option.
      value (any)  The default value of this config option.
      callback (function)  A function called when the value changes (optional).
      data (table)  Additional data for this config option, including config type, category, description, etc.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.config.add("myConfigKey", "My Config", true, function(oldVal, newVal) print(oldVal, newVal) end, {desc="Enable or disable something"})
]]
function lia.config.add(key, name, value, callback, data)
    assert(isstring(key), "Expected config key to be string, got " .. type(key))
    assert(istable(data), "Expected config data to be a table, got " .. type(data))
    local t = type(value)
    local configType = t == "boolean" and "Boolean" or t == "number" and (math.floor(value) == value and "Int" or "Float") or t == "table" and value.r and value.g and value.b and "Color" or "Generic"
    data.type = data.type or configType
    local oldConfig = lia.config.stored[key]
    local savedValue = oldConfig and oldConfig.value or value
    local category = data.category
    local desc = data.desc
    lia.config.stored[key] = {
        name = name or key,
        data = data,
        value = savedValue,
        default = value,
        desc = desc,
        category = category or L("character"),
        noNetworking = data.noNetworking or false,
        callback = callback
    }
end

--[[
   Function: lia.config.setDefault

   Description:
      Overrides the default value of an existing config.

   Parameters:
      key (string)  The key identifying the config.
      value (any)  The new default value.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.config.setDefault("myConfigKey", false)
]]
function lia.config.setDefault(key, value)
    local config = lia.config.stored[key]
    if config then config.default = value end
end

--[[
   Function: lia.config.forceSet

   Description:
      Forces a config value without triggering networking or callback if 'noSave' is true, then optionally saves.

   Parameters:
      key (string)  The key identifying the config.
      value (any)  The new value to set.
      noSave (boolean)  If true, does not save to disk.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.config.forceSet("myConfigKey", 42)
]]
function lia.config.forceSet(key, value, noSave)
    local config = lia.config.stored[key]
    if config then config.value = value end
    if not noSave then lia.config.save() end
end

--[[
   Function: lia.config.set

   Description:
      Sets a config value, runs callback, and handles networking (if on server). Also saves the config.

   Parameters:
      key (string)  The key identifying the config.
      value (any)  The new value to set.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.config.set("myConfigKey", 100)
]]
function lia.config.set(key, value)
    local config = lia.config.stored[key]
    if config then
        local oldValue = config.value
        config.value = value
        if SERVER then
            if not config.noNetworking then netstream.Start(nil, "cfgSet", key, value) end
            if config.callback then config.callback(oldValue, value) end
            lia.config.save()
        end
    end
end

--[[
   Function: lia.config.get

   Description:
      Retrieves the current value of a config, or returns a default if neither value nor default is set.

   Parameters:
      key (string)  The key identifying the config.
      default (any)  Fallback value if the config is not found.

   Returns:
      (any) The config's value or the provided default.

   Realm:
      Shared

   Example Usage:
      local val = lia.config.get("myConfigKey", false)
]]
function lia.config.get(key, default)
    local config = lia.config.stored[key]
    if config then
        if config.value ~= nil then
            if istable(config.value) and config.value.r and config.value.g and config.value.b then config.value = Color(config.value.r, config.value.g, config.value.b) end
            return config.value
        elseif config.default ~= nil then
            return config.default
        end
    end
    return default
end

--[[
   Function: lia.config.load

   Description:
      Loads the config data from storage (server-side) and updates the stored config values.
      Triggers "InitializedConfig" hook once done.

   Parameters:
      None

   Returns:
      nil

   Realm:
      Shared

   Internal Function:
      true

   Example Usage:
      lia.config.load()
]]
function lia.config.load()
    if SERVER then
        local data = lia.data.get("config", nil, false, true)
        if data then
            for k, v in pairs(data) do
                lia.config.stored[k] = lia.config.stored[k] or {}
                lia.config.stored[k].value = v
            end
        end
    end

    hook.Run("InitializedConfig")
end

if SERVER then
    --[[
       Function: lia.config.getChangedValues

       Description:
          Returns a table of all config entries where the current value differs from the default.

       Parameters:
          None

       Returns:
          (table) Key-value pairs of changed config entries.

       Realm:
          Server

       Example Usage:
          local changed = lia.config.getChangedValues()
]]
    function lia.config.getChangedValues()
        local data = {}
        for k, v in pairs(lia.config.stored) do
            if v.default ~= v.value then data[k] = v.value end
        end
        return data
    end

    --[[
       Function: lia.config.send

       Description:
          Sends current changed config values to a specified client.

       Parameters:
          client (player)  The player to receive the config data.

       Returns:
          nil

       Realm:
          Server

       Example Usage:
          lia.config.send(player)
]]
    function lia.config.send(client)
        netstream.Start(client, "cfgList", lia.config.getChangedValues())
    end

    --[[
       Function: lia.config.save

       Description:
          Saves all changed config values to persistent storage.

       Parameters:
          None

       Returns:
          nil

       Realm:
          Server

       Example Usage:
          lia.config.save()
]]
    function lia.config.save()
        local data = {}
        for k, v in pairs(lia.config.getChangedValues()) do
            data[k] = v
        end

        lia.data.set("config", data, false, true)
    end
end

lia.config.add("MoneyModel", "Money Model", "models/props_lab/box01a.mdl", nil, {
    desc = "Defines the model used for representing money in the game.",
    category = "Money",
    type = "Generic"
})

lia.config.add("MoneyLimit", "Money Limit", 0, nil, {
    desc = "Sets the limit of money a player can have [0 for infinite].",
    category = "Money",
    type = "Int",
    min = 0,
    max = 1000000
})

lia.config.add("CurrencySymbol", "Currency Symbol", "", function(newVal) lia.currency.symbol = newVal end, {
    desc = "Specifies the currency symbol used in the game.",
    category = "Money",
    type = "Generic"
})

lia.config.add("PKWorld", "PK World Deaths Count", false, nil, {
    desc = "When marked for Perma Kill, does world deaths count as perma killing?",
    category = "Character",
    type = "Boolean"
})

lia.config.add("CurrencySingularName", "Currency Singular Name", "Dollar", function(newVal) lia.currency.singular = newVal end, {
    desc = "Singular name of the in-game currency.",
    category = "Money",
    type = "Generic"
})

lia.config.add("CurrencyPluralName", "Currency Plural Name", "Dollars", function(newVal) lia.currency.plural = newVal end, {
    desc = "Plural name of the in-game currency.",
    category = "Money",
    type = "Generic"
})

lia.config.add("invW", "Inventory Width", 6, nil, {
    desc = "Defines the width of the default inventory.",
    category = "Character",
    type = "Int",
    min = 1,
    max = 20
})

lia.config.add("invH", "Inventory Height", 4, nil, {
    desc = "Defines the height of the default inventory.",
    category = "Character",
    type = "Int",
    min = 1,
    max = 20
})

lia.config.add("WalkSpeed", "Walk Speed", 130, function(_, newValue)
    for _, client in player.Iterator() do
        client:SetWalkSpeed(newValue)
    end
end, {
    desc = "Controls how fast characters walk.",
    category = "Character",
    type = "Int",
    min = 50,
    max = 300
})

lia.config.add("RunSpeed", "Run Speed", 235, function(_, newValue)
    for _, client in player.Iterator() do
        client:SetRunSpeed(newValue)
    end
end, {
    desc = "Controls how fast characters run.",
    category = "Character",
    type = "Int",
    min = 100,
    max = 500
})

lia.config.add("WalkRatio", "Walk Ratio", 0.5, nil, {
    desc = "Defines the walk speed ratio when holding the Alt key.",
    category = "Character",
    type = "Float",
    min = 0.1,
    max = 1.0,
    decimals = 2
})

lia.config.add("AllowExistNames", "Allow Duplicate Names", true, nil, {
    desc = "Determines whether duplicate character names are allowed.",
    category = "Character",
    type = "Boolean"
})

lia.config.add("MaxCharacters", "Max Characters", 5, nil, {
    desc = "Sets the maximum number of characters a player can have.",
    category = "Character",
    type = "Int",
    min = 1,
    max = 10
})

lia.config.add("AllowPMs", "Allow Private Messages", true, nil, {
    desc = "Determines whether private messages are allowed.",
    category = "Chat",
    type = "Boolean"
})

lia.config.add("MinDescLen", "Minimum Description Length", 16, nil, {
    desc = "Minimum length required for a character's description.",
    category = "Character",
    type = "Int",
    min = 10,
    max = 500
})

lia.config.add("SaveInterval", "Save Interval", 300, nil, {
    desc = "Interval for character saves in seconds.",
    category = "Character",
    type = "Int",
    min = 60,
    max = 3600
})

lia.config.add("DefMoney", "Default Money", 0, nil, {
    desc = "Specifies the default amount of money a player starts with.",
    category = "Character",
    type = "Int",
    min = 0,
    max = 10000
})

lia.config.add("DataSaveInterval", "Data Save Interval", 600, nil, {
    desc = "Time interval between data saves.",
    category = "Data",
    type = "Int",
    min = 60,
    max = 3600
})

lia.config.add("CharacterDataSaveInterval", "Character Data Save Interval", 300, nil, {
    desc = "Time interval between character data saves.",
    category = "Data",
    type = "Int",
    min = 60,
    max = 3600
})

lia.config.add("SpawnTime", "Respawn Time", 5, nil, {
    desc = "Time to respawn after death.",
    category = "Death",
    type = "Float",
    min = 1,
    max = 60
})

lia.config.add("TimeToEnterVehicle", "Vehicle Entry Time", 1, nil, {
    desc = "Time [in seconds] required to enter a vehicle.",
    category = "Quality of Life",
    type = "Float",
    min = 0.5,
    max = 10
})

lia.config.add("CarEntryDelayEnabled", "Car Entry Delay Enabled", true, nil, {
    desc = "Determines if the car entry delay is applicable.",
    category = "Timers",
    type = "Boolean"
})

lia.config.add("Font", "Font", "Arial", nil, {
    desc = "Specifies the core font used for UI elements.",
    category = "Visuals",
    type = "Generic"
})

lia.config.add("GenericFont", "Generic Font", "Segoe UI", nil, {
    desc = "Specifies the secondary font used for UI elements.",
    category = "Visuals",
    type = "Generic"
})

lia.config.add("MaxChatLength", "Max Chat Length", 256, nil, {
    desc = "Sets the maximum length of chat messages.",
    category = "Visuals",
    type = "Int",
    min = 50,
    max = 1024
})

lia.config.add("SchemaYear", "Schema Year", 2025, nil, {
    desc = "Year of the gamemode's schema.",
    category = "General",
    type = "Int",
    min = 0,
    max = 999999
})

lia.config.add("AmericanDates", "American Dates", true, nil, {
    desc = "Determines whether to use the American date format.",
    category = "General",
    type = "Boolean"
})

lia.config.add("AmericanTimeStamp", "American Timestamp", true, nil, {
    desc = "Determines whether to use the American timestamp format.",
    category = "General",
    type = "Boolean"
})

lia.config.add("AdminConsoleNetworkLogs", "Admin Console Network Logs", true, nil, {
    desc = "Specifies if the logging system should replicate to super admins' consoles.",
    category = "Staff",
    type = "Boolean"
})

lia.config.add("Color", "Theme Color", {
    r = 37,
    g = 116,
    b = 108
}, nil, {
    desc = "Sets the theme color used throughout the gamemode.",
    category = "Visuals",
    type = "Color"
})

lia.config.add("CharMenuBGInputDisabled", "Character Menu BG Input Disabled", true, nil, {
    desc = "Whether background input is disabled durinag character menu use",
    category = "Main Menu",
    type = "Boolean"
})

lia.config.add("AllowKeybindEditing", "Allow Keybind Editing", true, nil, {
    desc = "Whether keybind editing is allowed",
    category = "General",
    type = "Boolean"
})

lia.config.add("CrosshairEnabled", "Enable Crosshair", false, nil, {
    desc = "Enables the crosshair",
    category = "Visuals",
    type = "Boolean"
})

lia.config.add("BarsDisabled", "Disable Bars", false, nil, {
    desc = "Disables bars",
    category = "Visuals",
    type = "Boolean"
})

lia.config.add("AmmoDrawEnabled", "Enable Ammo Display", true, nil, {
    desc = "Enables ammo display",
    category = "Visuals",
    type = "Boolean"
})

hook.Add("PopulateConfigurationButtons", "PopulateConfig", function(pages)
    local ConfigFormatting = {
        Int = function(key, name, config, parent)
            local container = vgui.Create("DPanel", parent)
            container:SetTall(220)
            container:Dock(TOP)
            container:DockMargin(0, 60, 0, 10)
            container.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local panel = container:Add("DPanel")
            panel:Dock(FILL)
            panel.Paint = nil
            local label = panel:Add("DLabel")
            label:Dock(TOP)
            label:SetTall(45)
            label:SetText(name)
            label:SetFont("ConfigFontLarge")
            label:SetContentAlignment(5)
            label:SetTextColor(Color(255, 255, 255))
            label:DockMargin(0, 20, 0, 0)
            local description = panel:Add("DLabel")
            description:Dock(TOP)
            description:SetTall(35)
            description:SetText(config.desc or "")
            description:SetFont("DescriptionFontLarge")
            description:SetContentAlignment(5)
            description:SetTextColor(Color(200, 200, 200))
            description:DockMargin(0, 10, 0, 0)
            local slider = panel:Add("DNumSlider")
            slider:Dock(FILL)
            slider:DockMargin(10, 0, 10, 0)
            slider:SetMin(lia.config.get(key .. "_min", config.data and config.data.min or 0))
            slider:SetMax(lia.config.get(key .. "_max", config.data and config.data.max or 1))
            slider:SetDecimals(0)
            slider:SetValue(lia.config.get(key, config.value))
            slider:SetText("")
            slider.PerformLayout = function()
                slider.Label:SetWide(0)
                slider.TextArea:SetWide(50)
            end

            slider.OnValueChanged = function(_, v)
                local t = "ConfigChange_" .. key .. "_" .. os.time()
                timer.Create(t, 0.5, 1, function() netstream.Start("cfgSet", key, name, math.floor(v)) end)
            end
            return container
        end,
        Float = function(key, name, config, parent)
            local container = vgui.Create("DPanel", parent)
            container:SetTall(220)
            container:Dock(TOP)
            container:DockMargin(0, 60, 0, 10)
            container.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local panel = container:Add("DPanel")
            panel:Dock(FILL)
            panel.Paint = nil
            local label = panel:Add("DLabel")
            label:Dock(TOP)
            label:SetTall(45)
            label:SetText(name)
            label:SetFont("ConfigFontLarge")
            label:SetContentAlignment(5)
            label:SetTextColor(Color(255, 255, 255))
            label:DockMargin(0, 20, 0, 0)
            local description = panel:Add("DLabel")
            description:Dock(TOP)
            description:SetTall(35)
            description:SetText(config.desc or "")
            description:SetFont("DescriptionFontLarge")
            description:SetContentAlignment(5)
            description:SetTextColor(Color(200, 200, 200))
            description:DockMargin(0, 10, 0, 0)
            local slider = panel:Add("DNumSlider")
            slider:Dock(FILL)
            slider:DockMargin(10, 0, 10, 0)
            slider:SetMin(lia.config.get(key .. "_min", config.data and config.data.min or 0))
            slider:SetMax(lia.config.get(key .. "_max", config.data and config.data.max or 1))
            slider:SetDecimals(2)
            slider:SetValue(lia.config.get(key, config.value))
            slider:SetText("")
            slider.PerformLayout = function()
                slider.Label:SetWide(0)
                slider.TextArea:SetWide(50)
            end

            slider.OnValueChanged = function(_, v)
                local t = "ConfigChange_" .. key .. "_" .. os.time()
                timer.Create(t, 0.5, 1, function() netstream.Start("cfgSet", key, name, tonumber(v)) end)
            end
            return container
        end,
        Generic = function(key, name, config, parent)
            local container = vgui.Create("DPanel", parent)
            container:SetTall(220)
            container:Dock(TOP)
            container:DockMargin(0, 60, 0, 10)
            container.Paint = function() end
            local panel = container:Add("DPanel")
            panel:Dock(FILL)
            panel.Paint = nil
            local label = panel:Add("DLabel")
            label:Dock(TOP)
            label:SetTall(45)
            label:SetText(name)
            label:SetFont("ConfigFontLarge")
            label:SetContentAlignment(5)
            label:SetTextColor(Color(255, 255, 255))
            label:DockMargin(0, 20, 0, 0)
            local description = panel:Add("DLabel")
            description:Dock(TOP)
            description:SetTall(35)
            description:SetText(config.desc or "")
            description:SetFont("DescriptionFontLarge")
            description:SetContentAlignment(5)
            description:SetTextColor(Color(200, 200, 200))
            description:DockMargin(0, 10, 0, 0)
            local entry = panel:Add("DTextEntry")
            entry:Dock(TOP)
            entry:SetTall(60)
            entry:DockMargin(300, 10, 300, 0)
            entry:SetText(tostring(lia.config.get(key, config.value)))
            entry:SetFont("ConfigFontLarge")
            entry:SetTextColor(Color(255, 255, 255))
            entry.Paint = function(self, w, h)
                draw.RoundedBox(0, 0, 0, w, h, Color(50, 50, 50, 200))
                self:DrawTextEntryText(Color(255, 255, 255), Color(255, 255, 255), Color(255, 255, 255))
            end

            entry.OnEnter = function()
                local t = "ConfigChange_" .. key .. "_" .. os.time()
                timer.Create(t, 0.5, 1, function() netstream.Start("cfgSet", key, name, entry:GetText()) end)
            end
            return container
        end,
        Boolean = function(key, name, config, parent)
            local container = vgui.Create("DPanel", parent)
            container:SetTall(220)
            container:Dock(TOP)
            container:DockMargin(0, 60, 0, 10)
            container.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local panel = container:Add("DPanel")
            panel:Dock(FILL)
            panel.Paint = nil
            local label = panel:Add("DLabel")
            label:Dock(TOP)
            label:SetTall(45)
            label:SetText(name)
            label:SetFont("ConfigFontLarge")
            label:SetContentAlignment(5)
            label:SetTextColor(Color(255, 255, 255))
            label:DockMargin(0, 20, 0, 0)
            local description = panel:Add("DLabel")
            description:Dock(TOP)
            description:SetTall(35)
            description:SetText(config.desc or "")
            description:SetFont("DescriptionFontLarge")
            description:SetContentAlignment(5)
            description:SetTextColor(Color(200, 200, 200))
            description:DockMargin(0, 10, 0, 0)
            local button = panel:Add("DButton")
            button:Dock(TOP)
            button:SetTall(100)
            button:DockMargin(100, 10, 100, 0)
            button:SetText("")
            button.Paint = function(_, w, h)
                local v = lia.config.get(key, config.value)
                local ic = v and getIcon("0xe880", true) or getIcon("0xf096", true)
                lia.util.drawText(ic, w / 2, h / 2 - 10, color_white, 1, 1, "liaIconsHugeNew")
            end

            button.DoClick = function()
                local t = "ConfigChange_" .. key .. "_" .. os.time()
                timer.Create(t, 0.5, 1, function() netstream.Start("cfgSet", key, name, not lia.config.get(key, config.value)) end)
            end
            return container
        end,
        Color = function(key, name, config, parent)
            local container = vgui.Create("DPanel", parent)
            container:SetTall(220)
            container:Dock(TOP)
            container:DockMargin(0, 60, 0, 10)
            container.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local panel = container:Add("DPanel")
            panel:Dock(FILL)
            panel.Paint = nil
            local label = panel:Add("DLabel")
            label:Dock(TOP)
            label:SetTall(45)
            label:SetText(name)
            label:SetFont("ConfigFontLarge")
            label:SetContentAlignment(5)
            label:SetTextColor(Color(255, 255, 255))
            label:DockMargin(0, 20, 0, 0)
            local description = panel:Add("DLabel")
            description:Dock(TOP)
            description:SetTall(35)
            description:SetText(config.desc or "")
            description:SetFont("DescriptionFontLarge")
            description:SetContentAlignment(5)
            description:SetTextColor(Color(200, 200, 200))
            description:DockMargin(0, 10, 0, 0)
            local button = panel:Add("DButton")
            button:Dock(FILL)
            button:DockMargin(10, 0, 10, 0)
            button:SetText("")
            button.Paint = function(_, w, h)
                local c = lia.config.get(key, config.value)
                surface.SetDrawColor(c)
                surface.DrawRect(10, h / 2 - 15, w - 20, 30)
                draw.RoundedBox(2, 10, h / 2 - 15, w - 20, 30, Color(255, 255, 255, 50))
            end

            button.DoClick = function()
                if IsValid(button.picker) then button.picker:Remove() end
                local f = vgui.Create("DFrame")
                f:SetSize(300, 400)
                f:Center()
                f:MakePopup()
                local m = f:Add("DColorMixer")
                m:Dock(FILL)
                m:SetPalette(true)
                m:SetAlphaBar(true)
                m:SetWangs(true)
                m:SetColor(lia.config.get(key, config.value))
                local apply = f:Add("DButton")
                apply:Dock(BOTTOM)
                apply:SetTall(40)
                apply:SetText("Apply")
                apply:SetFont("ConfigFontLarge")
                apply.Paint = function(_, w, h)
                    surface.SetDrawColor(Color(0, 150, 0))
                    surface.DrawRect(0, 0, w, h)
                    if apply:IsHovered() then
                        surface.SetDrawColor(Color(0, 180, 0))
                        surface.DrawRect(0, 0, w, h)
                    end

                    surface.SetDrawColor(Color(255, 255, 255))
                    surface.DrawOutlinedRect(0, 0, w, h)
                end

                apply.DoClick = function()
                    local t = "ConfigChange_" .. key .. "_" .. os.time()
                    timer.Create(t, 0.5, 1, function() netstream.Start("cfgSet", key, name, m:GetColor()) end)
                    f:Remove()
                end

                button.picker = f
            end
            return container
        end,
        Table = function(key, name, config, parent)
            local container = vgui.Create("DPanel", parent)
            container:SetTall(220)
            container:Dock(TOP)
            container:DockMargin(0, 60, 0, 10)
            container.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local panel = container:Add("DPanel")
            panel:Dock(FILL)
            panel.Paint = nil
            local label = panel:Add("DLabel")
            label:Dock(TOP)
            label:SetTall(45)
            label:SetText(name)
            label:SetFont("ConfigFontLarge")
            label:SetContentAlignment(5)
            label:SetTextColor(Color(255, 255, 255))
            label:DockMargin(0, 20, 0, 0)
            local description = panel:Add("DLabel")
            description:Dock(TOP)
            description:SetTall(35)
            description:SetText(config.desc or "")
            description:SetFont("DescriptionFontLarge")
            description:SetContentAlignment(5)
            description:SetTextColor(Color(200, 200, 200))
            description:DockMargin(0, 10, 0, 0)
            local combo = panel:Add("DComboBox")
            combo:Dock(TOP)
            combo:SetTall(60)
            combo:DockMargin(300, 10, 300, 0)
            combo:SetValue(tostring(lia.config.get(key, config.value)))
            combo:SetFont("ConfigFontLarge")
            combo.Paint = function(self, w, h)
                draw.RoundedBox(0, 0, 0, w, h, Color(50, 50, 50, 200))
                self:DrawTextEntryText(Color(255, 255, 255), Color(255, 255, 255), Color(255, 255, 255))
            end

            local opts = config.data and config.data.options or {}
            for _, o in ipairs(opts) do
                combo:AddChoice(o)
            end

            combo.OnSelect = function(_, _, v)
                local t = "ConfigChange_" .. key .. "_" .. os.time()
                timer.Create(t, 0.5, 1, function() netstream.Start("cfgSet", key, name, v) end)
            end
            return container
        end
    }

    local function buildConfiguration(parent)
        parent:Clear()
        local search = vgui.Create("DTextEntry", parent)
        search:Dock(TOP)
        search:SetTall(30)
        search:DockMargin(5, 5, 5, 5)
        search:SetPlaceholderText("Search configurations...")
        local scroll = vgui.Create("DScrollPanel", parent)
        scroll:Dock(FILL)
        local function populate(filter)
            scroll:Clear()
            local categories = {}
            local keys = {}
            for k in pairs(lia.config.stored) do
                keys[#keys + 1] = k
            end

            table.sort(keys, function(a, b) return lia.config.stored[a].name < lia.config.stored[b].name end)
            for _, k in ipairs(keys) do
                local opt = lia.config.stored[k]
                local n = opt.name or ""
                local d = opt.desc or ""
                local ln, ld = n:lower(), d:lower()
                if filter == "" or ln:find(filter, 1, true) or ld:find(filter, 1, true) then
                    local cat = opt.category or "Miscellaneous"
                    categories[cat] = categories[cat] or {}
                    table.insert(categories[cat], {
                        key = k,
                        name = n,
                        config = opt,
                        elemType = opt.data and opt.data.type or "Generic"
                    })
                end
            end

            for catName, items in SortedPairs(categories) do
                local cat = vgui.Create("DCollapsibleCategory", scroll)
                cat:Dock(TOP)
                cat:SetLabel(catName)
                cat:SetExpanded(true)
                cat:DockMargin(0, 0, 0, 10)
                cat.Header:SetContentAlignment(5)
                cat.Header:SetTall(30)
                cat.Header:SetFont("liaMediumFont")
                cat.Header:SetTextColor(Color(255, 255, 255))
                cat.Header.Paint = function(_, w, h)
                    draw.RoundedBox(0, 0, 0, w, h, Color(20, 20, 20, 200))
                    surface.SetDrawColor(255, 255, 255, 80)
                    surface.DrawOutlinedRect(0, 0, w, h)
                end

                cat.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(40, 40, 40, 60)) end
                local body = vgui.Create("DPanel", cat)
                body:SetTall(#items * 240)
                body.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(20, 20, 20, 50)) end
                cat:SetContents(body)
                for _, it in ipairs(items) do
                    local el = ConfigFormatting[it.elemType](it.key, it.name, it.config, body)
                    el:Dock(TOP)
                    el:DockMargin(10, 10, 10, 0)
                    el.Paint = function(_, w, h)
                        draw.RoundedBox(4, 0, 0, w, h, Color(0, 0, 0, 200))
                        surface.SetDrawColor(255, 255, 255)
                        surface.DrawOutlinedRect(0, 0, w, h)
                    end
                end
            end
        end

        search.OnTextChanged = function() populate(search:GetValue():lower()) end
        populate("")
    end

    table.insert(pages, {
        name = "Configuration",
        drawFunc = function(parent) buildConfiguration(parent) end
    })
end)

-- ./gamemode/core/libraries/currency.lua
lia.currency = lia.currency or {}
lia.currency.symbol = lia.config.get("CurrencySymbol") or ""
lia.currency.singular = lia.config.get("CurrencySingularName") or "dollar"
lia.currency.plural = lia.config.get("CurrencyPluralName") or "dollars"
--[[
    lia.currency.get

    Description:
        Formats a numeric amount into a currency string using the defined symbol,
        singular, and plural names. If the amount is exactly 1, it returns the singular
        form; otherwise, it returns the plural form.

    Parameters:
        amount (number) - The amount to format.

    Returns:
        string - The formatted currency string.

    Realm:
        Shared

    Example Usage:
        lia.currency.get(10)  -- e.g., "$10 dollars"
]]
function lia.currency.get(amount)
    return lia.currency.symbol .. (amount == 1 and "1 " .. lia.currency.singular or amount .. " " .. lia.currency.plural)
end

if SERVER then
    --[[
        lia.currency.spawn

        Description:
            Spawns a currency entity at the specified position with a given amount and optional angle.
            Validates the position and ensures the amount is a non-negative number.

        Parameters:
            pos (Vector) - The spawn position for the currency entity.
            amount (number) - The monetary value for the entity.
            angle (Angle, optional) - The orientation for the entity (defaults to Angle(0, 0, 0)).

        Returns:
            Entity - The spawned currency entity if successful; nil otherwise.

        Realm:
            Server

        Example Usage:
            lia.currency.spawn(Vector(0, 0, 0), 100)
    ]]
    function lia.currency.spawn(pos, amount, angle)
        if not pos then
            lia.information("[Lilia] Can't create currency entity: Invalid Position")
        elseif not amount or amount < 0 then
            lia.information("[Lilia] Can't create currency entity: Invalid Amount of money")
        else
            local money = ents.Create("lia_money")
            money:SetPos(pos)
            money:setAmount(math.Round(math.abs(amount)))
            money:SetAngles(angle or Angle(0, 0, 0))
            money:Spawn()
            money:Activate()
            return money
        end
    end
end

-- ./gamemode/core/libraries/darkrp.lua
DarkRP = DarkRP or {}
RPExtraTeams = RPExtraTeams or {}
lia.darkrp = lia.darkrp or {}
if SERVER then
    function lia.darkrp.isEmpty(position, entitiesToIgnore)
        entitiesToIgnore = entitiesToIgnore or {}
        local contents = util.PointContents(position)
        local isClear = contents ~= CONTENTS_SOLID and contents ~= CONTENTS_MOVEABLE and contents ~= CONTENTS_LADDER and contents ~= CONTENTS_PLAYERCLIP and contents ~= CONTENTS_MONSTERCLIP
        if not isClear then return false end
        local isEmpty = true
        for _, entity in ipairs(ents.FindInSphere(position, 35)) do
            if (entity:IsNPC() or entity:IsPlayer() or entity:isProp() or entity.NotEmptyPos) and not table.HasValue(entitiesToIgnore, entity) then
                isEmpty = false
                break
            end
        end
        return isClear and isEmpty
    end

    function lia.darkrp.findEmptyPos(startPos, entitiesToIgnore, maxDistance, searchStep, checkArea)
        if lia.darkrp.isEmpty(startPos, entitiesToIgnore) and lia.darkrp.isEmpty(startPos + checkArea, entitiesToIgnore) then return startPos end
        for distance = searchStep, maxDistance, searchStep do
            for direction = -1, 1, 2 do
                local offset = distance * direction
                if lia.darkrp.isEmpty(startPos + Vector(offset, 0, 0), entitiesToIgnore) and lia.darkrp.isEmpty(startPos + Vector(offset, 0, 0) + checkArea, entitiesToIgnore) then return startPos + Vector(offset, 0, 0) end
                if lia.darkrp.isEmpty(startPos + Vector(0, offset, 0), entitiesToIgnore) and lia.darkrp.isEmpty(startPos + Vector(0, offset, 0) + checkArea, entitiesToIgnore) then return startPos + Vector(0, offset, 0) end
                if lia.darkrp.isEmpty(startPos + Vector(0, 0, offset), entitiesToIgnore) and lia.darkrp.isEmpty(startPos + Vector(0, 0, offset) + checkArea, entitiesToIgnore) then return startPos + Vector(0, 0, offset) end
            end
        end
        return startPos
    end

    function lia.darkrp.notify(client, _, _, message)
        client:notify(message)
    end
else
    local function wrapCharacters(text, remainingWidth, maxWidth)
        local accumulatedWidth = 0
        text = text:gsub(".", function(char)
            accumulatedWidth = accumulatedWidth + surface.GetTextSize(char)
            if accumulatedWidth >= remainingWidth then
                accumulatedWidth = surface.GetTextSize(char)
                remainingWidth = maxWidth
                return "\n" .. char
            end
            return char
        end)
        return text, accumulatedWidth
    end

    function lia.darkrp.textWrap(text, fontName, maxLineWidth)
        local accumulatedWidth = 0
        surface.SetFont(fontName)
        local spaceWidth = surface.GetTextSize(' ')
        text = text:gsub("(%s?[%S]+)", function(word)
            local firstChar = string.sub(word, 1, 1)
            if firstChar == "\n" or firstChar == "\t" then accumulatedWidth = 0 end
            local wordWidth = surface.GetTextSize(word)
            accumulatedWidth = accumulatedWidth + wordWidth
            if wordWidth >= maxLineWidth then
                local wrappedWord, finalWidth = wrapCharacters(word, maxLineWidth - (accumulatedWidth - wordWidth), maxLineWidth)
                accumulatedWidth = finalWidth
                return wrappedWord
            elseif accumulatedWidth < maxLineWidth then
                return word
            end

            if firstChar == ' ' then
                accumulatedWidth = wordWidth - spaceWidth
                return '\n' .. string.sub(word, 2)
            end

            accumulatedWidth = wordWidth
            return '\n' .. word
        end)
        return text
    end
end

for index, faction in ipairs(lia.faction.indices) do
    RPExtraTeams[index] = faction
    RPExtraTeams[index].team = index
end

function lia.darkrp.formatMoney(amount)
    return lia.currency.get(amount)
end

function lia.darkrp.createEntity(name, data)
    local cmd = data.cmd or string.lower(name)
    local ITEM = lia.item.register(cmd, "base_entities", nil, nil, true)
    ITEM.name = name
    ITEM.model = data.model or ""
    ITEM.desc = data.desc or ""
    ITEM.category = data.category or "Entities"
    ITEM.entityid = data.ent or ""
    ITEM.price = data.price or 0
    lia.information("Generated DarkRP entity as item " .. name)
end

function lia.darkrp.createCategory()
end

DarkRP.createCategory = lia.darkrp.createCategory
DarkRP.createEntity = lia.darkrp.createEntity
DarkRP.formatMoney = lia.darkrp.formatMoney
DarkRP.isEmpty = lia.darkrp.isEmpty
DarkRP.findEmptyPos = lia.darkrp.findEmptyPos
DarkRP.notify = lia.darkrp.notify
DarkRP.textWrap = lia.darkrp.textWrap

-- ./gamemode/core/libraries/data.lua
file.CreateDir("lilia")
lia.data = lia.data or {}
lia.data.stored = lia.data.stored or {}
if SERVER then
    --[[
      lia.data.set

      Description:
         Saves the provided value under the specified key to persistent storage.
         The data is written to a file whose path is constructed based on the folder, map, and flags.
         Also caches the value in lia.data.stored.

      Parameters:
         key (string) - The key under which the data is stored.
         value (any) - The value to store.
         global (boolean) - If true, uses a global path; otherwise, includes folder and map.
         ignoreMap (boolean) - If true, ignores the map directory.

      Returns:
         string - The path where the data was saved.

      Realm:
         Shared

      Example Usage:
         lia.data.set("exampleKey", {data = "exampleValue"}, false, false)
   ]]
    function lia.data.set(key, value, global, ignoreMap)
        local folder = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()
        local path = "lilia/" .. (global and "" or folder .. "/") .. (ignoreMap and "" or game.GetMap() .. "/")
        if not global then file.CreateDir("lilia/" .. folder .. "/") end
        file.CreateDir(path)
        file.Write(path .. key .. ".txt", pon.encode({value}))
        lia.data.stored[key] = value
        return path
    end

    --[[
      lia.data.delete

      Description:
         Deletes the stored data file corresponding to the specified key.
         Also removes the value from the cached storage.

      Parameters:
         key (string) - The key corresponding to the data to be deleted.
         global (boolean) - If true, uses a global path; otherwise, includes folder and map.
         ignoreMap (boolean) - If true, ignores the map directory.

      Returns:
         boolean - True if the file was deleted, false otherwise.

      Realm:
         Shared

      Example Usage:
         lia.data.delete("exampleKey", false, false)
   ]]
    function lia.data.delete(key, global, ignoreMap)
        local folder = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()
        local path = "lilia/" .. (global and "" or folder .. "/") .. (ignoreMap and "" or game.GetMap() .. "/")
        local contents = file.Read(path .. key .. ".txt", "DATA")
        if contents and contents ~= "" then
            file.Delete(path .. key .. ".txt")
            lia.data.stored[key] = nil
            return true
        else
            return false
        end
    end

    timer.Create("liaSaveData", lia.config.get("DataSaveInterval", 600), 0, function()
        hook.Run("SaveData")
        hook.Run("PersistenceSave")
    end)
end

--[[
   lia.data.get

   Description:
      Retrieves the stored data for the specified key.
      If refresh is not set and data exists in cache, returns the cached data.
      Otherwise, reads from the file, decodes, and caches the value.

   Parameters:
      key (string) - The key corresponding to the data.
      default (any) - The default value to return if no data is found.
      global (boolean) - If true, uses a global path; otherwise, includes folder and map.
      ignoreMap (boolean) - If true, ignores the map directory.
      refresh (boolean) - If true, forces reading from file instead of cache.

   Returns:
      any - The stored value, or the default if not found.

   Realm:
      Shared

   Example Usage:
      lia.data.get("exampleKey", {})
]]
function lia.data.get(key, default, global, ignoreMap, refresh)
    if not refresh then
        local stored = lia.data.stored[key]
        if stored ~= nil then return stored end
    end

    local folder = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()
    local path = "lilia/" .. (global and "" or folder .. "/") .. (ignoreMap and "" or game.GetMap() .. "/")
    local contents = file.Read(path .. key .. ".txt", "DATA")
    if contents and contents ~= "" then
        local status, decoded = pcall(pon.decode, contents)
        if status and decoded then
            local value = decoded[1]
            lia.data.stored[key] = value
            if value ~= nil then
                return value
            else
                return default
            end
        else
            return default
        end
    else
        return default
    end
end

-- ./gamemode/core/libraries/database.lua
lia.db = lia.db or {}
lia.db.queryQueue = lia.db.queue or {}
lia.db.prepared = lia.db.prepared or {}
MYSQLOO_QUEUE = MYSQLOO_QUEUE or {}
PREPARE_CACHE = {}
MYSQLOO_INTEGER = 0
MYSQLOO_STRING = 1
MYSQLOO_BOOL = 2
local modules = {}
local function ThrowQueryFault(query, fault)
    if string.find(fault, "duplicate column name:") then return end
    MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " * " .. query .. "\n")
    MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " " .. fault .. "\n")
end

local function ThrowConnectionFault(fault)
    MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " Lilia has failed to connect to the database.\n")
    MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " " .. fault .. "\n")
    setNetVar("dbError", fault)
end

local function promisifyIfNoCallback(queryHandler)
    return function(query, callback)
        local d
        local function throw(err)
            if d then
                d:reject(err)
            else
                ThrowQueryFault(query, err)
            end
        end

        if not isfunction(callback) then
            d = deferred.new()
            callback = function(results, lastID)
                d:resolve({
                    results = results,
                    lastID = lastID
                })
            end
        end

        queryHandler(query, callback, throw)
        return d
    end
end

modules.sqlite = {
    query = promisifyIfNoCallback(function(query, callback, throw)
        local data = sql.Query(query)
        local err = sql.LastError()
        if data == false then throw(err) end
        if callback then
            local lastID = tonumber(sql.QueryValue("SELECT last_insert_rowid()"))
            callback(data, lastID)
        end
    end),
    escape = function(value) return sql.SQLStr(value, true) end,
    connect = function(callback)
        lia.db.query = modules.sqlite.query
        if callback then callback() end
    end
}

modules.mysqloo = {
    query = promisifyIfNoCallback(function(query, callback, throw)
        if lia.db.getObject and lia.db.getObject() then
            local object = lia.db.getObject():query(query)
            if callback then
                function object:onSuccess(data)
                    callback(data, self:lastInsert())
                end
            end

            function object:onError(fault)
                if lia.db.getObject():status() == mysqloo.DATABASE_NOT_CONNECTED then
                    lia.db.queryQueue[#lia.db.queryQueue + 1] = {query, callback}
                    lia.db.connect(nil, true)
                    return
                end

                throw(fault)
            end

            object:start()
        else
            lia.db.queryQueue[#lia.db.queryQueue + 1] = {query, callback}
        end
    end),
    escape = function(value)
        local object = lia.db.getObject and lia.db.getObject()
        if object then
            return object:escape(value)
        else
            return sql.SQLStr(value, true)
        end
    end,
    queue = function()
        local count = 0
        for _, v in pairs(lia.db.pool) do
            count = count + v:queueSize()
        end
        return count
    end,
    abort = function()
        for _, v in pairs(lia.db.pool) do
            v:abortAllQueries()
        end
    end,
    getObject = function()
        local lowest = nil
        local lowestCount = 0
        local lowestIndex = 0
        for k, db in pairs(lia.db.pool) do
            local queueSize = db:queueSize()
            if not lowest or queueSize < lowestCount then
                lowest = db
                lowestCount = queueSize
                lowestIndex = k
            end
        end

        if not lowest then error("failed to find database in the pool") end
        return lowest, lowestIndex
    end,
    connect = function(callback)
        if not pcall(require, "mysqloo") then return setNetVar("dbError", system.IsWindows() and "Server is missing VC++ redistributables! " or "Server is missing binaries for mysqloo! ") end
        if mysqloo.VERSION ~= "9" or not mysqloo.MINOR_VERSION or tonumber(mysqloo.MINOR_VERSION) < 1 then
            MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " You are using an outdated mysqloo version.\n")
            MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " Download the latest mysqloo9 from here.\n")
            MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " https://github.com/syl0r/MySQLOO/releases.\n")
            return
        end

        local hostname = lia.db.hostname
        local username = lia.db.username
        local password = lia.db.password
        local database = lia.db.database
        local port = lia.db.port
        mysqloo.connect(hostname, username, password, database, port)
        lia.db.pool = {}
        local poolNum = 6
        local connectedPools = 0
        for i = 1, poolNum do
            lia.db.pool[i] = mysqloo.connect(hostname, username, password, database, port)
            local pool = lia.db.pool[i]
            pool:setAutoReconnect(true)
            pool:connect()
            function pool:onConnectionFailed(fault)
                ThrowConnectionFault(fault)
            end

            function pool:onConnected()
                pool:setCharacterSet("utf8")
                connectedPools = connectedPools + 1
                if connectedPools == poolNum then
                    lia.db.escape = modules.mysqloo.escape
                    lia.db.query = modules.mysqloo.query
                    lia.db.prepare = modules.mysqloo.prepare
                    lia.db.abort = modules.mysqloo.abort
                    lia.db.queue = modules.mysqloo.queue
                    lia.db.getObject = modules.mysqloo.getObject
                    lia.db.preparedCall = modules.mysqloo.preparedCall
                    if callback then callback() end
                    hook.Run("OnMySQLOOConnected")
                end
            end

            timer.Create("liaMySQLWakeUp" .. i, 600 + i, 0, function() pool:query("SELECT 1 + 1") end)
        end

        lia.db.object = lia.db.pool
    end,
    prepare = function(key, str, values)
        lia.db.prepared[key] = {
            query = str,
            values = values,
        }
    end,
    preparedCall = function(key, callback, ...)
        local preparedStatement = lia.db.prepared[key]
        if preparedStatement then
            local _, freeIndex = lia.db.getObject()
            PREPARE_CACHE[key] = PREPARE_CACHE[key] or {}
            PREPARE_CACHE[key][freeIndex] = PREPARE_CACHE[key][freeIndex] or lia.db.getObject():prepare(preparedStatement.query)
            local prepObj = PREPARE_CACHE[key][freeIndex]
            function prepObj:onSuccess(data)
                if callback then callback(data, self:lastInsert()) end
            end

            function prepObj:onError(err)
                ServerLog(err)
            end

            local arguments = {...}
            if table.Count(arguments) == table.Count(preparedStatement.values) then
                local index = 1
                for _, type in pairs(preparedStatement.values) do
                    if type == MYSQLOO_INTEGER then
                        prepObj:setNumber(index, arguments[index])
                    elseif type == MYSQLOO_STRING then
                        prepObj:setString(index, lia.db.convertDataType(arguments[index], true))
                    elseif type == MYSQLOO_BOOL then
                        prepObj:setBoolean(index, arguments[index])
                    end

                    index = index + 1
                end
            end

            prepObj:start()
        else
            MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " INVALID PREPARED STATEMENT : " .. key .. "\n")
        end
    end
}

lia.db.escape = lia.db.escape or modules.sqlite.escape
lia.db.query = lia.db.query or function(...) lia.db.queryQueue[#lia.db.queryQueue + 1] = {...} end
--[[
   Function: lia.db.connect

   Description:
      Establishes a connection to the configured database module. If the database
      is not already connected or if reconnect is true, it will initiate a new connection
      or re-establish one.

   Parameters:
      callback (function) - The function to call when the database connection is established.
      reconnect (boolean) - Whether to reconnect using an existing database object or not.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.db.connect(function()
         print("Database connected")
      end)
]]
function lia.db.connect(callback, reconnect)
    local dbModule = modules[lia.db.module]
    if dbModule then
        if (reconnect or not lia.db.connected) and not lia.db.object then
            dbModule.connect(function()
                lia.db.connected = true
                if isfunction(callback) then callback() end
                for i = 1, #lia.db.queryQueue do
                    lia.db.query(unpack(lia.db.queryQueue[i]))
                end

                lia.db.queryQueue = {}
            end)
        end

        lia.db.escape = dbModule.escape
        lia.db.query = dbModule.query
    else
        ErrorNoHalt("[Lilia] '" .. (lia.db.module or "Unavailable") .. "' is not a valid data storage method! \n")
    end
end

--[[
   Function: lia.db.wipeTables

   Description:
      Wipes all Lilia data tables from the database, dropping the specified
      tables. This action is irreversible and will remove all stored data.

   Parameters:
      callback (function) - The function to call when the wipe operation is completed.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.db.wipeTables(function()
         print("All data has been wiped.")
      end)
]]
function lia.db.wipeTables(callback)
    local function realCallback()
        if lia.db.module == "mysqloo" then
            lia.db.query("SET FOREIGN_KEY_CHECKS = 1;", function()
                MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " ALL LILIA DATA HAS BEEN WIPED\n")
                if isfunction(callback) then callback() end
            end)
        else
            MsgC(Color(83, 143, 239), "[Lilia] ", Color(0, 255, 0), "[Database]", Color(255, 255, 255), " ALL LILIA DATA HAS BEEN WIPED\n")
            if isfunction(callback) then callback() end
        end
    end

    if lia.db.module == "mysqloo" then
        local function startDeleting()
            local queries = string.Explode(";", [[
    DROP TABLE IF EXISTS `lia_players`;
    DROP TABLE IF EXISTS `lia_characters`;
    DROP TABLE IF EXISTS `lia_inventories`;
    DROP TABLE IF EXISTS `lia_items`;
    DROP TABLE IF EXISTS `lia_invdata`;
    DROP TABLE IF EXISTS `lilia_logs`;
]])
            local done = 0
            for i = 1, #queries do
                queries[i] = string.Trim(queries[i])
                if queries[i] == "" then
                    done = done + 1
                else
                    lia.db.query(queries[i], function()
                        done = done + 1
                        if done >= #queries then realCallback() end
                    end)
                end
            end
        end

        lia.db.query("SET FOREIGN_KEY_CHECKS = 0;", startDeleting)
    else
        lia.db.query([[
    DROP TABLE IF EXISTS lia_players;
    DROP TABLE IF EXISTS lia_characters;
    DROP TABLE IF EXISTS lia_inventories;
    DROP TABLE IF EXISTS lia_items;
    DROP TABLE IF EXISTS lia_invdata;
]], realCallback)
    end
end

--[[
   Function: lia.db.loadTables

   Description:
      Creates the required database tables if they do not already exist for
      storing Lilia data. This ensures the schema is properly set up.

   Parameters:
      None

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.db.loadTables()
]]
function lia.db.loadTables()
    local function done()
        lia.db.tablesLoaded = true
        hook.Run("LiliaTablesLoaded")
    end

    if lia.db.module == "sqlite" then
        lia.db.query([[
            CREATE TABLE IF NOT EXISTS lia_players (
                _steamID varchar,
                _steamName varchar,
                _firstJoin datetime,
                _lastJoin datetime,
                _data varchar,
                _intro binary
            );

            CREATE TABLE IF NOT EXISTS lia_characters (
                _id INTEGER PRIMARY KEY AUTOINCREMENT,
                _steamID VARCHAR,
                _name VARCHAR,
                _desc VARCHAR,
                _model VARCHAR,
                _attribs VARCHAR,
                _schema VARCHAR,
                _createTime DATETIME,
                _lastJoinTime DATETIME,
                _data VARCHAR,
                _money VARCHAR,
                _faction VARCHAR,
                recognized_as TEXT NOT NULL DEFAULT ''
            );

            CREATE TABLE IF NOT EXISTS lia_inventories (
                _invID integer PRIMARY KEY AUTOINCREMENT,
                _charID integer,
                _invType varchar
            );

            CREATE TABLE IF NOT EXISTS lia_items (
                _itemID integer PRIMARY KEY AUTOINCREMENT,
                _invID integer,
                _uniqueID varchar,
                _data varchar,
                _quantity integer,
                _x integer,
                _y integer
            );

            CREATE TABLE IF NOT EXISTS lia_invdata (
                _invID integer,
                _key text,
                _value text,
                FOREIGN KEY(_invID) REFERENCES lia_inventories(_invID),
                PRIMARY KEY (_invID, _key)
            );
        ]], done)
    else
        local queries = string.Explode(";", [[
            CREATE TABLE IF NOT EXISTS `lia_players` (
                `_steamID` VARCHAR(20) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_steamName` VARCHAR(32) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_firstJoin` DATETIME,
                `_lastJoin` DATETIME,
                `_data` VARCHAR(255) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_intro` BINARY(1) NULL DEFAULT 0,
                PRIMARY KEY (`_steamID`)
            );

            CREATE TABLE IF NOT EXISTS `lia_characters` (
                `_id` INT(12) NOT NULL AUTO_INCREMENT,
                `_steamID` VARCHAR(20) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_name` VARCHAR(70) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_desc` VARCHAR(512) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_model` VARCHAR(255) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_attribs` VARCHAR(512) DEFAULT NULL COLLATE 'utf8mb4_general_ci',
                `_schema` VARCHAR(24) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_createTime` DATETIME NOT NULL,
                `_lastJoinTime` DATETIME NOT NULL,
                `_data` VARCHAR(1024) DEFAULT NULL COLLATE 'utf8mb4_general_ci',
                `_money` INT(10) UNSIGNED NULL DEFAULT '0',
                `_faction` VARCHAR(255) DEFAULT NULL COLLATE 'utf8mb4_general_ci',
                `recognized_as` TEXT NOT NULL COLLATE 'utf8mb4_general_ci',
                PRIMARY KEY (`_id`)
            );

            CREATE TABLE IF NOT EXISTS `lia_inventories` (
                `_invID` INT(12) NOT NULL AUTO_INCREMENT,
                `_charID` INT(12) NULL DEFAULT NULL,
                `_invType` VARCHAR(24) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci',
                PRIMARY KEY (`_invID`)
            );

            CREATE TABLE IF NOT EXISTS `lia_items` (
                `_itemID` INT(12) NOT NULL AUTO_INCREMENT,
                `_invID` INT(12) NULL DEFAULT NULL,
                `_uniqueID` VARCHAR(60) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_data` VARCHAR(512) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci',
                `_quantity` INT(16),
                `_x` INT(4),
                `_y` INT(4),
                PRIMARY KEY (`_itemID`)
            );

            CREATE TABLE IF NOT EXISTS `lia_invdata` (
                `_invID` INT(12) NOT NULL,
                `_key` VARCHAR(32) NOT NULL COLLATE 'utf8mb4_general_ci',
                `_value` VARCHAR(255) NOT NULL COLLATE 'utf8mb4_general_ci',
                FOREIGN KEY (`_invID`) REFERENCES lia_inventories(_invID) ON DELETE CASCADE,
                PRIMARY KEY (`_invID`, `_key`)
            );
        ]])
        local i = 1
        local function doNextQuery()
            if i > #queries then return done() end
            local query = string.Trim(queries[i])
            if query == "" then
                i = i + 1
                return doNextQuery()
            end

            lia.db.query(query, function()
                i = i + 1
                doNextQuery()
            end)
        end

        doNextQuery()
    end

    hook.Run("OnLoadTables")
end

--[[
   Function: lia.db.waitForTablesToLoad

   Description:
      Returns a deferred object that resolves once the database tables are fully loaded.
      This allows asynchronous code to wait for table creation before proceeding.

   Parameters:
      None

   Returns:
      deferred - A deferred object that resolves when the tables are loaded.

   Realm:
      Shared

   Example Usage:
      lia.db.waitForTablesToLoad():next(function()
         print("Tables are loaded.")
      end)
]]
function lia.db.waitForTablesToLoad()
    TABLE_WAIT_ID = TABLE_WAIT_ID or 0
    local d = deferred.new()
    if lia.db.tablesLoaded then
        d:resolve()
    else
        hook.Add("LiliaTablesLoaded", tostring(TABLE_WAIT_ID), function() d:resolve() end)
    end

    TABLE_WAIT_ID = TABLE_WAIT_ID + 1
    return d
end

--[[
   Function: lia.db.convertDataType

   Description:
      Converts a Lua value into a string suitable for database insertion,
      handling strings, tables, and NULL values. Escaping is optionally applied
      unless noEscape is set.

   Parameters:
      value (any) - The value to be converted.
      noEscape (boolean) - If true, the returned string is not escaped.

   Returns:
      string - The converted data type as a string.

   Realm:
      Shared

   Example Usage:
      local data = lia.db.convertDataType({foo = "bar"})
]]
function lia.db.convertDataType(value, noEscape)
    if isstring(value) then
        if noEscape then
            return value
        else
            return "'" .. lia.db.escape(value) .. "'"
        end
    elseif istable(value) then
        if noEscape then
            return util.TableToJSON(value)
        else
            return "'" .. lia.db.escape(util.TableToJSON(value)) .. "'"
        end
    elseif value == NULL then
        return "NULL"
    end
    return value
end

local function genInsertValues(value, dbTable)
    local query = "lia_" .. (dbTable or "characters") .. " ("
    local keys = {}
    local values = {}
    for k, v in pairs(value) do
        keys[#keys + 1] = k
        values[#keys] = k:find("steamID") and v or lia.db.convertDataType(v)
    end
    return query .. table.concat(keys, ", ") .. ") VALUES (" .. table.concat(values, ", ") .. ")"
end

local function genUpdateList(value)
    local changes = {}
    for k, v in pairs(value) do
        changes[#changes + 1] = k .. " = " .. (k:find("steamID") and v or lia.db.convertDataType(v))
    end
    return table.concat(changes, ", ")
end

--[[
   Function: lia.db.insertTable

   Description:
      Inserts a new row into the specified database table with the given key-value pairs.
      The callback is invoked after the insert query is complete.

   Parameters:
      value (table) - Key-value pairs representing the columns and values to insert.
      callback (function) - The function to call when the insert operation is complete.
      dbTable (string) - The name of the table (without the 'lia_' prefix).

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.db.insertTable({_name = "John", _desc = "A character"}, function()
         print("Row inserted!")
      end, "characters")
]]
function lia.db.insertTable(value, callback, dbTable)
    local query = "INSERT INTO " .. genInsertValues(value, dbTable)
    lia.db.query(query, callback)
end

--[[
   Function: lia.db.updateTable

   Description:
      Updates one or more rows in the specified database table according to the
      provided condition. The callback is invoked once the update query finishes.

   Parameters:
      value (table) - Key-value pairs representing columns to update and their new values.
      callback (function) - The function to call after the update query is complete.
      dbTable (string) - The name of the table (without the 'lia_' prefix).
      condition (string) - The SQL condition to determine which rows to update.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.db.updateTable({_desc = "Updated character description"}, function()
         print("Character updated!")
      end, "characters", "_id = 1")
]]
function lia.db.updateTable(value, callback, dbTable, condition)
    local query = "UPDATE " .. "lia_" .. (dbTable or "characters") .. " SET " .. genUpdateList(value) .. (condition and " WHERE " .. condition or "")
    lia.db.query(query, callback)
end

--[[
   Function: lia.db.select

   Description:
      Retrieves rows from the specified database table, optionally filtered by
      a condition and limited to a specified number of results. Returns a deferred
      object that resolves with the query results.

   Parameters:
      fields (table|string) - The columns to select, either as a table or a comma-separated string.
      dbTable (string) - The name of the table (without the 'lia_' prefix).
      condition (string) - The SQL condition to filter results.
      limit (number) - Maximum number of rows to return.

   Returns:
      deferred - A deferred object that resolves to a table of results and last insert ID.

   Realm:
      Shared

   Example Usage:
      lia.db.select({"_id", "_name"}, "characters", "_faction = 'Rebels'", 10):next(function(data)
         PrintTable(data.results)
      end)
]]
function lia.db.select(fields, dbTable, condition, limit)
    local d = deferred.new()
    local from = istable(fields) and table.concat(fields, ", ") or tostring(fields)
    local tableName = "lia_" .. (dbTable or "characters")
    local query = "SELECT " .. from .. " FROM " .. tableName
    if condition then query = query .. " WHERE " .. tostring(condition) end
    if limit then query = query .. " LIMIT " .. tostring(limit) end
    lia.db.query(query, function(results, lastID)
        d:resolve({
            results = results,
            lastID = lastID
        })
    end)
    return d
end

--[[
   Function: lia.db.upsert

   Description:
      Inserts or updates a row in the specified database table. If a row with
      the same unique key exists, it updates it; otherwise, it inserts a new row.
      Returns a deferred object that resolves when the operation completes.

   Parameters:
      value (table) - Key-value pairs representing the columns and values.
      dbTable (string) - The name of the table (without the 'lia_' prefix).

   Returns:
      deferred - A deferred object that resolves to a table of results and last insert ID.

   Realm:
      Shared

   Example Usage:
      lia.db.upsert({_steamID = '12345', _name = 'Alice'}, 'players'):next(function(data)
         print("Upsert completed!")
      end)
]]
function lia.db.upsert(value, dbTable)
    local query
    if lia.db.object then
        query = "INSERT INTO " .. genInsertValues(value, dbTable) .. " ON DUPLICATE KEY UPDATE " .. genUpdateList(value)
    else
        query = "INSERT OR REPLACE INTO " .. genInsertValues(value, dbTable)
    end

    local d = deferred.new()
    lia.db.query(query, function(results, lastID)
        d:resolve({
            results = results,
            lastID = lastID
        })
    end)
    return d
end

--[[
   Function: lia.db.delete

   Description:
      Deletes rows from the specified database table that match the provided condition.
      If no condition is specified, all rows are deleted. Returns a deferred object.

   Parameters:
      dbTable (string) - The name of the table (without the 'lia_' prefix).
      condition (string) - The SQL condition that determines which rows to delete.

   Returns:
      deferred - A deferred object that resolves to the results of the deletion.

   Realm:
      Shared

   Example Usage:
      lia.db.delete("characters", "_id = 1"):next(function(data)
         print("Character deleted!")
      end)
]]
function lia.db.delete(dbTable, condition)
    local query
    dbTable = "lia_" .. (dbTable or "character")
    if condition then
        query = "DELETE FROM " .. dbTable .. " WHERE " .. condition
    else
        query = "DELETE * FROM " .. dbTable
    end

    local d = deferred.new()
    lia.db.query(query, function(results, lastID)
        d:resolve({
            results = results,
            lastID = lastID
        })
    end)
    return d
end

function lia.db.GetCharacterTable(callback)
    local query = lia.db.module == "sqlite" and "PRAGMA table_info(lia_characters)" or "DESCRIBE lia_characters"
    lia.db.query(query, function(results)
        if not results or #results == 0 then return callback({}) end
        local columns = {}
        if lia.db.module == "sqlite" then
            for _, row in ipairs(results) do
                table.insert(columns, row.name)
            end
        else
            for _, row in ipairs(results) do
                table.insert(columns, row.Field)
            end
        end

        callback(columns)
    end)
end

concommand.Add("database_list", function(ply)
    if IsValid(ply) then return end
    lia.db.GetCharacterTable(function(columns)
        if #columns == 0 then
            print("No columns found in lia_characters.")
        else
            print("Columns in lia_characters: " .. table.concat(columns, ", "))
        end
    end)
end)

function GM:RegisterPreparedStatements()
    lia.bootstrap("Database", "ADDED 5 PREPARED STATEMENTS.")
    lia.db.prepare("itemData", "UPDATE lia_items SET _data = ? WHERE _itemID = ?", {MYSQLOO_STRING, MYSQLOO_INTEGER})
    lia.db.prepare("itemx", "UPDATE lia_items SET _x = ? WHERE _itemID = ?", {MYSQLOO_INTEGER, MYSQLOO_INTEGER})
    lia.db.prepare("itemy", "UPDATE lia_items SET _y = ? WHERE _itemID = ?", {MYSQLOO_INTEGER, MYSQLOO_INTEGER})
    lia.db.prepare("itemq", "UPDATE lia_items SET _quantity = ? WHERE _itemID = ?", {MYSQLOO_INTEGER, MYSQLOO_INTEGER})
    lia.db.prepare("itemInstance", "INSERT INTO lia_items (_invID, _uniqueID, _data, _x, _y, _quantity) VALUES (?, ?, ?, ?, ?, ?)", {MYSQLOO_INTEGER, MYSQLOO_STRING, MYSQLOO_STRING, MYSQLOO_INTEGER, MYSQLOO_INTEGER, MYSQLOO_INTEGER,})
end

function GM:SetupDatabase()
    local databasePath = engine.ActiveGamemode() .. "/schema/database.lua"
    local databaseOverrideExists = file.Exists(databasePath, "LUA")
    if databaseOverrideExists then
        local databaseConfig = include(databasePath)
        if databaseConfig then
            lia.db.config = databaseConfig
            for k, v in pairs(databaseConfig) do
                lia.db[k] = v
            end
        end
    end

    if not lia.db.config then
        for k, v in pairs({
            module = "sqlite",
            hostname = "127.0.0.1",
            username = "",
            password = "",
            database = "",
            port = 3306,
        }) do
            lia.db[k] = v
        end
    end
end

function GM:DatabaseConnected()
    lia.bootstrap("Database", "Lilia has connected to the database. We are using " .. lia.db.module .. "!", Color(0, 255, 0))
end

function GM:OnMySQLOOConnected()
    hook.Run("RegisterPreparedStatements")
    MYSQLOO_PREPARED = true
end

-- ./gamemode/core/libraries/easyicons.lua
ICON_FONT = nil
local function ScrapPage()
    local d = deferred.new()
    http.Fetch('https://liliaframework.github.io/liaIcons', function(resp)
        local headpos = select(2, resp:find('<div class="row">'))
        local body = resp:sub(headpos)
        local scrapped = {}
        for str in body:gmatch('(icon-%S+);</i>') do
            local whitespaced = str:gsub('">', ' ')
            local nulled = whitespaced:gsub('&#', '0')
            local splitted = nulled:Split(' ')
            scrapped[splitted[1]] = splitted[2]
        end

        d:resolve(scrapped)
    end)
    return d
end

ScrapPage():next(function(scrapped)
    ICON_FONT = scrapped
    hook.Run("EasyIconsLoaded")
end)

function getIcon(sIcon, bIsCode)
    local iconValue = tonumber(bIsCode and sIcon or ICON_FONT[sIcon])
    if iconValue then
        local char = utf8.char(iconValue)
        return char
    end
end


-- ./gamemode/core/libraries/extended_spawnmenu.lua
local function getGameList()
    local games = engine.GetGames()
    table.insert(games, {
        title = "All",
        folder = "GAME",
        icon = "all",
        mounted = true
    })

    table.insert(games, {
        title = "Garry's Mod",
        folder = "garrysmod",
        icon = nil,
        mounted = true
    })
    return games
end

local currentSound
local function playSound(path)
    if currentSound then currentSound:Stop() end
    currentSound = CreateSound(LocalPlayer(), path)
    currentSound:Play()
end

local materialWarningShown
local function isMaterialUsable(path)
    if string.GetExtensionFromFilename(path) then return false end
    local shader = Material(path):GetShader()
    for _, s in ipairs{"LightmappedGeneric", "WorldVertexTransition", "Spritecard", "Water", "Cable", "Refract"} do
        if shader:find(s) then return false end
    end
    return true
end

local function showMaterialWarning()
    if materialWarningShown then return end
    materialWarningShown = true
    Derma_Message("Please note that not all materials are usable on entities.", "Warning", "OK")
end

local function registerContentType(typeName, setupIcon, onClick, menuEntries)
    spawnmenu.AddContentType(typeName, function(container, obj)
        if not obj.nicename or not obj.spawnname then return end
        local icon = vgui.Create("ContentIcon", container)
        icon:SetContentType(typeName)
        icon:SetSpawnName(obj.spawnname)
        icon:SetName(obj.nicename)
        setupIcon(icon, obj.spawnname)
        icon.DoClick = function() onClick(obj.spawnname) end
        icon.OpenMenu = function(icn)
            local menu = DermaMenu()
            for _, e in ipairs(menuEntries) do
                if e.spacer then
                    menu:AddSpacer()
                else
                    local txt = type(e.text) == "function" and e.text(obj.spawnname) or e.text
                    menu:AddOption(txt, function() e.action(obj.spawnname, icn) end):SetIcon(e.icon)
                end
            end

            menu:Open()
        end

        container:Add(icon)
        return icon
    end)
end

registerContentType("sound", function(icon) icon:SetMaterial("icon16/sound.png") end, playSound, {
    {
        text = "#spawnmenu.menu.copy",
        icon = "icon16/page_copy.png",
        action = function(p) SetClipboardText(p) end
    },
    {
        text = "Stop all sounds",
        icon = "icon16/sound_mute.png",
        action = function() RunConsoleCommand("stopsound") end
    },
    {
        spacer = true
    },
    {
        text = "#spawnmenu.menu.delete",
        icon = "icon16/bin_closed.png",
        action = function(_, icn)
            icn:Remove()
            hook.Run("SpawnlistContentChanged", icn)
        end
    }
})

registerContentType("material", function(icon, path)
    if path:match("%.png$") then
        icon:SetMaterial(path)
    else
        icon.Image:SetImage(path)
    end
end, function(path)
    if not isMaterialUsable(path) then showMaterialWarning() end
    RunConsoleCommand("material_override", path)
    spawnmenu.ActivateTool("material")
    surface.PlaySound("garrysmod/ui_click.wav")
end, {
    {
        text = "#spawnmenu.menu.copy",
        icon = "icon16/page_copy.png",
        action = function(p) SetClipboardText(p) end
    },
    {
        text = function(p) return isMaterialUsable(p) and "Use with Material Tool" or "Try with Material Tool (may not work)" end,
        icon = "icon16/pencil.png",
        action = function(p)
            RunConsoleCommand("material_override", p)
            spawnmenu.ActivateTool("material")
        end
    },
    {
        spacer = true
    },
    {
        text = "#spawnmenu.menu.delete",
        icon = "icon16/bin_closed.png",
        action = function(_, icn)
            icn:Remove()
            hook.Run("SpawnlistContentChanged", icn)
        end
    }
})

local function onFileNodeSelected(self, _, _)
    local view, pnl = self.ViewPanel, self.pnlContent
    view:Clear(true)
    local path, pathID = self.BasePath, self.PathID
    local files = {}
    for _, ext in ipairs(self.Extensions) do
        files = table.Add(files, file.Find(path .. "/*" .. ext, pathID))
    end

    local offset, limit = self.offset or 0, 512
    if #files > offset + limit and not self.Done then
        self.Done = true
        local newOff = offset + limit
        local page = (self.Parent or self):AddNode((self.Text or self:GetText()) .. " (" .. newOff .. " - " .. newOff + limit .. ")")
        page.ViewPanel, page.pnlContent, page.Parent, page.Text = view, pnl, self.Parent, self.Text or self:GetText()
        page.offset, page.BasePath, page.PathID, page.Extensions, page.SpawnType = newOff, path, pathID, self.Extensions, self.SpawnType
        page.OnNodeSelected = function() onFileNodeSelected(page) end
    end

    for i = offset + 1, math.min(#files, offset + limit) do
        local fname = files[i]
        local rel = path .. "/" .. fname
        if path:match("^addons/") or path:match("^download/") then
            local s = rel:find("/sound/") or rel:find("/materials/")
            if s then rel = rel:sub(s + 1) end
        end

        spawnmenu.CreateContentIcon(self.SpawnType, view, {
            spawnname = rel,
            nicename = fname
        })
    end

    pnl:SwitchPanel(view)
end

local function addBrowseContent(node, title, icon, folder, pathID, exts, spawnType)
    local view, pnl = node.ViewPanel, node.pnlContent
    local f, d = file.Find(folder, pathID)
    if not (f and #f > 0 or d and #d > 0) then return end
    local n = node:AddFolder(title, folder, pathID, false, false, "*.*")
    n:SetIcon(icon)
    n.ViewPanel, n.pnlContent = view, pnl
    n.BasePath, n.PathID, n.Extensions, n.SpawnType = folder, pathID, exts, spawnType
    n.OnNodeSelected = onFileNodeSelected
end

hook.Add("PopulateContent", "ExtendedSpawnmenuSounds", function(pnlContent, tree)
    timer.Simple(0.5, function()
        if not IsValid(tree) or not IsValid(pnlContent) then return end
        local view = vgui.Create("ContentContainer", pnlContent)
        view:SetVisible(false)
        local root = tree:AddNode("Browse Sounds", "icon16/sound.png")
        root.ViewPanel, root.pnlContent = view, pnlContent
        local addons = root:AddNode("#spawnmenu.category.addons", "icon16/folder_database.png")
        addons.ViewPanel, addons.pnlContent = view, pnlContent
        for _, a in SortedPairsByMemberValue(engine.GetAddons(), "title") do
            if a.downloaded and a.mounted and table.HasValue(select(2, file.Find("*", a.title)), "sound") then addBrowseContent(addons, a.title, "icon16/bricks.png", a.title .. "/sound", a.title, {".wav", ".mp3", ".ogg"}, "sound") end
        end

        local legacy = root:AddNode("#spawnmenu.category.addonslegacy", "icon16/folder_database.png")
        legacy.ViewPanel, legacy.pnlContent = view, pnlContent
        for _, folder in ipairs(file.Find("addons/*", "MOD")) do
            if file.IsDir("addons/" .. folder .. "/sound/", "MOD") then addBrowseContent(legacy, folder, "icon16/bricks.png", "addons/" .. folder .. "/sound", "MOD", {".wav", ".mp3", ".ogg"}, "sound") end
        end

        addBrowseContent(root, "#spawnmenu.category.downloads", "icon16/folder_database.png", "download/sound", "MOD", {".wav", ".mp3", ".ogg"}, "sound")
        local gamesNode = root:AddNode("#spawnmenu.category.games", "icon16/folder_database.png")
        gamesNode.ViewPanel, gamesNode.pnlContent = view, pnlContent
        for _, g in ipairs(getGameList()) do
            if g.mounted then addBrowseContent(gamesNode, g.title, "games/16/" .. (g.icon or g.folder) .. ".png", g.folder .. "/sound", g.folder, {".wav", ".mp3", ".ogg"}, "sound") end
        end
    end)
end)

hook.Add("PopulateContent", "ExtendedSpawnmenuMaterials", function(pnlContent, tree)
    timer.Simple(0.5, function()
        if not IsValid(tree) or not IsValid(pnlContent) then return end
        local view = vgui.Create("ContentContainer", pnlContent)
        view:SetVisible(false)
        local root = tree:AddNode("Browse Materials", "icon16/picture_empty.png")
        root.ViewPanel, root.pnlContent = view, pnlContent
        local addons = root:AddNode("#spawnmenu.category.addons", "icon16/folder_database.png")
        addons.ViewPanel, addons.pnlContent = view, pnlContent
        for _, a in SortedPairsByMemberValue(engine.GetAddons(), "title") do
            if a.downloaded and a.mounted and table.HasValue(select(2, file.Find("*", a.title)), "materials") then addBrowseContent(addons, a.title, "icon16/bricks.png", a.title .. "/materials", a.title, {".vmt", ".png"}, "material") end
        end

        local legacy = root:AddNode("#spawnmenu.category.addonslegacy", "icon16/folder_database.png")
        legacy.ViewPanel, legacy.pnlContent = view, pnlContent
        for _, folder in ipairs(file.Find("addons/*", "MOD")) do
            if file.IsDir("addons/" .. folder .. "/materials/", "MOD") then addBrowseContent(legacy, folder, "icon16/bricks.png", "addons/" .. folder .. "/materials", "MOD", {".vmt", ".png"}, "material") end
        end

        addBrowseContent(root, "#spawnmenu.category.downloads", "icon16/folder_database.png", "download/materials", "MOD", {".vmt", ".png"}, "material")
        local gamesNode = root:AddNode("#spawnmenu.category.games", "icon16/folder_database.png")
        gamesNode.ViewPanel, gamesNode.pnlContent = view, pnlContent
        for _, g in ipairs(getGameList()) do
            if g.mounted then addBrowseContent(gamesNode, g.title, "games/16/" .. (g.icon or g.folder) .. ".png", g.folder .. "/materials", g.folder, {".vmt", ".png"}, "material") end
        end
    end)
end)

hook.Add("PopulateContent", "rb655_extended_spawnmenu_entities", function(pnlContent, tree)
    local node = tree:AddNode("#spawnmenu.category.entities", "icon16/bricks.png")
    node.PropPanel = vgui.Create("ContentContainer", pnlContent)
    node.PropPanel:SetVisible(false)
    node.DoClick = function() pnlContent:SwitchPanel(node.PropPanel) end
    local categorized = {}
    for _, ent in pairs(list.Get("SpawnableEntities") or {}) do
        local cat = ent.Category or "Other"
        categorized[cat] = categorized[cat] or {}
        table.insert(categorized[cat], ent)
    end

    for catName, ents in SortedPairs(categorized) do
        local sub = node:AddNode(catName, "icon16/bricks.png")
        local panel = vgui.Create("ContentContainer", pnlContent)
        panel:SetVisible(false)
        local header = vgui.Create("ContentHeader", node.PropPanel)
        header:SetText(catName)
        node.PropPanel:Add(header)
        for _, ent in SortedPairsByMemberValue(ents, "PrintName") do
            local t = {
                nicename = ent.PrintName or ent.ClassName,
                spawnname = ent.ClassName,
                material = "entities/" .. ent.ClassName .. ".png",
                admin = ent.AdminOnly
            }

            spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "entity", panel, t)
            spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "entity", node.PropPanel, t)
        end

        sub.DoClick = function() pnlContent:SwitchPanel(panel) end
    end
end)

hook.Add("PopulateContent", "rb655_extended_spawnmenu_post_processing", function(pnlContent, tree)
    local node = tree:AddNode("#spawnmenu.category.postprocess", "icon16/picture.png")
    node.PropPanel = vgui.Create("ContentContainer", pnlContent)
    node.PropPanel:SetVisible(false)
    node.DoClick = function() pnlContent:SwitchPanel(node.PropPanel) end
    local categorized = {}
    for name, pp in pairs(list.Get("PostProcess") or {}) do
        pp.category = pp.category or "Other"
        pp.name = name
        categorized[pp.category] = categorized[pp.category] or {}
        table.insert(categorized[pp.category], pp)
    end

    for catName, pps in SortedPairs(categorized) do
        local sub = node:AddNode(catName, "icon16/picture.png")
        local panel = vgui.Create("ContentContainer", pnlContent)
        panel:SetVisible(false)
        local header = vgui.Create("ContentHeader", node.PropPanel)
        header:SetText(catName)
        node.PropPanel:Add(header)
        for _, pp in SortedPairsByMemberValue(pps, "PrintName") do
            if pp.func then
                pp.func(panel)
                pp.func(node.PropPanel)
            else
                local t = {
                    name = pp.name,
                    icon = pp.icon
                }

                spawnmenu.CreateContentIcon("postprocess", panel, t)
                spawnmenu.CreateContentIcon("postprocess", node.PropPanel, t)
            end
        end

        sub.DoClick = function() pnlContent:SwitchPanel(panel) end
    end
end)

hook.Add("PopulateContent", "rb655_extended_spawnmenu_npcs", function(pnlContent, tree)
    local node = tree:AddNode("#spawnmenu.category.npcs", "icon16/monkey.png")
    node.PropPanel = vgui.Create("ContentContainer", pnlContent)
    node.PropPanel:SetVisible(false)
    node.DoClick = function() pnlContent:SwitchPanel(node.PropPanel) end
    local cats = {}
    for className, ent in pairs(list.Get("NPC") or {}) do
        local cat = ent.Category or "Other"
        cats[cat] = cats[cat] or {}
        cats[cat][className] = ent
    end

    for catName, ents in SortedPairs(cats) do
        local sub = node:AddNode(catName, "icon16/monkey.png")
        local panel = vgui.Create("ContentContainer", pnlContent)
        panel:SetVisible(false)
        local header = vgui.Create("ContentHeader", node.PropPanel)
        header:SetText(catName)
        node.PropPanel:Add(header)
        for className, ent in SortedPairsByMemberValue(ents, "Name") do
            local t = {
                nicename = ent.Name or className,
                spawnname = className,
                material = "entities/" .. className .. ".png",
                weapon = ent.Weapons,
                admin = ent.AdminOnly
            }

            spawnmenu.CreateContentIcon("npc", panel, t)
            spawnmenu.CreateContentIcon("npc", node.PropPanel, t)
        end

        sub.DoClick = function() pnlContent:SwitchPanel(panel) end
    end
end)

hook.Add("PopulateContent", "rb655_extended_spawnmenu_vehicles", function(pnlContent, tree)
    local node = tree:AddNode("#spawnmenu.category.vehicles", "icon16/car.png")
    node.PropPanel = vgui.Create("ContentContainer", pnlContent)
    node.PropPanel:SetVisible(false)
    node.DoClick = function() pnlContent:SwitchPanel(node.PropPanel) end
    local cats = {}
    for className, v in pairs(list.Get("Vehicles") or {}) do
        v.Category = v.Category or "Other"
        v.ClassName, v.PrintName, v.ScriptedEntityType = className, v.Name, "vehicle"
        cats[v.Category] = cats[v.Category] or {}
        table.insert(cats[v.Category], v)
    end

    for catName, vs in SortedPairs(cats) do
        local sub = node:AddNode(catName, "icon16/car.png")
        local panel = vgui.Create("ContentContainer", pnlContent)
        panel:SetVisible(false)
        local header = vgui.Create("ContentHeader", node.PropPanel)
        header:SetText(catName)
        node.PropPanel:Add(header)
        for _, ent in SortedPairsByMemberValue(vs, "PrintName") do
            local t = {
                nicename = ent.PrintName or ent.ClassName,
                spawnname = ent.ClassName,
                material = "entities/" .. ent.ClassName .. ".png",
                admin = ent.AdminOnly
            }

            spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "entity", panel, t)
            spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "entity", node.PropPanel, t)
        end

        sub.DoClick = function() pnlContent:SwitchPanel(panel) end
    end
end)

hook.Add("PopulateContent", "rb655_extended_spawnmenu_weapons", function(pnlContent, tree)
    local node = tree:AddNode("#spawnmenu.category.weapons", "icon16/gun.png")
    node.PropPanel = vgui.Create("ContentContainer", pnlContent)
    node.PropPanel:SetVisible(false)
    node.DoClick = function() pnlContent:SwitchPanel(node.PropPanel) end
    local cats = {}
    for _, w in pairs(list.Get("Weapon") or {}) do
        if w.Spawnable or w.AdminSpawnable then
            local cat = w.Category or "Other"
            cats[cat] = cats[cat] or {}
            table.insert(cats[cat], w)
        end
    end

    for catName, ws in SortedPairs(cats) do
        local sub = node:AddNode(catName, "icon16/gun.png")
        local panel = vgui.Create("ContentContainer", pnlContent)
        panel:SetVisible(false)
        local header = vgui.Create("ContentHeader", node.PropPanel)
        header:SetText(catName)
        node.PropPanel:Add(header)
        for _, ent in SortedPairsByMemberValue(ws, "PrintName") do
            local t = {
                nicename = ent.PrintName or ent.ClassName,
                spawnname = ent.ClassName,
                material = "entities/" .. ent.ClassName .. ".png",
                admin = ent.AdminOnly
            }

            spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", panel, t)
            spawnmenu.CreateContentIcon(ent.ScriptedEntityType or "weapon", node.PropPanel, t)
        end

        sub.DoClick = function() pnlContent:SwitchPanel(panel) end
    end
end)

local function addRecursive(pnl, folder)
    local files, folders = file.Find(folder .. "*", "MOD")
    for _, v in ipairs(files) do
        if v:match("%.mdl$") then
            local func = spawnmenu.GetContentType("model")
            if func then
                local m = folder .. v
                m = m:match("models/.*") or m
                m = m:gsub("models/models/", "models/")
                func(pnl, {
                    model = m
                })
            end
        end
    end

    for _, d in ipairs(folders) do
        addRecursive(pnl, folder .. d .. "/")
    end
end

local function countRecursive(folder)
    local files, folders = file.Find(folder .. "*", "MOD")
    local cnt = 0
    for _, v in ipairs(files) do
        if v:match("%.mdl$") then cnt = cnt + 1 end
    end

    for _, d in ipairs(folders) do
        cnt = cnt + countRecursive(folder .. d .. "/")
    end
    return cnt
end

hook.Add("PopulateContent", "LegacyAddonProps", function(pnlContent, _, node)
    if not IsValid(node) or not IsValid(pnlContent) then return end
    local view = vgui.Create("ContentContainer", pnlContent)
    view:SetVisible(false)
    local legacy = node:AddNode("Addons - Legacy", "icon16/folder_database.png")
    for _, a in ipairs(file.Find("addons/*", "MOD")) do
        if file.IsDir("addons/" .. a .. "/models/", "MOD") then
            local c = countRecursive("addons/" .. a .. "/models/")
            if c > 0 then
                local child = legacy:AddNode(a .. " (" .. c .. ")", "icon16/bricks.png")
                child.DoClick = function()
                    view:Clear(true)
                    addRecursive(view, "addons/" .. a .. "/models/")
                    pnlContent:SwitchPanel(view)
                end
            end
        end
    end

    local f, d = file.Find("download/models", "MOD")
    if f and #f > 0 or d and #d > 0 then
        local dn = node:AddFolder("Downloads", "download/models", "MOD", false, false, "*.*")
        dn:SetIcon("icon16/folder_database.png")
        dn.OnNodeSelected = function(self)
            view:Clear(true)
            local p = self:GetFolder():match("/models/.*") or self:GetFolder()
            for _, v in ipairs(file.Find(self:GetFolder() .. "/*.mdl", self:GetPathID())) do
                local func = spawnmenu.GetContentType("model")
                if func then
                    func(view, {
                        model = p .. "/" .. v
                    })
                end
            end

            pnlContent:SwitchPanel(view)
        end
    end
end)

concommand.Add("extsm_addoninfo", function()
    local frame = vgui.Create("DFrame")
    frame:SetSize(ScrW() - 100, ScrH() - 100)
    frame:Center()
    frame:MakePopup()
    local scroll = frame:Add("DScrollPanel")
    scroll:Dock(FILL)
    scroll:Add("rb655_addonInfo")
end)

hook.Add("AddToolMenuCategories", "LegacyAddonPropsInfoCategory", function() spawnmenu.AddToolCategory("Utilities", "Robotboy655", "#Robotboy655") end)
hook.Add("PopulateToolMenu", "LegacyAddonPropsInfoThing", function()
    spawnmenu.AddToolMenuOption("Utilities", "Robotboy655", "LegacyInfoPanel", "Addon Information", "", "", function(panel)
        panel:ClearControls()
        panel:Button("Open addon data window", "extsm_addoninfo")
    end)
end)

local PANEL = {}
function PANEL:Init()
    self.computed = false
end

function PANEL:Compute()
    self.workshopSize = 0
    for _, f in ipairs(file.Find("addons/*.gma", "MOD")) do
        self.workshopSize = self.workshopSize + (file.Size("addons/" .. f, "MOD") or 0)
    end

    self.workshopWaste = 0
    self.workshopWasteFiles = {}
    for _, f in ipairs(file.Find("addons/*.gma", "MOD")) do
        local id = tonumber(f:match("_(%d+)%.gma$"))
        if id and not engine.GetAddons()[id] then
            local sz = file.Size("addons/" .. f, "MOD") or 0
            self.workshopWaste = self.workshopWaste + sz
            table.insert(self.workshopWasteFiles, {"addons/" .. f, sz})
        end
    end

    local _, addonFolders = file.Find("addons/*", "MOD")
    self.legacyAddons = {}
    for _, d in ipairs(addonFolders) do
        local path = "addons/" .. d .. "/"
        local status = "Installed"
        if file.IsDir(path .. "models/", "MOD") then status = "Installed (Has Models)" end
        local _, sub = file.Find(path .. "*", "MOD")
        if #sub < 1 then status = "Installed (Empty)" end
        if not (file.IsDir(path .. "models/", "MOD") or file.IsDir(path .. "materials/", "MOD") or file.IsDir(path .. "lua/", "MOD") or file.IsDir(path .. "sound/", "MOD")) then status = "Installed Incorrectly!" end
        self.legacyAddons[path] = status
    end

    local luaFiles = file.Find("cache/lua/*", "MOD")
    self.luaCacheFiles = #luaFiles
    self.luaCacheSize = self.luaCacheFiles * 1400
    local wsFiles = file.Find("cache/workshop/*", "MOD")
    self.wsCacheFiles = #wsFiles
    self.wsCacheSize = 0
    for _, f in ipairs(wsFiles) do
        self.wsCacheSize = self.wsCacheSize + (file.Size("cache/workshop/" .. f, "MOD") or 0)
    end

    self.computed = true
end

local function DrawText(text, font, x, y, clr)
    draw.SimpleText(text, font, x, y, clr)
    surface.SetFont(font)
    return surface.GetTextSize(text)
end

local function GetSize(bytes)
    local kb = bytes / 1000
    if kb < 1000 then return math.floor(kb * 10) / 10 .. " KB" end
    local mb = kb / 1000
    if mb < 1000 then return math.floor(mb * 10) / 10 .. " MB" end
    return math.floor(mb / 1000 * 10) / 10 .. " GB"
end

function PANEL:Paint()
    if not self.computed then self:Compute() end
    local wdt = self:GetParent():GetWide()
    local y = 0
    local _, th = DrawText("Cache Sizes", "AddonInfo_Header", 0, y, color_white)
    y = y + th
    local tw1, h1 = DrawText("~" .. GetSize(self.luaCacheSize) .. " (" .. self.luaCacheFiles .. " files)", "AddonInfo_Small", 0, y, Color(220, 220, 220))
    y = y + h1
    local tw2, h2 = DrawText("~" .. GetSize(self.wsCacheSize) .. " (" .. self.wsCacheFiles .. " files)", "AddonInfo_Small", 0, y, Color(220, 220, 220))
    y = y + h2
    local maxW = math.max(tw1, tw2) + 25
    local _, th2 = DrawText("Server Lua cache", "AddonInfo_Small", maxW, y, color_white)
    y = y + th2
    local _, th3 = DrawText("Workshop download cache", "AddonInfo_Small", maxW, y)
    y = y + th3 + ScreenScaleH(8)
    local _, th4 = DrawText("Workshop Subscriptions", "AddonInfo_Header", 0, y, color_white)
    y = y + th4
    local tw3, th5 = DrawText("Used Size:  ", "AddonInfo_Text", 0, y, color_white)
    local lblW = tw3
    y = y + th5
    local tw4, th6 = DrawText("Wasted Space:  ", "AddonInfo_Text", 0, y, color_white)
    lblW = math.max(lblW, tw4)
    y = y + th6
    local tw5, th7 = DrawText("Total Size:  ", "AddonInfo_Text", 0, y, color_white)
    lblW = math.max(lblW, tw5)
    y = y + th7 * 2
    local _, th8 = DrawText(GetSize(self.workshopSize - self.workshopWaste), "AddonInfo_Text", lblW, y, Color(220, 220, 220))
    y = y + th8
    local _, th9 = DrawText(GetSize(self.workshopWaste), "AddonInfo_Text", lblW, y, Color(220, 220, 220))
    y = y + th9
    local _, th10 = DrawText(GetSize(self.workshopSize), "AddonInfo_Text", lblW, y, Color(220, 220, 220))
    y = y + th10 * 2
    local _, th11 = DrawText("Files that aren't used: ( Safe to delete )", "AddonInfo_Text", 0, y, color_white)
    y = y + th11
    local maxW2 = 0
    for _, e in ipairs(self.workshopWasteFiles) do
        local tw6, th12 = DrawText(GetSize(e[2]) .. "    ", "AddonInfo_Small", 0, y, Color(220, 220, 220))
        maxW2 = math.max(maxW2, tw6)
        y = y + th12
    end

    y = y - #self.workshopWasteFiles * th12
    for _, e in ipairs(self.workshopWasteFiles) do
        local _, th13 = DrawText(e[1], "AddonInfo_Small", maxW2, y, color_white)
        y = y + th13
    end

    y = y + ScreenScaleH(8)
    local _, th14 = DrawText("Legacy Addons", "AddonInfo_Header", 0, y, color_white)
    y = y + th14 + ScreenScaleH(8)
    local _, th15 = DrawText("Legacy Addons with models:", "AddonInfo_Text", 0, y, color_white)
    y = y + th15
    if next(self.legacyAddons) then
        local nameW, startY = 0, y
        for p in pairs(self.legacyAddons) do
            local tw7, th16 = DrawText(p, "AddonInfo_Small", 0, y, color_white)
            nameW = math.max(nameW, tw7)
            y = y + th16
        end

        nameW = nameW + 25
        y = startY
        for _, st in pairs(self.legacyAddons) do
            local _, th17 = DrawText(st, "AddonInfo_Small", nameW, y, Color(220, 220, 220))
            y = y + th17
        end
    else
        local _, th18 = DrawText("None.", "AddonInfo_Small", 0, y, color_white)
        y = y + th18
    end

    if not system.IsWindows() then
        local _, th19 = DrawText("OSX AND LINUX USERS BEWARE:", "AddonInfo_Text", 0, y, color_white)
        y = y + th19
        local _, th20 = DrawText("MAKE SURE ALL FILE AND FOLDER NAMES", "AddonInfo_Text", 0, y, color_white)
        y = y + th20
        local _, th21 = DrawText("IN ALL ADDONS ARE LOWERCASE ONLY", "AddonInfo_Text", 0, y, color_white)
        y = y + th21
        local _, th22 = DrawText("INCLUDING ALL SUB FOLDERS", "AddonInfo_Text", 0, y, color_white)
        y = y + th22
    end

    self:SetSize(wdt, y)
end

vgui.Register("rb655_addonInfo", PANEL, "Panel")
hook.Add("PopulatePropMenu", "rb655_LoadLegacySpawnlists", function(pnl, _, node)
    if not IsValid(node) or not IsValid(pnl) then return end
    local view = vgui.Create("ContentContainer", pnl)
    view:SetVisible(false)
    local sid = 0
    for _, fn in ipairs(file.Find("settings/spawnlist/*.txt", "MOD")) do
        local content = util.KeyValuesToTable(file.Read("settings/spawnlist/" .. fn, "MOD") or "")
        if content and content.entries and not content.contents then
            local items = {}
            for _, e in ipairs(content.entries) do
                local mdl = type(e) == "table" and e.model or e
                table.insert(items, {
                    type = "model",
                    model = mdl
                })
            end

            local info = content.information or {
                name = fn
            }

            spawnmenu.AddPropCategory("settings/spawnlist/" .. fn, info.name, items, "icon16/page.png", sid + 1, sid)
            sid = sid + 1
        end
    end
end)

-- ./gamemode/core/libraries/factions.lua
lia.faction = lia.faction or {}
lia.faction.indices = lia.faction.indices or {}
lia.faction.teams = lia.faction.teams or {}
local DefaultModels = {"models/player/barney.mdl", "models/player/alyx.mdl", "models/player/breen.mdl", "models/player/p2_chell.mdl"}
--[[
   lia.faction.loadFromDir

   Description:
      Loads all Lua faction files (*.lua) from the specified directory,
      includes them as shared files, and registers the factions.
      Each faction file should define a FACTION table with properties such as name, desc, color, etc.

   Parameters:
      directory (string) - The path to the directory containing faction files.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.faction.loadFromDir("path/to/factions")
]]
function lia.faction.loadFromDir(directory)
   for _, v in ipairs(file.Find(directory .. "/*.lua", "LUA")) do
      local niceName
      if v:sub(1, 3) == "sh_" then
         niceName = v:sub(4, -5):lower()
      else
         niceName = v:sub(1, -5)
      end

      FACTION = lia.faction.teams[niceName] or {
         index = table.Count(lia.faction.teams) + 1,
         isDefault = true
      }

      if MODULE then FACTION.module = MODULE.uniqueID end
      lia.include(directory .. "/" .. v, "shared")
      if not FACTION.name then
         FACTION.name = L("unknown")
         ErrorNoHalt("Faction '" .. niceName .. "' is missing a name. You need to add a FACTION.name = \"Name\"\n")
      end

      if not FACTION.desc then
         FACTION.desc = L("noDesc")
         ErrorNoHalt("Faction '" .. niceName .. "' is missing a description. You need to add a FACTION.desc = \"Description\"\n")
      end

      if not FACTION.color then
         FACTION.color = Color(150, 150, 150)
         ErrorNoHalt("Faction '" .. niceName .. "' is missing a color. You need to add FACTION.color = Color(1, 2, 3)\n")
      end

      team.SetUp(FACTION.index, FACTION.name or L("unknown"), FACTION.color or Color(125, 125, 125))
      FACTION.models = FACTION.models or DefaultModels
      FACTION.uniqueID = FACTION.uniqueID or niceName
      for _, modelData in pairs(FACTION.models) do
         if isstring(modelData) then
            util.PrecacheModel(modelData)
         elseif istable(modelData) then
            util.PrecacheModel(modelData[1])
         end
      end

      lia.faction.indices[FACTION.index] = FACTION
      lia.faction.teams[niceName] = FACTION
      FACTION = nil
   end
end

--[[
   lia.faction.get

   Description:
      Retrieves a faction by its index or unique identifier.

   Parameters:
      identifier (number or string) - The faction's index or unique identifier.

   Returns:
      table|nil - The faction table if found; nil otherwise.

   Realm:
      Shared

   Example Usage:
      local faction = lia.faction.get("citizen")
]]
function lia.faction.get(identifier)
   return lia.faction.indices[identifier] or lia.faction.teams[identifier]
end

--[[
   lia.faction.getIndex

   Description:
      Retrieves the index of a faction by its unique identifier.

   Parameters:
      uniqueID (string) - The unique identifier of the faction.

   Returns:
      number|nil - The faction index if found; nil otherwise.

   Realm:
      Shared

   Example Usage:
      local index = lia.faction.getIndex("citizen")
]]
function lia.faction.getIndex(uniqueID)
   return lia.faction.teams[uniqueID] and lia.faction.teams[uniqueID].index
end

--[[
   lia.faction.getClasses

   Description:
      Retrieves a list of classes associated with the specified faction.

   Parameters:
      faction (string) - The faction unique identifier.

   Returns:
      table - A table containing class tables that belong to the faction.

   Realm:
      Shared

   Example Usage:
      local classes = lia.faction.getClasses("citizen")
]]
function lia.faction.getClasses(faction)
   local classes = {}
   for _, class in pairs(lia.class.list) do
      if class.faction == faction then table.insert(classes, class) end
   end
   return classes
end

--[[
   lia.faction.getPlayers

   Description:
      Retrieves all player entities whose characters belong to the specified faction.

   Parameters:
      faction (string) - The faction unique identifier.

   Returns:
      table - A table of player entities in the faction.

   Realm:
      Shared

   Example Usage:
      local players = lia.faction.getPlayers("citizen")
]]
function lia.faction.getPlayers(faction)
   local players = {}
   for _, v in player.Iterator() do
      local character = v:getChar()
      if character and character:getFaction() == faction then table.insert(players, v) end
   end
   return players
end

--[[
   lia.faction.getPlayerCount

   Description:
      Counts the number of players whose characters belong to the specified faction.

   Parameters:
      faction (string) - The faction unique identifier.

   Returns:
      number - The number of players in the faction.

   Realm:
      Shared

   Example Usage:
      local count = lia.faction.getPlayerCount("citizen")
]]
function lia.faction.getPlayerCount(faction)
   local count = 0
   for _, v in player.Iterator() do
      local character = v:getChar()
      if character and character:getFaction() == faction then count = count + 1 end
   end
   return count
end

--[[
   lia.faction.isFactionCategory

   Description:
      Checks if the specified faction is a member of a given category.
   Parameters:
      faction (string) - The faction unique identifier.
      categoryFactions (table) - A table containing faction identifiers that define the category.

   Returns:
      boolean - True if the faction is in the category; false otherwise.

   Realm:
      Shared

   Example Usage:
      local isMember = lia.faction.isFactionCategory("citizen", {"citizen", "veteran"})
]]
function lia.faction.isFactionCategory(faction, categoryFactions)
   if table.HasValue(categoryFactions, faction) then return true end
   return false
end

--[[
   lia.faction.jobGenerate

   Description:
      Generates a new faction (job) based on provided parameters.
      Creates a faction table with index, name, description, color, models, and registers it with the team system.
      Pre-caches the faction models.

   Parameters:
      index (number) - The team index for the faction.
      name (string) - The faction name.
      color (Color) - The faction color.
      default (boolean) - Whether the faction is default.
      models (table) - A table of model paths or model data for the faction.

   Returns:
      table - The newly generated faction table.

   Realm:
      Shared

   Example Usage:
      local faction = lia.faction.jobGenerate(2, "Police", Color(0, 0, 255), false, {"models/player/police.mdl"})
]]
function lia.faction.jobGenerate(index, name, color, default, models)
   local FACTION = {}
   FACTION.index = index
   FACTION.isDefault = default
   FACTION.name = name
   FACTION.desc = ""
   FACTION.color = color
   FACTION.models = models or DefaultModels
   FACTION.uniqueID = FACTION.uniqueID or name
   for _, v in pairs(FACTION.models) do
      if isstring(v) then
         util.PrecacheModel(v)
      elseif istable(v) then
         util.PrecacheModel(v[1])
      end
   end

   lia.faction.indices[FACTION.index] = FACTION
   lia.faction.teams[name] = FACTION
   team.SetUp(FACTION.index, FACTION.name, FACTION.color)
   return FACTION
end

local function formatModelDataEntry(name, faction, modelIndex, modelData, category)
   local newGroups
   if istable(modelData) and modelData[3] then
      local groups = {}
      if istable(modelData[3]) then
         local dummy
         if SERVER then
            dummy = ents.Create("prop_physics")
            dummy:SetModel(modelData[1])
         else
            dummy = ClientsideModel(modelData[1])
         end

         local groupData = dummy:GetBodyGroups()
         for _, group in ipairs(groupData) do
            if group.id > 0 then
               if modelData[3][group.id] then
                  groups[group.id] = modelData[3][group.id]
               elseif modelData[3][group.name] then
                  groups[group.id] = modelData[3][group.name]
               end
            end
         end

         dummy:Remove()
         newGroups = groups
      elseif isstring(modelData[3]) then
         newGroups = string.Explode("", modelData[3])
      end
   end

   if newGroups then
      if category then
         lia.faction.teams[name].models[category][modelIndex][3] = newGroups
         lia.faction.indices[faction.index].models[category][modelIndex][3] = newGroups
      else
         lia.faction.teams[name].models[modelIndex][3] = newGroups
         lia.faction.indices[faction.index].models[modelIndex][3] = newGroups
      end
   end
end

--[[
   lia.faction.formatModelData

   Description:
      Processes and formats model data for all registered factions.
      Iterates through each faction's model data and applies formatting to ensure proper grouping.

   Parameters:
      None

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.faction.formatModelData()
]]
function lia.faction.formatModelData()
   for name, faction in pairs(lia.faction.teams) do
      if faction.models then
         for modelIndex, modelData in pairs(faction.models) do
            if isstring(modelIndex) then
               for subIndex, subData in pairs(modelData) do
                  formatModelDataEntry(name, faction, subIndex, subData, modelIndex)
               end
            else
               formatModelDataEntry(name, faction, modelIndex, modelData)
            end
         end
      end
   end
end

--[[
   lia.faction.getCategories

   Description:
      Retrieves a list of model categories for a given faction.
      Categories are determined by keys in the faction's models table that are strings.

   Parameters:
      teamName (string) - The unique identifier of the faction.

   Returns:
      table - A list of category names.

   Realm:
      Shared

   Example Usage:
      local categories = lia.faction.getCategories("citizen")
]]
function lia.faction.getCategories(teamName)
   local categories = {}
   local faction = lia.faction.teams[teamName]
   if faction and faction.models then
      for key, _ in pairs(faction.models) do
         if isstring(key) then table.insert(categories, key) end
      end
   end
   return categories
end

--[[
   lia.faction.getModelsFromCategory

   Description:
      Retrieves models from a specified category for a given faction.

   Parameters:
      teamName (string) - The unique identifier of the faction.
      category (string) - The model category to retrieve.

   Returns:
      table - A table of models in the specified category.

   Realm:
      Shared

   Example Usage:
      local models = lia.faction.getModelsFromCategory("citizen", "special")
]]
function lia.faction.getModelsFromCategory(teamName, category)
   local models = {}
   local faction = lia.faction.teams[teamName]
   if faction and faction.models and faction.models[category] then
      for index, model in pairs(faction.models[category]) do
         models[index] = model
      end
   end
   return models
end

--[[
   lia.faction.getDefaultClass

   Description:
      Retrieves the default class for a specified faction.
      Searches through the class list for the first class that is marked as default for the faction.

   Parameters:
      id (string) - The unique identifier of the faction.

   Returns:
      table|nil - The default class table if found; nil otherwise.

   Realm:
      Shared

   Example Usage:
      local defaultClass = lia.faction.getDefaultClass("citizen")
]]
function lia.faction.getDefaultClass(id)
   local defaultClass = nil
   for _, class in ipairs(lia.class.list) do
      if class.faction == id and class.isDefault then
         defaultClass = class
         break
      end
   end
   return defaultClass
end

if CLIENT then
   --[[
      lia.faction.hasWhitelist

      Description:
         Determines if the local player has whitelist access for a given faction.
         Checks the local whitelist data against the faction's uniqueID.

      Parameters:
         faction (string) - The unique identifier of the faction.

      Returns:
         boolean - True if the player is whitelisted; false otherwise.

      Realm:
         Client

      Example Usage:
         local whitelisted = lia.faction.hasWhitelist("citizen")
   ]]
   function lia.faction.hasWhitelist(faction)
      local data = lia.faction.indices[faction]
      if data then
         if data.isDefault then return true end
         local liaData = lia.localData and lia.localData.whitelists or {}
         return liaData[SCHEMA.folder] and liaData[SCHEMA.folder][data.uniqueID] or false
      end
      return false
   end
end

-- ./gamemode/core/libraries/flags.lua
lia.flag = lia.flag or {}
lia.flag.list = lia.flag.list or {}
--[[
   lia.flag.add

   Description:
      Registers a new flag by adding it to the flag list.
      Each flag has a description and an optional callback that is executed when the flag is applied to a player.

   Parameters:
      flag (string) - The unique flag identifier.
      desc (string) - A description of what the flag does.
      callback (function) - An optional callback function executed when the flag is applied to a player.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.flag.add("C", "Spawn vehicles.")
]]
function lia.flag.add(flag, desc, callback)
    if lia.flag.list[flag] then return end
    lia.flag.list[flag] = {
        desc = desc,
        callback = callback
    }
end

if SERVER then
    --[[
      lia.flag.onSpawn

      Description:
         Called when a player spawns. This function checks the player's character flags and triggers
         the associated callbacks for each flag that the character possesses.

      Parameters:
         client (Player) - The player who spawned.

      Returns:
         nil

      Realm:
         Server

      Example Usage:
         lia.flag.onSpawn(player)
]]
    function lia.flag.onSpawn(client)
        if client:getChar() then
            local flags = client:getChar():getFlags()
            for i = 1, #flags do
                local flag = flags:sub(i, i)
                local info = lia.flag.list[flag]
                if info and info.callback then info.callback(client, true) end
            end
        end
    end
end

lia.flag.add("C", L("flagSpawnVehicles"))
lia.flag.add("z", L("flagSpawnSweps"))
lia.flag.add("E", L("flagSpawnSents"))
lia.flag.add("L", L("flagSpawnEffects"))
lia.flag.add("r", L("flagSpawnRagdolls"))
lia.flag.add("e", L("flagSpawnProps"))
lia.flag.add("n", L("flagSpawnNpcs"))
lia.flag.add("p", L("flagPhysgun"), function(client, isGiven)
    if isGiven then
        client:Give("weapon_physgun")
        client:SelectWeapon("weapon_physgun")
    else
        client:StripWeapon("weapon_physgun")
    end
end)

lia.flag.add("t", L("flagToolgun"), function(client, isGiven)
    if isGiven then
        client:Give("gmod_tool")
        client:SelectWeapon("gmod_tool")
    else
        client:StripWeapon("gmod_tool")
    end
end)

hook.Add("CreateInformationButtons", "CreateInformationMenuFlags", function(pages)
    local client = LocalPlayer()
    table.insert(pages, {
        name = L("flags"),
        drawFunc = function(panel)
            local searchEntry = vgui.Create("DTextEntry", panel)
            searchEntry:Dock(TOP)
            searchEntry:SetTall(30)
            searchEntry:SetPlaceholderText(L("searchFlags"))
            local scroll = vgui.Create("DScrollPanel", panel)
            scroll:Dock(FILL)
            local canvas = scroll:GetCanvas()
            local function refresh()
                canvas:Clear()
                local filter = searchEntry:GetValue():lower()
                for flagName, flagData in SortedPairs(lia.flag.list) do
                    if isnumber(flagName) then continue end
                    local nameLower = flagName:lower()
                    local descLower = (flagData.desc or ""):lower()
                    if filter ~= "" and not (nameLower:find(filter, 1, true) or descLower:find(filter, 1, true)) then continue end
                    local hasDesc = flagData.desc and flagData.desc ~= ""
                    local height = hasDesc and 80 or 40
                    local flagPanel = vgui.Create("DPanel", canvas)
                    flagPanel:Dock(TOP)
                    flagPanel:DockMargin(10, 5, 10, 0)
                    flagPanel:SetTall(height)
                    flagPanel.Paint = function(_, w, h)
                        local hasFlag = client:getChar():hasFlags(flagName)
                        local status = hasFlag and "" or ""
                        local statusColor = hasFlag and Color(0, 255, 0) or Color(255, 0, 0)
                        draw.RoundedBox(4, 0, 0, w, h, Color(40, 40, 40, 200))
                        draw.SimpleText("Flag '" .. flagName .. "'", "liaMediumFont", 20, 10, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
                        draw.SimpleText(status, "liaHugeFont", w - 20, h / 2, statusColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
                        if hasDesc then draw.SimpleText(flagData.desc, "liaSmallFont", 20, 45, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP) end
                    end
                end
            end

            searchEntry.OnTextChanged = refresh
            refresh()
        end
    })
end)

-- ./gamemode/core/libraries/fonts.lua
lia.font = lia.font or {}
lia.font.stored = lia.font.stored or {}
if CLIENT then
    function lia.font.register(fontName, fontData)
        if not (isstring(fontName) and istable(fontData)) then return lia.error("[Font] Invalid font name or data provided.") end
        surface.CreateFont(fontName, fontData)
    end

    local oldCreateFont = surface.CreateFont
    surface.CreateFont = function(name, data)
        if isstring(name) and istable(data) then lia.font.stored[name] = data end
        oldCreateFont(name, data)
    end

    lia.font.register("AddonInfo_Header", {
        font = "Helvetica",
        size = ScreenScaleH(24),
        weight = 1000
    })

    lia.font.register("AddonInfo_Text", {
        font = "Helvetica",
        size = ScreenScaleH(9),
        weight = 1000
    })

    lia.font.register("AddonInfo_Small", {
        font = "Helvetica",
        size = ScreenScaleH(8),
        weight = 1000
    })

    lia.font.register("ConfigFont", {
        font = lia.config.get("Font"),
        size = 26,
        weight = 500,
        extended = true,
        antialias = true
    })

    lia.font.register("MediumConfigFont", {
        font = lia.config.get("Font"),
        size = 30,
        weight = 1000,
        extended = true,
        antialias = true
    })

    lia.font.register("SmallConfigFont", {
        font = lia.config.get("Font"),
        size = math.max(ScreenScale(8), 20),
        weight = 500,
        extended = true,
        antialias = true
    })

    lia.font.register("ConfigFontBold", {
        font = lia.config.get("Font"),
        size = 26,
        weight = 1000,
        extended = true,
        antialias = true
    })

    lia.font.register("ConfigFontLarge", {
        font = lia.config.get("Font"),
        size = 36,
        weight = 700,
        extended = true,
        antialias = true
    })

    lia.font.register("DescriptionFontLarge", {
        font = lia.config.get("Font"),
        size = 24,
        weight = 500,
        extended = true,
        antialias = true
    })

    lia.font.register("ticketsystem", {
        font = lia.config.get("Font"),
        size = 15,
        weight = 400
    })

    lia.font.register("VendorButtonFont", {
        font = lia.config.get("Font"),
        weight = 200,
        size = 40
    })

    lia.font.register("VendorMediumFont", {
        font = lia.config.get("Font"),
        weight = 500,
        size = 22
    })

    lia.font.register("VendorSmallFont", {
        font = lia.config.get("Font"),
        weight = 500,
        size = 22
    })

    lia.font.register("VendorTinyFont", {
        font = lia.config.get("Font"),
        weight = 500,
        size = 15
    })

    lia.font.register("VendorLightFont", {
        font = lia.config.get("Font"),
        weight = 200,
        size = 22
    })

    lia.font.register("VendorItemNameFont", {
        font = lia.config.get("Font"),
        size = 24,
        weight = 700
    })

    lia.font.register("VendorItemDescFont", {
        font = lia.config.get("Font"),
        size = 18,
        weight = 500
    })

    lia.font.register("VendorItemStatsFont", {
        font = lia.config.get("Font"),
        size = 16,
        weight = 500
    })

    lia.font.register("VendorItemPriceFont", {
        font = lia.config.get("Font"),
        size = 20,
        weight = 600
    })

    lia.font.register("VendorActionButtonFont", {
        font = lia.config.get("Font"),
        size = 18,
        weight = 600
    })

    lia.font.register("liaCharLargeFont", {
        font = lia.config.get("GenericFont"),
        size = 36 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 700,
        antialias = true
    })

    lia.font.register("liaCharMediumFont", {
        font = lia.config.get("GenericFont"),
        size = 28 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 600,
        antialias = true
    })

    lia.font.register("liaCharSmallFont", {
        font = lia.config.get("GenericFont"),
        size = 20 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 500,
        antialias = true
    })

    lia.font.register("liaCharSubTitleFont", {
        font = lia.config.get("GenericFont"),
        size = 16 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 500,
        antialias = true
    })

    lia.font.register("DarkSkinSmall", {
        font = "Roboto",
        size = 14,
        weight = 400
    })

    lia.font.register("Roboto.20", {
        font = "Roboto",
        size = 20
    })

    lia.font.register("Roboto.15", {
        font = "Roboto",
        size = 15
    })

    lia.font.register("Roboto.22", {
        font = "Roboto",
        size = 22
    })

    lia.font.register("DarkSkinRegular", {
        font = "Roboto",
        size = 18,
        weight = 400
    })

    lia.font.register("DarkSkinMedium", {
        font = "Roboto",
        size = 24,
        weight = 400
    })

    lia.font.register("DarkSkinLarge", {
        font = "Roboto",
        size = 32,
        weight = 400
    })

    lia.font.register("DarkSkinHuge", {
        font = "Roboto",
        size = 56,
        weight = 400
    })

    lia.font.register("lia3D2DFont", {
        font = lia.config.get("Font"),
        size = 2048,
        extended = true,
        weight = 1000
    })

    lia.font.register("liaTitleFont", {
        font = lia.config.get("Font"),
        size = ScreenScaleH(30) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaSubTitleFont", {
        font = lia.config.get("Font"),
        size = ScreenScaleH(18) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 500
    })

    lia.font.register("liaSubTitleFont", {
        font = lia.config.get("Font"),
        size = ScreenScaleH(18) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 500
    })

    lia.font.register("liaBigTitle", {
        font = lia.config.get("Font"),
        size = 30,
        weight = 800
    })

    lia.font.register("liaBigText", {
        font = lia.config.get("Font"),
        size = 26,
        weight = 600
    })

    lia.font.register("liaHugeText", {
        font = lia.config.get("Font"),
        size = 48,
        weight = 600
    })

    lia.font.register("liaBigBtn", {
        font = lia.config.get("Font"),
        size = 28,
        weight = 900
    })

    lia.font.register("liaMenuButtonFont", {
        font = lia.config.get("Font"),
        size = ScreenScaleH(14),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaMenuButtonLightFont", {
        font = lia.config.get("Font"),
        size = ScreenScaleH(14) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 200
    })

    lia.font.register("liaToolTipText", {
        font = lia.config.get("Font"),
        size = 20,
        extended = true,
        weight = 500
    })

    lia.font.register("liaDynFontSmall", {
        font = lia.config.get("Font"),
        size = ScreenScaleH(22) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaDynFontMedium", {
        font = lia.config.get("Font"),
        size = ScreenScaleH(28) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaDynFontBig", {
        font = lia.config.get("Font"),
        size = ScreenScaleH(48) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaCleanTitleFont", {
        font = lia.config.get("GenericFont"),
        size = 200 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaHugeFont", {
        font = lia.config.get("GenericFont"),
        size = 72 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaBigFont", {
        font = lia.config.get("GenericFont"),
        size = 36 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaMediumFont", {
        font = lia.config.get("GenericFont"),
        size = 25 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaSmallFont", {
        font = lia.config.get("GenericFont"),
        size = math.max(ScreenScaleH(6), 17) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 500
    })

    lia.font.register("liaMiniFont", {
        font = lia.config.get("GenericFont"),
        size = math.max(ScreenScaleH(5), 14) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 400
    })

    lia.font.register("liaMediumLightFont", {
        font = lia.config.get("GenericFont"),
        size = 25 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 200
    })

    lia.font.register("liaGenericFont", {
        font = lia.config.get("GenericFont"),
        size = 20 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 1000
    })

    lia.font.register("liaGenericLightFont", {
        font = lia.config.get("GenericFont"),
        size = 20 * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 500
    })

    lia.font.register("liaChatFont", {
        font = lia.config.get("GenericFont"),
        size = math.max(ScreenScaleH(7), 17) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 200
    })

    lia.font.register("liaChatFontItalics", {
        font = lia.config.get("GenericFont"),
        size = math.max(ScreenScaleH(7), 17) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 200,
        italic = true
    })

    lia.font.register("liaChatFontBold", {
        font = lia.config.get("GenericFont"),
        size = math.max(ScreenScaleH(7), 17) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 800
    })

    lia.font.register("liaItemDescFont", {
        font = lia.config.get("GenericFont"),
        size = math.max(ScreenScaleH(6), 17) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        shadow = true,
        weight = 500
    })

    lia.font.register("liaSmallBoldFont", {
        font = lia.config.get("GenericFont"),
        size = math.max(ScreenScaleH(8), 20) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 800
    })

    lia.font.register("liaItemBoldFont", {
        font = lia.config.get("GenericFont"),
        shadow = true,
        size = math.max(ScreenScaleH(8), 20) * math.min(ScrW() / 1920, ScrH() / 1080),
        extended = true,
        weight = 800
    })

    lia.font.register("liaIconsSmall", {
        font = "nsicons",
        size = 22,
        extended = true,
        weight = 500
    })

    lia.font.register("liaIconsMedium", {
        font = "nsicons",
        extended = true,
        size = 28,
        weight = 500
    })

    lia.font.register("liaIconsBig", {
        font = "nsicons",
        extended = true,
        size = 48,
        weight = 500
    })

    lia.font.register("liaIconsSmallNew", {
        font = "nsicons",
        size = 22,
        extended = true,
        weight = 500
    })

    lia.font.register("liaIconsMediumNew", {
        font = "nsicons",
        extended = true,
        size = 28,
        weight = 500
    })

    lia.font.register("liaIconsBigNew", {
        font = "nsicons",
        extended = true,
        size = 48,
        weight = 500
    })

    lia.font.register("liaIconsHugeNew", {
        font = "nsicons",
        extended = true,
        size = 78,
        weight = 500
    })

    lia.font.register("liaNoticeFont", {
        font = lia.config.get("GenericFont"),
        size = 22,
        weight = 500,
        extended = true,
        antialias = true
    })

    lia.font.register("roboto", {
        font = "Roboto Bold",
        extended = false,
        size = 25,
        weight = 700,
        blursize = 0,
        scanlines = 0,
        antialias = true,
        underline = false,
        italic = false,
        strikeout = false,
        symbol = false,
        rotary = false,
        shadow = false,
        additive = false,
        outline = false
    })

    lia.font.register("roboton", {
        font = "Roboto",
        extended = false,
        size = 19,
        weight = 700,
        blursize = 0,
        scanlines = 0,
        antialias = true,
        underline = false,
        italic = false,
        strikeout = false,
        symbol = false,
        rotary = false,
        shadow = false,
        additive = false,
        outline = false
    })

    lia.font.register("robotoBig", {
        font = "Roboto Bold",
        extended = false,
        size = 36,
        weight = 0,
        blursize = 0,
        scanlines = 0,
        antialias = true,
        underline = false,
        italic = false,
        strikeout = false,
        symbol = false,
        rotary = false,
        shadow = false,
        additive = false,
        outline = false
    })

    lia.font.register("robotoBig2", {
        font = "Roboto Bold",
        extended = false,
        size = 150,
        weight = 0,
        blursize = 0,
        scanlines = 0,
        antialias = true,
        underline = false,
        italic = false,
        strikeout = false,
        symbol = false,
        rotary = false,
        shadow = false,
        additive = false,
        outline = false
    })

    local cs = ScrH() / 1080
    lia.font.register("liaCharTitleFont", {
        font = lia.config.get("Font"),
        weight = 200,
        size = math.floor(70 * cs + 10),
        additive = true
    })

    lia.font.register("liaCharDescFont", {
        font = lia.config.get("Font"),
        weight = 200,
        size = math.floor(24 * cs + 10),
        additive = true
    })

    lia.font.register("liaCharSubTitleFont", {
        font = lia.config.get("Font"),
        weight = 200,
        size = math.floor(12 * cs + 10),
        additive = true
    })

    lia.font.register("liaCharButtonFont", {
        font = lia.config.get("Font"),
        weight = 200,
        size = math.floor(24 * cs + 10),
        additive = true
    })

    lia.font.register("liaCharSmallButtonFont", {
        font = lia.config.get("Font"),
        weight = 200,
        size = math.floor(22 * cs + 10),
        additive = true
    })

    function lia.font.getAvailableFonts()
        local list = {}
        for name in pairs(lia.font.stored) do
            list[#list + 1] = name
        end

        table.sort(list)
        return list
    end
end

lia.config.add("Font", "Font", "Arial", nil, {
    desc = "Specifies the core font used for UI elements.",
    category = "Visuals",
    type = "Table",
    options = CLIENT and lia.font.getAvailableFonts() or {"Arial"}
})

lia.config.add("GenericFont", "Generic Font", "Segoe UI", nil, {
    desc = "Specifies the secondary font used for UI elements.",
    category = "Visuals",
    type = "Table",
    options = CLIENT and lia.font.getAvailableFonts() or {"Arial"}
})

hook.Run("PostLoadFonts", lia.config.get("Font"), lia.config.get("GenericFont"))

-- ./gamemode/core/libraries/inventory.lua
lia.inventory = lia.inventory or {}
lia.inventory.types = lia.inventory.types or {}
lia.inventory.instances = lia.inventory.instances or {}
local function serverOnly(value)
    return SERVER and value or nil
end

local InvTypeStructType = {
    __index = "table",
    add = serverOnly("function"),
    remove = serverOnly("function"),
    sync = serverOnly("function"),
    typeID = "string",
    className = "string"
}

local function checkType(typeID, struct, expected, prefix)
    prefix = prefix or ""
    for key, expectedType in pairs(expected) do
        local actualValue = struct[key]
        local expectedTypeString = isstring(expectedType) and expectedType or type(expectedType)
        assert(type(actualValue) == expectedTypeString, "expected type of " .. prefix .. key .. " to be " .. expectedTypeString .. " for inventory type " .. typeID .. ", got " .. type(actualValue))
        if istable(expectedType) then checkType(typeID, actualValue, expectedType, prefix .. key .. ".") end
    end
end

--[[
   Function: lia.inventory.newType

   Description:
      Registers a new inventory type.

   Parameters:
      typeID (string)  unique identifier
      invTypeStruct (table)  definition matching InvTypeStructType

   Returns:
      nil
]]
function lia.inventory.newType(typeID, invTypeStruct)
    assert(not lia.inventory.types[typeID], "duplicate inventory type " .. typeID)
    assert(istable(invTypeStruct), "expected table for argument #2")
    checkType(typeID, invTypeStruct, InvTypeStructType)
    debug.getregistry()[invTypeStruct.className] = invTypeStruct
    lia.inventory.types[typeID] = invTypeStruct
end

--[[
   Function: lia.inventory.new

   Description:
      Instantiates a new inventory instance.

   Parameters:
      typeID (string)

   Returns:
      table
]]
function lia.inventory.new(typeID)
    local class = lia.inventory.types[typeID]
    assert(class ~= nil, "bad inventory type " .. typeID)
    return setmetatable({
        items = {},
        config = table.Copy(class.config)
    }, class)
end

if SERVER then
    local INV_FIELDS = {"_invID", "_invType", "_charID"}
    local INV_TABLE = "inventories"
    local DATA_FIELDS = {"_key", "_value"}
    local DATA_TABLE = "invdata"
    local ITEMS_TABLE = "items"
    --[[
      Function: lia.inventory.loadByID

      Description:
         Loads an inventory by ID (cached or via custom loader).

      Parameters:
         id (number), noCache? (boolean)

      Returns:
         deferred
   ]]
    function lia.inventory.loadByID(id, noCache)
        local instance = lia.inventory.instances[id]
        if instance and not noCache then
            local d = deferred.new()
            d:resolve(instance)
            return d
        end

        for _, invType in pairs(lia.inventory.types) do
            local loadFunction = rawget(invType, "loadFromStorage")
            if loadFunction then
                local d = loadFunction(invType, id)
                if d then return d end
            end
        end

        assert(isnumber(id) and id >= 0, "No inventories implement loadFromStorage for ID " .. tostring(id))
        return lia.inventory.loadFromDefaultStorage(id, noCache)
    end

    --[[
      Function: lia.inventory.loadFromDefaultStorage

      Description:
         Default database loader.

      Parameters:
         id (number), noCache? (boolean)

      Returns:
         deferred
   ]]
    function lia.inventory.loadFromDefaultStorage(id, noCache)
        return deferred.all({lia.db.select(INV_FIELDS, INV_TABLE, "_invID = " .. id, 1), lia.db.select(DATA_FIELDS, DATA_TABLE, "_invID = " .. id)}):next(function(res)
            if lia.inventory.instances[id] and not noCache then return lia.inventory.instances[id] end
            local results = res[1].results and res[1].results[1] or nil
            if not results then return end
            local typeID = results._invType
            local invType = lia.inventory.types[typeID]
            if not invType then
                ErrorNoHalt("Inventory " .. id .. " has invalid type " .. typeID .. "\n")
                return
            end

            local instance = invType:new()
            instance.id = id
            instance.data = {}
            for _, row in ipairs(res[2].results or {}) do
                local decoded = util.JSONToTable(row._value)
                instance.data[row._key] = decoded and decoded[1] or nil
            end

            instance.data.char = tonumber(results._charID) or instance.data.char
            lia.inventory.instances[id] = instance
            instance:onLoaded()
            return instance:loadItems():next(function() return instance end)
        end, function(err)
            LiliaInformation("Failed to load inventory " .. tostring(id))
            LiliaInformation(err)
        end)
    end

    --[[
      Function: lia.inventory.instance

      Description:
         Creates & persists a new inventory instance.

      Parameters:
         typeID (string), initialData? (table)

      Returns:
         deferred
   ]]
    function lia.inventory.instance(typeID, initialData)
        local invType = lia.inventory.types[typeID]
        assert(istable(invType), "invalid inventory type " .. tostring(typeID))
        assert(initialData == nil or istable(initialData), "initialData must be a table for lia.inventory.instance")
        initialData = initialData or {}
        return invType:initializeStorage(initialData):next(function(id)
            local instance = invType:new()
            instance.id = id
            instance.data = initialData
            lia.inventory.instances[id] = instance
            instance:onInstanced()
            return instance
        end)
    end

    --[[
      Function: lia.inventory.loadAllFromCharID

      Description:
         Loads all inventories for a character.

      Parameters:
         charID (number)

      Returns:
         deferred
   ]]
    function lia.inventory.loadAllFromCharID(charID)
        assert(isnumber(charID), "charID must be a number")
        return lia.db.select({"_invID"}, INV_TABLE, "_charID = " .. charID):next(function(res) return deferred.map(res.results or {}, function(result) return lia.inventory.loadByID(tonumber(result._invID)) end) end)
    end

    --[[
      Function: lia.inventory.deleteByID

      Description:
         Deletes an inventory and its data.

      Parameters:
         id (number)

      Returns:
         nil
   ]]
    function lia.inventory.deleteByID(id)
        lia.db.delete(DATA_TABLE, "_invID = " .. id)
        lia.db.delete(INV_TABLE, "_invID = " .. id)
        lia.db.delete(ITEMS_TABLE, "_invID = " .. id)
        local instance = lia.inventory.instances[id]
        if instance then instance:destroy() end
    end

    --[[
      Function: lia.inventory.cleanUpForCharacter

      Description:
         Destroys all inventories for a character.

      Parameters:
         character

      Returns:
         nil
   ]]
    function lia.inventory.cleanUpForCharacter(character)
        for _, inventory in pairs(character:getInv(true)) do
            inventory:destroy()
        end
    end
else
    --[[
      Function: lia.inventory.show

      Description:
         Displays inventory UI clientside.

      Parameters:
         inventory, parent

      Returns:
         Panel
   ]]
    function lia.inventory.show(inventory, parent)
        local globalName = "inv" .. inventory.id
        if IsValid(lia.gui[globalName]) then lia.gui[globalName]:Remove() end
        local panel = hook.Run("CreateInventoryPanel", inventory, parent)
        lia.gui[globalName] = panel
        return panel
    end
end

-- ./gamemode/core/libraries/item.lua
lia.item = lia.item or {}
lia.item.base = lia.item.base or {}
lia.item.list = lia.item.list or {}
lia.item.instances = lia.item.instances or {}
lia.item.inventories = lia.inventory.instances or {}
lia.item.inventoryTypes = lia.item.inventoryTypes or {}
local DefaultFunctions = {
   drop = {
      tip = "dropTip",
      icon = "icon16/world.png",
      onRun = function(item)
         local client = item.player
         item:removeFromInventory(true):next(function() item:spawn(client) end)
         return false
      end,
      onCanRun = function(item) return item.entity == nil and not IsValid(item.entity) and not item.noDrop end
   },
   take = {
      tip = "takeTip",
      icon = "icon16/box.png",
      onRun = function(item)
         local client = item.player
         local inventory = client:getChar():getInv()
         local entity = item.entity
         if client.itemTakeTransaction and client.itemTakeTransactionTimeout > RealTime() then return false end
         client.itemTakeTransaction = true
         client.itemTakeTransactionTimeout = RealTime()
         if not inventory then return false end
         local d = deferred.new()
         inventory:add(item):next(function()
            client.itemTakeTransaction = nil
            if IsValid(entity) then
               entity.liaIsSafe = true
               entity:Remove()
            end

            if not IsValid(client) then return end
            d:resolve()
         end):catch(function(err)
            if err == "noFit" then
               client:notify("This item can't fit in your inventory. (" .. item.width .. "x" .. item.height .. ")")
            else
               client:notifyLocalized(err)
            end

            client.itemTakeTransaction = nil
            d:reject()
         end)
         return d
      end,
      onCanRun = function(item) return IsValid(item.entity) end
   },
   giveForward = {
      tip = "giveForwardTip",
      icon = "icon16/arrow_up.png",
      onRun = function(item)
         local function canTransferItemsFromInventoryUsingGiveForward(_, action, _)
            if action == "transfer" then return true end
         end

         local client = item.player
         local inv = client:getChar():getInv()
         local target = client:GetEyeTraceNoCursor().Entity
         if not (target and target:IsValid() and target:IsPlayer() and target:Alive() and client:GetPos():DistToSqr(target:GetPos()) < 6500) then return false end
         local targetInv = target:getChar():getInv()
         if not target or not targetInv then return false end
         inv:addAccessRule(canTransferItemsFromInventoryUsingGiveForward)
         targetInv:addAccessRule(canTransferItemsFromInventoryUsingGiveForward)
         client:setAction("Giving " .. item.name .. " to " .. target:Name(), lia.config.get("ItemGiveSpeed", 6))
         target:setAction(client:Name() .. " is giving you a " .. item.name, lia.config.get("ItemGiveSpeed", 6))
         client:doStaredAction(target, function()
            local res = hook.Run("HandleItemTransferRequest", client, item:getID(), nil, nil, targetInv:getID())
            if not res then return end
            res:next(function()
               if not IsValid(client) then return end
               if istable(res) and isstring(res.error) then return client:notifyLocalized(res.error) end
               client:EmitSound("physics/cardboard/cardboard_box_impact_soft2.wav", 50)
            end)
         end, lia.config.get("ItemGiveSpeed", 6), function() client:setAction() end, 100)
         return false
      end,
      onCanRun = function(item)
         local client = item.player
         local target = client:GetEyeTraceNoCursor().Entity
         return item.entity == nil and lia.config.get("ItemGiveEnabled") and not IsValid(item.entity) and not item.noDrop and target and IsValid(target) and target:IsPlayer() and target:Alive() and client:GetPos():DistToSqr(target:GetPos()) < 6500
      end
   }
}

lia.meta.item.width = 1
lia.meta.item.height = 1
--[[
   lia.item.get

   Description:
      Retrieves an item definition by its identifier, checking both lia.item.base and lia.item.list.

   Parameters:
      identifier (string) - The unique identifier of the item.

   Returns:
      The item table if found, otherwise nil.

   Realm:
      Shared

   Example Usage:
      local itemDef = lia.item.get("testItem")
]]
function lia.item.get(identifier)
   return lia.item.base[identifier] or lia.item.list[identifier]
end

--[[
   lia.item.getItemByID

   Description:
      Retrieves an item instance by its numeric item ID. Also determines whether it's in an inventory
      or in the world.

   Parameters:
      itemID (number) - The numeric item ID.

   Returns:
      A table containing 'item' (the item object) and 'location' (the string location) if found,
      otherwise nil and an error message.

   Realm:
      Shared

   Example Usage:
      local result = lia.item.getItemByID(42)
      if result then
          print("Item location: " .. result.location)
      end
]]
function lia.item.getItemByID(itemID)
   assert(isnumber(itemID), "itemID must be a number")
   local item = lia.item.instances[itemID]
   if not item then return nil, "Item not found" end
   local location = "unknown"
   if item.invID then
      local inventory = lia.item.getInv(item.invID)
      if inventory then location = "inventory" end
   elseif item.entity and IsValid(item.entity) then
      location = "world"
   end
   return {
      item = item,
      location = location
   }
end

--[[
   lia.item.getInstancedItemByID

   Description:
      Retrieves the item instance table itself by its numeric ID without additional location info.

   Parameters:
      itemID (number) - The numeric item ID.

   Returns:
      The item instance table if found, otherwise nil and an error message.

   Realm:
      Shared

   Example Usage:
      local itemInstance = lia.item.getInstancedItemByID(42)
      if itemInstance then
          print("Got item: " .. itemInstance.name)
      end
]]
function lia.item.getInstancedItemByID(itemID)
   assert(isnumber(itemID), "itemID must be a number")
   local item = lia.item.instances[itemID]
   if not item then return nil, "Item not found" end
   return item
end

--[[
   lia.item.getItemDataByID

   Description:
      Retrieves the 'data' table of an item instance by its numeric item ID.

   Parameters:
      itemID (number) - The numeric item ID.

   Returns:
      The data table if found, otherwise nil and an error message.

   Realm:
      Shared

   Example Usage:
      local data = lia.item.getItemDataByID(42)
      if data then
          print("Item data found.")
      end
]]
function lia.item.getItemDataByID(itemID)
   assert(isnumber(itemID), "itemID must be a number")
   local item = lia.item.instances[itemID]
   if not item then return nil, "Item not found" end
   return item.data
end

--[[
   lia.item.load

   Description:
      Processes the item file path to generate a uniqueID, and calls lia.item.register
      to register the item. Used for loading items from directory structures.

   Parameters:
      path (string) - The path to the Lua file for the item.
      baseID (string) - The base item's uniqueID to inherit from.
      isBaseItem (boolean) - Whether this item is a base item.

   Returns:
      None

   Realm:
      Shared

   Example Usage:
      lia.item.load("items/base/sh_item_base.lua", nil, true)
]]
function lia.item.load(path, baseID, isBaseItem)
   local uniqueID = path:match("sh_([_%w]+)%.lua") or path:match("([_%w]+)%.lua")
   if uniqueID then
      uniqueID = (isBaseItem and "base_" or "") .. uniqueID
      lia.item.register(uniqueID, baseID, isBaseItem, path)
   elseif not path:find(".txt") then
      ErrorNoHalt("[Lilia] Item at '" .. path .. "' follows an invalid naming convention!\n")
   end
end

--[[
   lia.item.isItem

   Description:
      Checks if the given object is recognized as an item (via isItem flag).

   Parameters:
      object (any) - The object to check.

   Returns:
      true if the object is an item, false otherwise.

   Realm:
      Shared

   Example Usage:
      local result = lia.item.isItem(myObject)
      if result then
          print("It's an item!")
      end
]]
function lia.item.isItem(object)
   return istable(object) and object.isItem
end

--[[
   lia.item.getInv

   Description:
      Retrieves an inventory table by its ID from lia.item.inventories.

   Parameters:
      id (number) - The ID of the inventory to retrieve.

   Returns:
      The inventory table if found, otherwise nil.

   Realm:
      Shared

   Example Usage:
      local inv = lia.item.getInv(5)
      if inv then
          print("Got inventory with ID 5")
      end
]]
function lia.item.getInv(invID)
   return lia.inventory.instances[invID]
end

--[[
   lia.item.register

   Description:
      Registers a new item or base item with a unique ID. This sets up the meta table
      and merges data from the specified base. Optionally includes the file if provided.

   Parameters:
      uniqueID (string) - The unique identifier for the item.
      baseID (string) - The unique identifier of the base item.
      isBaseItem (boolean) - Whether this should be registered as a base item.
      path (string) - The optional path to the item file for inclusion.
      luaGenerated (boolean) - True if the item is generated in code without file.

   Returns:
      The registered item table.

   Realm:
      Shared

   Example Usage:
      lia.item.register("special_item", "base_item", false, "path/to/item.lua")
]]
function lia.item.register(uniqueID, baseID, isBaseItem, path, luaGenerated)
   assert(isstring(uniqueID), "uniqueID must be a string")
   local baseTable = lia.item.base[baseID] or lia.meta.item
   if baseID then assert(baseTable, "Item " .. uniqueID .. " has a non-existent base " .. baseID) end
   local targetTable = isBaseItem and lia.item.base or lia.item.list
   if luaGenerated then
      ITEM = setmetatable({
         hooks = table.Copy(baseTable.hooks or {}),
         postHooks = table.Copy(baseTable.postHooks or {}),
         BaseClass = baseTable,
         __tostring = baseTable.__tostring,
      }, {
         __eq = baseTable.__eq,
         __tostring = baseTable.__tostring,
         __index = baseTable
      })

      ITEM.__tostring = baseTable.__tostring
      ITEM.desc = "noDesc"
      ITEM.uniqueID = uniqueID
      ITEM.base = baseID
      ITEM.isBase = isBaseItem
      ITEM.category = ITEM.category or "Miscellaneous"
      ITEM.functions = table.Copy(baseTable.functions or DefaultFunctions)
   else
      ITEM = targetTable[uniqueID] or setmetatable({
         hooks = table.Copy(baseTable.hooks or {}),
         postHooks = table.Copy(baseTable.postHooks or {}),
         BaseClass = baseTable,
         __tostring = baseTable.__tostring,
      }, {
         __eq = baseTable.__eq,
         __tostring = baseTable.__tostring,
         __index = baseTable
      })

      ITEM.__tostring = baseTable.__tostring
      ITEM.desc = "noDesc"
      ITEM.uniqueID = uniqueID
      ITEM.base = baseID
      ITEM.isBase = isBaseItem
      ITEM.category = ITEM.category or "Miscellaneous"
      ITEM.functions = ITEM.functions or table.Copy(baseTable.functions or DefaultFunctions)
   end

   if not luaGenerated and path then lia.include(path, "shared") end
   ITEM:onRegistered()
   local itemType = ITEM.uniqueID
   targetTable[itemType] = ITEM
   hook.Run("OnItemRegistered", ITEM)
   ITEM = nil
   return targetTable[itemType]
end

--[[
   lia.item.loadFromDir

   Description:
      Loads item Lua files from a specified directory. Base items are loaded first,
      then any folders (with base_ prefix usage), and finally any loose Lua files.

   Parameters:
      directory (string) - The path to the directory containing item files.

   Returns:
      None

   Realm:
      Shared

   Example Usage:
      lia.item.loadFromDir("lilia/gamemode/items")
]]
function lia.item.loadFromDir(directory)
   local files, folders
   files = file.Find(directory .. "/base/*.lua", "LUA")
   for _, v in ipairs(files) do
      lia.item.load(directory .. "/base/" .. v, nil, true)
   end

   files, folders = file.Find(directory .. "/*", "LUA")
   for _, v in ipairs(folders) do
      if v == "base" then continue end
      for _, v2 in ipairs(file.Find(directory .. "/" .. v .. "/*.lua", "LUA")) do
         lia.item.load(directory .. "/" .. v .. "/" .. v2, "base_" .. v, nil, false)
      end
   end

   for _, v in ipairs(files) do
      lia.item.load(directory .. "/" .. v)
   end

   hook.Run("InitializedItems")
end

--[[
   lia.item.new

   Description:
      Creates an item instance (not in the database) from a registered item definition.
      The new item is stored in lia.item.instances using the provided item ID.

   Parameters:
      uniqueID (string) - The unique identifier of the item definition.
      id (number) - The numeric ID for this new item instance.

   Returns:
      The newly created item instance.

   Realm:
      Shared

   Example Usage:
      local newItem = lia.item.new("testItem", 101)
      print(newItem.id) -- 101
]]
function lia.item.new(uniqueID, id)
   id = id and tonumber(id) or id
   assert(isnumber(id), "non-number ID given to lia.item.new")
   if lia.item.instances[id] and lia.item.instances[id].uniqueID == uniqueID then return lia.item.instances[id] end
   local stockItem = lia.item.list[uniqueID]
   if stockItem then
      local item = setmetatable({
         id = id,
         data = {}
      }, {
         __eq = stockItem.__eq,
         __tostring = stockItem.__tostring,
         __index = stockItem
      })

      lia.item.instances[id] = item
      return item
   else
      error("[Lilia] Attempt to create an unknown item '" .. tostring(uniqueID) .. "'\n")
   end
end

--[[
   lia.item.registerInv

   Description:
      Registers an inventory type with a given width and height. The inventory type
      becomes accessible for creation or usage in the system.

   Parameters:
      invType (string) - The inventory type name (identifier).
      w (number) - The width of this inventory type.
      h (number) - The height of this inventory type.

   Returns:
      None

   Realm:
      Shared

   Example Usage:
      lia.item.registerInv("smallInv", 4, 4)
]]
function lia.item.registerInv(invType, w, h)
   local GridInv = FindMetaTable("GridInv")
   assert(GridInv, "GridInv not found")
   local inventory = GridInv:extend("GridInv" .. invType)
   inventory.invType = invType
   function inventory:getWidth()
      return w
   end

   function inventory:getHeight()
      return h
   end

   inventory:register(invType)
end

--[[
   lia.item.newInv

   Description:
      Asynchronously creates a new inventory (with a specific invType) and associates it
      with the given character owner. Once created, it syncs the inventory to the owner if online.

   Parameters:
      owner (number) - The character ID who owns this inventory.
      invType (string) - The inventory type (must be registered first).
      callback (function) - Optional callback function receiving the new inventory.

   Returns:
      None (asynchronous, uses a deferred internally).

   Realm:
      Shared

   Example Usage:
      lia.item.newInv(10, "smallInv", function(inventory)
          print("New inventory created:", inventory.id)
      end)
]]
function lia.item.newInv(owner, invType, callback)
   lia.inventory.instance(invType, {
      char = owner
   }):next(function(inventory)
      inventory.invType = invType
      if owner and owner > 0 then
         for _, v in player.Iterator() do
            if v:getChar() and v:getChar():getID() == owner then
               inventory:sync(v)
               break
            end
         end
      end

      if callback then callback(inventory) end
   end)
end

--[[
   lia.item.createInv

   Description:
      Creates a new GridInv instance with a specified width, height, and ID,
      then caches it in lia.inventory.instances.

   Parameters:
      w (number) - The width of the inventory.
      h (number) - The height of the inventory.
      id (number) - The numeric ID to assign to this inventory.

   Returns:
      The newly created GridInv instance.

   Realm:
      Shared

   Example Usage:
      local inv = lia.item.createInv(6, 6, 200)
      print("Created inventory with ID:", inv.id)
]]
function lia.item.createInv(w, h, id)
   local GridInv = FindMetaTable("GridInv")
   assert(GridInv, "GridInv not found")
   local instance = GridInv:new()
   instance.id = id
   instance.data = {
      w = w,
      h = h
   }

   lia.inventory.instances[id] = instance
   return instance
end

if SERVER then
   --[[
       lia.item.setItemDataByID

       Description:
          Sets a specific key-value in the data table of an item instance by its numeric ID.
          Optionally notifies receivers about the change.

       Parameters:
          itemID (number) - The numeric item ID.
          key (string) - The data key to set.
          value (any) - The value to set for the specified key.
          receivers (table) - Optional table of players to receive the update.
          noSave (boolean) - If true, won't save the data to the database immediately.
          noCheckEntity (boolean) - If true, won't check if the item entity is valid.

       Returns:
          true if successful, false and error message if item not found.

       Realm:
          Server

       Example Usage:
          local success, err = lia.item.setItemDataByID(50, "durability", 90)
          if not success then
              print("Error:", err)
          end
    ]]
   function lia.item.setItemDataByID(itemID, key, value, receivers, noSave, noCheckEntity)
      assert(isnumber(itemID), "itemID must be a number")
      assert(isstring(key), "key must be a string")
      local item = lia.item.instances[itemID]
      if not item then return false, "Item not found" end
      item:setData(key, value, receivers, noSave, noCheckEntity)
      return true
   end

   --[[
       lia.item.instance

       Description:
          Asynchronously creates a new item in the database, optionally assigned to an inventory.
          Once the item is created, a new item object is constructed and returned via a deferred.

       Parameters:
          index (number) - The inventory ID to place the item into (or 0/NULL if none).
          uniqueID (string) - The item definition's unique ID.
          itemData (table) - The data table to store on the item.
          x (number) - Optional grid X position (for grid inventories).
          y (number) - Optional grid Y position.
          callback (function) - Optional callback with the newly created item.

       Returns:
          A deferred object that resolves to the new item.

       Realm:
          Server

       Example Usage:
          lia.item.instance(1, "testItem", {someKey = "someValue"}):next(function(item)
              print("Item created with ID:", item.id)
          end)
    ]]
   function lia.item.instance(index, uniqueID, itemData, x, y, callback)
      if isstring(index) and (istable(uniqueID) or itemData == nil and x == nil) then
         itemData = uniqueID
         uniqueID = index
      end

      local d = deferred.new()
      local itemTable = lia.item.list[uniqueID]
      if not itemTable then
         d:reject("Attempt to instantiate invalid item " .. tostring(uniqueID))
         return d
      end

      if not istable(itemData) then itemData = {} end
      if isnumber(itemData.x) then
         x = itemData.x
         itemData.x = nil
      end

      if isnumber(itemData.y) then
         y = itemData.y
         itemData.y = nil
      end

      local function onItemCreated(_, itemID)
         local item = lia.item.new(uniqueID, itemID)
         if item then
            item.data = itemData
            item.invID = index
            item.data.x = x
            item.data.y = y
            item.quantity = itemTable.maxQuantity
            if callback then callback(item) end
            d:resolve(item)
            item:onInstanced(index, x, y, item)
         end
      end

      if not isnumber(index) then index = NULL end
      if MYSQLOO_PREPARED and isnumber(index) then
         lia.db.preparedCall("itemInstance", onItemCreated, index, uniqueID, itemData, x, y, itemTable.maxQuantity or 1)
      else
         lia.db.insertTable({
            _invID = index,
            _uniqueID = uniqueID,
            _data = itemData,
            _x = x,
            _y = y,
            _quantity = itemTable.maxQuantity or 1
         }, onItemCreated, "items")
      end
      return d
   end

   --[[
       lia.item.deleteByID

       Description:
          Deletes an item from the system (database and memory) by its numeric ID.

       Parameters:
          id (number) - The numeric item ID to delete.

       Returns:
          None

       Realm:
          Server

       Example Usage:
          lia.item.deleteByID(42)
    ]]
   function lia.item.deleteByID(id)
      if lia.item.instances[id] then
         lia.item.instances[id]:delete()
      else
         lia.db.delete("items", "_itemID = " .. id)
      end
   end

   --[[
       lia.item.loadItemByID

       Description:
          Loads items from the database by a given ID or set of IDs, creating the corresponding
          item instances in memory. This is commonly used during inventory or character loading.

       Parameters:
          itemIndex (number or table) - Either a single numeric item ID or a table of numeric item IDs.

       Returns:
          None (asynchronous query).

       Realm:
          Server

       Example Usage:
          lia.item.loadItemByID(42)
          -- or
          lia.item.loadItemByID({10, 11, 12})
    ]]
   function lia.item.loadItemByID(itemIndex)
      local range
      if istable(itemIndex) then
         range = "(" .. table.concat(itemIndex, ", ") .. ")"
      elseif isnumber(itemIndex) then
         range = "(" .. itemIndex .. ")"
      else
         return
      end

      lia.db.query("SELECT _itemID, _uniqueID, _data, _x, _y, _quantity FROM lia_items WHERE _itemID IN " .. range, function(data)
         if data then
            for _, v in ipairs(data) do
               local itemID = tonumber(v._itemID)
               local data = util.JSONToTable(v._data or "[]")
               local uniqueID = v._uniqueID
               local itemTable = lia.item.list[uniqueID]
               if itemTable and itemID then
                  local item = lia.item.new(uniqueID, itemID)
                  item.invID = 0
                  item.data = data or {}
                  item.data.x = tonumber(v._x)
                  item.data.y = tonumber(v._y)
                  item.quantity = tonumber(v._quantity)
                  item:onRestored()
               end
            end
         end
      end)
   end

   --[[
       lia.item.spawn

       Description:
          Creates a new item instance (not in an inventory) and spawns a corresponding
          entity in the world at the specified position/angles.

       Parameters:
          uniqueID (string) - The unique ID of the item definition.
          position (Vector) - The spawn position in the world.
          callback (function) - Optional callback when the item and entity are created.
          angles (Angle) - Optional spawn angles.
          data (table) - Additional data to set on the item.

       Returns:
          A deferred object if callback is not given, otherwise none.

       Realm:
          Server

       Example Usage:
          lia.item.spawn("testItem", Vector(0,0,0)):next(function(item)
              print("Spawned item entity with ID:", item.id)
          end)
    ]]
   function lia.item.spawn(uniqueID, position, callback, angles, data)
      local d
      if not isfunction(callback) then
         if isangle(callback) == "Angle" or istable(angles) then
            angles = callback
            data = angles
         end

         d = deferred.new()
         callback = function(item) d:resolve(item) end
      end

      lia.item.instance(0, uniqueID, data or {}, 1, 1, function(item)
         local entity = item:spawn(position, angles)
         if callback then callback(item, entity) end
      end)
      return d
   end

   --[[
       lia.item.restoreInv

       Description:
          Restores an existing inventory by loading it through lia.inventory.loadByID,
          then sets its width/height data, optionally providing a callback once loaded.

       Parameters:
          invID (number) - The inventory ID to restore.
          w (number) - Width to set for the inventory.
          h (number) - Height to set for the inventory.
          callback (function) - Optional function to call once the inventory is restored.

       Returns:
          None (asynchronous call).

       Realm:
          Server

       Example Usage:
          lia.item.restoreInv(101, 5, 5, function(inv)
              print("Restored inventory with ID 101.")
          end)
    ]]
   function lia.item.restoreInv(invID, w, h, callback)
      lia.inventory.loadByID(invID):next(function(inventory)
         if not inventory then return end
         inventory:setData("w", w)
         inventory:setData("h", h)
         if callback then callback(inventory) end
      end)
   end
end

lia.item.loadFromDir("lilia/gamemode/items")

-- ./gamemode/core/libraries/keybind.lua
lia.keybind = lia.keybind or {}
lia.keybind.stored = lia.keybind.stored or {}
local KeybindKeys = {
    ["first"] = KEY_FIRST,
    ["none"] = KEY_NONE,
    ["0"] = KEY_0,
    ["1"] = KEY_1,
    ["2"] = KEY_2,
    ["3"] = KEY_3,
    ["4"] = KEY_4,
    ["5"] = KEY_5,
    ["6"] = KEY_6,
    ["7"] = KEY_7,
    ["8"] = KEY_8,
    ["9"] = KEY_9,
    ["a"] = KEY_A,
    ["b"] = KEY_B,
    ["c"] = KEY_C,
    ["d"] = KEY_D,
    ["e"] = KEY_E,
    ["f"] = KEY_F,
    ["g"] = KEY_G,
    ["h"] = KEY_H,
    ["i"] = KEY_I,
    ["j"] = KEY_J,
    ["k"] = KEY_K,
    ["l"] = KEY_L,
    ["m"] = KEY_M,
    ["n"] = KEY_N,
    ["o"] = KEY_O,
    ["p"] = KEY_P,
    ["q"] = KEY_Q,
    ["r"] = KEY_R,
    ["s"] = KEY_S,
    ["t"] = KEY_T,
    ["u"] = KEY_U,
    ["v"] = KEY_V,
    ["w"] = KEY_W,
    ["x"] = KEY_X,
    ["y"] = KEY_Y,
    ["z"] = KEY_Z,
    ["kp_0"] = KEY_PAD_0,
    ["kp_1"] = KEY_PAD_1,
    ["kp_2"] = KEY_PAD_2,
    ["kp_3"] = KEY_PAD_3,
    ["kp_4"] = KEY_PAD_4,
    ["kp_5"] = KEY_PAD_5,
    ["kp_6"] = KEY_PAD_6,
    ["kp_7"] = KEY_PAD_7,
    ["kp_8"] = KEY_PAD_8,
    ["kp_9"] = KEY_PAD_9,
    ["kp_divide"] = KEY_PAD_DIVIDE,
    ["kp_multiply"] = KEY_PAD_MULTIPLY,
    ["kp_minus"] = KEY_PAD_MINUS,
    ["kp_plus"] = KEY_PAD_PLUS,
    ["kp_enter"] = KEY_PAD_ENTER,
    ["kp_decimal"] = KEY_PAD_DECIMAL,
    ["lbracket"] = KEY_LBRACKET,
    ["rbracket"] = KEY_RBRACKET,
    ["semicolon"] = KEY_SEMICOLON,
    ["apostrophe"] = KEY_APOSTROPHE,
    ["backquote"] = KEY_BACKQUOTE,
    ["comma"] = KEY_COMMA,
    ["period"] = KEY_PERIOD,
    ["slash"] = KEY_SLASH,
    ["backslash"] = KEY_BACKSLASH,
    ["minus"] = KEY_MINUS,
    ["equal"] = KEY_EQUAL,
    ["enter"] = KEY_ENTER,
    ["space"] = KEY_SPACE,
    ["backspace"] = KEY_BACKSPACE,
    ["tab"] = KEY_TAB,
    ["capslock"] = KEY_CAPSLOCK,
    ["numlock"] = KEY_NUMLOCK,
    ["escape"] = KEY_ESCAPE,
    ["scrolllock"] = KEY_SCROLLLOCK,
    ["insert"] = KEY_INSERT,
    ["delete"] = KEY_DELETE,
    ["home"] = KEY_HOME,
    ["end"] = KEY_END,
    ["pageup"] = KEY_PAGEUP,
    ["pagedown"] = KEY_PAGEDOWN,
    ["break"] = KEY_BREAK,
    ["lshift"] = KEY_LSHIFT,
    ["rshift"] = KEY_RSHIFT,
    ["lalt"] = KEY_LALT,
    ["ralt"] = KEY_RALT,
    ["lctrl"] = KEY_LCONTROL,
    ["rctrl"] = KEY_RCONTROL,
    ["lwin"] = KEY_LWIN,
    ["rwin"] = KEY_RWIN,
    ["app"] = KEY_APP,
    ["up"] = KEY_UP,
    ["left"] = KEY_LEFT,
    ["down"] = KEY_DOWN,
    ["right"] = KEY_RIGHT,
    ["f1"] = KEY_F1,
    ["f2"] = KEY_F2,
    ["f3"] = KEY_F3,
    ["f4"] = KEY_F4,
    ["f5"] = KEY_F5,
    ["f6"] = KEY_F6,
    ["f7"] = KEY_F7,
    ["f8"] = KEY_F8,
    ["f9"] = KEY_F9,
    ["f10"] = KEY_F10,
    ["f11"] = KEY_F11,
    ["f12"] = KEY_F12,
    ["capslocktoggle"] = KEY_CAPSLOCKTOGGLE,
    ["numlocktoggle"] = KEY_NUMLOCKTOGGLE,
    ["scrolllocktoggle"] = KEY_SCROLLLOCKTOGGLE,
    ["last"] = KEY_LAST
}

--[[
   lia.keybind.add

   Description:
      Registers a new keybind for a given action.
      Converts the provided key identifier to its corresponding key constant (if it's a string),
      and stores the keybind settings including the default key, press callback, and release callback.
      Also maps the key code back to the action identifier for reverse lookup.

   Parameters:
      k (string or number) - The key identifier, either as a string (to be converted) or as a key code.
      d (string) - The unique identifier for the keybind action.
      cb (function) - The callback function to be executed when the key is pressed.
      rcb (function) - The callback function to be executed when the key is released.

   Returns:
      nil

   Realm:
      Client

   Example Usage:
      lia.keybind.add("space", "jump", function() print("Jump pressed!") end, function() print("Jump released!") end)
]]
function lia.keybind.add(k, d, cb, rcb)
    local c = isstring(k) and KeybindKeys[string.lower(k)] or k
    if not c then return end
    lia.keybind.stored[d] = lia.keybind.stored[d] or {}
    if not lia.keybind.stored[d].value then lia.keybind.stored[d].value = c end
    lia.keybind.stored[d].default = c
    lia.keybind.stored[d].callback = cb
    lia.keybind.stored[d].release = rcb
    lia.keybind.stored[c] = d
end

--[[
   lia.keybind.get

   Description:
      Retrieves the current key code for a specified keybind action.
      If the keybind has a set value, that value is returned; otherwise, it falls back to the default key
      or an optionally provided fallback value.

   Parameters:
      a (string) - The unique identifier for the keybind action.
      df (number) - An optional default key code to return if the keybind is not set.

   Returns:
      number - The key code associated with the keybind action, or the default/fallback value if not set.

   Realm:
      Client

   Example Usage:
      local jumpKey = lia.keybind.get("jump", KEY_SPACE)
]]
function lia.keybind.get(a, df)
    local act = lia.keybind.stored[a]
    if act then return act.value or act.default or df end
    return df
end

--[[
   lia.keybind.save

   Description:
      Saves the current keybind settings to a file.
      The function creates a directory specific to the active gamemode, constructs a filename based on the server's IP address,
      and writes the keybind mapping (action identifiers to key codes) in JSON format.

   Parameters:
      None

   Returns:
      nil

   Realm:
      Client

   Internal Function:
      true

   Example Usage:
      lia.keybind.save()
]]
function lia.keybind.save()
    local dp = "lilia/keybinds/" .. engine.ActiveGamemode()
    file.CreateDir(dp)
    local ip = string.Explode(":", game.GetIPAddress())[1]
    local f = ip:gsub("%.", "_")
    local s = dp .. "/" .. f .. ".txt"
    local d = {}
    for k, v in pairs(lia.keybind.stored) do
        if istable(v) and v.value then d[k] = v.value end
    end

    local j = util.TableToJSON(d, true)
    if j then file.Write(s, j) end
end

--[[
   lia.keybind.load

   Description:
      Loads keybind settings from a file.
      The function reads a JSON file from a gamemode-specific directory, applies the saved keybind values to the stored keybinds,
      and if no saved file is found, it resets the keybinds to their default values and saves them.
      It also sets up a reverse mapping from key codes to keybind action identifiers.
      Finally, it triggers the "InitializedKeybinds" hook.

   Parameters:
      None

   Returns:
      nil

   Realm:
      Client

   Internal Function:
      true

   Example Usage:
      lia.keybind.load()
]]
function lia.keybind.load()
    local dp = "lilia/keybinds/" .. engine.ActiveGamemode()
    file.CreateDir(dp)
    local ip = string.Explode(":", game.GetIPAddress())[1]
    local f = ip:gsub("%.", "_")
    local l = dp .. "/" .. f .. ".txt"
    local d = file.Read(l, "DATA")
    if d then
        local s = util.JSONToTable(d)
        for k, v in pairs(s) do
            if lia.keybind.stored[k] then lia.keybind.stored[k].value = v end
        end
    else
        for _, v in pairs(lia.keybind.stored) do
            if istable(v) and v.default then v.value = v.default end
        end

        lia.keybind.save()
    end

    for action, data in pairs(lia.keybind.stored) do
        if istable(data) and data.value then lia.keybind.stored[data.value] = action end
    end

    hook.Run("InitializedKeybinds")
end

hook.Add("PlayerButtonDown", "liaKeybindPress", function(p, b)
    local action = lia.keybind.stored[b]
    if not IsFirstTimePredicted() then return end
    if action and lia.keybind.stored[action] and lia.keybind.stored[action].callback then lia.keybind.stored[action].callback(p) end
end)

hook.Add("PlayerButtonUp", "liaKeybindRelease", function(p, b)
    local action = lia.keybind.stored[b]
    if not IsFirstTimePredicted() then return end
    if action and lia.keybind.stored[action] and lia.keybind.stored[action].release then lia.keybind.stored[action].release(p) end
end)

hook.Add("PopulateConfigurationButtons", "PopulateKeybinds", function(pages)
    local function buildKeybinds(parent)
        parent:Clear()
        local container = parent:Add("DPanel")
        container:Dock(FILL)
        local allowEdit = lia.config.get("AllowKeybindEditing", true)
        local searchEntry, scroll
        local function populateRows(filter)
            scroll:Clear()
            if not istable(lia.keybind.stored) then return end
            local taken = {}
            for action, data in pairs(lia.keybind.stored) do
                if istable(data) and data.value then taken[data.value] = action end
            end

            local sortedActions = {}
            for action, data in pairs(lia.keybind.stored) do
                if istable(data) and (filter == "" or tostring(action):lower():find(filter, 1, true)) then sortedActions[#sortedActions + 1] = action end
            end

            table.sort(sortedActions, function(a, b) return tostring(a) < tostring(b) end)
            for _, action in ipairs(sortedActions) do
                local data = lia.keybind.stored[action]
                local row = scroll:Add("DPanel")
                row:Dock(TOP)
                row:DockMargin(4, 4, 4, 4)
                row:SetTall(50)
                local lbl = row:Add("DLabel")
                lbl:Dock(LEFT)
                lbl:SetWide(300)
                lbl:SetFont("liaBigFont")
                lbl:SetText(action)
                local currentKey = lia.keybind.get(action, KEY_NONE)
                if allowEdit then
                    local combo = row:Add("DComboBox")
                    combo:Dock(RIGHT)
                    combo:SetWide(200)
                    combo:SetFont("liaMediumFont")
                    combo:SetValue(input.GetKeyName(currentKey) or "NONE")
                    local choices = {}
                    for name, code in pairs(KeybindKeys) do
                        if not taken[code] or code == currentKey then
                            choices[#choices + 1] = {
                                txt = input.GetKeyName(code) or name,
                                keycode = code
                            }
                        end
                    end

                    table.sort(choices, function(a, b) return a.txt < b.txt end)
                    for _, c in ipairs(choices) do
                        combo:AddChoice(c.txt, c.keycode)
                    end

                    combo.OnSelect = function(_, _, _, newKey)
                        if not newKey then return end
                        for tk, tv in pairs(taken) do
                            if tk == newKey and tv ~= action then
                                combo:SetValue(input.GetKeyName(currentKey) or "NONE")
                                return
                            end
                        end

                        taken[currentKey] = nil
                        if lia.keybind.stored[currentKey] then lia.keybind.stored[currentKey] = nil end
                        data.value = newKey
                        lia.keybind.stored[newKey] = action
                        taken[newKey] = action
                        lia.keybind.save()
                        currentKey = newKey
                    end
                else
                    local textLabel = row:Add("DLabel")
                    textLabel:Dock(LEFT)
                    textLabel:SetWide(300)
                    textLabel:SetFont("liaBigFont")
                    textLabel:SetText(input.GetKeyName(currentKey) or "NONE")
                end
            end
        end

        if allowEdit then
            local resetAllBtn = container:Add("DButton")
            resetAllBtn:Dock(TOP)
            resetAllBtn:SetTall(30)
            resetAllBtn:SetText(L("resetAllKeybinds"))
            resetAllBtn.DoClick = function()
                for action, data in pairs(lia.keybind.stored) do
                    if istable(data) and data.default then
                        if lia.keybind.stored[data.value] then lia.keybind.stored[data.value] = nil end
                        data.value = data.default
                        lia.keybind.stored[data.default] = action
                    end
                end

                lia.keybind.save()
                populateRows(searchEntry:GetValue():lower())
            end
        end

        searchEntry = container:Add("DTextEntry")
        searchEntry:Dock(TOP)
        searchEntry:SetTall(30)
        searchEntry:SetPlaceholderText("Search keybinds...")
        searchEntry.OnTextChanged = function() populateRows(searchEntry:GetValue():lower()) end
        scroll = container:Add("DScrollPanel")
        scroll:Dock(FILL)
        populateRows("")
    end

    pages[#pages + 1] = {
        name = L("keybinds"),
        drawFunc = buildKeybinds
    }
end)

lia.keybind.add(KEY_I, "Open Inventory", function()
    local f1Menu = vgui.Create("liaMenu")
    f1Menu:setActiveTab("inv")
end)

lia.keybind.add(KEY_T, "Quick Take Item", function()
    local client = LocalPlayer()
    if not client:getChar() or vgui.CursorVisible() then return end
    local ent = client:getTracedEntity()
    if IsValid(ent) and ent:isItem() then netstream.Start("invAct", "take", ent) end
end)

lia.keybind.add(KEY_NONE, "Admin Mode", function() lia.command.send("adminmode") end)

-- ./gamemode/core/libraries/languages.lua
lia.lang = lia.lang or {}
lia.lang.names = lia.lang.names or {}
lia.lang.stored = lia.lang.stored or {}
--[[
   lia.lang.loadFromDir

   Description:
      Loads all Lua language files (*.lua) from the specified directory,
      includes them as shared files, and merges any defined LANGUAGE table
      into the stored language data. If a language name (NAME) is provided in the file,
      it is registered in lia.lang.names.

   Parameters:
      directory (string) - The path to the directory containing language files.

   Returns:
      nil

   Realm:
      Shared

   Internal Function:
      true

   Example Usage:
      lia.lang.loadFromDir("path/to/languages")
]]
function lia.lang.loadFromDir(directory)
    for _, v in ipairs(file.Find(directory .. "/*.lua", "LUA")) do
        local niceName
        if v:sub(1, 3) == "sh_" then
            niceName = v:sub(4, -5):lower()
        else
            niceName = v:sub(1, -5):lower()
        end

        lia.include(directory .. "/" .. v, "shared")
        if LANGUAGE then
            if NAME then
                lia.lang.names[niceName] = NAME
                NAME = nil
            end

            lia.lang.stored[niceName] = table.Merge(lia.lang.stored[niceName] or {}, LANGUAGE)
            LANGUAGE = nil
        end
    end
end

--[[
   lia.lang.AddTable

   Description:
      Adds or merges a table of language key-value pairs into the stored language table
      for a specified language. If the language already exists in the storage, the new values
      will be merged with the existing ones.

   Parameters:
      name (string) - The name of the language to update.
      tbl (table) - A table containing language key-value pairs to add.

   Returns:
      nil

   Realm:
      Shared

   Example Usage:
      lia.lang.AddTable("english", { greeting = "Hello", farewell = "Goodbye" })
]]
function lia.lang.AddTable(name, tbl)
    local lowerName = name:lower()
    lia.lang.stored[lowerName] = lia.lang.stored[lowerName] or {}
    for k, v in pairs(tbl) do
        lia.lang.stored[lowerName][k] = v
    end
end

lia.lang.loadFromDir("lilia/gamemode/languages")
local langs = {}
for key, _ in pairs(lia.lang.stored) do
    local displayName = key:sub(1, 1):upper() .. key:sub(2)
    table.insert(langs, displayName)
end

function L(key, ...)
    local languages = lia.lang.stored or {}
    local langKey = lia.config.get("Language", "english"):lower()
    local info = languages[langKey]
    return string.format(info and info[key] or key, ...)
end

table.sort(langs)
lia.config.add("Language", "Language", "English", nil, {
    desc = "Determines the language setting for the game.",
    category = "General",
    type = "Table",
    options = langs
})

hook.Run("OnLocalizationLoaded")


-- ./gamemode/core/libraries/logger.lua
lia.log = lia.log or {}
lia.log.types = lia.log.types or {}
if SERVER then
   --[[
      lia.log.loadTables

      Description:
         Creates the logs directory for the current active gamemode under "lilia/logs".

      Parameters:
         None

      Returns:
         nil

      Realm:
         Server

      Internal Function:
         true
   ]]
   function lia.log.loadTables()
      file.CreateDir("lilia/logs/" .. engine.ActiveGamemode())
   end

   --[[
      lia.log.addType

      Description:
         Registers a new log type by associating a log generating function and a category with the log type identifier.
         The registered function will be used later to generate log messages for that type.

      Parameters:
         logType (string) - The unique identifier for the log type.
         func (function) - A function that takes a client and additional parameters, returning a log string.
         category (string) - The category for the log type, used for organizing log files.

      Returns:
         nil

      Realm:
         Server
   ]]
   function lia.log.addType(logType, func, category)
      lia.log.types[logType] = {
         func = func,
         category = category,
      }
   end

   --[[
      lia.log.getString

      Description:
         Retrieves the log string and its associated category for a given client and log type.
         It calls the registered log function with the provided parameters.

      Parameters:
         client (Player) - The client for which the log is generated.
         logType (string) - The identifier for the log type.
         ... (vararg) - Additional parameters passed to the log function.

      Returns:
         string, string - The generated log string and its category if successful; otherwise, nil.

      Realm:
         Server

      Internal Function:
         true
   ]]
   function lia.log.getString(client, logType, ...)
      local logData = lia.log.types[logType]
      if not logData then return end
      if isfunction(logData.func) then
         local success, result = pcall(logData.func, client, ...)
         if success then return result, logData.category end
      end
   end

   --[[
      lia.log.add

      Description:
         Generates a log string using the registered log type function, triggers the "OnServerLog" hook,
         and appends the log string to a log file corresponding to its category in the logs directory.

      Parameters:
         client (Player) - The client associated with the log event.
         logType (string) - The identifier for the log type.
         ... (vararg) - Additional parameters passed to the log type function.

      Returns:
         nil

      Realm:
         Server
   ]]
   function lia.log.add(client, logType, ...)
      local logString, category = lia.log.getString(client, logType, ...)
      if not isstring(category) then category = "Uncategorized" end
      if not isstring(logString) then return end
      hook.Run("OnServerLog", client, logType, logString, category)
      local logsDir = "lilia/logs/" .. engine.ActiveGamemode()
      if not file.Exists(logsDir, "DATA") then file.CreateDir(logsDir) end
      local filenameCategory = string.lower(string.gsub(category, "%s+", "_"))
      local logFilePath = logsDir .. "/" .. filenameCategory .. ".txt"
      file.Append(logFilePath, "[" .. os.date("%Y-%m-%d %H:%M:%S") .. "]\t" .. logString .. "\r\n")
   end
end

-- ./gamemode/core/libraries/menu.lua
local menu = lia.menu or {}
lia.menu = menu
menu.list = menu.list or {}
local surface_SetFont = surface.SetFont
local surface_GetTextSize = surface.GetTextSize
local surface_SetDrawColor = surface.SetDrawColor
local surface_DrawRect = surface.DrawRect
local surface_SetMaterial = surface.SetMaterial
local surface_DrawTexturedRect = surface.DrawTexturedRect
local surface_DrawOutlinedRect = surface.DrawOutlinedRect
local lia_drawText = lia.util.drawText
local ColorAlpha = ColorAlpha
local math_max = math.max
local math_Clamp = math.Clamp
local math_cos = math.cos
local approach = math.Approach
local LerpVector = LerpVector
local FrameTime = FrameTime
local RealTime = RealTime
local LocalPlayer = LocalPlayer
local IsValid = IsValid
local isEntity = isentity
local Material = Material
local table_insert = table.insert
local table_sort = table.sort
local table_remove = table.remove
local pad = 12
local rowH = 28
local gradient = Material("vgui/gradient-u")
local rangeSqr = 9216
local clickDist = 96
local function buildItems(opts)
    local list, w = {}, 0
    surface_SetFont("liaMediumFont")
    for k, v in pairs(opts) do
        list[#list + 1] = {k, v}
        w = math_max(w, surface_GetTextSize(tostring(k)))
    end

    table_sort(list, function(a, b) return tostring(a[1]) < tostring(b[1]) end)
    return list, w
end

function menu.add(opts, pos, onRemove)
    local client = LocalPlayer()
    local items, txtW = buildItems(opts)
    local ent
    if isEntity(pos) then
        ent = pos
        pos = ent:WorldToLocal(client:GetEyeTrace().HitPos)
    end
    return table_insert(menu.list, {
        position = pos or client:GetEyeTrace().HitPos,
        entity = ent,
        items = items,
        width = txtW + pad * 2,
        height = #items * rowH,
        onRemove = onRemove
    })
end

local function getScreenPos(d, ft)
    if d.entity then
        if not IsValid(d.entity) then return end
        local world = d.entity:LocalToWorld(d.position)
        d.entPos = LerpVector(ft * 15, d.entPos or world, world)
        return d.entPos:ToScreen()
    end
    return d.position:ToScreen()
end

local function drawBackground(x, y, w, h, a)
    local a90 = a * 0.9
    surface_SetDrawColor(40, 40, 40, a90)
    surface_DrawRect(x - 4, y - 4, w + 8, h + 8)
    surface_SetDrawColor(250, 250, 250, a90 * 0.025)
    surface_SetMaterial(gradient)
    surface_DrawTexturedRect(x - 4, y - 4, w + 8, h + 8)
    surface_SetDrawColor(0, 0, 0, a90 * 0.25)
    surface_DrawOutlinedRect(x - 4, y - 4, w + 8, h + 8)
end

function menu.drawAll()
    local client = LocalPlayer()
    local sw, sh = ScrW(), ScrH()
    local mx, my = sw * 0.5, sh * 0.5
    local pPos = client:GetPos()
    local ft = FrameTime() * 30
    for i = #menu.list, 1, -1 do
        local d = menu.list[i]
        local sp = getScreenPos(d, ft)
        if not sp then
            table_remove(menu.list, i)
            if d.onRemove then d:onRemove() end
            continue
        end

        local w, h = d.width, d.height
        local x = math_Clamp(sp.x - w * 0.5, 8, sw - w - 8)
        local y = math_Clamp(sp.y, 8, sh - h - 8)
        local inRange = pPos:DistToSqr(IsValid(d.entity) and d.entity:GetPos() or d.position) <= rangeSqr
        local inside = mx >= x and mx <= x + w and my >= y and my <= y + h and inRange
        local a = d.alpha or 0
        if not d.displayed or inside then
            d.alpha = approach(a, 255, ft * 25)
            if d.alpha == 255 then d.displayed = true end
        else
            d.alpha = approach(a, 0, inRange and ft or ft * 45)
            if d.alpha == 0 then
                table_remove(menu.list, i)
                if d.onRemove then d:onRemove() end
                continue
            end
        end

        drawBackground(x, y, w, h, d.alpha)
        local osc = math_cos(RealTime() * 8)
        for idx = 1, #d.items do
            local lbl, _ = d.items[idx][1], d.items[idx][2]
            local oy = y + (idx - 1) * rowH
            if inside and my >= oy and my <= oy + rowH then
                surface_SetDrawColor(ColorAlpha(lia.config.get("Color"), d.alpha + osc * 40))
                surface_DrawRect(x, oy, w, rowH)
            end

            lia_drawText(lbl, x + pad, oy + 2, ColorAlpha(color_white, d.alpha), nil, nil, "liaMediumFont")
        end
    end
end

function menu.getActiveMenu()
    local client = LocalPlayer()
    local sw, sh = ScrW(), ScrH()
    local mx, my = sw * 0.5, sh * 0.5
    local pPos = client:GetPos()
    for i = #menu.list, 1, -1 do
        local d = menu.list[i]
        local sp = getScreenPos(d, 0)
        if not sp then
            table_remove(menu.list, i)
            continue
        end

        local w, h = d.width, d.height
        local x = math_Clamp(sp.x - w * 0.5, 8, sw - w - 8)
        local y = math_Clamp(sp.y, 8, sh - h - 8)
        if mx < x or mx > x + w or my < y or my > y + h then continue end
        if pPos:Distance(IsValid(d.entity) and d.entity:GetPos() or d.position) > clickDist then continue end
        local idx = math.floor((my - y) / rowH) + 1
        local item = d.items[idx]
        if item then return i, item[2] end
    end
end

function menu.onButtonPressed(id, cb)
    table_remove(menu.list, id)
    if cb then
        cb()
        return true
    end
    return false
end

-- ./gamemode/core/libraries/modularity.lua
lia.module = lia.module or {}
lia.module.list = lia.module.list or {}
local ModuleFolders = {"config", "dependencies", "libs", "hooks", "libraries", "commands", "netcalls", "meta", "derma", "pim"}
local ModuleFiles = {"pim.lua", "client.lua", "server.lua", "config.lua", "commands.lua"}
local function loadPermissions(Privileges)
    if not Privileges or not istable(Privileges) then return end
    for _, privilegeData in ipairs(Privileges) do
        local privilegeName = privilegeData.Name
        if not CAMI.GetPrivilege(privilegeName) then
            CAMI.RegisterPrivilege({
                Name = privilegeName,
                MinAccess = privilegeData.MinAccess or "admin",
                Description = privilegeData.Description or "Allows access to " .. privilegeName:gsub("^%l", string.upper)
            })
        end
    end
end

local function loadDependencies(Dependencies)
    if not Dependencies then return end
    if istable(Dependencies) then
        for _, dep in ipairs(Dependencies) do
            lia.include(dep.File, dep.Realm)
        end
    else
        lia.include(Dependencies)
    end
end

local function loadExtras(path)
    lia.lang.loadFromDir(path .. "/languages")
    lia.faction.loadFromDir(path .. "/factions")
    lia.class.loadFromDir(path .. "/classes")
    lia.attribs.loadFromDir(path .. "/attributes")
    for _, fileName in ipairs(ModuleFiles) do
        local filePath = path .. "/" .. fileName
        if file.Exists(filePath, "LUA") then lia.include(filePath) end
    end

    for _, folder in ipairs(ModuleFolders) do
        local subPath = path .. "/" .. folder
        if file.Exists(subPath, "LUA") then lia.includeDir(subPath, true, true) end
    end

    lia.includeEntities(path .. "/entities")
    lia.item.loadFromDir(path .. "/items")
    hook.Run("DoModuleIncludes", path, MODULE)
end

local function loadSubmodules(path)
    local files, folders = file.Find(path .. "/submodules/*", "LUA")
    if #files > 0 or #folders > 0 then lia.module.loadFromDir(path .. "/submodules", "module") end
end

--[[
   Function: lia.module.load

   Description:
      Loads a module from a specified path. If the module is a single file, it includes it directly;
      if it is a directory, it loads the core file (or its extended version), applies permissions, workshop content, dependencies, extras, and submodules.
      It also registers the module in the module list if applicable.

   Parameters:
      uniqueID - The unique identifier of the module.
      path - The file system path where the module is located.
      isSingleFile - Boolean indicating if the module is a single file.
      variable - A global variable name used to temporarily store the module.

   Returns:
      nil
]]
function lia.module.load(uniqueID, path, isSingleFile, variable)
    local lowerVariable = variable:lower()
    local normalPath = path .. "/" .. lowerVariable .. ".lua"
    local extendedPath = path .. "/sh_" .. lowerVariable .. ".lua"
    local ModuleCore = file.Exists(normalPath, "LUA")
    local ExtendedCore = file.Exists(extendedPath, "LUA")
    if not isSingleFile and not ModuleCore and not ExtendedCore then return end
    local oldModule = MODULE
    MODULE = {
        folder = path,
        module = oldModule,
        uniqueID = uniqueID,
        name = L("unknown"),
        desc = L("noDesc"),
        author = L("anonymous"),
        identifier = "",
        enabled = true,
        IsValid = function() return true end
    }

    if uniqueID == "schema" then
        if SCHEMA then MODULE = SCHEMA end
        variable = "SCHEMA"
        MODULE.folder = engine.ActiveGamemode()
    elseif lia.module.list[uniqueID] then
        MODULE = lia.module.list[uniqueID]
    end

    _G[variable] = MODULE
    MODULE.loading = true
    MODULE.path = path
    if isSingleFile then
        lia.include(path, "shared")
    else
        lia.include(ModuleCore and normalPath or extendedPath, "shared")
    end

    local isEnabled = isfunction(MODULE.enabled) and MODULE.enabled() or MODULE.enabled
    if uniqueID ~= "schema" and not isEnabled then
        MODULE = oldModule
        return
    end

    if uniqueID ~= "schema" and MODULE.identifier and MODULE.identifier ~= "" then _G[MODULE.identifier] = {} end
    loadPermissions(MODULE.CAMIPrivileges)
    if not isSingleFile then
        loadDependencies(MODULE.Dependencies)
        loadExtras(path)
    end

    MODULE.loading = false
    local uniqueID2 = uniqueID == "schema" and MODULE.name or uniqueID
    function MODULE:setData(value, global, ignoreMap)
        lia.data.set(uniqueID2, value, global, ignoreMap)
    end

    function MODULE:getData(default, global, ignoreMap, refresh)
        return lia.data.get(uniqueID2, default, global, ignoreMap, refresh) or {}
    end

    for k, v in pairs(MODULE) do
        if isfunction(v) then hook.Add(k, MODULE, v) end
    end

    if uniqueID == "schema" then
        function MODULE:IsValid()
            return true
        end
    else
        lia.module.list[uniqueID] = MODULE
        if MODULE.identifier and MODULE.identifier ~= "" and uniqueID ~= "schema" then _G[MODULE.identifier] = lia.module.list[uniqueID] end
        loadSubmodules(path)
        if MODULE.ModuleLoaded then MODULE:ModuleLoaded() end
        if MODULE.Public then
            lia.module.versionChecks = lia.module.versionChecks or {}
            table.insert(lia.module.versionChecks, {
                uniqueID = MODULE.uniqueID,
                name = MODULE.name,
                localVersion = MODULE.version,
                source = MODULE.source
            })
        end

        if MODULE.Private then
            lia.module.privateVersionChecks = lia.module.privateVersionChecks or {}
            table.insert(lia.module.privateVersionChecks, {
                uniqueID = MODULE.uniqueID,
                name = MODULE.name,
                localVersion = MODULE.version,
                source = MODULE.source
            })
        end

        _G[variable] = oldModule
    end
end

--[[
   Function: lia.module.initialize

   Description:
      Initializes the module system by loading the schema and various module directories,
      then running the appropriate hooks after modules have been loaded.

   Parameters:
      None

   Returns:
      nil
]]
function lia.module.initialize()
    local schema = engine.ActiveGamemode()
    lia.module.load("schema", schema .. "/schema", false, "schema")
    hook.Run("InitializedSchema")
    lia.module.loadFromDir("lilia/modules/core", "module")
    lia.module.loadFromDir("lilia/modules/frameworkui", "module")
    lia.module.loadFromDir("lilia/modules/characters", "module")
    lia.module.loadFromDir("lilia/modules/utilities", "module")
    lia.module.loadFromDir(schema .. "/preload", "module")
    lia.module.loadFromDir(schema .. "/modules", "module")
    lia.module.loadFromDir(schema .. "/overrides", "module")
    hook.Run("InitializedModules")
end

--[[
   Function: lia.module.loadFromDir

   Description:
      Loads modules from a specified directory. It iterates over all subfolders and .lua files in the directory.
      Each subfolder is treated as a multi-file module, and each .lua file as a single-file module.
      Non-Lua files are ignored.

   Parameters:
      directory - The directory path from which to load modules.
      group - A string representing the module group (e.g., "schema" or "module").

   Returns:
      nil
]]
function lia.module.loadFromDir(directory, group)
    local locationVar = group == "schema" and "SCHEMA" or "MODULE"
    local files, folders = file.Find(directory .. "/*", "LUA")
    for _, folderName in ipairs(folders) do
        lia.module.load(folderName, directory .. "/" .. folderName, false, locationVar)
    end

    for _, fileName in ipairs(files) do
        if fileName:sub(-4) == ".lua" then
            local uniqueID = string.StripExtension(fileName)
            lia.module.load(uniqueID, directory .. "/" .. fileName, true, locationVar)
        end
    end
end

--[[
   Function: lia.module.get

   Description:
      Retrieves a module table by its identifier.

   Parameters:
      identifier - The unique identifier of the module to retrieve.

   Returns:
      The module table if found, or nil if the module is not registered.
]]
function lia.module.get(identifier)
    return lia.module.list[identifier]
end

-- ./gamemode/core/libraries/networking.lua
lia.net = lia.net or {}
lia.net.globals = lia.net.globals or {}
local playerMeta = FindMetaTable("Player")
local entityMeta = FindMetaTable("Entity")
if SERVER then
    function checkBadType(name, object)
        if isfunction(object) then
            ErrorNoHalt("Net var '" .. name .. "' contains a bad object type!")
            return true
        elseif istable(object) then
            for k, v in pairs(object) do
                if checkBadType(name, k) or checkBadType(name, v) then return true end
            end
        end
    end

    function setNetVar(key, value, receiver)
        if checkBadType(key, value) then return end
        if getNetVar(key) == value then return end
        lia.net.globals[key] = value
        netstream.Start(receiver, "gVar", key, value)
    end

    function getNetVar(key, default)
        local value = lia.net.globals[key]
        return value ~= nil and value or default
    end

    hook.Add("EntityRemoved", "nCleanUp", function(entity) entity:clearNetVars() end)
    hook.Add("PlayerInitialSpawn", "nSync", function(client) client:syncVars() end)
    hook.Add("CharDeleted", "liaCharRemoveName", function(client, character)
        lia.char.names[character:getID()] = nil
        netstream.Start(client, "liaCharFetchNames", lia.char.names)
    end)

    hook.Add("OnCharCreated", "liaCharAddName", function(client, character, data)
        lia.char.names[character:getID()] = data.name
        netstream.Start(client, "liaCharFetchNames", lia.char.names)
    end)
else
    function getNetVar(key, default)
        local value = lia.net.globals[key]
        return value ~= nil and value or default
    end

    playerMeta.getLocalVar = entityMeta.getNetVar
end


-- ./gamemode/core/libraries/notice.lua
if SERVER then
    function lia.notices.notify(message, recipient)
        net.Start("liaNotify")
        net.WriteString(message)
        if recipient then
            net.Send(recipient)
        else
            net.Broadcast()
        end
    end

    function lia.notices.notifyLocalized(key, recipient, ...)
        local args = {...}
        if recipient and type(recipient) ~= "Player" then
            table.insert(args, 1, recipient)
            recipient = nil
        end

        net.Start("liaNotifyL")
        net.WriteString(key)
        net.WriteUInt(#args, 8)
        for i = 1, #args do
            net.WriteString(tostring(args[i]))
        end

        if recipient then
            net.Send(recipient)
        else
            net.Broadcast()
        end
    end
else
    local function OrganizeNotices()
        local scrW = ScrW()
        for k, v in ipairs(lia.notices) do
            v:MoveTo(scrW - (v:GetWide() + 4), (k - 1) * (v:GetTall() + 4) + 4, 0.15, k / #lia.notices * 0.25)
        end
    end

    function lia.notices.notify(message)
        local notice = vgui.Create("liaNotice")
        local i = table.insert(lia.notices, notice)
        local scrW = ScrW()
        notice:SetText(message)
        notice:SetPos(scrW, (i - 1) * (notice:GetTall() + 4) + 4)
        notice:SizeToContentsX()
        notice:SetWide(notice:GetWide() + 16)
        notice.start = CurTime() + 0.25
        notice.endTime = CurTime() + 7.75
        OrganizeNotices()
        MsgC(Color(0, 255, 255), message .. "\n")
        timer.Simple(0.15, function() LocalPlayer():EmitSound(unpack({"garrysmod/content_downloaded.wav", 50, 250})) end)
        timer.Simple(7.75, function()
            if IsValid(notice) then
                for k, v in ipairs(lia.notices) do
                    if v == notice then
                        notice:MoveTo(scrW, notice.y, 0.15, 0.1, nil, function() notice:Remove() end)
                        table.remove(lia.notices, k)
                        OrganizeNotices()
                        break
                    end
                end
            end
        end)

        MsgN(message)
    end

    function lia.notices.notifyLocalized(key, ...)
        lia.notices.notify(L(key, ...))
    end

    function notification.AddLegacy(text)
        lia.notices.notify(tostring(text))
    end
end

-- ./gamemode/core/libraries/option.lua
lia.option = lia.option or {}
lia.option.stored = lia.option.stored or {}
--[[
       lia.option.add

       Description:
          Adds a configuration option to the lia.option system.

       Parameters:
          key (string)  The unique key for the option.
          name (string)  The display name of the option.
          desc (string)  A brief description of the option's purpose.
          default (any)  The default value for this option.
          callback (function)  A function to call when the options value changes (optional).
          data (table)  Additional data describing the option (e.g., min, max, type, category, visible, shouldNetwork).

       Returns:
          nil

       Realm:
          Shared
]]
function lia.option.add(key, name, desc, default, callback, data)
    assert(isstring(key), "Expected option key to be a string, got " .. type(key))
    assert(isstring(name), "Expected option name to be a string, got " .. type(name))
    assert(istable(data), "Expected option data to be a table, got " .. type(data))
    local t = type(default)
    local optionType = t == "boolean" and "Boolean" or t == "number" and (math.floor(default) == default and "Int" or "Float") or t == "table" and default.r and default.g and default.b and "Color" or "Generic"
    if optionType == "Int" or optionType == "Float" then
        data.min = data.min or optionType == "Int" and math.floor(default / 2) or default / 2
        data.max = data.max or optionType == "Int" and math.floor(default * 2) or default * 2
    end

    if data.type then optionType = data.type end
    local old = lia.option.stored[key]
    local value = old and old.value or default
    lia.option.stored[key] = {
        name = name,
        desc = desc,
        data = data,
        value = value,
        default = default,
        callback = callback,
        type = optionType,
        visible = data.visible,
        shouldNetwork = data.shouldNetwork
    }
end

--[[
       lia.option.set

       Description:
          Sets the value of a specified option, saves locally, and optionally networks to the server.

       Parameters:
          key (string)  The unique key identifying the option.
          value (any)  The new value to assign to this option.

       Returns:
          nil

       Realm:
          Client
]]
function lia.option.set(key, value)
    local opt = lia.option.stored[key]
    if not opt then return end
    local old = opt.value
    opt.value = value
    if opt.callback then opt.callback(old, value) end
    lia.option.save()
    if opt.shouldNetwork and SERVER then hook.Run("liaOptionReceived", ply, key, value) end
end

--[[
       lia.option.get

       Description:
          Retrieves the value of a specified option, or returns a default if it doesn't exist.

       Parameters:
          key (string)  The unique key identifying the option.
          default (any)  The value to return if the option is not found.

       Returns:
          (any) The current value of the option or the provided default.

       Realm:
          Client
]]
function lia.option.get(key, default)
    local opt = lia.option.stored[key]
    if opt then
        if opt.value ~= nil then return opt.value end
        if opt.default ~= nil then return opt.default end
    end
    return default
end

--[[
       lia.option.save

       Description:
          Saves all current option values to a file, named based on the server IP, within the active gamemode folder.

       Parameters:
          None

       Returns:
          nil

       Realm:
          Client
]]
function lia.option.save()
    local dir = "lilia/options/" .. engine.ActiveGamemode()
    file.CreateDir(dir)
    local ip = string.Explode(":", game.GetIPAddress())[1]
    local name = ip:gsub("%.", "_")
    local path = dir .. "/" .. name .. ".txt"
    local out = {}
    for k, v in pairs(lia.option.stored) do
        if v.value ~= nil then out[k] = v.value end
    end

    local json = util.TableToJSON(out, true)
    if json then file.Write(path, json) end
end

--[[
       lia.option.load

       Description:
          Loads saved option values from disk based on server IP and applies them to lia.option.stored.

       Parameters:
          None

       Returns:
          nil

       Realm:
          Client
]]
function lia.option.load()
    local dir = "lilia/options/" .. engine.ActiveGamemode()
    file.CreateDir(dir)
    local ip = string.Explode(":", game.GetIPAddress())[1]
    local name = ip:gsub("%.", "_")
    local path = dir .. "/" .. name .. ".txt"
    local data = file.Read(path, "DATA")
    if data then
        local saved = util.JSONToTable(data)
        for k, v in pairs(saved) do
            if lia.option.stored[k] then lia.option.stored[k].value = v end
        end
    end

    hook.Run("InitializedOptions")
end

hook.Add("PopulateConfigurationButtons", "PopulateOptions", function(pages)
    local OptionFormatting = {
        Int = function(key, name, cfg, parent)
            local c = vgui.Create("DPanel", parent)
            c:SetTall(220)
            c:Dock(TOP)
            c:DockMargin(0, 60, 0, 10)
            c.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local p = c:Add("DPanel")
            p:Dock(FILL)
            p.Paint = nil
            local lbl = p:Add("DLabel")
            lbl:Dock(TOP)
            lbl:SetTall(45)
            lbl:SetText(name)
            lbl:SetFont("ConfigFontLarge")
            lbl:SetContentAlignment(5)
            lbl:SetTextColor(Color(255, 255, 255))
            lbl:DockMargin(0, 20, 0, 0)
            local desc = p:Add("DLabel")
            desc:Dock(TOP)
            desc:SetTall(35)
            desc:SetText(cfg.desc or "")
            desc:SetFont("DescriptionFontLarge")
            desc:SetContentAlignment(5)
            desc:SetTextColor(Color(200, 200, 200))
            desc:DockMargin(0, 10, 0, 0)
            local slider = p:Add("DNumSlider")
            slider:Dock(FILL)
            slider:DockMargin(10, 0, 10, 0)
            slider:SetMin(lia.config.get(key .. "_min", cfg.data and cfg.data.min or 0))
            slider:SetMax(lia.config.get(key .. "_max", cfg.data and cfg.data.max or 1))
            slider:SetDecimals(0)
            slider:SetValue(lia.option.get(key, cfg.value))
            slider.PerformLayout = function()
                slider.Label:SetWide(100)
                slider.TextArea:SetWide(50)
            end

            slider.OnValueChanged = function(_, v) timer.Create("ConfigChange" .. name, 1, 1, function() lia.option.set(key, math.floor(v)) end) end
            return c
        end,
        Float = function(key, name, cfg, parent)
            local c = vgui.Create("DPanel", parent)
            c:SetTall(220)
            c:Dock(TOP)
            c:DockMargin(0, 60, 0, 10)
            c.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local p = c:Add("DPanel")
            p:Dock(FILL)
            p.Paint = nil
            local lbl = p:Add("DLabel")
            lbl:Dock(TOP)
            lbl:SetTall(45)
            lbl:SetText(name)
            lbl:SetFont("ConfigFontLarge")
            lbl:SetContentAlignment(5)
            lbl:SetTextColor(Color(255, 255, 255))
            lbl:DockMargin(0, 20, 0, 0)
            local desc = p:Add("DLabel")
            desc:Dock(TOP)
            desc:SetTall(35)
            desc:SetText(cfg.desc or "")
            desc:SetFont("DescriptionFontLarge")
            desc:SetContentAlignment(5)
            desc:SetTextColor(Color(200, 200, 200))
            desc:DockMargin(0, 10, 0, 0)
            local slider = p:Add("DNumSlider")
            slider:Dock(FILL)
            slider:DockMargin(10, 0, 10, 0)
            slider:SetMin(lia.config.get(key .. "_min", cfg.data and cfg.data.min or 0))
            slider:SetMax(lia.config.get(key .. "_max", cfg.data and cfg.data.max or 1))
            slider:SetDecimals(2)
            slider:SetValue(lia.option.get(key, cfg.value))
            slider.PerformLayout = function()
                slider.Label:SetWide(100)
                slider.TextArea:SetWide(50)
            end

            slider.OnValueChanged = function(_, v) timer.Create("ConfigChange" .. name, 1, 1, function() lia.option.set(key, math.Round(v, 2)) end) end
            return c
        end,
        Generic = function(key, name, cfg, parent)
            local c = vgui.Create("DPanel", parent)
            c:SetTall(220)
            c:Dock(TOP)
            c:DockMargin(0, 60, 0, 10)
            c.Paint = function() end
            local p = c:Add("DPanel")
            p:Dock(FILL)
            p.Paint = nil
            local lbl = p:Add("DLabel")
            lbl:Dock(TOP)
            lbl:SetTall(45)
            lbl:SetText(name)
            lbl:SetFont("ConfigFontLarge")
            lbl:SetContentAlignment(5)
            lbl:SetTextColor(Color(255, 255, 255))
            lbl:DockMargin(0, 20, 0, 0)
            local desc = p:Add("DLabel")
            desc:Dock(TOP)
            desc:SetTall(35)
            desc:SetText(cfg.desc or "")
            desc:SetFont("DescriptionFontLarge")
            desc:SetContentAlignment(5)
            desc:SetTextColor(Color(200, 200, 200))
            desc:DockMargin(0, 10, 0, 0)
            local entry = p:Add("DTextEntry")
            entry:Dock(TOP)
            entry:SetTall(60)
            entry:DockMargin(300, 10, 300, 0)
            entry:SetText(tostring(lia.option.get(key, cfg.value)))
            entry:SetFont("ConfigFontLarge")
            entry:SetTextColor(Color(255, 255, 255))
            entry.OnEnter = function(btn) lia.option.set(key, btn:GetText()) end
            return c
        end,
        Boolean = function(key, name, cfg, parent)
            local c = vgui.Create("DPanel", parent)
            c:SetTall(220)
            c:Dock(TOP)
            c:DockMargin(0, 60, 0, 10)
            c.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local p = c:Add("DPanel")
            p:Dock(FILL)
            p.Paint = nil
            local lbl = p:Add("DLabel")
            lbl:Dock(TOP)
            lbl:SetTall(45)
            lbl:SetText(name)
            lbl:SetFont("ConfigFontLarge")
            lbl:SetContentAlignment(5)
            lbl:SetTextColor(Color(255, 255, 255))
            lbl:DockMargin(0, 20, 0, 0)
            local desc = p:Add("DLabel")
            desc:Dock(TOP)
            desc:SetTall(35)
            desc:SetText(cfg.desc or "")
            desc:SetFont("DescriptionFontLarge")
            desc:SetContentAlignment(5)
            desc:SetTextColor(Color(200, 200, 200))
            desc:DockMargin(0, 10, 0, 0)
            local btn = p:Add("DButton")
            btn:Dock(TOP)
            btn:SetTall(100)
            btn:DockMargin(100, 10, 100, 0)
            btn:SetText("")
            btn.Paint = function(_, w, h)
                local ic = lia.option.get(key, cfg.value) and getIcon("0xe880", true) or getIcon("0xf096", true)
                lia.util.drawText(ic, w / 2, h / 2 - 10, color_white, 1, 1, "liaIconsHugeNew")
            end

            btn.DoClick = function() lia.option.set(key, not lia.option.get(key, cfg.value)) end
            return c
        end,
        Color = function(key, name, cfg, parent)
            local c = vgui.Create("DPanel", parent)
            c:SetTall(220)
            c:Dock(TOP)
            c:DockMargin(0, 60, 0, 10)
            c.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local p = c:Add("DPanel")
            p:Dock(FILL)
            p.Paint = nil
            local lbl = p:Add("DLabel")
            lbl:Dock(TOP)
            lbl:SetTall(45)
            lbl:SetText(name)
            lbl:SetFont("ConfigFontLarge")
            lbl:SetContentAlignment(5)
            lbl:SetTextColor(Color(255, 255, 255))
            lbl:DockMargin(0, 20, 0, 0)
            local desc = p:Add("DLabel")
            desc:Dock(TOP)
            desc:SetTall(35)
            desc:SetText(cfg.desc or "")
            desc:SetFont("DescriptionFontLarge")
            desc:SetContentAlignment(5)
            desc:SetTextColor(Color(200, 200, 200))
            desc:DockMargin(0, 10, 0, 0)
            local btn = p:Add("DButton")
            btn:Dock(FILL)
            btn:DockMargin(10, 0, 10, 0)
            btn:SetText("")
            btn:SetCursor("hand")
            btn.Paint = function(_, w, h)
                local col = lia.option.get(key, cfg.value)
                surface.SetDrawColor(col)
                surface.DrawRect(10, h / 2 - 15, w - 20, 30)
                draw.RoundedBox(2, 10, h / 2 - 15, w - 20, 30, Color(255, 255, 255, 50))
            end

            btn.DoClick = function()
                if IsValid(btn.picker) then btn.picker:Remove() end
                local frm = vgui.Create("DFrame")
                frm:SetSize(300, 400)
                frm:Center()
                frm:MakePopup()
                local mixer = frm:Add("DColorMixer")
                mixer:Dock(FILL)
                mixer:SetPalette(true)
                mixer:SetAlphaBar(true)
                mixer:SetWangs(true)
                mixer:SetColor(lia.option.get(key, cfg.value))
                local apply = frm:Add("DButton")
                apply:Dock(BOTTOM)
                apply:SetTall(40)
                apply:SetText("Apply")
                apply:SetTextColor(color_white)
                apply:SetFont("ConfigFontLarge")
                apply:DockMargin(10, 10, 10, 10)
                apply.Paint = function(self, w, h)
                    surface.SetDrawColor(Color(0, 150, 0))
                    surface.DrawRect(0, 0, w, h)
                    if self:IsHovered() then
                        surface.SetDrawColor(Color(0, 180, 0))
                        surface.DrawRect(0, 0, w, h)
                    end

                    surface.SetDrawColor(Color(255, 255, 255))
                    surface.DrawOutlinedRect(0, 0, w, h)
                end

                apply.DoClick = function()
                    timer.Create("ConfigChange" .. name, 1, 1, function() lia.option.set(key, frm.curColor) end)
                    frm:Remove()
                end

                mixer.ValueChanged = function(_, v) frm.curColor = v end
                btn.picker = frm
            end
            return c
        end,
        Table = function(key, name, cfg, parent)
            local c = vgui.Create("DPanel", parent)
            c:SetTall(220)
            c:Dock(TOP)
            c:DockMargin(0, 60, 0, 10)
            c.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
            local p = c:Add("DPanel")
            p:Dock(FILL)
            p.Paint = nil
            local lbl = p:Add("DLabel")
            lbl:Dock(TOP)
            lbl:SetTall(45)
            lbl:SetText(name)
            lbl:SetFont("ConfigFontLarge")
            lbl:SetContentAlignment(5)
            lbl:SetTextColor(Color(255, 255, 255))
            lbl:DockMargin(0, 20, 0, 0)
            local desc = p:Add("DLabel")
            desc:Dock(TOP)
            desc:SetTall(35)
            desc:SetText(cfg.desc or "")
            desc:SetFont("DescriptionFontLarge")
            desc:SetContentAlignment(5)
            desc:SetTextColor(Color(200, 200, 200))
            desc:DockMargin(0, 10, 0, 0)
            local combo = p:Add("DComboBox")
            combo:Dock(TOP)
            combo:SetTall(60)
            combo:DockMargin(300, 10, 300, 0)
            combo:SetFont("ConfigFontLarge")
            combo:SetTextColor(Color(255, 255, 255))
            local opts = cfg.data and cfg.data.options or {}
            local cur = lia.option.get(key, cfg.value)
            combo:SetValue(tostring(cur))
            combo.Paint = function(self, w, h)
                draw.RoundedBox(0, 0, 0, w, h, Color(50, 50, 50, 200))
                self:DrawTextEntryText(Color(255, 255, 255), Color(255, 255, 255), Color(255, 255, 255))
            end

            for _, opt in ipairs(opts) do
                combo:AddChoice(opt, opt, opt == cur)
            end

            combo.OnSelect = function(_, _, v) lia.option.set(key, v) end
            return c
        end
    }

    local function buildOptions(parent, filter)
        local categories = {}
        local keys = {}
        for k in pairs(lia.option.stored) do
            keys[#keys + 1] = k
        end

        table.sort(keys, function(a, b) return lia.option.stored[a].name < lia.option.stored[b].name end)
        for _, key in ipairs(keys) do
            local opt = lia.option.stored[key]
            if not opt.visible or type(opt.visible) == "function" and opt.visible() then
                local name = opt.name
                local desc = opt.desc or ""
                local ln, ld = name:lower(), desc:lower()
                if filter == "" or ln:find(filter, 1, true) or ld:find(filter, 1, true) then
                    local catName = opt.data and opt.data.category or "Miscellaneous"
                    categories[catName] = categories[catName] or {}
                    categories[catName][#categories[catName] + 1] = {
                        key = key,
                        name = name,
                        config = opt,
                        elemType = opt.type or "Generic"
                    }
                end
            end
        end

        for catName, items in SortedPairs(categories) do
            local cat = vgui.Create("DCollapsibleCategory", parent)
            cat:Dock(TOP)
            cat:SetLabel(catName)
            cat:SetExpanded(true)
            cat:DockMargin(0, 0, 0, 10)
            cat.Header:SetContentAlignment(5)
            cat.Header:SetTall(30)
            cat.Header:SetFont("liaMediumFont")
            cat.Header:SetTextColor(Color(255, 255, 255))
            cat.Header.Paint = function(_, w, h)
                draw.RoundedBox(0, 0, 0, w, h, Color(20, 20, 20, 200))
                surface.SetDrawColor(255, 255, 255, 80)
                surface.DrawOutlinedRect(0, 0, w, h)
            end

            cat.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(40, 40, 40, 60)) end
            local body = vgui.Create("DPanel", cat)
            body:SetTall(#items * 240)
            body.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(20, 20, 20, 50)) end
            cat:SetContents(body)
            for _, v in ipairs(items) do
                local panel = OptionFormatting[v.elemType](v.key, v.name, v.config, body)
                panel:Dock(TOP)
                panel:DockMargin(10, 10, 10, 0)
                panel.Paint = function(_, w, h)
                    draw.RoundedBox(4, 0, 0, w, h, Color(0, 0, 0, 200))
                    surface.SetDrawColor(255, 255, 255)
                    surface.DrawOutlinedRect(0, 0, w, h)
                end
            end
        end
    end

    pages[#pages + 1] = {
        name = L("options"),
        drawFunc = function(parent)
            parent:Clear()
            local searchEntry = vgui.Create("DTextEntry", parent)
            searchEntry:Dock(TOP)
            searchEntry:SetTall(30)
            searchEntry:DockMargin(5, 5, 5, 5)
            searchEntry:SetPlaceholderText(L("searchOptions"))
            local scroll = vgui.Create("DScrollPanel", parent)
            scroll:Dock(FILL)
            local function refresh()
                scroll:Clear()
                buildOptions(scroll, searchEntry:GetValue():lower())
            end

            searchEntry.OnTextChanged = function() refresh() end
            refresh()
        end
    }
end)

lia.option.add("descriptionWidth", "Description Width", "Adjust the description width on the HUD", 0.5, nil, {
    category = "HUD",
    min = 0.1,
    max = 1,
    decimals = 2
})

-- ./gamemode/core/libraries/thirdparty/cl_markup.lua
module("lia.markup", package.seeall)
local TEXT_ALIGN_CENTER, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM = 1, 2, 3
local colour_stack = {
    {
        r = 255,
        g = 255,
        b = 255,
        a = 255
    }
}

local font_stack = {"DermaDefault"}
local blocks = {}
local colourmap = {
    ["black"] = {
        r = 0,
        g = 0,
        b = 0,
        a = 255
    },
    ["white"] = {
        r = 255,
        g = 255,
        b = 255,
        a = 255
    },
    ["dkgrey"] = {
        r = 64,
        g = 64,
        b = 64,
        a = 255
    },
    ["grey"] = {
        r = 128,
        g = 128,
        b = 128,
        a = 255
    },
    ["ltgrey"] = {
        r = 192,
        g = 192,
        b = 192,
        a = 255
    },
    ["dkgray"] = {
        r = 64,
        g = 64,
        b = 64,
        a = 255
    },
    ["gray"] = {
        r = 128,
        g = 128,
        b = 128,
        a = 255
    },
    ["ltgray"] = {
        r = 192,
        g = 192,
        b = 192,
        a = 255
    },
    ["red"] = {
        r = 255,
        g = 0,
        b = 0,
        a = 255
    },
    ["green"] = {
        r = 0,
        g = 255,
        b = 0,
        a = 255
    },
    ["blue"] = {
        r = 0,
        g = 0,
        b = 255,
        a = 255
    },
    ["yellow"] = {
        r = 255,
        g = 255,
        b = 0,
        a = 255
    },
    ["purple"] = {
        r = 255,
        g = 0,
        b = 255,
        a = 255
    },
    ["cyan"] = {
        r = 0,
        g = 255,
        b = 255,
        a = 255
    },
    ["turq"] = {
        r = 0,
        g = 255,
        b = 255,
        a = 255
    },
    ["dkred"] = {
        r = 128,
        g = 0,
        b = 0,
        a = 255
    },
    ["dkgreen"] = {
        r = 0,
        g = 128,
        b = 0,
        a = 255
    },
    ["dkblue"] = {
        r = 0,
        g = 0,
        b = 128,
        a = 255
    },
    ["dkyellow"] = {
        r = 128,
        g = 128,
        b = 0,
        a = 255
    },
    ["dkpurple"] = {
        r = 128,
        g = 0,
        b = 128,
        a = 255
    },
    ["dkcyan"] = {
        r = 0,
        g = 128,
        b = 128,
        a = 255
    },
    ["dkturq"] = {
        r = 0,
        g = 128,
        b = 128,
        a = 255
    },
    ["ltred"] = {
        r = 255,
        g = 128,
        b = 128,
        a = 255
    },
    ["ltgreen"] = {
        r = 128,
        g = 255,
        b = 128,
        a = 255
    },
    ["ltblue"] = {
        r = 128,
        g = 128,
        b = 255,
        a = 255
    },
    ["ltyellow"] = {
        r = 255,
        g = 255,
        b = 128,
        a = 255
    },
    ["ltpurple"] = {
        r = 255,
        g = 128,
        b = 255,
        a = 255
    },
    ["ltcyan"] = {
        r = 128,
        g = 255,
        b = 255,
        a = 255
    },
    ["ltturq"] = {
        r = 128,
        g = 255,
        b = 255,
        a = 255
    },
}

local function colourMatch(c)
    c = string.lower(c)
    return colourmap[c]
end

local function ExtractParams(p1, p2, p3)
    if string.utf8sub(p1, 1, 1) == "/" then
        local tag = string.utf8sub(p1, 2)
        if tag == "color" or tag == "colour" then
            table.remove(colour_stack)
        elseif tag == "font" or tag == "face" then
            table.remove(font_stack)
        end
    else
        if p1 == "color" or p1 == "colour" then
            local rgba = colourMatch(p2)
            if rgba == nil then
                rgba = {}
                local x = {"r", "g", "b", "a"}
                n = 1
                for k, _ in string.gmatch(p2, "(%d+),?") do
                    rgba[x[n]] = k
                    n = n + 1
                end
            end

            table.insert(colour_stack, rgba)
        elseif p1 == "font" or p1 == "face" then
            table.insert(font_stack, tostring(p2))
        elseif p1 == "img" and p2 then
            local exploded = string.Explode(",", p2)
            local material = exploded[1] or p2
            local p3 = exploded[2]
            local found = file.Find("materials/" .. material .. ".*", "GAME")
            if found[1] and found[1]:find("%.png") then material = material .. ".png" end
            local texture = Material(material)
            local sizeData = string.Explode("x", p3 or "16x16")
            w = tonumber(sizeData[1]) or 16
            h = tonumber(sizeData[2]) or 16
            if texture then
                table.insert(blocks, {
                    texture = texture,
                    w = w,
                    h = h
                })
            end
        end
    end
end

local function CheckTextOrTag(p)
    if p == "" then return end
    if p == nil then return end
    if string.utf8sub(p, 1, 1) == "<" then
        string.gsub(p, "<([/%a]*)=?([^>]*)", ExtractParams)
    else
        local text_block = {}
        text_block.text = p
        text_block.colour = colour_stack[#colour_stack]
        text_block.font = font_stack[#font_stack]
        table.insert(blocks, text_block)
    end
end

local function ProcessMatches(p1, p2, p3)
    if p1 then CheckTextOrTag(p1) end
    if p2 then CheckTextOrTag(p2) end
    if p3 then CheckTextOrTag(p3) end
end

local MarkupObject = {}
function MarkupObject:create()
    local o = {}
    setmetatable(o, self)
    self.__index = self
    return o
end

function MarkupObject:getWidth()
    return self.totalWidth
end

function MarkupObject:getHeight()
    return self.totalHeight
end

function MarkupObject:size()
    return self.totalWidth, self.totalHeight
end

function MarkupObject:draw(xOffset, yOffset, halign, valign, alphaoverride)
    for i = 1, #self.blocks do
        local blk = self.blocks[i]
        if blk.texture then
            local y = yOffset + blk.h - blk.thisY + blk.offset.y
            local x = xOffset + blk.offset.x
            if halign == TEXT_ALIGN_CENTER then
                x = x - self.totalWidth / 2
            elseif halign == TEXT_ALIGN_RIGHT then
                x = x - self.totalWidth
            end

            if valign == TEXT_ALIGN_CENTER then y = y - blk.h / 2 end
            surface.SetDrawColor(blk.colour.r, blk.colour.g, blk.colour.b, alphaoverride or blk.colour.a or 255)
            surface.SetMaterial(blk.texture)
            surface.DrawTexturedRect(x, y, blk.w, blk.h)
        else
            local y = yOffset + blk.height - blk.thisY + blk.offset.y
            local x = xOffset
            if halign == TEXT_ALIGN_CENTER then
                x = x - self.totalWidth / 2
            elseif halign == TEXT_ALIGN_RIGHT then
                x = x - self.totalWidth
            end

            x = x + blk.offset.x
            if self.onDrawText then
                self.onDrawText(blk.text, blk.font, x, y, blk.colour, halign, valign, alphaoverride, blk)
            else
                if valign == TEXT_ALIGN_CENTER then
                    y = y - self.totalHeight / 2
                elseif valign == TEXT_ALIGN_BOTTOM then
                    y = y - self.totalHeight
                end

                local alpha = blk.colour.a
                if alphaoverride then alpha = alphaoverride end
                surface.SetFont(blk.font)
                surface.SetTextColor(blk.colour.r, blk.colour.g, blk.colour.b, alpha)
                surface.SetTextPos(x, y)
                surface.DrawText(blk.text)
            end
        end
    end
end

function parse(ml, maxwidth)
    colour_stack = {
        {
            r = 255,
            g = 255,
            b = 255,
            a = 255
        }
    }

    font_stack = {"DermaDefault"}
    blocks = {}
    if not string.find(ml, "<") then ml = ml .. "<nop>" end
    string.gsub(ml, "([^<>]*)(<[^>]+.)([^<>]*)", ProcessMatches)
    local xOffset = 0
    local yOffset = 0
    local xSize = 0
    local xMax = 0
    local thisMaxY = 0
    local new_block_list = {}
    local ymaxes = {}
    local texOffset = 0
    local lineHeight = 0
    for i = 1, #blocks do
        local block = blocks[i]
        if block.text then
            surface.SetFont(block.font)
            local thisY = 0
            local curString = ""
            block.text = string.gsub(block.text, "&gt;", ">")
            block.text = string.gsub(block.text, "&lt;", "<")
            block.text = string.gsub(block.text, "&amp;", "&")
            for j = 1, string.utf8len(block.text) do
                local ch = string.utf8sub(block.text, j, j)
                if ch == "\n" then
                    if thisY == 0 then
                        thisY = lineHeight + texOffset
                        thisMaxY = lineHeight + texOffset
                    else
                        lineHeight = thisY + texOffset
                    end

                    if string.utf8len(curString) > 0 then
                        local x1, y1 = surface.GetTextSize(curString)
                        local new_block = {}
                        new_block.text = curString
                        new_block.font = block.font
                        new_block.colour = block.colour
                        new_block.thisY = thisY
                        new_block.thisX = x1
                        new_block.offset = {}
                        new_block.offset.x = xOffset
                        new_block.offset.y = yOffset
                        table.insert(new_block_list, new_block)
                        if xOffset + x1 > xMax then xMax = xOffset + x1 end
                    end

                    xOffset = 0
                    xSize = 0
                    yOffset = yOffset + thisMaxY
                    thisY = 0
                    curString = ""
                    thisMaxY = 0
                elseif ch == "\t" then
                    if string.utf8len(curString) > 0 then
                        local x1, y1 = surface.GetTextSize(curString)
                        local new_block = {}
                        new_block.text = curString
                        new_block.font = block.font
                        new_block.colour = block.colour
                        new_block.thisY = thisY
                        new_block.thisX = x1
                        new_block.offset = {}
                        new_block.offset.x = xOffset
                        new_block.offset.y = yOffset
                        table.insert(new_block_list, new_block)
                        if xOffset + x1 > xMax then xMax = xOffset + x1 end
                    end

                    local xOldSize = xSize
                    xSize = 0
                    curString = ""
                    local xOldOffset = xOffset
                    xOffset = math.ceil((xOffset + xOldSize) / 50) * 50
                    if xOffset == xOldOffset then xOffset = xOffset + 50 end
                else
                    local x, y = surface.GetTextSize(ch)
                    if x == nil then return end
                    if maxwidth and maxwidth > x and xOffset + xSize + x >= maxwidth then
                        local lastSpacePos = string.utf8len(curString)
                        for k = 1, string.utf8len(curString) do
                            local chspace = string.utf8sub(curString, k, k)
                            if chspace == " " then lastSpacePos = k end
                        end

                        if lastSpacePos == string.utf8len(curString) then
                            ch = string.utf8sub(curString, lastSpacePos, lastSpacePos) .. ch
                            j = lastSpacePos
                            curString = string.utf8sub(curString, 1, lastSpacePos - 1)
                        else
                            ch = string.utf8sub(curString, lastSpacePos + 1) .. ch
                            j = lastSpacePos + 1
                            curString = string.utf8sub(curString, 1, lastSpacePos)
                        end

                        local m = 1
                        local chLen = string.utf8len(ch)
                        while m <= chLen and string.utf8sub(ch, m, m) == " " do
                            m = m + 1
                        end

                        ch = string.utf8sub(ch, m)
                        local x1, y1 = surface.GetTextSize(curString)
                        if y1 > thisMaxY then
                            thisMaxY = y1
                            ymaxes[yOffset] = thisMaxY
                            lineHeight = y1
                        end

                        local new_block = {}
                        new_block.text = curString
                        new_block.font = block.font
                        new_block.colour = block.colour
                        new_block.thisY = thisY
                        new_block.thisX = x1
                        new_block.offset = {}
                        new_block.offset.x = xOffset
                        new_block.offset.y = yOffset
                        table.insert(new_block_list, new_block)
                        if xOffset + x1 > xMax then xMax = xOffset + x1 end
                        xOffset = 0
                        xSize = 0
                        x, y = surface.GetTextSize(ch)
                        yOffset = yOffset + thisMaxY
                        thisY = 0
                        curString = ""
                        thisMaxY = 0
                    end

                    curString = curString .. ch
                    thisY = y
                    xSize = xSize + x
                    if y > thisMaxY then
                        thisMaxY = y
                        ymaxes[yOffset] = thisMaxY
                        lineHeight = y
                    end
                end
            end

            if string.utf8len(curString) > 0 then
                local x1, y1 = surface.GetTextSize(curString)
                local new_block = {}
                new_block.text = curString
                new_block.font = block.font
                new_block.colour = block.colour
                new_block.thisY = thisY
                new_block.thisX = x1
                new_block.offset = {}
                new_block.offset.x = xOffset
                new_block.offset.y = yOffset
                table.insert(new_block_list, new_block)
                lineHeight = thisY
                if xOffset + x1 > xMax then xMax = xOffset + x1 end
                xOffset = xOffset + x1
            end

            xSize = 0
        elseif block.texture then
            local newBlock = table.Copy(block)
            newBlock.colour = block.colour or {
                r = 255,
                g = 255,
                b = 255,
                a = 255
            }

            newBlock.thisX = block.w
            newBlock.thisY = block.h - 3
            newBlock.offset = {
                x = xOffset,
                y = yOffset
            }

            table.insert(new_block_list, newBlock)
            xOffset = xOffset + block.w + 1
            texOffset = block.h / 2
        end
    end

    local totalHeight = 0
    for i = 1, #new_block_list do
        local block = new_block_list[i]
        block.height = ymaxes[block.offset.y]
        if block.height and block.offset.y + block.height > totalHeight then totalHeight = block.offset.y + block.height end
    end

    local newObject = MarkupObject:create()
    newObject.totalHeight = totalHeight
    newObject.totalWidth = xMax
    newObject.blocks = new_block_list
    return newObject
end

local PANEL = {}
function PANEL:Init()
    self:SetPaintBackground(false)
end

function PANEL:setMarkup(text, onDrawText)
    local object = lia.markup.parse(text, self:GetWide())
    object.onDrawText = onDrawText
    self:SetTall(object:getHeight())
    self.Paint = function() object:draw(0, 0) end
end

vgui.Register("liaMarkupPanel", PANEL, "DPanel")

-- ./gamemode/core/libraries/thirdparty/cl_utf8.lua
local function utf8charbytes(s, i)
    i = i or 1
    if not isstring(s) then error("bad argument #1 to 'utf8charbytes' (string expected, got " .. type(s) .. ")") end
    if not isnumber(i) then error("bad argument #2 to 'utf8charbytes' (number expected, got " .. type(i) .. ")") end
    local c = s:byte(i)
    if c > 0 and c <= 127 then
        return 1
    elseif c >= 194 and c <= 223 then
        local c2 = s:byte(i + 1)
        if not c2 then error("UTF-8 string terminated early") end
        if c2 < 128 or c2 > 191 then error("Invalid UTF-8 character") end
        return 2
    elseif c >= 224 and c <= 239 then
        local c2 = s:byte(i + 1)
        local c3 = s:byte(i + 2)
        if not c2 or not c3 then error("UTF-8 string terminated early") end
        if c == 224 and (c2 < 160 or c2 > 191) then
            error("Invalid UTF-8 character")
        elseif c == 237 and (c2 < 128 or c2 > 159) then
            error("Invalid UTF-8 character")
        elseif c2 < 128 or c2 > 191 then
            error("Invalid UTF-8 character")
        end

        if c3 < 128 or c3 > 191 then error("Invalid UTF-8 character") end
        return 3
    elseif c >= 240 and c <= 244 then
        local c2 = s:byte(i + 1)
        local c3 = s:byte(i + 2)
        local c4 = s:byte(i + 3)
        if not c2 or not c3 or not c4 then error("UTF-8 string terminated early") end
        if c == 240 and (c2 < 144 or c2 > 191) then
            error("Invalid UTF-8 character")
        elseif c == 244 and (c2 < 128 or c2 > 143) then
            error("Invalid UTF-8 character")
        elseif c2 < 128 or c2 > 191 then
            error("Invalid UTF-8 character")
        end

        if c3 < 128 or c3 > 191 then error("Invalid UTF-8 character") end
        if c4 < 128 or c4 > 191 then error("Invalid UTF-8 character") end
        return 4
    else
        error("Invalid UTF-8 character")
    end
end

local function utf8len(s)
    if not isstring(s) then error("bad argument #1 to 'utf8len' (string expected, got " .. type(s) .. ")") end
    local pos = 1
    local bytes = s:len()
    local len = 0
    while pos <= bytes do
        len = len + 1
        pos = pos + utf8charbytes(s, pos)
    end
    return len
end

if not string.utf8bytes then string.utf8bytes = utf8charbytes end
if not string.utf8len then string.utf8len = utf8len end
local function utf8sub(s, i, j)
    j = j or -1
    if not isstring(s) then error("bad argument #1 to 'utf8sub' (string expected, got " .. type(s) .. ")") end
    if not isnumber(i) then error("bad argument #2 to 'utf8sub' (number expected, got " .. type(i) .. ")") end
    if not isnumber(j) then error("bad argument #3 to 'utf8sub' (number expected, got " .. type(j) .. ")") end
    local pos = 1
    local bytes = s:len()
    local len = 0
    local l = i >= 0 and j >= 0 or s:utf8len()
    local startChar = i >= 0 and i or l + i + 1
    local endChar = j >= 0 and j or l + j + 1
    if startChar > endChar then return "" end
    local startByte, endByte = 1, bytes
    while pos <= bytes do
        len = len + 1
        if len == startChar then startByte = pos end
        pos = pos + utf8charbytes(s, pos)
        if len == endChar then
            endByte = pos - 1
            break
        end
    end
    return s:sub(startByte, endByte)
end

if not string.utf8sub then string.utf8sub = utf8sub end
local function utf8replace(s, mapping)
    if not isstring(s) then error("bad argument #1 to 'utf8replace' (string expected, got " .. type(s) .. ")") end
    if not istable(mapping) then error("bad argument #2 to 'utf8replace' (table expected, got " .. type(mapping) .. ")") end
    local pos = 1
    local bytes = s:len()
    local charbytes
    local newstr = ""
    while pos <= bytes do
        charbytes = utf8charbytes(s, pos)
        local c = s:sub(pos, pos + charbytes - 1)
        newstr = newstr .. (mapping[c] or c)
        pos = pos + charbytes
    end
    return newstr
end

local function utf8upper(s)
    return utf8replace(s, utf8_lc_uc)
end

if not string.utf8upper and utf8_lc_uc then string.utf8upper = utf8upper end
local function utf8lower(s)
    return utf8replace(s, utf8_uc_lc)
end

if not string.utf8lower and utf8_uc_lc then string.utf8lower = utf8lower end
local function utf8reverse(s)
    if not isstring(s) then error("bad argument #1 to 'utf8reverse' (string expected, got " .. type(s) .. ")") end
    local bytes = s:len()
    local pos = bytes
    local charbytes
    local newstr = ""
    while pos > 0 do
        c = s:byte(pos)
        while c >= 128 and c <= 191 do
            pos = pos - 1
            c = s:byte(pos)
        end

        charbytes = utf8charbytes(s, pos)
        newstr = newstr .. s:sub(pos, pos + charbytes - 1)
        pos = pos - 1
    end
    return newstr
end

if not string.utf8reverse then string.utf8reverse = utf8reverse end

-- ./gamemode/core/libraries/thirdparty/sh_cami.lua
local version = 20211019
if CAMI and CAMI.Version >= version then return end
CAMI = CAMI or {}
CAMI.Version = version
local CAMI_PRIVILEGE = {}
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}
function CAMI.RegisterUsergroup(usergroup, source)
    if source then usergroup.CAMI_Source = tostring(source) end
    usergroups[usergroup.Name] = usergroup
    hook.Run("CAMI.OnUsergroupRegistered", usergroup, source)
    return usergroup
end

function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end
    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil
    hook.Run("CAMI.OnUsergroupUnregistered", usergroup, source)
    return true
end

function CAMI.GetUsergroups()
    return usergroups
end

function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end
        usergroupName = usergroups[usergroupName] and usergroups[usergroupName].Inherits or usergroupName
    until not usergroups[usergroupName] or usergroups[usergroupName].Inherits == usergroupName
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end
    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end
    return usergroupName
end

function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege
    hook.Run("CAMI.OnPrivilegeRegistered", privilege)
    return privilege
end

function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end
    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil
    hook.Run("CAMI.OnPrivilegeUnregistered", privilege)
    return true
end

function CAMI.GetPrivileges()
    return privileges
end

function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

local defaultAccessHandler = {
    ["CAMI.PlayerHasAccess"] = function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        if not IsValid(actorPly) then return callback(true, "Fallback.") end
        local priv = privileges[privilegeName]
        local fallback = extraInfoTbl and (not extraInfoTbl.Fallback and actorPly:IsAdmin() or extraInfoTbl.Fallback == "user" and true or extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())
        if not priv then return callback(fallback, "Fallback.") end
        local hasAccess = priv.MinAccess == "user" or priv.MinAccess == "admin" and actorPly:IsAdmin() or priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()
        if hasAccess and priv.HasAccess then hasAccess = priv:HasAccess(actorPly, targetPly) end
        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] = function(_, _, _, callback) callback(false, "No information available.") end
}

function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly, extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end
    if not IsValid(actorPly) then return end
    if actorPly:IsBot() then return true end
    hook.Run("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly, privilegeName, callback_, targetPly, extraInfoTbl)
    if callback ~= nil then return end
    if hasAccess == nil then
        local priv = privileges[privilegeName]
        if priv then
            if priv.MinAccess == "user" then
                hasAccess = true
                reason = "Defaulted to 'user' permissions."
            elseif priv.MinAccess == "admin" then
                hasAccess = false
                reason = "Insufficient permissions. Defaulted to 'user' permissions."
            elseif priv.MinAccess == "superadmin" then
                hasAccess = false
                reason = "Insufficient permissions. Defaulted to 'user' permissions."
            else
                hasAccess = false
                reason = "Undefined privilege level. Defaulted to 'user' permissions."
            end
        else
            if extraInfoTbl then
                if not extraInfoTbl.Fallback then
                    hasAccess = actorPly:IsAdmin()
                    reason = "No fallback specified. Defaulted to 'user' permissions."
                elseif extraInfoTbl.Fallback == "user" then
                    hasAccess = true
                    reason = "Fallback to 'user' permissions."
                elseif extraInfoTbl.Fallback == "admin" then
                    hasAccess = actorPly:IsAdmin()
                    reason = "Fallback to 'admin' permissions."
                elseif extraInfoTbl.Fallback == "superadmin" then
                    hasAccess = actorPly:IsSuperAdmin()
                    reason = "Fallback to 'superadmin' permissions."
                else
                    hasAccess = false
                    reason = "Invalid fallback specified. Defaulted to 'user' permissions."
                end
            else
                hasAccess = true
                reason = "No privilege found. Defaulted to 'user' permissions."
            end
        end
    end
    return hasAccess, reason
end

function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly, extraInfoTbl)
    local allowedPlys = {}
    local countdown = player.GetCount()
    local function onResult(client, hasAccess, _)
        countdown = countdown - 1
        if hasAccess then table.insert(allowedPlys, client) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, client in player.Iterator() do
        CAMI.PlayerHasAccess(client, privilegeName, function(...) onResult(client, ...) end, targetPly, extraInfoTbl)
    end
end

function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback, targetSteam, extraInfoTbl)
    hook.Run("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam, privilegeName, callback, targetSteam, extraInfoTbl)
end

function CAMI.SignalUserGroupChanged(client, old, new, source)
    hook.Run("CAMI.PlayerUsergroupChanged", client, old, new, source)
end

function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Run("CAMI.SteamIDUsergroupChanged", steamId, old, new, source)
end

-- ./gamemode/core/libraries/thirdparty/sh_curtime.lua
if SERVER then
    timer.Create("CurTime-Sync", 30, -1, function()
        net.Start("CurTime-Sync", true)
        net.WriteFloat(CurTime())
        net.Broadcast()
    end)
else
    hook.Add("InitPostEntity", "CurTime-Sync", function()
        local SyncTime = 0
        net.Receive("CurTime-Sync", function()
            local ServerCurTime = net.ReadFloat()
            if not ServerCurTime then return end
            SyncTime = OldCurTime() - ServerCurTime
        end)

        OldCurTime = OldCurTime or CurTime
        function CurTime()
            return OldCurTime() - SyncTime
        end
    end)
end

-- ./gamemode/core/libraries/thirdparty/sh_deferred.lua
local PENDING, FULFILLED, REJECTED = "pending", "fulfilled", "rejected"
local HANDLER_RESOLVE, HANDLER_REJECT, HANDLER_PROMISE = 1, 2, 3
REJECTION_HANDLER_ID = REJECTION_HANDLER_ID or 0
UNHANDLED_PROMISES = UNHANDLED_PROMISES or {}
local Promise = {
    state = PENDING,
    value = nil,
}

Promise.__index = Promise
function Promise:new()
    local instance = {
        onResolve = onResolve,
        onReject = onReject,
        handlers = {}
    }

    setmetatable(instance, Promise)
    return instance
end

function Promise:__tostring()
    local value = ""
    if self.value then
        value = ", value=" .. tostring(self.value)
    elseif self.reason then
        value = ", reason=" .. tostring(self.reason)
    end
    return "Promise{state=" .. self.state .. value .. "}"
end

function Promise:resolve(value)
    if self.state == PENDING then
        self.state = FULFILLED
        self.value = value
        self:_handle(value)
    end
    return self
end

function Promise:reject(reason)
    if self.state == PENDING then
        self.state = REJECTED
        self.reason = reason
        self:_handle(reason)
    end
    return self
end

function Promise:next(onResolve, onReject)
    if not isfunction(onResolve) then onResolve = nil end
    if not isfunction(onReject) then onReject = nil end
    local promise = Promise:new()
    self.handlers[#self.handlers + 1] = {
        [HANDLER_RESOLVE] = onResolve,
        [HANDLER_REJECT] = onReject,
        [HANDLER_PROMISE] = promise
    }

    if self.state ~= PENDING then
        timer.Simple(0, function()
            if self.state == FULFILLED then
                self:_handle(self.value)
            else
                self:_handle(self.reason)
            end
        end)
    end

    if DEBUG_IGNOREUNHANDLED then return promise end
    if self.rejectionHandlerID then
        promise.rejectionHandlerID = self.rejectionHandlerID
    else
        promise.rejectionHandlerID = REJECTION_HANDLER_ID
        UNHANDLED_PROMISES[REJECTION_HANDLER_ID] = true
        REJECTION_HANDLER_ID = REJECTION_HANDLER_ID + 1
    end
    return promise
end

function Promise:catch(onReject)
    return self:next(nil, onReject)
end

function Promise:_handle(value)
    if value == self then return self:reject("cannot resolve to self") end
    if istable(value) and value.next then
        if value.state then
            if not DEBUG_IGNOREUNHANDLED then
                UNHANDLED_PROMISES[value.rejectionHandlerID] = nil
                value.rejectionHandlerID = self.rejectionHandlerID
            end

            self.state = value.state
            if value.state == PENDING then
                self.value = value.value
                self.reason = value.reason
                value:next(function(newValue)
                    self:resolve(newValue)
                    return newValue
                end, function(reason)
                    self:reject(reason)
                    value.rejectionHandlerID = nil
                    return reason
                end)
            elseif value.state == FULFILLED then
                self:_handle(value.value)
            else
                self:reject(value.reason)
            end
            return
        elseif isfunction(value.next) then
            self.state = PENDING
            self.value = nil
            local first = true
            local function resolvePromise(newValue)
                if first then
                    self:resolve(newValue)
                    first = nil
                end
            end

            local function rejectPromise(reason)
                if first then
                    self:reject(reason)
                    first = nil
                end
            end

            local status, result = pcall(value.next, resolvePromise, rejectPromise)
            if not status and first then self:reject(result) end
            return
        end
    end

    local handler, onResolve, onReject, promise
    local isRejected = self.state == REJECTED
    for i = 1, #self.handlers do
        handler = self.handlers[i]
        onResolve = handler[HANDLER_RESOLVE]
        onReject = handler[HANDLER_REJECT]
        promise = handler[HANDLER_PROMISE]
        if isRejected then
            if onReject then
                local status, result = pcall(onReject, value)
                if status then
                    promise:_handle(result)
                    if self.rejectionHandlerID then UNHANDLED_PROMISES[self.rejectionHandlerID] = nil end
                else
                    promise:reject(result)
                end
            else
                promise:reject(value)
            end
        else
            if onResolve then
                local status, result = pcall(onResolve, value)
                if status then
                    promise:_handle(result)
                else
                    promise:reject(result)
                end
            else
                promise:resolve(value)
            end
        end
    end

    self.handlers = {}
    if isRejected and not DEBUG_IGNOREUNHANDLED then
        local trace = debug.traceback()
        timer.Simple(0.1, function()
            if UNHANDLED_PROMISES[self.rejectionHandlerID] and not DEBUG_IGNOREUNHANDLED then
                UNHANDLED_PROMISES[self.rejectionHandlerID] = nil
                ErrorNoHalt("Unhandled rejection: " .. tostring(self.reason or "") .. "\n")
                print(trace)
            end
        end)
    end
end

deferred = {}
function deferred.isPromise(value)
    return istable(value) and isfunction(value.next) and isfunction(value.resolve) and value.state
end

function deferred.new()
    local promise = Promise:new()
    if not DEBUG_IGNOREUNHANDLED then
        promise.rejectionHandlerID = REJECTION_HANDLER_ID
        UNHANDLED_PROMISES[REJECTION_HANDLER_ID] = true
        REJECTION_HANDLER_ID = REJECTION_HANDLER_ID + 1
    end
    return promise
end

function deferred.reject(reason)
    return deferred.new():reject(reason)
end

function deferred.resolve(value)
    return deferred.new():resolve(value)
end

function deferred.all(promises)
    assert(istable(promises), "promises must be a table of promises")
    local results = {}
    local d = deferred.new()
    local method = "resolve"
    local expected = #promises
    local finished = 0
    if finished == expected then return d:resolve(results) end
    local onFinish = function(i, resolved)
        return function(value)
            results[i] = value
            if not resolved then method = "reject" end
            finished = finished + 1
            if finished == expected then d[method](d, results) end
            return value
        end
    end

    for i = 1, expected do
        promises[i]:next(onFinish(i, true), onFinish(i, false))
    end
    return d
end

function deferred.map(args, fn)
    assert(istable(args), "args must be a table of values")
    assert(isfunction(fn), "map called without a function")
    local expected = #args
    local finished = 0
    local results = {}
    local d = deferred.new()
    if expected == 0 then return d:resolve(results) end
    for i = 1, expected do
        fn(args[i], i, expected):next(function(value)
            results[i] = value
            finished = finished + 1
            if finished == expected then d:resolve(results) end
        end, function(reason) d:reject(reason) end)
    end
    return d
end

function deferred.fold(promises, folder, initial)
    assert(istable(promises), "promises must be a table")
    assert(isfunction(folder), "folder must be a function")
    local d = deferred.new()
    local total = initial
    local length = #promises
    if length == 0 then return d:resolve(total) end
    local i = 1
    local function onRejected(reason)
        d:reject(reason)
        return reason
    end

    local function handle(value)
        total = folder(total, value, i, length)
        if i == length then
            d:resolve(total)
            return value
        end

        i = i + 1
        promises[i]:next(handle, onRejected)
        return value
    end

    promises[1]:next(handle, onRejected)
    return d
end

function deferred.filter(promises, filter)
    return deferred.fold(promises, function(acc, value)
        if filter(value) then acc[#acc + 1] = value end
        return acc
    end, {})
end

function deferred.each(promises, fn)
    return deferred.fold(promises, function(_, value, i, length) fn(value, i, length) end, nil):next(function() return nil end)
end

function deferred.some(promises, count)
    assert(istable(promises), "promises must be a table")
    assert(isnumber(count) and count >= 0 and math.floor(count) == count, "count must be a non-negative integer")
    local d = deferred.new()
    local results = {}
    local finished = 0
    if count == finished then return d:resolve(results) end
    for _, promise in ipairs(promises) do
        promise:next(function(value)
            if d.state ~= PENDING then return value end
            finished = finished + 1
            results[finished] = value
            if finished == count then d:resolve(results) end
            return value
        end, function(reason) d:reject(reason) end)
    end
    return d
end

function deferred.any(promises)
    return deferred.some(promises, 1):next(function(results) return results[1] end)
end


-- ./gamemode/core/libraries/thirdparty/sh_net.lua
local NetworkStringToIDCache = {}
local pon = {}
_G.pon = pon
local type, count = type, table.Count
local tonumber = tonumber
local format = string.format
do
    local type, count = type, table.Count
    local tonumber = tonumber
    local format = string.format
    local encode = {}
    local tryCache
    local cacheSize = 0
    encode['table'] = function(self, tbl, output, cache)
        if cache[tbl] then
            output[#output + 1] = format('(%x)', cache[tbl])
            return
        else
            cacheSize = cacheSize + 1
            cache[tbl] = cacheSize
        end

        local first = next(tbl, nil)
        local predictedNumeric = 1
        local lastKey = nil
        if first == 1 then
            output[#output + 1] = '{'
            for k, v in next, tbl do
                if k == predictedNumeric then
                    predictedNumeric = predictedNumeric + 1
                    local tv = type(v)
                    if tv == 'string' then
                        local pid = cache[v]
                        if pid then
                            output[#output + 1] = format('(%x)', pid)
                        else
                            cacheSize = cacheSize + 1
                            cache[v] = cacheSize
                            self.string(self, v, output, cache)
                        end
                    else
                        self[tv](self, v, output, cache)
                    end
                else
                    break
                end
            end

            predictedNumeric = predictedNumeric - 1
        else
            predictedNumeric = nil
        end

        if predictedNumeric == nil then
            output[#output + 1] = '['
        else
            output[#output + 1] = '~'
        end

        for k, v in next, tbl, predictedNumeric do
            local tk, tv = type(k), type(v)
            if tk == 'string' then
                local pid = cache[k]
                if pid then
                    output[#output + 1] = format('(%x)', pid)
                else
                    cacheSize = cacheSize + 1
                    cache[k] = cacheSize
                    self.string(self, k, output, cache)
                end
            else
                self[tk](self, k, output, cache)
            end

            if tv == 'string' then
                local pid = cache[v]
                if pid then
                    output[#output + 1] = format('(%x)', pid)
                else
                    cacheSize = cacheSize + 1
                    cache[v] = cacheSize
                    self.string(self, v, output, cache)
                end
            else
                self[tv](self, v, output, cache)
            end
        end

        output[#output + 1] = '}'
    end

    local gsub = string.gsub
    encode['string'] = function(self, str, output)
        local estr, count = gsub(str, ";", "\\;")
        if count == 0 then
            output[#output + 1] = '\'' .. str .. ';'
        else
            output[#output + 1] = '"' .. estr .. '";'
        end
    end

    encode['number'] = function(self, num, output)
        if num % 1 == 0 then
            if num < 0 then
                output[#output + 1] = format('x%x;', -num)
            else
                output[#output + 1] = format('X%x;', num)
            end
        else
            output[#output + 1] = tonumber(num) .. ';'
        end
    end

    encode['boolean'] = function(self, val, output) output[#output + 1] = val and 't' or 'f' end
    encode['Vector'] = function(self, val, output) output[#output + 1] = 'v' .. val.x .. ',' .. val.y .. ',' .. val.z .. ';' end
    encode['Angle'] = function(self, val, output) output[#output + 1] = 'a' .. val.p .. ',' .. val.y .. ',' .. val.r .. ';' end
    encode['Entity'] = function(self, val, output) output[#output + 1] = 'E' .. (IsValid(val) and val:EntIndex() .. ';' or '#') end
    encode['Player'] = encode['Entity']
    encode['Vehicle'] = encode['Entity']
    encode['Weapon'] = encode['Entity']
    encode['NPC'] = encode['Entity']
    encode['NextBot'] = encode['Entity']
    encode['PhysObj'] = encode['Entity']
    encode['nil'] = function() output[#output + 1] = '?' end
    encode.__index = function(key)
        ErrorNoHalt('Type: ' .. key .. ' can not be encoded. Encoded as as pass-over value.')
        return encode['nil']
    end

    do
        local empty, concat = table.Empty, table.concat
        function pon.encode(tbl)
            local output = {}
            cacheSize = 0
            encode['table'](encode, tbl, output, {})
            local res = concat(output)
            return res
        end
    end
end

do
    local tonumber = tonumber
    local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode
    local Vector, Angle, Entity = Vector, Angle, Entity
    local decode = {}
    decode['{'] = function(self, index, str, cache)
        local cur = {}
        cache[#cache + 1] = cur
        local k, v, tk, tv = 1, nil, nil, nil
        while true do
            tv = sub(str, index, index)
            if not tv or tv == '~' then
                index = index + 1
                break
            end

            if tv == '}' then return index + 1, cur end
            index = index + 1
            index, v = self[tv](self, index, str, cache)
            cur[k] = v
            k = k + 1
        end

        while true do
            tk = sub(str, index, index)
            if not tk or tk == '}' then
                index = index + 1
                break
            end

            index = index + 1
            index, k = self[tk](self, index, str, cache)
            tv = sub(str, index, index)
            index = index + 1
            index, v = self[tv](self, index, str, cache)
            cur[k] = v
        end
        return index, cur
    end

    decode['['] = function(self, index, str, cache)
        local cur = {}
        cache[#cache + 1] = cur
        local k, v, tk, tv = 1, nil, nil, nil
        while true do
            tk = sub(str, index, index)
            if not tk or tk == '}' then
                index = index + 1
                break
            end

            index = index + 1
            index, k = self[tk](self, index, str, cache)
            if not k then continue end
            tv = sub(str, index, index)
            index = index + 1
            if not self[tv] then print('did not find type: ' .. tv) end
            index, v = self[tv](self, index, str, cache)
            cur[k] = v
        end
        return index, cur
    end

    decode['"'] = function(self, index, str, cache)
        local finish = find(str, '";', index, true)
        local res = gsub(sub(str, index, finish - 1), '\\;', ';')
        index = finish + 2
        cache[#cache + 1] = res
        return index, res
    end

    decode['\''] = function(self, index, str, cache)
        local finish = find(str, ';', index, true)
        local res = sub(str, index, finish - 1)
        index = finish + 1
        cache[#cache + 1] = res
        return index, res
    end

    decode['n'] = function(self, index, str, cache)
        index = index - 1
        local finish = find(str, ';', index, true)
        local num = tonumber(sub(str, index, finish - 1))
        index = finish + 1
        return index, num
    end

    decode['0'] = decode['n']
    decode['1'] = decode['n']
    decode['2'] = decode['n']
    decode['3'] = decode['n']
    decode['4'] = decode['n']
    decode['5'] = decode['n']
    decode['6'] = decode['n']
    decode['7'] = decode['n']
    decode['8'] = decode['n']
    decode['9'] = decode['n']
    decode['-'] = decode['n']
    decode['X'] = function(self, index, str, cache)
        local finish = find(str, ';', index, true)
        local num = tonumber(sub(str, index, finish - 1), 16)
        index = finish + 1
        return index, num
    end

    decode['x'] = function(self, index, str, cache)
        local finish = find(str, ';', index, true)
        local num = -tonumber(sub(str, index, finish - 1), 16)
        index = finish + 1
        return index, num
    end

    decode['('] = function(self, index, str, cache)
        local finish = find(str, ')', index, true)
        local num = tonumber(sub(str, index, finish - 1), 16)
        index = finish + 1
        return index, cache[num]
    end

    decode['t'] = function(self, index) return index, true end
    decode['f'] = function(self, index) return index, false end
    decode['v'] = function(self, index, str, cache)
        local finish = find(str, ';', index, true)
        local vecStr = sub(str, index, finish - 1)
        index = finish + 1
        local segs = Explode(',', vecStr, false)
        return index, Vector(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
    end

    decode['a'] = function(self, index, str, cache)
        local finish = find(str, ';', index, true)
        local angStr = sub(str, index, finish - 1)
        index = finish + 1
        local segs = Explode(',', angStr, false)
        return index, Angle(tonumber(segs[1]), tonumber(segs[2]), tonumber(segs[3]))
    end

    decode['E'] = function(self, index, str, cache)
        if str[index] == '#' then
            index = index + 1
            return index, NULL
        else
            local finish = find(str, ';', index, true)
            local num = tonumber(sub(str, index, finish - 1))
            index = finish + 1
            return index, Entity(num)
        end
    end

    decode['P'] = function(self, index, str, cache)
        local finish = find(str, ';', index, true)
        local num = tonumber(sub(str, index, finish - 1))
        index = finish + 1
        return index, Entity(num) or NULL
    end

    decode['?'] = function(self, index, str, cache) return index + 1, nil end
    function pon.decode(data)
        local _, res = decode[sub(data, 1, 1)](decode, 2, data, {})
        return res
    end
end

local type, error, pcall, pairs, _player = type, error, pcall, pairs, player
netstream = netstream or {}
netstream.stored = netstream.stored or {}
function netstream.Split(data)
    local index = 1
    local result = {}
    local buffer = {}
    for i = 0, string.len(data) do
        buffer[#buffer + 1] = string.sub(data, i, i)
        if #buffer == 32768 then
            result[#result + 1] = table.concat(buffer)
            index = index + 1
            buffer = {}
        end
    end

    result[#result + 1] = table.concat(buffer)
    return result
end

function netstream.Hook(name, Callback)
    netstream.stored[name] = Callback
end

if SERVER then
    function netstream.Start(player, name, ...)
        local recipients = {}
        local bShouldSend = false
        local bSendPVS = false
        if not istable(player) then
            if not player then
                player = _player.GetAll()
            elseif type(player) == "Vector" then
                bSendPVS = true
            else
                player = {player}
            end
        end

        if type(player) ~= "Vector" then
            for k, v in pairs(player) do
                if type(v) == "Player" then
                    recipients[#recipients + 1] = v
                    bShouldSend = true
                elseif type(k) == "Player" then
                    recipients[#recipients + 1] = k
                    bShouldSend = true
                end
            end
        else
            bShouldSend = true
        end

        local dataTable = {...}
        local encodedData = pon.encode(dataTable)
        if encodedData and #encodedData > 0 and bShouldSend then
            net.Start("NetStreamDS")
            net.WriteString(name)
            net.WriteUInt(#encodedData, 32)
            net.WriteData(encodedData, #encodedData)
            if bSendPVS then
                net.SendPVS(player)
            else
                net.Send(recipients)
            end
        end
    end

    net.Receive("NetStreamDS", function(length, player)
        local NS_DS_NAME = net.ReadString()
        local NS_DS_LENGTH = net.ReadUInt(32)
        local NS_DS_DATA = net.ReadData(NS_DS_LENGTH)
        if NS_DS_NAME and NS_DS_DATA and NS_DS_LENGTH then
            player.nsDataStreamName = NS_DS_NAME
            player.nsDataStreamData = ""
            if player.nsDataStreamName and player.nsDataStreamData then
                player.nsDataStreamData = NS_DS_DATA
                if netstream.stored[player.nsDataStreamName] then
                    local bStatus, value = pcall(pon.decode, player.nsDataStreamData)
                    if bStatus then
                        netstream.stored[player.nsDataStreamName](player, unpack(value))
                    else
                        ErrorNoHalt("NetStream: '" .. NS_DS_NAME .. "'\n" .. value .. "\n")
                    end
                end

                player.nsDataStreamName = nil
                player.nsDataStreamData = nil
            end
        end

        NS_DS_NAME, NS_DS_DATA, NS_DS_LENGTH = nil, nil, nil
    end)
else
    function netstream.Start(name, ...)
        local dataTable = {...}
        local encodedData = pon.encode(dataTable)
        if encodedData and #encodedData > 0 then
            net.Start("NetStreamDS")
            net.WriteString(name)
            net.WriteUInt(#encodedData, 32)
            net.WriteData(encodedData, #encodedData)
            net.SendToServer()
        end
    end

    net.Receive("NetStreamDS", function(length)
        local NS_DS_NAME = net.ReadString()
        local NS_DS_LENGTH = net.ReadUInt(32)
        local NS_DS_DATA = net.ReadData(NS_DS_LENGTH)
        if NS_DS_NAME and NS_DS_DATA and NS_DS_LENGTH and netstream.stored[NS_DS_NAME] then
            local bStatus, value = pcall(pon.decode, NS_DS_DATA)
            if bStatus then
                netstream.stored[NS_DS_NAME](unpack(value))
            else
                ErrorNoHalt("NetStream: '" .. NS_DS_NAME .. "'\n" .. value .. "\n")
            end
        end

        NS_DS_NAME, NS_DS_DATA, NS_DS_LENGTH = nil, nil, nil
    end)
end

local function NetworkStringToID(str)
    local id = NetworkStringToIDCache[str]
    if id then return id end
    id = util.NetworkStringToID(str)
    if SERVER and id == 0 then id = util.AddNetworkString(str) end
    if id ~= 0 then
        NetworkStringToIDCache[str] = id
        return id
    end
end

local NetReceiverByID = {}
function net.Receive(name, func)
    local id = NetworkStringToID(name)
    if id then NetReceiverByID[id] = func end
    net.Receivers[name:lower()] = func
end

function net.Incoming(len, client)
    local i = net.ReadHeader()
    local func = NetReceiverByID[i]
    if not func then
        local str = util.NetworkIDToString(i)
        if not str then return end
        func = net.Receivers[str:lower()]
        if not func then return end
        NetReceiverByID[i] = func
    end

    func(len - 16, client)
end

if SERVER then
    local BaseNetStart = net.Start
    function net.Start(messageName, unreliable)
        NetworkStringToID(messageName)
        return BaseNetStart(messageName, unreliable)
    end
end

-- ./gamemode/core/libraries/thirdparty/sh_sfs.lua
local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then return "Color" end
    return internal_type(v)
end

local chars = {}
do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f
local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f
local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f
local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf
local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2
local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6
local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca
local DOUBLE = 0xcb
local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce
local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1
local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4
local VECTOR = 0xd5
local ANGLE = 0xd6
local ENTITY = 0xd7
local PLAYER = 0xd8
local COLOR = 0xd9
local ARRAY_ZERO_BASED_INDEX = 0xda
local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf
local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
local encoders = {}
local Encoder = {
    encoders = encoders
}

do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack
        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0
    }

    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0
        local encoder = get_encoder(buffer, val)
        if encoder == nil then return nil, concat(buffer, nil, buffer[0] - 1, buffer[0]) end
        if encoder(buffer, val, arg) == true then return nil, concat(buffer, nil, buffer[0] - 1, buffer[0]) end
        local result = concat(buffer, nil, 1, buffer[0])
        if #buffer > max_cache_size then
            buffer = {
                [0] = 0
            }
        end
        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0
        if encoders.array(buffer, arr, len) == true then return nil, concat(buffer, nil, buffer[0] - 1, buffer[0]) end
        local result = concat(buffer, nil, 1, buffer[0])
        if #buffer > max_cache_size then
            buffer = {
                [0] = 0
            }
        end
        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end

    Encoder.write = write
    encoders["nil"] = function(buf) write(buf, chars[NIL]) end
    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index
        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then write(buf, chars[ARRAY_ZERO_BASED_INDEX]) end
        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    function encoders.table(buf, tbl)
        do
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end

            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1
            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)
            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0]
        buf[0] = table_start
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end

            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end

        write(buf, str)
    end

    function encoders.number(buf, num)
        if num > MAX_NUMBER and num ~= HUGE or num < MIN_NUMBER and num ~= -HUGE then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, client)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(client))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end

    Encoder.write_unsigned = write_unsigned
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / 2 ^ exponent - 1
        if exponent < -1023 then
            exponent = -1023
            fraction = abs_value / 2 ^ exponent
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        if value == 0 then
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000
        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[exp_out % 16 * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end

    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}

do
    local sub = string.sub
    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end

    Decoder.byte = byte
    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then return nil, "Unsupported type: ", t end
        return decoder
    end

    Decoder.get_decoder = get_decoder
    local context = {1, "", 0, HUGE,}
    local decode = function()
        if context[3] < 1 then return nil, "Buffer is empty" end
        local err, err_2
        local decoder
        local val
        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then return nil, err, err_2 end
        val, err, err_2 = decoder(context)
        if err ~= nil then return nil, err, err_2 end
        return val
    end

    function Decoder.decode(str)
        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE
        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(max_size) ~= "number" then return nil, "max_size is not a number", max_size end
        if max_size < 0 then return nil, "max_size can either be a positive number or math.huge for unlimited", max_size end
        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size
        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then return nil, err end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then return nil, err end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then return nil, err end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then return nil, err end
        return decode_array(ctx, len)
    end

    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then return nil, err end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then return nil, err end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then return nil, err end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then return nil, err end
        return decode_table(ctx, len)
    end

    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then return nil, err end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then return nil, err end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then return nil, err end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then return nil, err end
        return decode_string(ctx, len)
    end

    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then return nil, err end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then return nil, err end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then return nil, err end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then return nil, err end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then return nil, b2 end
        return b1 + b2 * 0x100 + b3 * 0x10000 + b4 * 0x1000000 + b5 * 0x100000000 + b6 * 0x10000000000 + b7 * 0x1000000000000
    end

    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then return nil, err end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then return nil, err end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then return nil, err end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then return nil, err end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then return nil, b2 end
        return -(b1 + b2 * 0x100 + b3 * 0x10000 + b4 * 0x1000000 + b5 * 0x100000000 + b6 * 0x10000000000 + b7 * 0x1000000000000)
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1
        local err, err_2
        local decoder
        local x, y, z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        x, err = decoder(ctx)
        if err ~= nil then return nil, err end
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        y, err = decoder(ctx)
        if err ~= nil then return nil, err end
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        z, err = decoder(ctx)
        if err ~= nil then return nil, err end
        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        local err, err_2
        local decoder
        local p, y, r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        p, err = decoder(ctx)
        if err ~= nil then return nil, err end
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        y, err = decoder(ctx)
        if err ~= nil then return nil, err end
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        r, err = decoder(ctx)
        if err ~= nil then return nil, err end
        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1
        local err, err_2
        local decoder
        local ent_index
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        ent_index, err = decoder(ctx)
        if err ~= nil then return nil, err end
        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1
        local err, err_2
        local decoder
        local user_id
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        user_id, err = decoder(ctx)
        if err ~= nil then return nil, err end
        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1
        local err, err_2
        local decoder
        local r, g, b, a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        r, err = decoder(ctx)
        if err ~= nil then return nil, err end
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        g, err = decoder(ctx)
        if err ~= nil then return nil, err end
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        b, err = decoder(ctx)
        if err ~= nil then return nil, err end
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then return nil, err, err_2 end
        a, err = decoder(ctx)
        if err ~= nil then return nil, err end
        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}
        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then return nil, err, err_2 end
            val, err = decoder(ctx)
            if err ~= nil then return nil, err end
            arr[idx] = val
        end
        return arr
    end

    Decoder.decode_array = decode_array
    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then return nil, err, err_2 end
            key, err = decoder(ctx)
            if err ~= nil then return nil, err end
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then return nil, err, err_2 end
            val, err = decoder(ctx)
            if err ~= nil then return nil, err end
            tbl[key] = val
        end
        return tbl
    end

    Decoder.decode_table = decode_table
    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len
        return sub(ctx[2], index, index + len - 1)
    end

    Decoder.decode_string = decode_string
    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then return nil, b2 end
        local sign = b1 >= 128 and 1 or 0
        local exponent = b1 % 128 * 16 + floor(b2 / 16)
        local fraction = b2 % 16 * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        if exponent == 2047 then
            if fraction == 0 then return (sign == 0 and 1 or -1) * HUGE end
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        if exponent == 0 then
            return (sign == 0 and 1 or -1) * 2 ^ (exponent - 1023) * fraction / 0x10000000000000
        else
            return (sign == 0 and 1 or -1) * 2 ^ (exponent - 1023) * (fraction / 0x10000000000000 + 1)
        end
    end

    Decoder.decode_double = decode_double
    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end

    Decoder.read_type = read_type
    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then return nil, err end
        return bty
    end

    Decoder.read_byte = read_byte
    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then return nil, b2 end
        return b1 * 0x100 + b2
    end

    Decoder.read_word = read_word
    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then return nil, b2 end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end

    Decoder.read_dword = read_dword
end
return {
    Encoder = Encoder,
    Decoder = Decoder,
    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,
    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,
    set_type_function = function(t_fn) type = t_fn end,
    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then return nil, "No more free slots for custom encoders" end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,
    add_decoder = function(typ, decoder) decoders[typ] = decoder end,
    chars = chars,
    VERSION = "2.0.1"
}


-- ./gamemode/core/libraries/thirdparty/sv_mysql.lua
mysql = mysql or {
    module = "sqlite"
}

local QueueTable = {}
local tostring = tostring
local table = table
local Replacements = {
    sqlite = {
        Create = {{"UNSIGNED ", ""}, {"NOT NULL AUTO_INCREMENT", ""}, {"AUTO_INCREMENT", ""}, {"INT%(%d*%)", "INTEGER"}, {"INT ", "INTEGER"}}
    }
}

local MODULE_NOT_EXIST = "[mysql] The %s module does not exist!\n"
local QUERY_CLASS = {}
QUERY_CLASS.__index = QUERY_CLASS
function QUERY_CLASS:New(tableName, queryType)
    local newObject = setmetatable({}, QUERY_CLASS)
    newObject.queryType = queryType
    newObject.tableName = tableName
    newObject.selectList = {}
    newObject.insertList = {}
    newObject.updateList = {}
    newObject.createList = {}
    newObject.whereList = {}
    newObject.orderByList = {}
    return newObject
end

function QUERY_CLASS:Escape(text)
    return mysql:Escape(tostring(text))
end

function QUERY_CLASS:ForTable(tableName)
    self.tableName = tableName
end

function QUERY_CLASS:Where(key, value)
    self:WhereEqual(key, value)
end

function QUERY_CLASS:WhereEqual(key, value)
    self.whereList[#self.whereList + 1] = "`" .. key .. "` = '" .. self:Escape(value) .. "'"
end

function QUERY_CLASS:WhereNotEqual(key, value)
    self.whereList[#self.whereList + 1] = "`" .. key .. "` != '" .. self:Escape(value) .. "'"
end

function QUERY_CLASS:WhereLike(key, value, format)
    format = format or "%%%s%%"
    self.whereList[#self.whereList + 1] = "`" .. key .. "` LIKE '" .. string.format(format, self:Escape(value)) .. "'"
end

function QUERY_CLASS:WhereNotLike(key, value, format)
    format = format or "%%%s%%"
    self.whereList[#self.whereList + 1] = "`" .. key .. "` NOT LIKE '" .. string.format(format, self:Escape(value)) .. "'"
end

function QUERY_CLASS:WhereGT(key, value)
    self.whereList[#self.whereList + 1] = "`" .. key .. "` > '" .. self:Escape(value) .. "'"
end

function QUERY_CLASS:WhereLT(key, value)
    self.whereList[#self.whereList + 1] = "`" .. key .. "` < '" .. self:Escape(value) .. "'"
end

function QUERY_CLASS:WhereGTE(key, value)
    self.whereList[#self.whereList + 1] = "`" .. key .. "` >= '" .. self:Escape(value) .. "'"
end

function QUERY_CLASS:WhereLTE(key, value)
    self.whereList[#self.whereList + 1] = "`" .. key .. "` <= '" .. self:Escape(value) .. "'"
end

function QUERY_CLASS:WhereIn(key, value)
    value = istable(value) and value or {value}
    local values = ""
    local bFirst = true
    for k, v in pairs(value) do
        values = values .. (bFirst and "" or ", ") .. self:Escape(v)
        bFirst = false
    end

    self.whereList[#self.whereList + 1] = "`" .. key .. "` IN (" .. values .. ")"
end

function QUERY_CLASS:OrderByDesc(key)
    self.orderByList[#self.orderByList + 1] = "`" .. key .. "` DESC"
end

function QUERY_CLASS:OrderByAsc(key)
    self.orderByList[#self.orderByList + 1] = "`" .. key .. "` ASC"
end

function QUERY_CLASS:Callback(queryCallback)
    self.callback = queryCallback
end

function QUERY_CLASS:Select(fieldName)
    self.selectList[#self.selectList + 1] = "`" .. fieldName .. "`"
end

function QUERY_CLASS:Insert(key, value)
    self.insertList[#self.insertList + 1] = {"`" .. key .. "`", "'" .. self:Escape(value) .. "'"}
end

function QUERY_CLASS:Update(key, value)
    self.updateList[#self.updateList + 1] = {"`" .. key .. "`", "'" .. self:Escape(value) .. "'"}
end

function QUERY_CLASS:Create(key, value)
    self.createList[#self.createList + 1] = {"`" .. key .. "`", value}
end

function QUERY_CLASS:Add(key, value)
    self.add = {"`" .. key .. "`", value}
end

function QUERY_CLASS:Drop(key)
    self.drop = "`" .. key .. "`"
end

function QUERY_CLASS:PrimaryKey(key)
    self.primaryKey = "`" .. key .. "`"
end

function QUERY_CLASS:Limit(value)
    self.limit = value
end

function QUERY_CLASS:Offset(value)
    self.offset = value
end

local function ApplyQueryReplacements(mode, query)
    if not Replacements[mysql.module] then return query end
    local result = query
    local entries = Replacements[mysql.module][mode]
    for i = 1, #entries do
        result = string.gsub(result, entries[i][1], entries[i][2])
    end
    return result
end

local function BuildSelectQuery(queryObj)
    local queryString = {"SELECT"}
    if not istable(queryObj.selectList) or #queryObj.selectList == 0 then
        queryString[#queryString + 1] = " *"
    else
        queryString[#queryString + 1] = " " .. table.concat(queryObj.selectList, ", ")
    end

    if isstring(queryObj.tableName) then
        queryString[#queryString + 1] = " FROM `" .. queryObj.tableName .. "` "
    else
        ErrorNoHalt("[mysql] No table name specified!\n")
        return
    end

    if istable(queryObj.whereList) and #queryObj.whereList > 0 then
        queryString[#queryString + 1] = " WHERE "
        queryString[#queryString + 1] = table.concat(queryObj.whereList, " AND ")
    end

    if istable(queryObj.orderByList) and #queryObj.orderByList > 0 then
        queryString[#queryString + 1] = " ORDER BY "
        queryString[#queryString + 1] = table.concat(queryObj.orderByList, ", ")
    end

    if isnumber(queryObj.limit) then
        queryString[#queryString + 1] = " LIMIT "
        queryString[#queryString + 1] = queryObj.limit
    end
    return table.concat(queryString)
end

local function BuildInsertQuery(queryObj, bIgnore)
    local suffix = bIgnore and (mysql.module == "sqlite" and "INSERT OR IGNORE INTO" or "INSERT IGNORE INTO") or "INSERT INTO"
    local queryString = {suffix}
    local keyList = {}
    local valueList = {}
    if isstring(queryObj.tableName) then
        queryString[#queryString + 1] = " `" .. queryObj.tableName .. "`"
    else
        ErrorNoHalt("[mysql] No table name specified!\n")
        return
    end

    for i = 1, #queryObj.insertList do
        keyList[#keyList + 1] = queryObj.insertList[i][1]
        valueList[#valueList + 1] = queryObj.insertList[i][2]
    end

    if #keyList == 0 then return end
    queryString[#queryString + 1] = " (" .. table.concat(keyList, ", ") .. ")"
    queryString[#queryString + 1] = " VALUES (" .. table.concat(valueList, ", ") .. ")"
    return table.concat(queryString)
end

local function BuildUpdateQuery(queryObj)
    local queryString = {"UPDATE"}
    if isstring(queryObj.tableName) then
        queryString[#queryString + 1] = " `" .. queryObj.tableName .. "`"
    else
        ErrorNoHalt("[mysql] No table name specified!\n")
        return
    end

    if istable(queryObj.updateList) and #queryObj.updateList > 0 then
        local updateList = {}
        queryString[#queryString + 1] = " SET"
        for i = 1, #queryObj.updateList do
            updateList[#updateList + 1] = queryObj.updateList[i][1] .. " = " .. queryObj.updateList[i][2]
        end

        queryString[#queryString + 1] = " " .. table.concat(updateList, ", ")
    end

    if istable(queryObj.whereList) and #queryObj.whereList > 0 then
        queryString[#queryString + 1] = " WHERE "
        queryString[#queryString + 1] = table.concat(queryObj.whereList, " AND ")
    end

    if isnumber(queryObj.offset) then
        queryString[#queryString + 1] = " OFFSET "
        queryString[#queryString + 1] = queryObj.offset
    end
    return table.concat(queryString)
end

local function BuildDeleteQuery(queryObj)
    local queryString = {"DELETE FROM"}
    if isstring(queryObj.tableName) then
        queryString[#queryString + 1] = " `" .. queryObj.tableName .. "`"
    else
        ErrorNoHalt("[mysql] No table name specified!\n")
        return
    end

    if istable(queryObj.whereList) and #queryObj.whereList > 0 then
        queryString[#queryString + 1] = " WHERE "
        queryString[#queryString + 1] = table.concat(queryObj.whereList, " AND ")
    end

    if isnumber(queryObj.limit) then
        queryString[#queryString + 1] = " LIMIT "
        queryString[#queryString + 1] = queryObj.limit
    end
    return table.concat(queryString)
end

local function BuildDropQuery(queryObj)
    local queryString = {"DROP TABLE"}
    if isstring(queryObj.tableName) then
        queryString[#queryString + 1] = " `" .. queryObj.tableName .. "`"
    else
        ErrorNoHalt("[mysql] No table name specified!\n")
        return
    end
    return table.concat(queryString)
end

local function BuildTruncateQuery(queryObj)
    local queryString = {"TRUNCATE TABLE"}
    if isstring(queryObj.tableName) then
        queryString[#queryString + 1] = " `" .. queryObj.tableName .. "`"
    else
        ErrorNoHalt("[mysql] No table name specified!\n")
        return
    end
    return table.concat(queryString)
end

local function BuildCreateQuery(queryObj)
    local queryString = {"CREATE TABLE IF NOT EXISTS"}
    if isstring(queryObj.tableName) then
        queryString[#queryString + 1] = " `" .. queryObj.tableName .. "`"
    else
        ErrorNoHalt("[mysql] No table name specified!\n")
        return
    end

    queryString[#queryString + 1] = " ("
    if istable(queryObj.createList) and #queryObj.createList > 0 then
        local createList = {}
        for i = 1, #queryObj.createList do
            if mysql.module == "sqlite" then
                createList[#createList + 1] = queryObj.createList[i][1] .. " " .. ApplyQueryReplacements("Create", queryObj.createList[i][2])
            else
                createList[#createList + 1] = queryObj.createList[i][1] .. " " .. queryObj.createList[i][2]
            end
        end

        queryString[#queryString + 1] = " " .. table.concat(createList, ", ")
    end

    if isstring(queryObj.primaryKey) then
        queryString[#queryString + 1] = ", PRIMARY KEY"
        queryString[#queryString + 1] = " (" .. queryObj.primaryKey .. ")"
    end

    queryString[#queryString + 1] = " )"
    return table.concat(queryString)
end

local function BuildAlterQuery(queryObj)
    local queryString = {"ALTER TABLE"}
    if isstring(queryObj.tableName) then
        queryString[#queryString + 1] = " `" .. queryObj.tableName .. "`"
    else
        ErrorNoHalt("[mysql] No table name specified!\n")
        return
    end

    if istable(queryObj.add) then
        queryString[#queryString + 1] = " ADD " .. queryObj.add[1] .. " " .. ApplyQueryReplacements("Create", queryObj.add[2])
    elseif isstring(queryObj.drop) then
        if mysql.module == "sqlite" then
            ErrorNoHalt("[mysql] Cannot drop columns in sqlite!\n")
            return
        end

        queryString[#queryString + 1] = " DROP COLUMN " .. queryObj.drop
    end
    return table.concat(queryString)
end

function QUERY_CLASS:Execute(bQueueQuery)
    local queryString = nil
    local queryType = string.lower(self.queryType)
    if queryType == "select" then
        queryString = BuildSelectQuery(self)
    elseif queryType == "insert" then
        queryString = BuildInsertQuery(self)
    elseif queryType == "insert ignore" then
        queryString = BuildInsertQuery(self, true)
    elseif queryType == "update" then
        queryString = BuildUpdateQuery(self)
    elseif queryType == "delete" then
        queryString = BuildDeleteQuery(self)
    elseif queryType == "drop" then
        queryString = BuildDropQuery(self)
    elseif queryType == "truncate" then
        queryString = BuildTruncateQuery(self)
    elseif queryType == "create" then
        queryString = BuildCreateQuery(self)
    elseif queryType == "alter" then
        queryString = BuildAlterQuery(self)
    end

    if isstring(queryString) then
        if not bQueueQuery then
            return mysql:RawQuery(queryString, self.callback)
        else
            return mysql:Queue(queryString, self.callback)
        end
    end
end

function mysql:Select(tableName)
    return QUERY_CLASS:New(tableName, "SELECT")
end

function mysql:Insert(tableName)
    return QUERY_CLASS:New(tableName, "INSERT")
end

function mysql:InsertIgnore(tableName)
    return QUERY_CLASS:New(tableName, "INSERT IGNORE")
end

function mysql:Update(tableName)
    return QUERY_CLASS:New(tableName, "UPDATE")
end

function mysql:Delete(tableName)
    return QUERY_CLASS:New(tableName, "DELETE")
end

function mysql:Drop(tableName)
    return QUERY_CLASS:New(tableName, "DROP")
end

function mysql:Truncate(tableName)
    return QUERY_CLASS:New(tableName, "TRUNCATE")
end

function mysql:Create(tableName)
    return QUERY_CLASS:New(tableName, "CREATE")
end

function mysql:Alter(tableName)
    return QUERY_CLASS:New(tableName, "ALTER")
end

local UTF8MB4 = "ALTER DATABASE %s CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci"
function mysql:Connect(host, username, password, database, port, socket, flags)
    port = port or 3306
    if self.module == "mysqloo" then
        if not istable(mysqloo) then require("mysqloo") end
        if mysqloo then
            if self.connection and self.connection:ping() then return end
            local clientFlag = flags or 0
            if not isstring(socket) then
                self.connection = mysqloo.connect(host, username, password, database, port)
            else
                self.connection = mysqloo.connect(host, username, password, database, port, socket, clientFlag)
            end

            self.connection.onConnected = function(connection)
                local success, error_message = connection:setCharacterSet("utf8mb4")
                if not success then
                    ErrorNoHalt("Failed to set MySQL encoding!\n")
                    ErrorNoHalt(error_message .. "\n")
                else
                    self:RawQuery(string.format(UTF8MB4, database))
                end

                mysql:OnConnected()
            end

            self.connection.onConnectionFailed = function(database, errorText) mysql:OnConnectionFailed(errorText) end
            self.connection:connect()
            timer.Create("mysql.KeepAlive", 300, 0, function() self.connection:ping() end)
        else
            ErrorNoHalt(string.format(MODULE_NOT_EXIST, self.module))
        end
    elseif self.module == "sqlite" then
        mysql:OnConnected()
    end
end

function mysql:RawQuery(query, callback, flags, ...)
    if self.module == "mysqloo" then
        local queryObj = self.connection:query(query)
        queryObj:setOption(mysqloo.OPTION_NAMED_FIELDS)
        queryObj.onSuccess = function(queryObj, result)
            if callback then
                local bStatus, value = pcall(callback, result, true, tonumber(queryObj:lastInsert()))
                if not bStatus then error(string.format("[mysql] MySQL Callback Error!\n%s\n", value)) end
            end
        end

        queryObj.onError = function(queryObj, errorText) ErrorNoHalt(string.format("[mysql] MySQL Query Error!\nQuery: %s\n%s\n", query, errorText)) end
        queryObj:start()
    elseif self.module == "sqlite" then
        local result = sql.Query(query)
        if result == false then
            error(string.format("[mysql] SQL Query Error!\nQuery: %s\n%s\n", query, sql.LastError()))
        else
            if callback then
                local bStatus, value = pcall(callback, result, true, tonumber(sql.QueryValue("SELECT last_insert_rowid()")))
                if not bStatus then error(string.format("[mysql] SQL Callback Error!\n%s\n", value)) end
            end
        end
    else
        ErrorNoHalt(string.format("[mysql] Unsupported module \"%s\"!\n", self.module))
    end
end

function mysql:Queue(queryString, callback)
    if isstring(queryString) then QueueTable[#QueueTable + 1] = {queryString, callback} end
end

function mysql:Escape(text)
    if self.connection then
        if self.module == "mysqloo" then return self.connection:escape(text) end
    else
        return sql.SQLStr(text, true)
    end
end

function mysql:Disconnect()
    if self.connection and self.module == "mysqloo" then self.connection:disconnect(true) end
end

function mysql:Think()
    if #QueueTable > 0 and istable(QueueTable[1]) then
        local queueObj = QueueTable[1]
        local queryString = queueObj[1]
        local callback = queueObj[2]
        if isstring(queryString) then self:RawQuery(queryString, callback) end
        table.remove(QueueTable, 1)
    end
end

function mysql:SetModule(moduleName)
    self.module = moduleName
end

function mysql:OnConnected()
    MsgC(Color(25, 235, 25), "[mysql] Connected to the database!\n")
    hook.Run("DatabaseConnected")
end

function mysql:OnConnectionFailed(errorText)
    ErrorNoHalt(string.format("[mysql] Unable to connect to the database!\n%s\n", errorText))
    hook.Run("DatabaseConnectionFailed", errorText)
end

function mysql:IsConnected()
    return self.module == "mysqloo" and self.connection and self.connection:ping() or self.module == "sqlite"
end
return mysql

-- ./gamemode/core/libraries/time.lua
lia.time = lia.time or {}
--[[
    lia.time.TimeSince
    Description:
       Returns a human-readable string indicating how long ago a given time occurred (e.g., "5 minutes ago").

    Parameters:
       strTime (string or number)  The time in string or timestamp form.

    Returns:
       (string) The time since the given date/time in a readable format.

    Realm:
       Shared

    Example Usage:
       print(lia.time.TimeSince("2025-03-27"))
 ]]
function lia.time.TimeSince(strTime)
    local timestamp
    if isnumber(strTime) then
        timestamp = strTime
    elseif isstring(strTime) then
        local year, month, day = lia.time.ParseTime(strTime)
        if not (year and month and day) then return L("invalidDate") end
        timestamp = os.time{
            year = year,
            month = month,
            day = day,
            hour = 0,
            min = 0,
            sec = 0
        }
    else
        return L("invalidInput")
    end

    local diff = os.time() - timestamp
    if diff < 60 then
        return L("secondsAgo", diff)
    elseif diff < 3600 then
        return L("minutesAgo", math.floor(diff / 60))
    elseif diff < 86400 then
        return L("hoursAgo", math.floor(diff / 3600))
    else
        return L("daysAgo", math.floor(diff / 86400))
    end
end

--[[
   lia.time.toNumber

   Description:
      Converts a string timestamp (YYYY-MM-DD HH:MM:SS) to a table with numeric fields:
      year, month, day, hour, min, sec. Defaults to current time if not provided.

   Parameters:
      str (string)  The time string to convert (optional).

   Returns:
      (table) A table with numeric year, month, day, hour, min, sec.

   Realm:
      Shared

   Example Usage:
      local t = lia.time.toNumber("2025-03-27 14:30:00")
      print(t.year, t.month, t.day, t.hour, t.min, t.sec)
 ]]
function lia.time.toNumber(str)
    str = str or os.date("%Y-%m-%d %H:%M:%S", os.time())
    return {
        year = tonumber(str:sub(1, 4)),
        month = tonumber(str:sub(6, 7)),
        day = tonumber(str:sub(9, 10)),
        hour = tonumber(str:sub(12, 13)),
        min = tonumber(str:sub(15, 16)),
        sec = tonumber(str:sub(18, 19)),
    }
end

--[[
    lia.time.GetDate

    Description:
       Returns the full current date and time formatted based on the
       "AmericanTimeStamps" configuration flag:
        If enabled: "Weekday, Month DD, YYYY, HH:MM:SSam/pm"
        If disabled: "Weekday, DD Month YYYY, HH:MM:SS"

    Parameters:
       None

    Returns:
       (string) Formatted date and time string.
 ]]
function lia.time.GetDate()
    local ct = os.date("*t")
    local american = lia.config.get("AmericanTimeStamps", false)
    local weekdayKeys = {"weekdaySunday", "weekdayMonday", "weekdayTuesday", "weekdayWednesday", "weekdayThursday", "weekdayFriday", "weekdaySaturday"}
    local monthKeys = {"monthJanuary", "monthFebruary", "monthMarch", "monthApril", "monthMay", "monthJune", "monthJuly", "monthAugust", "monthSeptember", "monthOctober", "monthNovember", "monthDecember"}
    local dayName = L(weekdayKeys[ct.wday])
    local monthName = L(monthKeys[ct.month])
    if american then
        local suffix = ct.hour < 12 and "am" or "pm"
        local hour12 = ct.hour % 12
        if hour12 == 0 then hour12 = 12 end
        return string.format("%s, %s %02d, %04d, %02d:%02d:%02d%s", dayName, monthName, ct.day, ct.year, hour12, ct.min, ct.sec, suffix)
    end
    return string.format("%s, %02d %s %04d, %02d:%02d:%02d", dayName, ct.day, monthName, ct.year, ct.hour, ct.min, ct.sec)
end

--[[
    lia.time.GetHour

    Description:
       Returns the current hour formatted based on the
       "AmericanTimeStamps" configuration flag:
        If enabled: "Ham" or "Hpm" (12-hour with am/pm)
        If disabled: H (023, 24-hour)

    Parameters:
       None

    Returns:
       (string|number) Current hour string with suffix when AmericanTimeStamps
                      is enabled, otherwise numeric hour in 24-hour format.
 ]]
function lia.time.GetHour()
    local ct = os.date("*t")
    local american = lia.config.get("AmericanTimeStamps", false)
    if american then
        local suffix = ct.hour < 12 and "am" or "pm"
        local hour12 = ct.hour % 12
        if hour12 == 0 then hour12 = 12 end
        return string.format("%d%s", hour12, suffix)
    end
    return ct.hour
end

-- ./gamemode/core/libraries/util.lua
--[[
   lia.util.FindPlayersInBox

   Description:
      Finds and returns a table of players within a given axis-aligned bounding box.

   Parameters:
      mins (Vector)  The minimum corner of the bounding box.
      maxs (Vector)  The maximum corner of the bounding box.

   Returns:
      table  A table of valid player entities.

   Realm:
      Shared

   Example Usage:
      local players = lia.util.FindPlayersInBox(Vector(0, 0, 0), Vector(100, 100, 100))
      for _, ply in ipairs(players) do
         print(ply:Name())
      end
]]
function lia.util.FindPlayersInBox(mins, maxs)
   local entsList = ents.FindInBox(mins, maxs)
   local plyList = {}
   for _, v in pairs(entsList) do
      if IsValid(v) and v:IsPlayer() then plyList[#plyList + 1] = v end
   end
   return plyList
end

--[[
   lia.util.FindPlayersInSphere

   Description:
      Finds and returns a table of players within a given spherical radius from an origin.

   Parameters:
      origin (Vector)  The center of the sphere.
      radius (number)  The radius of the sphere.

   Returns:
      table  A table of valid player entities.

   Realm:
      Shared

   Example Usage:
      local players = lia.util.FindPlayersInSphere(Vector(0, 0, 0), 200)
      for _, ply in ipairs(players) do
         print(ply:Name())
      end
]]
function lia.util.FindPlayersInSphere(origin, radius)
   local plys = {}
   local r2 = radius ^ 2
   for _, client in player.Iterator() do
      if client:GetPos():DistToSqr(origin) <= r2 then plys[#plys + 1] = client end
   end
   return plys
end

--[[
   lia.util.findPlayer

   Description:
      Attempts to find a player by identifier. The identifier can be STEAMID, SteamID64, "^" (self), "@" (looking at target), or partial name.

   Parameters:
      client (Player)  The player requesting the find (used for notifications).
      identifier (string)  The identifier to search by.

   Returns:
      Player|nil  The found player, or nil if not found.

   Realm:
      Shared

   Alias:
      lia.command.findPlayer

   Example Usage:
      local foundPly = lia.util.findPlayer(someAdmin, "Bob")
      if foundPly then
         print("Found player: " .. foundPly:Name())
      end
]]
function lia.util.findPlayer(client, identifier)
   local isValidClient = IsValid(client)
   if not isstring(identifier) or identifier == "" then
      if isValidClient then client:notifyLocalized("mustProvideString") end
      return nil
   end

   if string.match(identifier, "^STEAM_%d+:%d+:%d+$") then
      local ply = player.GetBySteamID(identifier)
      if IsValid(ply) then return ply end
      if isValidClient then client:notifyLocalized("plyNoExist") end
      return nil
   end

   if string.match(identifier, "^%d+$") and #identifier >= 17 then
      local sid = util.SteamIDFrom64(identifier)
      if sid then
         local ply = player.GetBySteamID(sid)
         if IsValid(ply) then return ply end
      end

      if isValidClient then client:notifyLocalized("plyNoExist") end
      return nil
   end

   if isValidClient and identifier == "^" then return client end
   if isValidClient and identifier == "@" then
      local trace = client:getTracedEntity()
      if IsValid(trace) and trace:IsPlayer() then return trace end
      client:notifyLocalized("lookToUseAt")
      return nil
   end

   local safe = string.PatternSafe(identifier)
   for _, ply in player.Iterator() do
      if lia.util.stringMatches(ply:Name(), safe) then return ply end
   end

   if isValidClient then client:notifyLocalized("plyNoExist") end
   return nil
end

--[[
   lia.util.findPlayerItems

   Description:
      Finds all item entities in the world created by the specified player.

   Parameters:
      client (Player)  The player whose items to find.

   Returns:
      table  A table of valid item entities.

   Realm:
      Shared

   Example Usage:
      local items = lia.util.findPlayerItems(LocalPlayer())
      for _, item in ipairs(items) do
         print("Found item entity: " .. item:GetClass())
      end
]]
function lia.util.findPlayerItems(client)
   local items = {}
   for _, item in ents.Iterator() do
      if IsValid(item) and item:isItem() and item:GetCreator() == client then table.insert(items, item) end
   end
   return items
end

--[[
   lia.util.findPlayerItemsByClass

   Description:
      Finds all item entities in the world created by the specified player with a specific class ID.

   Parameters:
      client (Player)  The player whose items to find.
      class (string)  The class ID to filter by.

   Returns:
      table  A table of valid item entities matching the class.

   Realm:
      Shared

   Example Usage:
      local items = lia.util.findPlayerItemsByClass(LocalPlayer(), "food_banana")
      for _, item in ipairs(items) do
         print("Found item entity: " .. item:GetClass())
      end
]]
function lia.util.findPlayerItemsByClass(client, class)
   local items = {}
   for _, item in ents.Iterator() do
      if IsValid(item) and item:isItem() and item:GetCreator() == client and item:getNetVar("id") == class then table.insert(items, item) end
   end
   return items
end

--[[
   lia.util.findPlayerEntities

   Description:
      Finds all entities in the world created by or associated with the specified player. An optional class filter can be applied.

   Parameters:
      client (Player)  The player whose entities to find.
      class (string|nil)  The class name to filter by (optional).

   Returns:
      table  A table of valid entities.

   Realm:
      Shared

   Example Usage:
      local entities = lia.util.findPlayerEntities(LocalPlayer(), "prop_physics")
      for _, ent in ipairs(entities) do
         print("Found player entity: " .. ent:GetClass())
      end
]]
function lia.util.findPlayerEntities(client, class)
   local entities = {}
   for _, entity in ents.Iterator() do
      if IsValid(entity) and (not class or entity:GetClass() == class) and (entity:GetCreator() == client or entity.client and entity.client == client) then table.insert(entities, entity) end
   end
   return entities
end

--[[
   lia.util.stringMatches

   Description:
      Checks if string a matches string b (case-insensitive, partial matches).

   Parameters:
      a (string)  The first string to check.
      b (string)  The second string to match against.

   Returns:
      boolean  True if they match, false otherwise.

   Realm:
      Shared

   Example Usage:
      if lia.util.stringMatches("Hello", "he") then
         print("Strings match!")
      end
]]
function lia.util.stringMatches(a, b)
   if a and b then
      local a2, b2 = a:lower(), b:lower()
      if a == b then return true end
      if a2 == b2 then return true end
      if a:find(b) then return true end
      if a2:find(b2) then return true end
   end
   return false
end

--[[
   lia.util.getAdmins

   Description:
      Returns all players considered staff or admins, as determined by client:isStaff().

   Returns:
      table  A table of player entities who are staff.

   Realm:
      Shared

   Example Usage:
      local admins = lia.util.getAdmins()
      for _, admin in ipairs(admins) do
         print("Staff: " .. admin:Name())
      end
]]
function lia.util.getAdmins()
   local staff = {}
   for _, client in player.Iterator() do
      local hasPermission = client:isStaff()
      if hasPermission then staff[#staff + 1] = client end
   end
   return staff
end

--[[
   lia.util.findPlayerBySteamID64

   Description:
      Finds a player currently on the server by their SteamID64.

   Parameters:
      SteamID64 (string)  The SteamID64 to search for.

   Returns:
      Player|nil  The found player or nil if not found.

   Realm:
      Shared

   Example Usage:
      local ply = lia.util.findPlayerBySteamID64("76561198000000000")
      if ply then
         print("Found player: " .. ply:Name())
      end
]]
function lia.util.findPlayerBySteamID64(SteamID64)
   for _, client in player.Iterator() do
      if client:SteamID64() == SteamID64 then return client end
   end
   return nil
end

--[[
   lia.util.findPlayerBySteamID

   Description:
      Finds a player currently on the server by their SteamID.

   Parameters:
      SteamID (string)  The SteamID to search for (e.g. "STEAM_0:1:23456789").

   Returns:
      Player|nil  The found player or nil if not found.

   Realm:
      Shared

   Example Usage:
      local ply = lia.util.findPlayerBySteamID("STEAM_0:1:23456789")
      if ply then
         print("Found player: " .. ply:Name())
      end
]]
function lia.util.findPlayerBySteamID(SteamID)
   for _, client in player.Iterator() do
      if client:SteamID64() == SteamID then return client end
   end
   return nil
end

--[[
   lia.util.canFit

   Description:
      Checks if a hull (defined by mins and maxs) can fit at the given position without intersecting obstacles.

   Parameters:
      pos (Vector)  The position to test.
      mins (Vector)  The minimum corner of the hull (defaults to Vector(16, 16, 0) if nil).
      maxs (Vector)  The maximum corner of the hull (defaults to same as mins if nil).
      filter (table|Entity|function)  Optional filter for the trace.

   Returns:
      boolean  True if it can fit, false otherwise.

   Realm:
      Shared

   Example Usage:
      local canStand = lia.util.canFit(somePos, Vector(-16, -16, 0), Vector(16, 16, 72))
      if canStand then
         print("The player can stand here.")
      end
]]
function lia.util.canFit(pos, mins, maxs, filter)
   mins = mins ~= nil and mins or Vector(16, 16, 0)
   local tr = util.TraceHull({
      start = pos + Vector(0, 0, 1),
      mask = MASK_PLAYERSOLID,
      filter = filter,
      endpos = pos,
      mins = mins.x > 0 and mins * -1 or mins,
      maxs = maxs ~= nil and maxs or mins
   })
   return not tr.Hit
end

--[[
   lia.util.playerInRadius

   Description:
      Finds and returns a table of players within a given radius from a position.

   Parameters:
      pos (Vector)  The center position.
      dist (number)  The radius to search within.

   Returns:
      table  A table of player entities within the radius.

   Realm:
      Shared

   Example Usage:
      local playersNearby = lia.util.playerInRadius(Vector(0, 0, 0), 250)
      for _, ply in ipairs(playersNearby) do
         print("Nearby player: " .. ply:Name())
      end
]]
function lia.util.playerInRadius(pos, dist)
   dist = dist * dist
   local t = {}
   for _, client in player.Iterator() do
      if IsValid(client) and client:GetPos():DistToSqr(pos) < dist then t[#t + 1] = client end
   end
   return t
end

--[[
   lia.util.formatStringNamed

   Description:
      Formats a string with named or indexed placeholders. If a table is passed, uses named keys. Otherwise uses ordered arguments.

   Parameters:
      format (string)  The format string with placeholders like "{key}".
      ... (vararg|table)  Either a table or vararg arguments to fill placeholders.

   Returns:
      string  The formatted string.

   Realm:
      Shared

   Example Usage:
      local result = lia.util.formatStringNamed("Hello, {name}!", {name = "Bob"})
      print(result) -- "Hello, Bob!"
]]
function lia.util.formatStringNamed(format, ...)
   local arguments = {...}
   local bArray = false
   local input
   if istable(arguments[1]) then
      input = arguments[1]
   else
      input = arguments
      bArray = true
   end

   local i = 0
   local result = format:gsub("{(%w-)}", function(word)
      i = i + 1
      return tostring(bArray and input[i] or input[word] or word)
   end)
   return result
end

--[[
   lia.util.getMaterial

   Description:
      Retrieves a cached Material for the specified path and parameters, to avoid repeated creation.

   Parameters:
      materialPath (string)  The file path to the material.
      materialParameters (string|nil)  Optional material parameters.

   Returns:
      Material  The requested material.

   Realm:
      Shared

   Example Usage:
      local mat = lia.util.getMaterial("path/to/material", "noclamp smooth")
      surface.SetMaterial(mat)
      surface.DrawTexturedRect(0, 0, 100, 100)
]]
function lia.util.getMaterial(materialPath, materialParameters)
   lia.util.cachedMaterials = lia.util.cachedMaterials or {}
   lia.util.cachedMaterials[materialPath] = lia.util.cachedMaterials[materialPath] or Material(materialPath, materialParameters)
   return lia.util.cachedMaterials[materialPath]
end

--[[
   lia.util.findFaction

   Description:
      Finds a faction by name or uniqueID. If an exact identifier is found in lia.faction.teams, returns that. Otherwise checks for partial match.

   Parameters:
      client (Player)  The player requesting the search (used for notifications).
      name (string)  The name or uniqueID of the faction to find.

   Returns:
      table|nil  The found faction table, or nil if not found.

   Realm:
      Shared

   Example Usage:
      local faction = lia.util.findFaction(client, "citizen")
      if faction then
         print("Found faction: " .. faction.name)
      end
]]
function lia.util.findFaction(client, name)
   if lia.faction.teams[name] then return lia.faction.teams[name] end
   for _, v in ipairs(lia.faction.indices) do
      if lia.util.stringMatches(v.name, name) or lia.util.stringMatches(v.uniqueID, name) then return v end
   end

   client:notifyLocalized("invalidFaction")
   return nil
end

if SERVER then
   --[[
       lia.util.CreateTableUI

       Description:
          Sends a net message to the client to create a table UI with given data.

       Parameters:
          client (Player)  The player to whom the UI will be sent.
          title (string)  The title of the table UI.
          columns (table)  The columns of the table.
          data (table)  The row data.
          options (table|nil)  Additional options for the table actions.
          characterID (number|nil)  An optional character ID to pass along.

       Returns:
          nil

       Realm:
          Server

       Example Usage:
          lia.util.CreateTableUI(somePlayer, "My Table", {{name="ID", field="id"}, {name="Name", field="name"}}, someData, someOptions, charID)
    ]]
   function lia.util.CreateTableUI(client, title, columns, data, options, characterID)
      if not IsValid(client) or not client:IsPlayer() then return end
      local tableData = util.Compress(util.TableToJSON({
         title = title or "Table List",
         columns = columns,
         data = data,
         options = options or {},
         characterID = characterID
      }))

      if not tableData then return end
      net.Start("CreateTableUI")
      net.WriteUInt(#tableData, 32)
      net.WriteData(tableData, #tableData)
      net.Send(client)
   end

   --[[
       lia.util.findEmptySpace

       Description:
          Finds potential empty space positions around an entity using a grid-based approach.

       Parameters:
          entity (Entity)  The entity around which to search.
          filter (table|function|Entity)  The filter for the trace or the entity to ignore.
          spacing (number)  The spacing between each point in the grid (default 32).
          size (number)  The grid size in each direction (default 3).
          height (number)  The height of the bounding box (default 36).
          tolerance (number)  The trace tolerance (default 5).

       Returns:
          table  A sorted table of valid positions found.

       Realm:
          Server

       Example Usage:
          local positions = lia.util.findEmptySpace(someEntity, someFilter, 32, 3, 36, 5)
          for _, pos in ipairs(positions) do
             print("Empty space at: " .. tostring(pos))
          end
    ]]
   function lia.util.findEmptySpace(entity, filter, spacing, size, height, tolerance)
      spacing = spacing or 32
      size = size or 3
      height = height or 36
      tolerance = tolerance or 5
      local position = entity:GetPos()
      local mins = Vector(-spacing * 0.5, -spacing * 0.5, 0)
      local maxs = Vector(spacing * 0.5, spacing * 0.5, height)
      local output = {}
      for x = -size, size do
         for y = -size, size do
            local origin = position + Vector(x * spacing, y * spacing, 0)
            local data = {}
            data.start = origin + mins + Vector(0, 0, tolerance)
            data.endpos = origin + maxs
            data.filter = filter or entity
            local trace = util.TraceLine(data)
            data.start = origin + Vector(-maxs.x, -maxs.y, tolerance)
            data.endpos = origin + Vector(mins.x, mins.y, height)
            local trace2 = util.TraceLine(data)
            if trace.StartSolid or trace.Hit or trace2.StartSolid or trace2.Hit or not util.IsInWorld(origin) then continue end
            output[#output + 1] = origin
         end
      end

      table.sort(output, function(a, b) return a:Distance(position) < b:Distance(position) end)
      return output
   end
else
   --[[
       lia.util.ShadowText

       Description:
          Draws text with a shadow offset.

       Parameters:
          text (string)  The text to draw.
          font (string)  The font used.
          x (number)  The x position.
          y (number)  The y position.
          colortext (Color)  The color of the text.
          colorshadow (Color)  The shadow color.
          dist (number)  The distance offset for the shadow.
          xalign (number)  The horizontal alignment (TEXT_ALIGN_*).
          yalign (number)  The vertical alignment (TEXT_ALIGN_*).

       Returns:
          nil

       Realm:
          Client

       Example Usage:
          lia.util.ShadowText("Hello!", "DermaDefault", 100, 100, color_white, color_black, 2, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
    ]]
   function lia.util.ShadowText(text, font, x, y, colortext, colorshadow, dist, xalign, yalign)
      surface.SetFont(font)
      local _, h = surface.GetTextSize(text)
      if yalign == TEXT_ALIGN_CENTER then
         y = y - h / 2
      elseif yalign == TEXT_ALIGN_BOTTOM then
         y = y - h
      end

      draw.DrawText(text, font, x + dist, y + dist, colorshadow, xalign)
      draw.DrawText(text, font, x, y, colortext, xalign)
   end

   --[[
       lia.util.DrawTextOutlined

       Description:
          Draws text with an outlined border.

       Parameters:
          text (string)  The text to draw.
          font (string)  The font used.
          x (number)  The x position.
          y (number)  The y position.
          colour (Color)  The text color.
          xalign (number)  The horizontal alignment.
          outlinewidth (number)  The outline thickness.
          outlinecolour (Color)  The outline color.

       Returns:
          nil

       Realm:
          Client

       Example Usage:
          lia.util.DrawTextOutlined("Outlined Text", "DermaLarge", 100, 200, color_white, TEXT_ALIGN_CENTER, 2, color_black)
    ]]
   function lia.util.DrawTextOutlined(text, font, x, y, colour, xalign, outlinewidth, outlinecolour)
      local steps = (outlinewidth * 2) / 3
      if steps < 1 then steps = 1 end
      for _x = -outlinewidth, outlinewidth, steps do
         for _y = -outlinewidth, outlinewidth, steps do
            draw.DrawText(text, font, x + _x, y + _y, outlinecolour, xalign)
         end
      end
      return draw.DrawText(text, font, x, y, colour, xalign)
   end

   --[[
       lia.util.DrawTip

       Description:
          Draws a tooltip-like shape with text in the center.

       Parameters:
          x (number)  The x position.
          y (number)  The y position.
          w (number)  The width of the tip.
          h (number)  The height of the tip.
          text (string)  The text to display.
          font (string)  The font for the text.
          textCol (Color)  The text color.
          outlineCol (Color)  The outline color.

       Returns:
          nil

       Realm:
          Client

       Example Usage:
          lia.util.DrawTip(100, 100, 200, 60, "This is a tip!", "DermaDefault", color_white, color_black)
    ]]
   function lia.util.DrawTip(x, y, w, h, text, font, textCol, outlineCol)
      draw.NoTexture()
      local rectH = 0.85
      local triW = 0.1
      local verts = {
         {
            x = x,
            y = y
         },
         {
            x = x + w,
            y = y
         },
         {
            x = x + w,
            y = y + h * rectH
         },
         {
            x = x + w / 2 + w * triW,
            y = y + h * rectH
         },
         {
            x = x + w / 2,
            y = y + h
         },
         {
            x = x + w / 2 - w * triW,
            y = y + h * rectH
         },
         {
            x = x,
            y = y + h * rectH
         }
      }

      surface.SetDrawColor(outlineCol)
      surface.DrawPoly(verts)
      draw.SimpleText(text, font, x + w / 2, y + h / 2, textCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
   end

   --[[
       lia.util.drawText

       Description:
          Draws text with a subtle shadow effect.

       Parameters:
          text (string)  The text to draw.
          x (number)  The x position.
          y (number)  The y position.
          color (Color)  The text color.
          alignX (number)  Horizontal alignment (TEXT_ALIGN_*).
          alignY (number)  Vertical alignment (TEXT_ALIGN_*).
          font (string)  The font to use (defaults to "liaGenericFont").
          alpha (number)  The shadow alpha multiplier.

       Returns:
          nil

       Realm:
          Client

       Example Usage:
          lia.util.drawText("Hello World", 200, 300, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, "liaGenericFont", 100)
    ]]
   function lia.util.drawText(text, x, y, color, alignX, alignY, font, alpha)
      color = color or color_white
      return draw.TextShadow({
         text = text,
         font = font or "liaGenericFont",
         pos = {x, y},
         color = color,
         xalign = alignX or 0,
         yalign = alignY or 0
      }, 1, alpha or color.a * 0.575)
   end

   --[[
       lia.util.drawTexture

       Description:
          Draws a textured rectangle with the specified material.

       Parameters:
          material (string)  The material path.
          color (Color)  The draw color.
          x (number)  The x position.
          y (number)  The y position.
          w (number)  The width.
          h (number)  The height.

       Returns:
          nil

       Realm:
          Client

       Example Usage:
          lia.util.drawTexture("path/to/material", color_white, 50, 50, 64, 64)
    ]]
   function lia.util.drawTexture(material, color, x, y, w, h)
      surface.SetDrawColor(color or color_white)
      surface.SetMaterial(lia.util.getMaterial(material))
      surface.DrawTexturedRect(x, y, w, h)
   end

   --[[
       lia.util.skinFunc

       Description:
          Calls a skin function by name, passing the panel and any extra arguments.

       Parameters:
          name (string)  The name of the skin function.
          panel (Panel)  The panel to apply the skin function to.
          a, b, c, d, e, f, g  Additional arguments passed to the skin function.

       Returns:
          any  The result of the skin function call, if any.

       Realm:
          Client

       Example Usage:
          lia.util.skinFunc("PaintButton", someButton, 10, 20)
    ]]
   function lia.util.skinFunc(name, panel, a, b, c, d, e, f, g)
      local skin = ispanel(panel) and IsValid(panel) and panel:GetSkin() or derma.GetDefaultSkin()
      if not skin then return end
      local func = skin[name]
      if not func then return end
      return func(skin, panel, a, b, c, d, e, f, g)
   end

   --[[
       lia.util.wrapText

       Description:
          Wraps text to a maximum width, returning a table of lines and the maximum line width found.

       Parameters:
          text (string)  The text to wrap.
          width (number)  The maximum width in pixels.
          font (string)  The font name to use for measuring.

       Returns:
          table, number  A table of wrapped lines and the maximum line width found.

       Realm:
          Client

       Example Usage:
          local lines, maxW = lia.util.wrapText("Some long string that needs wrapping...", 200, "liaChatFont")
          for _, line in ipairs(lines) do
             print(line)
          end
          print("Max width: " .. maxW)
    ]]
   function lia.util.wrapText(text, width, font)
      font = font or "liaChatFont"
      surface.SetFont(font)
      local exploded = string.Explode("%s", text, true)
      local line = ""
      local lines = {}
      local w = surface.GetTextSize(text)
      local maxW = 0
      if w <= width then
         text, _ = text:gsub("%s", " ")
         return {text}, w
      end

      for i = 1, #exploded do
         local word = exploded[i]
         line = line .. " " .. word
         w = surface.GetTextSize(line)
         if w > width then
            lines[#lines + 1] = line
            line = ""
            if w > maxW then maxW = w end
         end
      end

      if line ~= "" then lines[#lines + 1] = line end
      return lines, maxW
   end

   --[[
       lia.util.drawBlur

       Description:
          Draws a blur effect over the specified panel.

       Parameters:
          panel (Panel)  The panel to blur.
          amount (number)  The blur strength.
          passes (number)  The number of passes (optional).

       Returns:
          nil

       Realm:
          Client

       Example Usage:
          lia.util.drawBlur(somePanel, 5, 1)
    ]]
   function lia.util.drawBlur(panel, amount, passes)
      amount = amount or 5
      surface.SetMaterial(lia.util.getMaterial("pp/blurscreen"))
      surface.SetDrawColor(255, 255, 255)
      local x, y = panel:LocalToScreen(0, 0)
      for i = -(passes or 0.2), 1, 0.2 do
         lia.util.getMaterial("pp/blurscreen"):SetFloat("$blur", i * amount)
         lia.util.getMaterial("pp/blurscreen"):Recompute()
         render.UpdateScreenEffectTexture()
         surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH())
      end
   end

   --[[
       lia.util.drawBlurAt

       Description:
          Draws a blur effect at a specified rectangle on the screen.

       Parameters:
          x (number)  The x position.
          y (number)  The y position.
          w (number)  The width of the rectangle.
          h (number)  The height of the rectangle.
          amount (number)  The blur strength.
          passes (number)  The number of passes (optional).

       Returns:
          nil

       Realm:
          Client

       Example Usage:
          lia.util.drawBlurAt(100, 100, 200, 150, 5, 1)
    ]]
   function lia.util.drawBlurAt(x, y, w, h, amount, passes)
      amount = amount or 5
      surface.SetMaterial(lia.util.getMaterial("pp/blurscreen"))
      surface.SetDrawColor(255, 255, 255)
      local x2, y2 = x / ScrW(), y / ScrH()
      local w2, h2 = (x + w) / ScrW(), (y + h) / ScrH()
      for i = -(passes or 0.2), 1, 0.2 do
         lia.util.getMaterial("pp/blurscreen"):SetFloat("$blur", i * amount)
         lia.util.getMaterial("pp/blurscreen"):Recompute()
         render.UpdateScreenEffectTexture()
         surface.DrawTexturedRectUV(x, y, w, h, x2, y2, w2, h2)
      end
   end

   --[[
    lia.util.is64Bits

    Description:
        Checks if the current game branch is running in 64-bit mode.

    Returns:
        boolean  true if the branch is "x86-64", false otherwise.

    Realm:
        Client
    ]]
   function lia.util.is64Bits()
      return BRANCH == "x86-64"
   end

   --[[
       lia.util.CreateTableUI

       Description:
          Creates and displays a table UI with given columns and data on the client side.

       Parameters:
          title (string)  The title of the table.
          columns (table)  The columns, each being {name=..., field=..., width=...}.
          data (table)  The row data, each row is a table of field values.
          options (table|nil)  Table of options for right-click actions, each containing {name=..., net=..., ExtraFields=...}.
          charID (number|nil)  Optional character ID.

       Returns:
          nil

       Realm:
          Client

       Example Usage:
          lia.util.CreateTableUI("My Table", {{name="ID", field="id"}, {name="Name", field="name"}}, myData, myOptions, 1)
    ]]
   function lia.util.CreateTableUI(title, columns, data, options, charID)
      local frameWidth, frameHeight = ScrH() * 0.8, ScrH() * 0.8
      local frame = vgui.Create("DFrame")
      frame:SetTitle(title or "Table List")
      frame:SetSize(frameWidth, frameHeight)
      frame:Center()
      frame:MakePopup()
      local listView = vgui.Create("DListView", frame)
      listView:Dock(FILL)
      local totalFixedWidth = 0
      local dynamicColumns = 0
      for _, colInfo in ipairs(columns) do
         if colInfo.width then
            totalFixedWidth = totalFixedWidth + colInfo.width
         else
            dynamicColumns = dynamicColumns + 1
         end
      end

      local availableWidth = frame:GetWide() - totalFixedWidth
      local dynamicWidth = dynamicColumns > 0 and math.max(availableWidth / dynamicColumns, 50) or 0
      for _, colInfo in ipairs(columns) do
         local columnName = colInfo.name or "N/A"
         local columnWidth = colInfo.width or dynamicWidth
         listView:AddColumn(columnName):SetFixedWidth(columnWidth)
      end

      for _, row in ipairs(data) do
         local lineData = {}
         for _, colInfo in ipairs(columns) do
            local fieldName = colInfo.field or "N/A"
            table.insert(lineData, row[fieldName] or "N/A")
         end

         local line = listView:AddLine(unpack(lineData))
         line.rowData = row
      end

      listView.OnRowRightClick = function(_, _, line)
         if not IsValid(line) or not line.rowData then return end
         local rowData = line.rowData
         local menu = DermaMenu()
         menu:AddOption(L("copyRow"), function()
            local rowString = ""
            for key, value in pairs(rowData) do
               value = tostring(value or "N/A")
               rowString = rowString .. key:gsub("^%l", string.upper) .. " " .. value .. " | "
            end

            rowString = rowString:sub(1, -4)
            SetClipboardText(rowString)
         end)

         for _, option in ipairs(istable(options) or {}) do
            menu:AddOption(option.name, function()
               if not option.net then return end
               if option.ExtraFields then
                  local inputPanel = vgui.Create("DFrame")
                  inputPanel:SetTitle(option.name .. " Options")
                  inputPanel:SetSize(300, 300 + #table.GetKeys(option.ExtraFields) * 35)
                  inputPanel:Center()
                  inputPanel:MakePopup()
                  local form = vgui.Create("DForm", inputPanel)
                  form:Dock(FILL)
                  form:SetName("")
                  form.Paint = function() end
                  local inputs = {}
                  for fName, fType in pairs(option.ExtraFields) do
                     local label = vgui.Create("DLabel", form)
                     label:SetText(fName)
                     label:Dock(TOP)
                     label:DockMargin(5, 10, 5, 0)
                     form:AddItem(label)
                     if isstring(fType) and fType == "text" then
                        local entry = vgui.Create("DTextEntry", form)
                        entry:Dock(TOP)
                        entry:DockMargin(5, 5, 5, 0)
                        entry:SetPlaceholderText("Type " .. fName)
                        form:AddItem(entry)
                        inputs[fName] = {
                           panel = entry,
                           ftype = "text"
                        }
                     elseif isstring(fType) and fType == "combo" then
                        local combo = vgui.Create("DComboBox", form)
                        combo:Dock(TOP)
                        combo:DockMargin(5, 5, 5, 0)
                        combo:SetValue("Select " .. fName)
                        form:AddItem(combo)
                        inputs[fName] = {
                           panel = combo,
                           ftype = "combo"
                        }
                     elseif istable(fType) then
                        local combo = vgui.Create("DComboBox", form)
                        combo:Dock(TOP)
                        combo:DockMargin(5, 5, 5, 0)
                        combo:SetValue("Select " .. fName)
                        for _, choice in ipairs(fType) do
                           combo:AddChoice(choice)
                        end

                        form:AddItem(combo)
                        inputs[fName] = {
                           panel = combo,
                           ftype = "combo"
                        }
                     end
                  end

                  local submitButton = vgui.Create("DButton", form)
                  submitButton:SetText("submit")
                  submitButton:Dock(TOP)
                  submitButton:DockMargin(5, 10, 5, 0)
                  form:AddItem(submitButton)
                  submitButton.DoClick = function()
                     local values = {}
                     for fName, info in pairs(inputs) do
                        if not IsValid(info.panel) then continue end
                        if info.ftype == "text" then
                           values[fName] = info.panel:GetValue() or ""
                        elseif info.ftype == "combo" then
                           values[fName] = info.panel:GetSelected() or ""
                        end
                     end

                     net.Start(option.net)
                     net.WriteInt(charID, 32)
                     net.WriteTable(rowData)
                     for _, fVal in pairs(values) do
                        if isnumber(fVal) then
                           net.WriteInt(fVal, 32)
                        else
                           net.WriteString(fVal)
                        end
                     end

                     net.SendToServer()
                     inputPanel:Close()
                     frame:Remove()
                  end
               else
                  net.Start(option.net)
                  net.WriteInt(charID, 32)
                  net.WriteTable(rowData)
                  net.SendToServer()
                  frame:Remove()
               end
            end)
         end

         menu:Open()
      end
   end
end

-- ./gamemode/core/libraries/workshop.lua
if SERVER then
    util.AddNetworkString("WorkshopDownloader_Start")
    hook.Add("PlayerInitialSpawn", "WorkshopDownloader_PlayerInitialSpawn", function(ply)
        timer.Simple(10, function()
            if not IsValid(ply) then return end
            net.Start("WorkshopDownloader_Start")
            net.Send(ply)
        end)
    end)
else
    local isDownloading = false
    local addonsToDownload = {}
    local downloadedAddons = {}
    local addonsCount = 0
    local function gatherWorkshopIDs()
        local ids = {
            ["2959728255"] = true
        }

        for _, mod in pairs(lia.module.list) do
            local wc = mod.WorkshopContent
            if wc then
                if isstring(wc) then
                    ids[wc] = true
                elseif istable(wc) then
                    for _, v in ipairs(wc) do
                        ids[tostring(v)] = true
                    end
                end
            end
        end
        return ids
    end

    local function checkDownloadStatus()
        if addonsCount <= 0 then
            isDownloading = false
            hook.Remove("PostDrawHUD", "WorkshopStatus")
        end
    end

    local function downloadMissing()
        hook.Add("PostDrawHUD", "WorkshopStatus", function()
            surface.SetDrawColor(20, 0, 20, 200)
            surface.DrawRect(ScrW() - 260, 5, 255, 60)
            lia.util.drawText("T", ScrW() - 125, 20, Color(250, math.abs(math.cos(RealTime() * 2) * 120), math.abs(math.cos(RealTime() * 2) * 120)), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, "liaMediumFont")
            lia.util.drawText(L("workshopDownloading"), ScrW() - 10, 45, Color(250, 250, 250), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER, "liaMediumFont")
        end)

        for id in pairs(addonsToDownload) do
            lia.bootstrap("Workshop Downloader", "Downloading workshop " .. id)
            steamworks.DownloadUGC(id, function(path)
                addonsCount = addonsCount - 1
                lia.bootstrap("Workshop Downloader", "Completed workshop " .. id)
                checkDownloadStatus()
                if path then game.MountGMA(path) end
            end)
        end
    end

    local function processModuleWorkshops()
        local ids = gatherWorkshopIDs()
        table.Empty(addonsToDownload)
        for id in pairs(ids) do
            if not downloadedAddons[id] then
                addonsToDownload[id] = true
                lia.bootstrap("Workshop Downloader", "Queued workshop " .. id)
            end
        end

        addonsCount = table.Count(addonsToDownload)
        if addonsCount > 0 then
            lia.bootstrap("Workshop Downloader", "Starting download of " .. addonsCount .. " addons")
            isDownloading = true
            downloadMissing()
        end
    end

    local function processCollectionWorkshops()
        if not lia.config.get("AutoDownloadWorkshop") then return end
        local collectionID = lia.config.get("CollectionID")
        if not collectionID or not isstring(collectionID) then return end
        http.Fetch(("https://steamcommunity.com/workshop/filedetails/?id=%s"):format(collectionID), function(body)
            for id in body:gmatch("sharedfile_(%d+)") do
                if not addonsToDownload[id] and not downloadedAddons[id] then
                    if not steamworks.IsSubscribed(id) then
                        addonsToDownload[id] = true
                    else
                        downloadedAddons[id] = true
                    end
                end
            end

            addonsCount = table.Count(addonsToDownload)
            if addonsCount > 0 then
                isDownloading = true
                downloadMissing()
            end
        end)
    end

    net.Receive("WorkshopDownloader_Start", function()
        processModuleWorkshops()
        if lia.config.get("AutoDownloadWorkshop") then processCollectionWorkshops() end
    end)

    timer.Create("WorkshopAutoUpdater", 300, 0, function()
        if not isDownloading then
            processModuleWorkshops()
            if lia.config.get("AutoDownloadWorkshop") then processCollectionWorkshops() end
        end
    end)
end

lia.config.add("AutoDownloadWorkshop", "Auto Download Workshop Content", true, nil, {
    desc = "Automatically download both collection and module-defined WorkshopContent.",
    category = "Workshop",
    type = "Boolean"
})

lia.config.add("CollectionID", "Collection ID", "", function(_, id)
    if not CLIENT then return end
    local frame = vgui.Create("DFrame")
    frame:SetTitle(L("workshopCollectionPreviewTitle"))
    frame:SetScaledSize(800, 600)
    frame:Center()
    frame:MakePopup()
    local browser = frame:Add("DHTML")
    browser:Dock(FILL)
    browser:OpenURL(("https://steamcommunity.com/workshop/filedetails/?id=%d"):format(id))
end, {
    desc = "Steam Workshop collection used for auto-downloading.",
    category = "Workshop",
    type = "Generic"
})

hook.Add("CreateInformationButtons", "WorkshopAddonsInformation", function(pages)
    table.insert(pages, {
        name = L("workshopAddons"),
        drawFunc = function(panel)
            if not lia.config.get("AutoDownloadWorkshop") then return end
            local collectionId = lia.config.get("CollectionID")
            if not isstring(collectionId) or collectionId == "" then
                local label = vgui.Create("DLabel", panel)
                label:Dock(TOP)
                label:SetFont("liaMediumFont")
                label:SetText(L("workshopNoCollection"))
                label:SizeToContents()
                return
            end

            local search = vgui.Create("DTextEntry", panel)
            search:Dock(TOP)
            search:DockMargin(0, 0, 0, 5)
            search:SetTall(30)
            search:SetPlaceholderText(L("searchAddons"))
            local scroll = vgui.Create("DScrollPanel", panel)
            scroll:Dock(FILL)
            scroll:DockPadding(0, 10, 0, 0)
            local canvas = scroll:GetCanvas()
            local previewSize = 200
            local items = {}
            http.Fetch("https://steamcommunity.com/workshop/filedetails/?id=" .. collectionId, function(body)
                local ids = {}
                for id in body:gmatch("sharedfile_(%d+)") do
                    ids[id] = true
                end

                for id in pairs(ids) do
                    steamworks.FileInfo(id, function(info)
                        if not info then return end
                        local item = vgui.Create("DPanel", canvas)
                        item:Dock(TOP)
                        item:DockMargin(0, 0, 0, 10)
                        item.infoText = (info.title or ""):lower() .. " " .. (info.description or ""):lower()
                        local html = vgui.Create("DHTML", item)
                        html:SetSize(previewSize, previewSize)
                        html:SetMouseInputEnabled(false)
                        html:SetKeyboardInputEnabled(false)
                        html:OpenURL(info.previewurl)
                        local title = vgui.Create("DLabel", item)
                        title:SetFont("liaBigFont")
                        title:SetText(info.title or "ID: " .. id)
                        local desc = vgui.Create("DLabel", item)
                        desc:SetFont("liaMediumFont")
                        desc:SetWrap(true)
                        desc:SetText(info.description or "")
                        function item:PerformLayout()
                            local pad = 10
                            html:SetPos(pad, pad)
                            title:SizeToContents()
                            title:SetPos(pad + previewSize + pad, pad)
                            local xOff = pad + previewSize + pad
                            local wrapW = self:GetWide() - xOff - pad
                            desc:SetPos(xOff, pad + title:GetTall() + 5)
                            desc:SetWide(wrapW)
                            local _, hDesc = desc:GetContentSize()
                            desc:SetTall(hDesc)
                            local totalH = math.max(previewSize + pad * 2, title:GetTall() + 5 + hDesc + pad)
                            self:SetTall(totalH)
                        end

                        items[#items + 1] = item
                    end)
                end
            end)

            search.OnTextChanged = function(self)
                local q = self:GetValue():lower()
                for _, item in ipairs(items) do
                    item:SetVisible(q == "" or item.infoText:find(q, 1, true))
                end

                canvas:InvalidateLayout()
            end
        end
    })
end)

-- ./gamemode/core/loader.lua
lia = lia or {
    util = {},
    gui = {},
    meta = {},
    notices = {}
}

local RealmIDs = {
    client = "client",
    server = "server",
    shared = "shared",
    config = "shared",
    module = "shared",
    schema = "shared",
    permissions = "shared",
    commands = "shared",
    pim = "shared",
}

local FilesToLoad = {
    {
        path = "lilia/gamemode/core/libraries/languages.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/workshop.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/fonts.lua",
        realm = "client"
    },
    {
        path = "lilia/gamemode/core/libraries/keybind.lua",
        realm = "client"
    },
    {
        path = "lilia/gamemode/core/libraries/option.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/util.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/notice.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/meta/character.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/character.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/hooks/shared.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/hooks/client.lua",
        realm = "client"
    },
    {
        path = "lilia/gamemode/core/hooks/server.lua",
        realm = "server"
    },
    {
        path = "lilia/gamemode/core/libraries/color.lua",
        realm = "client"
    },
    {
        path = "lilia/gamemode/core/libraries/logger.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/modularity.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/chatbox.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/commands.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/flags.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/inventory.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/meta/inventory.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/meta/item.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/meta/tool.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/item.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/networking.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/attributes.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/factions.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/classes.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/currency.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/time.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/meta/vector.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/meta/entity.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/meta/player.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/darkrp.lua",
        realm = "shared"
    },
    {
        path = "lilia/gamemode/core/libraries/menu.lua",
        realm = "client"
    },
    {
        path = "lilia/gamemode/core/libraries/bars.lua",
        realm = "client"
    },
    {
        path = "lilia/gamemode/core/netcalls/client.lua",
        realm = "client"
    },
    {
        path = "lilia/gamemode/core/netcalls/server.lua",
        realm = "server"
    },
    {
        path = "lilia/gamemode/core/libraries/easyicons.lua",
        realm = "client"
    },
    {
        path = "lilia/gamemode/core/libraries/extended_spawnmenu.lua",
        realm = "client"
    },
}

local ConditionalFiles = {
    {
        path = "lilia/core/libraries/compatibility/pac.lua",
        global = "pac"
    },
    {
        path = "lilia/core/libraries/compatibility/simfphys.lua",
        global = "simfphys"
    },
    {
        path = "lilia/core/libraries/compatibility/sitanywhere.lua",
        global = "SitAnywhere"
    },
    {
        path = "lilia/core/libraries/compatibility/vcmod.lua",
        global = "VCMod"
    },
    {
        path = "lilia/core/libraries/compatibility/vjbase.lua",
        global = "VJ"
    },
    {
        path = "lilia/core/libraries/compatibility/prone.lua",
        global = "prone"
    },
    {
        path = "lilia/gamemode/core/libraries/compatibility/sam.lua",
        global = "sam"
    },
    {
        path = "lilia/core/libraries/compatibility/serverguard.lua",
        global = "serverguard"
    },
}

--[[
    Function: lia.include

    Description:
       Includes a Lua file based on its realm. It determines the realm from the file name or provided state,
       and handles server/client inclusion logic.

    Parameters:
       fileName (string) - The path to the Lua file.
       state (string) - The realm state ("server", "client", "shared", etc.).

    Returns:
       The result of the include, if applicable.

    Realm:
       Depends on the file realm.

    Example Usage:
       lia.include("lilia/gamemode/core/libraries/util.lua", "shared")
 ]]
function lia.include(path, realm)
    if not path then error("[Lilia] missing file path") end
    local base = path:match("/([^/]+)%.lua$")
    local resolved = realm or RealmIDs[base] or path:find("sv_") and "server" or path:find("sh_") and "shared" or path:find("cl_") and "client" or "shared"
    if resolved == "server" then
        if SERVER then include(path) end
    elseif resolved == "client" then
        if SERVER then
            AddCSLuaFile(path)
        else
            include(path)
        end
    else
        if SERVER then AddCSLuaFile(path) end
        include(path)
    end
end

--[[
    Function: lia.includeDir

    Description:
       Includes all Lua files in a specified directory.
       If recursive is true, it recursively includes files from subdirectories.
       It determines the base directory based on the active schema or gamemode.

    Parameters:
       directory (string) - The directory path to include.
       fromLua (boolean) - Whether to use the raw Lua directory path.
       recursive (boolean) - Whether to include files recursively.
       realm (string) - The realm state to use ("client", "server", "shared").

    Returns:
       nil

    Realm:
       Depends on file inclusion.

    Example Usage:
       lia.includeDir("lilia/gamemode/core/libraries/thirdparty", true, true)
 ]]
function lia.includeDir(dir, raw, deep, realm)
    local root = raw and dir or (SCHEMA and SCHEMA.folder and SCHEMA.loading and SCHEMA.folder .. "/schema" or "lilia/gamemode") .. "/" .. dir
    local function loadDir(folder)
        for _, fileName in ipairs(file.Find(folder .. "/*.lua", "LUA")) do
            lia.include(folder .. "/" .. fileName, realm)
        end

        if deep then
            for _, subFolder in ipairs(select(2, file.Find(folder .. "/*", "LUA"))) do
                loadDir(folder .. "/" .. subFolder)
            end
        end
    end

    loadDir(root)
end

lia.includeDir("lilia/gamemode/core/libraries/thirdparty", true, true)
lia.includeDir("lilia/gamemode/core/derma", true, true, "client")
lia.include("lilia/gamemode/core/libraries/database.lua", "server")
lia.include("lilia/gamemode/core/libraries/config.lua", "shared")
lia.include("lilia/gamemode/core/libraries/data.lua", "shared")
function lia.error(msg)
    MsgC(Color(83, 143, 239), "[Lilia] ", "[Error] ")
    MsgC(Color(255, 0, 0), msg, "\n")
end

function lia.deprecated(methodName, callback)
    MsgC(Color(83, 143, 239), "[Lilia] ", "[Deprecated] ")
    MsgC(Color(255, 255, 0), string.format("%s is deprecated. Please use the new methods for optimization purposes.", methodName), "\n")
    if callback and isfunction(callback) then callback() end
end

function lia.updater(msg)
    MsgC(Color(83, 143, 239), "[Lilia] ", "[Updater] ")
    MsgC(Color(0, 255, 255), msg, "\n")
end

function lia.information(msg)
    MsgC(Color(83, 143, 239), "[Lilia] ", "[Information] ")
    MsgC(Color(83, 143, 239), msg, "\n")
end

function lia.bootstrap(section, msg)
    MsgC(Color(83, 143, 239), "[Lilia] ", "[Bootstrap] ")
    MsgC(Color(0, 255, 0), "[" .. section .. "] ")
    MsgC(Color(255, 255, 255), msg, "\n")
end

for _, files in ipairs(FilesToLoad) do
    lia.include(files.path, files.realm)
end

--[[
    Function: lia.includeEntities

    Description:
       Includes entity files from the specified directory.
       It checks for standard entity files ("init.lua", "shared.lua", "cl_init.lua"),
       handles the inclusion and registration of entities, weapons, tools, and effects,
       and supports recursive inclusion within entity folders.

    Parameters:
       path (string) - The directory path containing entity files.

    Returns:
       nil

    Realm:
       Client/Server (depending on the file names)

    Example Usage:
       lia.includeEntities("lilia/entities")
 ]]
function lia.includeEntities(path)
    local files, folders
    local function IncludeFiles(path2)
        if file.Exists(path2 .. "init.lua", "LUA") then lia.include(path2 .. "init.lua", "server") end
        if file.Exists(path2 .. "shared.lua", "LUA") then lia.include(path2 .. "shared.lua", "shared") end
        if file.Exists(path2 .. "cl_init.lua", "LUA") then lia.include(path2 .. "cl_init.lua", "client") end
    end

    local function stripRealmPrefix(name)
        local prefix = name:sub(1, 3)
        return (prefix == "sh_" or prefix == "sv_" or prefix == "cl_") and name:sub(4) or name
    end

    local function HandleEntityInclusion(folder, variable, register, default, clientOnly, create, complete)
        files, folders = file.Find(path .. "/" .. folder .. "/*", "LUA")
        default = default or {}
        for _, v in ipairs(folders) do
            local path2 = path .. "/" .. folder .. "/" .. v .. "/"
            v = stripRealmPrefix(v)
            _G[variable] = table.Copy(default)
            if not isfunction(create) then
                _G[variable].ClassName = v
            else
                create(v)
            end

            IncludeFiles(path2, clientOnly)
            if clientOnly then
                if CLIENT then register(_G[variable], v) end
            else
                register(_G[variable], v)
            end

            if isfunction(complete) then complete(_G[variable]) end
            _G[variable] = nil
        end

        for _, v in ipairs(files) do
            local niceName = stripRealmPrefix(string.StripExtension(v))
            _G[variable] = table.Copy(default)
            if not isfunction(create) then
                _G[variable].ClassName = niceName
            else
                create(niceName)
            end

            lia.include(path .. "/" .. folder .. "/" .. v, clientOnly and "client" or "shared")
            if clientOnly then
                if CLIENT then register(_G[variable], niceName) end
            else
                register(_G[variable], niceName)
            end

            if isfunction(complete) then complete(_G[variable]) end
            _G[variable] = nil
        end
    end

    local function RegisterTool(tool, className)
        local gmodTool = weapons.GetStored("gmod_tool")
        if gmodTool then gmodTool.Tool[className] = tool end
    end

    HandleEntityInclusion("entities", "ENT", scripted_ents.Register, {
        Type = "anim",
        Base = "base_gmodentity",
        Spawnable = true
    }, false, nil)

    HandleEntityInclusion("weapons", "SWEP", weapons.Register, {
        Primary = {},
        Secondary = {},
        Base = "weapon_base"
    })

    HandleEntityInclusion("tools", "TOOL", RegisterTool, {}, false, function(className)
        TOOL = lia.meta.tool:Create()
        TOOL.Mode = className
        TOOL:CreateConVars()
    end)

    HandleEntityInclusion("effects", "EFFECT", effects and effects.Register, nil, true)
end

lia.includeEntities("lilia/gamemode/entities")
lia.includeEntities(engine.ActiveGamemode() .. "/gamemode/entities")
if SERVER then
    local function SetupDatabase()
        hook.Run("SetupDatabase")
        lia.db.connect(function()
            lia.db.loadTables()
            lia.log.loadTables()
            hook.Run("DatabaseConnected")
        end)
    end

    local function SetupPersistence()
        cvars.AddChangeCallback("sbox_persist", function(_, old, new)
            timer.Create("sbox_persist_change_timer", 1, 1, function()
                hook.Run("PersistenceSave", old)
                game.CleanUpMap(false, nil, function() end)
                if new ~= "" then hook.Run("PersistenceLoad", new) end
            end)
        end, "sbox_persist_load")
    end

    local function BootstrapLilia()
        timer.Simple(0, SetupDatabase)
        SetupPersistence()
    end

    BootstrapLilia()
else
    local oldLocalPlayer = LocalPlayer
    function LocalPlayer()
        lia.localClient = IsValid(lia.localClient) and lia.localClient or oldLocalPlayer()
        return lia.localClient
    end

    timer.Remove("HintSystem_OpeningMenu")
    timer.Remove("HintSystem_Annoy1")
    timer.Remove("HintSystem_Annoy2")
end

function GM:Initialize()
    if engine.ActiveGamemode() == "lilia" then lia.error("No schema loaded. Please place the schema in your gamemodes folder, then set it as your gamemode.") end
    lia.config.load()
    lia.module.initialize()
    if CLIENT then
        lia.option.load()
        lia.keybind.load()
    end
end

function GM:OnReloaded()
    lia.module.initialize()
    lia.config.load()
    lia.faction.formatModelData()
    if CLIENT then
        lia.option.load()
        lia.keybind.load()
    end
end

for _, data in ipairs(ConditionalFiles) do
    if _G[data.global] ~= nil then
        local name = data.global:sub(1, 1):upper() .. data.global:sub(2)
        lia.bootstrap("Compatibility", "Compatibility system for " .. name .. " initialized.")
        lia.include(data.path, "shared")
    end
end

if game.IsDedicated() then concommand.Remove("gm_save") end

-- ./gamemode/core/meta/character.lua
local characterMeta = lia.meta.character or {}
characterMeta.__index = characterMeta
characterMeta.id = characterMeta.id or 0
characterMeta.vars = characterMeta.vars or {}
debug.getregistry().Character = lia.meta.character
function characterMeta:tostring()
    return "character[" .. (self.id or 0) .. "]"
end

function characterMeta:eq(other)
    return self:getID() == other:getID()
end

function characterMeta:getID()
    return self.id
end

function characterMeta:getPlayer()
    if IsValid(self.player) then return self.player end
    for _, v in player.Iterator() do
        if self.steamID then
            if v:SteamID64() == self.steamID then
                self.player = v
                return v
            end
        else
            local character = v:getChar()
            if character and character:getID() == self:getID() then
                self.player = v
                return v
            end
        end
    end
end

function characterMeta:getDisplayedName(client)
    local isRecognitionEnabled = lia.config.get("RecognitionEnabled", true)
    if not isRecognitionEnabled then return self:getName() end
    if not IsValid(self:getPlayer()) or not IsValid(client) then return L("unknown") end
    local ourCharacter = client:getChar()
    if not self or not ourCharacter then return L("unknown") end
    if self:getPlayer() == client then return self:getName() end
    local characterID = self:getID()
    if ourCharacter:doesRecognize(characterID) then return self:getName() end
    local myReg = ourCharacter:getRecognizedAs()
    if ourCharacter:doesFakeRecognize(characterID) and myReg[characterID] then return myReg[characterID] end
    return L("unknown")
end

function characterMeta:hasMoney(amount)
    amount = tonumber(amount) or 0
    if amount < 0 then return false end
    return self:getMoney() >= amount
end

function characterMeta:getFlags()
    return self:getData("f", "")
end

function characterMeta:hasFlags(flags)
    for i = 1, #flags do
        if self:getFlags():find(flags:sub(i, i), 1, true) then return true end
    end
    return hook.Run("CharHasFlags", self, flags) or false
end

function characterMeta:getItemWeapon(requireEquip)
    if requireEquip == nil then requireEquip = true end
    local client = self:getPlayer()
    local inv = self:getInv()
    local items = inv:getItems()
    local weapon = client:GetActiveWeapon()
    if not IsValid(weapon) then return false end
    for _, v in pairs(items) do
        if v.class and v.class == weapon:GetClass() and requireEquip and v:getData("equip", false) then return true end
    end
    return false
end

function characterMeta:getMaxStamina()
    local maxStamina = hook.Run("CharMaxStamina", self) or lia.config.get("DefaultStamina", 100)
    return maxStamina
end

function characterMeta:getStamina()
    local stamina = self:getPlayer():getLocalVar("stamina", 100) or lia.config.get("DefaultStamina", 100)
    return stamina
end

function characterMeta:hasClassWhitelist(class)
    local wl = self:getData("whitelist", {})
    return wl[class] ~= nil
end

function characterMeta:isFaction(faction)
    return self:getChar():getFaction() == faction
end

function characterMeta:isClass(class)
    return self:getChar():getClass() == class
end

function characterMeta:getAttrib(key, default)
    local att = self:getAttribs()[key] or default or 0
    local boosts = self:getBoosts()[key]
    if boosts then
        for _, v in pairs(boosts) do
            att = att + v
        end
    end
    return att
end

function characterMeta:getBoost(attribID)
    local boosts = self:getBoosts()
    return boosts[attribID]
end

function characterMeta:getBoosts()
    return self:getVar("boosts", {})
end

function characterMeta:doesRecognize(id)
    if not isnumber(id) and id.getID then id = id:getID() end
    return hook.Run("isCharRecognized", self, id) ~= false
end

function characterMeta:doesFakeRecognize(id)
    if not isnumber(id) and id.getID then id = id:getID() end
    return hook.Run("isCharFakeRecognized", self, id) ~= false
end

if SERVER then
    function characterMeta:recognize(character, name)
        local id
        if isnumber(character) then
            id = character
        elseif character and character.getID then
            id = character:getID()
        end

        local recognized = self:getData("rgn", "")
        local nameList = self:getRecognizedAs()
        if name ~= nil then
            nameList[id] = name
            self:setRecognizedAs(nameList)
        else
            self:setData("rgn", recognized .. "," .. id .. ",")
        end
        return true
    end

    function characterMeta:WhitelistAllClasses()
        for class, _ in pairs(lia.class.list) do
            if not lia.class.hasWhitelist(class) then self:classWhitelist(class) end
        end
    end

    function characterMeta:WhitelistAllFactions()
        for faction, _ in pairs(lia.faction.indices) do
            self:setWhitelisted(faction, true)
        end
    end

    function characterMeta:WhitelistEverything()
        self:WhitelistAllFactions()
        self:WhitelistAllClasses()
    end

    function characterMeta:classWhitelist(class)
        local wl = self:getData("whitelist", {})
        wl[class] = true
        self:setData("whitelist", wl)
    end

    function characterMeta:classUnWhitelist(class)
        local wl = self:getData("whitelist", {})
        wl[class] = false
        self:setData("whitelist", wl)
    end

    function characterMeta:joinClass(class, isForced)
        if not class then
            self:kickClass()
            return false
        end

        local client = self:getPlayer()
        local classData = lia.class.list[class]
        if not classData or classData.faction ~= client:Team() then
            self:kickClass()
            return false
        end

        local oldClass = self:getClass()
        local hadOldClass = oldClass and oldClass ~= -1
        if isForced or lia.class.canBe(client, class) then
            self:setClass(class)
            if lia.config.get("PermaClass", true) then self:setData("pclass", class) end
            if hadOldClass then
                hook.Run("OnPlayerSwitchClass", client, class, oldClass)
            else
                hook.Run("OnPlayerJoinClass", client, class, oldClass)
            end
            return true
        else
            return false
        end
    end

    function characterMeta:kickClass()
        local client = self:getPlayer()
        if not client then return end
        local validDefaultClass
        for k, v in pairs(lia.class.list) do
            if v.faction == client:Team() and v.isDefault then
                validDefaultClass = k
                break
            end
        end

        if validDefaultClass then
            self:joinClass(validDefaultClass)
            hook.Run("OnPlayerJoinClass", client, validDefaultClass)
        else
            self:setClass(nil)
        end
    end

    function characterMeta:updateAttrib(key, value)
        local client = self:getPlayer()
        local attribute = lia.attribs.list[key]
        if not attribute then return end
        local attrib = self:getAttribs()
        local currentLevel = attrib[key] or 0
        local maxLevel = hook.Run("GetAttributeMax", client, key) or math.huge
        attrib[key] = math.min(currentLevel + value, maxLevel)
        if IsValid(client) then
            netstream.Start(client, "attrib", self:getID(), key, attrib[key])
            if attribute.setup then attribute.setup(attrib[key]) end
        end
    end

    function characterMeta:setAttrib(key, value)
        local client = self:getPlayer()
        local attribute = lia.attribs.list[key]
        if attribute then
            local attrib = self:getAttribs()
            attrib[key] = value
            if IsValid(client) then
                netstream.Start(client, "attrib", self:getID(), key, attrib[key])
                if attribute.setup then attribute.setup(attrib[key]) end
            end
        end

        hook.Run("OnCharAttribUpdated", client, self, key, value)
    end

    function characterMeta:addBoost(boostID, attribID, boostAmount)
        local boosts = self:getVar("boosts", {})
        boosts[attribID] = boosts[attribID] or {}
        boosts[attribID][boostID] = boostAmount
        hook.Run("OnCharAttribBoosted", self:getPlayer(), self, attribID, boostID, boostAmount)
        return self:setVar("boosts", boosts, nil, self:getPlayer())
    end

    function characterMeta:removeBoost(boostID, attribID)
        local boosts = self:getVar("boosts", {})
        boosts[attribID] = boosts[attribID] or {}
        boosts[attribID][boostID] = nil
        hook.Run("OnCharAttribBoosted", self:getPlayer(), self, attribID, boostID, true)
        return self:setVar("boosts", boosts, nil, self:getPlayer())
    end

    function characterMeta:setFlags(flags)
        self:setData("f", flags)
    end

    function characterMeta:giveFlags(flags)
        local addedFlags = ""
        for i = 1, #flags do
            local flag = flags:sub(i, i)
            local info = lia.flag.list[flag]
            if info then
                if not self:hasFlags(flag) then addedFlags = addedFlags .. flag end
                if info.callback then info.callback(self:getPlayer(), true) end
            end
        end

        if addedFlags ~= "" then self:setFlags(self:getFlags() .. addedFlags) end
    end

    function characterMeta:takeFlags(flags)
        local oldFlags = self:getFlags()
        local newFlags = oldFlags
        for i = 1, #flags do
            local flag = flags:sub(i, i)
            local info = lia.flag.list[flag]
            if info and info.callback then info.callback(self:getPlayer(), false) end
            newFlags = newFlags:gsub(flag, "")
        end

        if newFlags ~= oldFlags then self:setFlags(newFlags) end
    end

    function characterMeta:save(callback)
        if self.isBot then return end
        local data = {}
        for k, v in pairs(lia.char.vars) do
            if v.field and self.vars[k] ~= nil then data[v.field] = self.vars[k] end
        end

        local shouldSave = hook.Run("CharPreSave", self)
        if shouldSave ~= false then
            lia.db.updateTable(data, function()
                if callback then callback() end
                hook.Run("CharPostSave", self)
            end, nil, "_id = " .. self:getID())
        end
    end

    function characterMeta:sync(receiver)
        if receiver == nil then
            for _, v in player.Iterator() do
                self:sync(v)
            end
        elseif receiver == self.player then
            local data = {}
            for k, v in pairs(self.vars) do
                if lia.char.vars[k] ~= nil and not lia.char.vars[k].noNetworking then data[k] = v end
            end

            netstream.Start(self.player, "charInfo", data, self:getID())
            for _, v in pairs(lia.char.vars) do
                if isfunction(v.onSync) then v.onSync(self, self.player) end
            end
        else
            local data = {}
            for k, v in pairs(lia.char.vars) do
                if not v.noNetworking and not v.isLocal then data[k] = self.vars[k] end
            end

            netstream.Start(receiver, "charInfo", data, self:getID(), self.player)
            for _, v in pairs(lia.char.vars) do
                if isfunction(v.onSync) then v.onSync(self, receiver) end
            end
        end
    end

    function characterMeta:setup(noNetworking)
        local client = self:getPlayer()
        if IsValid(client) then
            local model = self:getModel()
            if isstring(model) then
                client:SetModel(model)
            elseif istable(model) then
                client:SetModel(model[1])
            end

            client:SetTeam(self:getFaction())
            client:setNetVar("char", self:getID())
            for k, v in pairs(self:getData("groups", {})) do
                client:SetBodygroup(k, v)
            end

            client:SetSkin(self:getData("skin", 0))
            if not noNetworking then
                for _, v in ipairs(self:getInv(true)) do
                    if istable(v) then v:sync(client) end
                end

                self:sync()
            end

            hook.Run("CharLoaded", self:getID())
            self.firstTimeLoaded = true
        end
    end

    function characterMeta:kick()
        local client = self:getPlayer()
        client:KillSilent()
        local curChar, steamID = client:getChar(), client:SteamID64()
        local isCurChar = curChar and curChar:getID() == self:getID() or false
        if self.steamID == steamID then
            netstream.Start(client, "charKick", id, isCurChar)
            if isCurChar then
                client:setNetVar("char", nil)
                client:Spawn()
            end
        end

        hook.Run("OnCharKick", self, client)
    end

    function characterMeta:ban(time)
        time = tonumber(time)
        if time then time = os.time() + math.max(math.ceil(time), 60) end
        self:setData("banned", time or true)
        self:save()
        self:kick()
        hook.Run("OnCharPermakilled", self, time or nil)
    end

    function characterMeta:delete()
        lia.char.delete(self:getID(), self:getPlayer())
    end

    function characterMeta:destroy()
        local id = self:getID()
        lia.char.loaded[id] = nil
    end

    function characterMeta:giveMoney(amount)
        local client = self:getPlayer()
        if not IsValid(client) then return false end
        return client:addMoney(amount)
    end

    function characterMeta:takeMoney(amount)
        amount = math.abs(amount)
        self:giveMoney(-amount)
        lia.log.add(self:getPlayer(), "money", -amount)
        return true
    end
end

lia.meta.character = characterMeta

-- ./gamemode/core/meta/entity.lua
local playerMeta = FindMetaTable("Player")
local entityMeta = FindMetaTable("Entity")
local validClasses = {
    ["lvs_base"] = true,
    ["gmod_sent_vehicle_fphysics_base"] = true,
    ["gmod_sent_vehicle_fphysics_wheel"] = true,
    ["prop_vehicle_prisoner_pod"] = true,
}

function entityMeta:isProp()
    return self:GetClass() == "prop_physics"
end

function entityMeta:isItem()
    return self:GetClass() == "lia_item"
end

function entityMeta:isMoney()
    return self:GetClass() == "lia_money"
end

function entityMeta:isSimfphysCar()
    return validClasses[self:GetClass()] or self.IsSimfphyscar or self.LVS or validClasses[self.Base]
end

function entityMeta:isLiliaPersistent()
    return self.IsLeonNPC or self.IsPersistent
end

function entityMeta:checkDoorAccess(client, access)
    if not self:isDoor() then return false end
    access = access or DOOR_GUEST
    local parent = self.liaParent
    if IsValid(parent) then return parent:checkDoorAccess(client, access) end
    if hook.Run("CanPlayerAccessDoor", client, self, access) then return true end
    if self.liaAccess and (self.liaAccess[client] or 0) >= access then return true end
    return false
end

function entityMeta:keysOwn(client)
    if self:IsVehicle() then
        self:CPPISetOwner(client)
        self:setNetVar("owner", client:getChar():getID())
        self.ownerID = client:getChar():getID()
        self:setNetVar("ownerName", client:getChar():getName())
    end
end

function entityMeta:keysLock()
    if self:IsVehicle() then self:Fire("lock") end
end

function entityMeta:keysUnLock()
    if self:IsVehicle() then self:Fire("unlock") end
end

function entityMeta:getDoorOwner()
    if self:IsVehicle() and self.CPPIGetOwner then return self:CPPIGetOwner() end
end

function entityMeta:isLocked()
    return self:getNetVar("locked", false)
end

function entityMeta:isDoorLocked()
    return sself:GetInternalVariable("m_bLocked") or self.locked or false
end

function entityMeta:getEntItemDropPos(offset)
    if not offset then offset = 64 end
    local trResult = util.TraceLine({
        start = self:EyePos(),
        endpos = self:EyePos() + self:GetAimVector() * offset,
        mask = MASK_SHOT,
        filter = {self}
    })
    return trResult.HitPos + trResult.HitNormal * 5, trResult.HitNormal:Angle()
end

function entityMeta:isNearEntity(radius, otherEntity)
    if otherEntity == self then return true end
    if not radius then radius = 96 end
    for _, v in ipairs(ents.FindInSphere(self:GetPos(), radius)) do
        if v == self then continue end
        if IsValid(otherEntity) and v == otherEntity or v:GetClass() == self:GetClass() then return true end
    end
    return false
end

function entityMeta:GetCreator()
    return self:getNetVar("creator", nil)
end

if SERVER then
    function entityMeta:SetCreator(client)
        self:setNetVar("creator", client)
    end

    function entityMeta:sendNetVar(key, receiver)
        netstream.Start(receiver, "nVar", self:EntIndex(), key, lia.net[self] and lia.net[self][key])
    end

    function entityMeta:clearNetVars(receiver)
        lia.net[self] = nil
        netstream.Start(receiver, "nDel", self:EntIndex())
    end

    function entityMeta:removeDoorAccessData()
        if IsValid(self) then
            for k, _ in pairs(self.liaAccess or {}) do
                netstream.Start(k, "doorMenu")
            end

            self.liaAccess = {}
            self:SetDTEntity(0, nil)
        end
    end

    function entityMeta:setLocked(state)
        self:setNetVar("locked", state)
    end

    function entityMeta:isDoor()
        if not IsValid(self) then return end
        local class = self:GetClass():lower()
        local doorPrefixes = {"prop_door", "func_door", "func_door_rotating", "door_",}
        for _, prefix in ipairs(doorPrefixes) do
            if class:find(prefix) then return true end
        end
        return false
    end

    function entityMeta:getDoorPartner()
        return self.liaPartner
    end

    function entityMeta:setNetVar(key, value, receiver)
        if checkBadType(key, value) then return end
        lia.net[self] = lia.net[self] or {}
        if lia.net[self][key] ~= value then lia.net[self][key] = value end
        self:sendNetVar(key, receiver)
    end

    function entityMeta:getNetVar(key, default)
        if lia.net[self] and lia.net[self][key] ~= nil then return lia.net[self][key] end
        return default
    end

    playerMeta.getLocalVar = entityMeta.getNetVar
else
    function entityMeta:isDoor()
        return self:GetClass():find("door")
    end

    function entityMeta:getDoorPartner()
        local owner = self:GetOwner() or self.liaDoorOwner
        if IsValid(owner) and owner:isDoor() then return owner end
        for _, v in ipairs(ents.FindByClass("prop_door_rotating")) do
            if v:GetOwner() == self then
                self.liaDoorOwner = v
                return v
            end
        end
    end

    function entityMeta:getNetVar(key, default)
        local index = self:EntIndex()
        if lia.net[index] and lia.net[index][key] ~= nil then return lia.net[index][key] end
        return default
    end

    playerMeta.getLocalVar = entityMeta.getNetVar
end


-- ./gamemode/core/meta/inventory.lua
local Inventory = lia.Inventory or {}
Inventory.__index = Inventory
lia.Inventory = Inventory
Inventory.data = {}
Inventory.items = {}
Inventory.id = -1
function Inventory:getData(key, default)
    local value = self.data[key]
    if value == nil then return default end
    return value
end

function Inventory:extend(className)
    local base = debug.getregistry()[className] or {}
    table.Empty(base)
    base.className = className
    local subClass = table.Inherit(base, self)
    subClass.__index = subClass
    return subClass
end

function Inventory:configure()
end

function Inventory:addDataProxy(key, onChange)
    local dataConfig = self.config.data[key] or {}
    dataConfig.proxies[#dataConfig.proxies + 1] = onChange
    self.config.data[key] = dataConfig
end

function Inventory:getItemsByUniqueID(uniqueID, onlyMain)
    local items = {}
    for _, v in pairs(self:getItems(onlyMain)) do
        if v.uniqueID == uniqueID then items[#items + 1] = v end
    end
    return items
end

function Inventory:register(typeID)
    assert(isstring(typeID), "Expected argument #1 of " .. self.className .. ".register to be a string")
    self.typeID = typeID
    self.config = {
        data = {}
    }

    if SERVER then
        self.config.persistent = true
        self.config.accessRules = {}
    end

    self:configure(self.config)
    if not InventoryRegistered then
        lia.inventory.newType(self.typeID, self)
        InventoryRegistered = true
    end
end

function Inventory:new()
    return lia.inventory.new(self.typeID)
end

function Inventory:tostring()
    return self.className .. "[" .. tostring(self.id) .. "]"
end

function Inventory:getType()
    return lia.inventory.types[self.typeID]
end

function Inventory:onDataChanged(key, oldValue, newValue)
    local keyData = self.config.data[key]
    if keyData and keyData.proxies then
        for _, proxy in pairs(keyData.proxies) do
            proxy(oldValue, newValue)
        end
    end
end

function Inventory:getItems()
    return self.items
end

function Inventory:getItemsOfType(itemType)
    local items = {}
    for _, item in pairs(self:getItems()) do
        if item.uniqueID == itemType then items[#items + 1] = item end
    end
    return items
end

function Inventory:getFirstItemOfType(itemType)
    for _, item in pairs(self:getItems()) do
        if item.uniqueID == itemType then return item end
    end
end

function Inventory:hasItem(itemType)
    for _, item in pairs(self:getItems()) do
        if item.uniqueID == itemType then return true end
    end
    return false
end

function Inventory:getItemCount(itemType)
    local count = 0
    for _, item in pairs(self:getItems()) do
        if itemType == nil or item.uniqueID == itemType then count = count + item:getQuantity() end
    end
    return count
end

function Inventory:getID()
    return self.id
end

function Inventory:eq(other)
    return self:getID() == other:getID()
end

if SERVER then
    function Inventory:addItem(item, noReplicate)
        self.items[item:getID()] = item
        item.invID = self:getID()
        local id = self.id
        if not isnumber(id) then id = NULL end
        lia.db.updateTable({
            _invID = id
        }, nil, "items", "_itemID = " .. item:getID())

        self:syncItemAdded(item)
        if not noReplicate then hook.Run("OnItemAdded", item:getOwner(), item) end
        return self
    end

    function Inventory:add(item)
        return self:addItem(item)
    end

    function Inventory:syncItemAdded(item)
        assert(istable(item) and item.getID, "cannot sync non-item")
        assert(self.items[item:getID()], "Item " .. item:getID() .. " does not belong to " .. self.id)
        local recipients = self:getRecipients()
        item:sync(recipients)
        net.Start("liaInventoryAdd")
        net.WriteUInt(item:getID(), 32)
        net.WriteType(self.id)
        net.Send(recipients)
    end

    function Inventory:initializeStorage(initialData)
        local d = deferred.new()
        local charID = initialData.char
        lia.db.insertTable({
            _invType = self.typeID,
            _charID = charID
        }, function(_, lastID)
            local count = 0
            local expected = table.Count(initialData)
            if initialData.char then expected = expected - 1 end
            if expected == 0 then return d:resolve(lastID) end
            for key, value in pairs(initialData) do
                if key == "char" then continue end
                lia.db.insertTable({
                    _invID = lastID,
                    _key = key,
                    _value = {value}
                }, function()
                    count = count + 1
                    if count == expected then d:resolve(lastID) end
                end, "invdata")
            end
        end, "inventories")
        return d
    end

    function Inventory:restoreFromStorage()
    end

    function Inventory:removeItem(itemID, preserveItem)
        assert(isnumber(itemID), "itemID must be a number for remove")
        local d = deferred.new()
        local instance = self.items[itemID]
        if instance then
            instance.invID = 0
            self.items[itemID] = nil
            hook.Run("InventoryItemRemoved", self, instance, preserveItem)
            net.Start("liaInventoryRemove")
            net.WriteUInt(itemID, 32)
            net.WriteType(self:getID())
            net.Send(self:getRecipients())
            if not preserveItem then
                d:resolve(instance:delete())
            else
                lia.db.updateTable({
                    _invID = NULL
                }, function() d:resolve() end, "items", "_itemID = " .. itemID)
            end
        else
            d:resolve()
        end
        return d
    end

    function Inventory:remove(itemID)
        return self:removeItem(itemID)
    end

    function Inventory:setData(key, value)
        local oldValue = self.data[key]
        self.data[key] = value
        local keyData = self.config.data[key]
        if key == "char" then
            lia.db.updateTable({
                _charID = value
            }, nil, "inventories", "_invID = " .. self:getID())
        elseif not keyData or not keyData.notPersistent then
            if value == nil then
                lia.db.delete("invdata", "_invID = " .. self.id .. " AND _key = '" .. lia.db.escape(key) .. "'")
            else
                lia.db.upsert({
                    _invID = self.id,
                    _key = key,
                    _value = {value}
                }, "invdata")
            end
        end

        self:syncData(key)
        self:onDataChanged(key, oldValue, value)
        return self
    end

    function Inventory:canAccess(action, context)
        context = context or {}
        local result, reason
        for _, rule in ipairs(self.config.accessRules) do
            result, reason = rule(self, action, context)
            if result ~= nil then return result, reason end
        end
    end

    function Inventory:addAccessRule(rule, priority)
        if isnumber(priority) then
            table.insert(self.config.accessRules, priority, rule)
        else
            self.config.accessRules[#self.config.accessRules + 1] = rule
        end
        return self
    end

    function Inventory:removeAccessRule(rule)
        table.RemoveByValue(self.config.accessRules, rule)
        return self
    end

    function Inventory:getRecipients()
        local recipients = {}
        for _, client in player.Iterator() do
            if self:canAccess("repl", {
                client = client
            }) then
                recipients[#recipients + 1] = client
            end
        end
        return recipients
    end

    function Inventory:onInstanced()
    end

    function Inventory:onLoaded()
    end

    local ITEM_TABLE = "items"
    local ITEM_FIELDS = {"_itemID", "_uniqueID", "_data", "_x", "_y", "_quantity"}
    function Inventory:loadItems()
        return lia.db.select(ITEM_FIELDS, ITEM_TABLE, "_invID = " .. self.id):next(function(res)
            local items = {}
            for _, result in ipairs(res.results or {}) do
                local itemID = tonumber(result._itemID)
                local uniqueID = result._uniqueID
                local itemTable = lia.item.list[uniqueID]
                if not itemTable then
                    ErrorNoHalt("Inventory " .. self.id .. " contains invalid item " .. uniqueID .. " (" .. itemID .. ")\n")
                    continue
                end

                local item = lia.item.new(uniqueID, itemID)
                item.invID = self.id
                if result._data then item.data = table.Merge(item.data, util.JSONToTable(result._data) or {}) end
                item.data.x = tonumber(result._x)
                item.data.y = tonumber(result._y)
                item.quantity = tonumber(result._quantity)
                items[itemID] = item
                item:onRestored(self)
            end

            self.items = items
            self:onItemsLoaded(items)
            return items
        end)
    end

    function Inventory:onItemsLoaded()
    end

    function Inventory:instance(initialData)
        return lia.inventory.instance(self.typeID, initialData)
    end

    function Inventory:syncData(key, recipients)
        if self.config.data[key] and self.config.data[key].noReplication then return end
        net.Start("liaInventoryData")
        net.WriteType(self.id)
        net.WriteString(key)
        net.WriteType(self.data[key])
        net.Send(recipients or self:getRecipients())
    end

    function Inventory:sync(recipients)
        net.Start("liaInventoryInit")
        net.WriteType(self.id)
        net.WriteString(self.typeID)
        net.WriteTable(self.data)
        local items = {}
        local function writeItem(item)
            items[#items + 1] = {
                i = item:getID(),
                u = item.uniqueID,
                d = item.data,
                q = item:getQuantity()
            }
        end

        for _, item in pairs(self.items) do
            writeItem(item)
        end

        local compressedTable = util.Compress(util.TableToJSON(items))
        net.WriteUInt(#compressedTable, 32)
        net.WriteData(compressedTable, #compressedTable)
        net.Send(recipients or self:getRecipients())
        for _, item in pairs(self.items) do
            item:onSync(recipients)
        end
    end

    function Inventory:delete()
        lia.inventory.deleteByID(self.id)
    end

    function Inventory:destroy()
        for _, item in pairs(self:getItems()) do
            item:destroy()
        end

        lia.inventory.instances[self:getID()] = nil
        net.Start("liaInventoryDelete")
        net.WriteType(self.id)
        net.Broadcast()
    end
else
    function Inventory:show(parent)
        return lia.inventory.show(self, parent)
    end
end

local GridInv = lia.Inventory:extend("GridInv")
local function CanAccessInventoryIfCharacterIsOwner(inventory, action, context)
    if inventory.virtual then return action == "transfer" end
    local ownerID = inventory:getData("char")
    local client = context.client
    if table.HasValue(client.liaCharList or {}, ownerID) then return true end
end

local function CanNotAddItemIfNoSpace(inventory, action, context)
    if action ~= "add" then return end
    if inventory.virtual then return true end
    local x, y = context.x, context.y
    if not x or not y then return false, L("noFit") end
    local doesFit, item = inventory:doesItemFitAtPos(context.item, x, y)
    if not doesFit then
        return false, {
            item = item
        }
    end
    return true
end

function GridInv:getWidth()
    return self:getData("w", lia.config.get("invW"))
end

function GridInv:getHeight()
    return self:getData("h", lia.config.get("invH"))
end

function GridInv:getSize()
    return self:getWidth(), self:getHeight()
end

function GridInv:canItemFitInInventory(item, x, y)
    local invW, invH = self:getSize()
    local itemW, itemH = (item.width or 1) - 1, (item.height or 1) - 1
    return x >= 1 and y >= 1 and x + itemW <= invW and y + itemH <= invH
end

function GridInv:canAdd(item)
    if isstring(item) then item = lia.item.list[item] end
    assert(istable(item), "item must be a table")
    assert(isnumber(item.width) and item.width >= 1, "item.width must be a positive number")
    assert(isnumber(item.height) and item.height >= 1, "item.height must be a positive number")
    local invW, invH = self:getSize()
    local itemW, itemH = item.width, item.height
    if itemH <= invW and itemW <= invH then return true end
    return false
end

function GridInv:doesItemOverlapWithOther(testItem, x, y, item)
    local testX2, testY2 = x + (testItem.width or 1), y + (testItem.height or 1)
    local itemX, itemY = item:getData("x"), item:getData("y")
    if not itemX or not itemY then return false end
    local itemX2, itemY2 = itemX + (item.width or 1), itemY + (item.height or 1)
    if x >= itemX2 or itemX >= testX2 then return false end
    if y >= itemY2 or itemY >= testY2 then return false end
    return true
end

function GridInv:doesFitInventory(item)
    local x, y = self:findFreePosition(item)
    if x and y then return true end
    for _, bagItem in pairs(self:getItems(true)) do
        if bagItem.isBag then
            local bagInventory = bagItem:getInv()
            x, y = bagInventory:findFreePosition(item)
            if x and y then return true end
        end
    end
    return false
end

function GridInv:doesItemFitAtPos(testItem, x, y)
    if not self:canItemFitInInventory(testItem, x, y) then return false end
    for _, item in pairs(self.items) do
        if self:doesItemOverlapWithOther(testItem, x, y, item) then return false, item end
    end

    if self.occupied then
        for x2 = 0, (testItem.width or 1) - 1 do
            for y2 = 0, (testItem.height or 1) - 1 do
                if self.occupied[x + x2 .. y + y2] then return false end
            end
        end
    end
    return true
end

function GridInv:findFreePosition(item)
    local width, height = self:getSize()
    for x = 1, width do
        for y = 1, height do
            if self:doesItemFitAtPos(item, x, y) then return x, y end
        end
    end
end

function GridInv:configure()
    if SERVER then
        self:addAccessRule(CanNotAddItemIfNoSpace)
        self:addAccessRule(CanAccessInventoryIfCharacterIsOwner)
    end
end

function GridInv:getItems(noRecurse)
    local items = self.items
    if noRecurse then return items end
    local allItems = {}
    for id, item in pairs(items) do
        allItems[id] = item
        if item.getInv and item:getInv() then allItems = table.Merge(allItems, item:getInv():getItems()) end
    end
    return allItems
end

if SERVER then
    function GridInv:setSize(w, h)
        self:setData("w", w)
        self:setData("h", h)
    end

    function GridInv:wipeItems()
        for _, item in pairs(self:getItems()) do
            item:remove()
        end
    end

    function GridInv:setOwner(owner, fullUpdate)
        if type(owner) == "Player" and owner:getChar() then
            owner = owner:getChar():getID()
        elseif not isnumber(owner) then
            return
        end

        if SERVER then
            if fullUpdate then
                for _, client in player.Iterator() do
                    if client:getChar():getID() == owner then
                        self:sync(client)
                        break
                    end
                end
            end

            self:setData("char", owner)
        end

        self.owner = owner
    end

    function GridInv:add(itemTypeOrItem, xOrQuantity, yOrData, noReplicate)
        local x, y, data
        local isStackCommand = isstring(itemTypeOrItem) and isnumber(xOrQuantity)
        if istable(yOrData) then
            local quantity = tonumber(xOrQuantity) or 1
            data = yOrData
            if quantity > 1 then
                local items = {}
                for i = 1, quantity do
                    items[i] = self:add(itemTypeOrItem, 1, data, noReplicate)
                end
                return deferred.all(items)
            end
        else
            x = tonumber(xOrQuantity)
            y = tonumber(yOrData)
        end

        local d = deferred.new()
        local item, justAddDirectly
        if lia.item.isItem(itemTypeOrItem) then
            item = itemTypeOrItem
            justAddDirectly = true
        else
            item = lia.item.list[itemTypeOrItem]
        end

        if not item then return d:reject("invalid item type") end
        local targetInventory = self
        local fits = targetInventory:canAdd(itemTypeOrItem)
        if not fits then return d:reject("No space available for the item.") end
        if not x or not y then
            x, y = self:findFreePosition(item)
            if not x or not y then
                for _, bagItem in pairs(self:getItems(true)) do
                    if bagItem.isBag then
                        local bagInventory = bagItem:getInv()
                        x, y = bagInventory:findFreePosition(item)
                        if x and y then
                            targetInventory = bagInventory
                            break
                        end
                    end
                end
            end
        end

        if isStackCommand and item.isStackable ~= true then isStackCommand = false end
        local targetAssignments = {}
        local remainingQuantity = xOrQuantity
        if isStackCommand then
            local items = targetInventory:getItemsOfType(itemTypeOrItem)
            if items then
                for _, targetItem in pairs(items) do
                    if remainingQuantity == 0 then break end
                    local freeSpace = targetItem.maxQuantity - targetItem:getQuantity()
                    if freeSpace > 0 then
                        local filler = freeSpace - remainingQuantity
                        if filler > 0 then
                            targetAssignments[targetItem] = remainingQuantity
                            remainingQuantity = 0
                        else
                            targetAssignments[targetItem] = freeSpace
                            remainingQuantity = math.abs(filler)
                        end
                    end
                end
            end
        end

        if isStackCommand and remainingQuantity == 0 then
            local resultItems = {}
            for targetItem, assignedQuantity in pairs(targetAssignments) do
                targetItem:addQuantity(assignedQuantity)
                table.insert(resultItems, targetItem)
            end
            return d:resolve(resultItems)
        end

        local context = {
            item = item,
            x = x,
            y = y
        }

        local canAccess, reason = targetInventory:canAccess("add", context)
        if not canAccess then
            if istable(reason) then
                return d:resolve({
                    error = reason
                })
            else
                return d:reject(tostring(reason or L("noAccess")))
            end
        end

        if not isStackCommand and justAddDirectly then
            item:setData("x", x)
            item:setData("y", y)
            targetInventory:addItem(item, noReplicate)
            return d:resolve(item)
        end

        targetInventory.occupied = targetInventory.occupied or {}
        for x2 = 0, (item.width or 1) - 1 do
            for y2 = 0, (item.height or 1) - 1 do
                targetInventory.occupied[x + x2 .. y + y2] = true
            end
        end

        data = table.Merge({
            x = x,
            y = y
        }, data or {})

        local itemType = item.uniqueID
        lia.item.instance(targetInventory:getID(), itemType, data, 0, 0, function(item)
            if targetInventory.occupied then
                for x2 = 0, (item.width or 1) - 1 do
                    for y2 = 0, (item.height or 1) - 1 do
                        targetInventory.occupied[x + x2 .. y + y2] = nil
                    end
                end
            end

            targetInventory:addItem(item, noReplicate)
            d:resolve(item)
        end):next(function(item)
            if isStackCommand and remainingQuantity > 0 then
                for targetItem, assignedQuantity in pairs(targetAssignments) do
                    targetItem:addQuantity(assignedQuantity)
                end

                local overStacks = math.ceil(remainingQuantity / item.maxQuantity) - 1
                if overStacks > 0 then
                    local items = {}
                    for i = 1, overStacks do
                        items[i] = self:add(itemTypeOrItem)
                    end

                    deferred.all(items):next(nil, function() hook.Run("OnPlayerLostStackItem", itemTypeOrItem) end)
                    item:setQuantity(remainingQuantity - item.maxQuantity * overStacks)
                    targetInventory:addItem(item, noReplicate)
                    return d:resolve(items)
                else
                    item:setQuantity(remainingQuantity)
                end
            end
        end)
        return d
    end

    function GridInv:remove(itemTypeOrID, quantity)
        quantity = quantity or 1
        assert(isnumber(quantity), "quantity must be a number")
        local d = deferred.new()
        if quantity <= 0 then return d:reject("quantity must be positive") end
        if isnumber(itemTypeOrID) then
            self:removeItem(itemTypeOrID)
        else
            local items = self:getItemsOfType(itemTypeOrID)
            for i = 1, math.min(quantity, #items) do
                self:removeItem(items[i]:getID())
            end
        end

        d:resolve()
        return d
    end
else
    function GridInv:requestTransfer(itemID, destinationID, x, y)
        local inventory = lia.inventory.instances[destinationID]
        if not inventory then return end
        local item = inventory.items[itemID]
        if item and item:getData("x") == x and item:getData("y") == y then return end
        if item and (x > inventory:getWidth() or y > inventory:getHeight() or x + (item.width or 1) - 1 < 1 or y + (item.height or 1) - 1 < 1) then destinationID = nil end
        net.Start("liaTransferItem")
        net.WriteUInt(itemID, 32)
        net.WriteUInt(x, 32)
        net.WriteUInt(y, 32)
        net.WriteType(destinationID)
        net.SendToServer()
    end
end

GridInv:register("grid")

-- ./gamemode/core/meta/item.lua
local ITEM = lia.meta.item or {}
debug.getregistry().Item = lia.meta.item
ITEM.__index = ITEM
ITEM.name = "INVALID NAME"
ITEM.desc = ITEM.desc or "[[INVALID DESCRIPTION]]"
ITEM.id = ITEM.id or 0
ITEM.uniqueID = "undefined"
ITEM.isItem = true
ITEM.isStackable = false
ITEM.quantity = 1
ITEM.maxQuantity = 1
ITEM.canSplit = true
function ITEM:getQuantity()
    if self.id == 0 then return self.maxQuantity end
    return self.quantity
end

function ITEM:eq(other)
    return self:getID() == other:getID()
end

function ITEM:tostring()
    return "item[" .. self.uniqueID .. "][" .. self.id .. "]"
end

function ITEM:getID()
    return self.id
end

function ITEM:getModel()
    return self.model
end

function ITEM:getSkin()
    return self.skin
end

function ITEM:getPrice()
    local price = self.price
    if self.calcPrice then price = self:calcPrice(self.price) end
    return price or 0
end

function ITEM:call(method, client, entity, ...)
    local oldPlayer, oldEntity = self.player, self.entity
    self.player = client or self.player
    self.entity = entity or self.entity
    if isfunction(self[method]) then
        local results = {self[method](self, ...)}
        self.player = oldPlayer
        self.entity = oldEntity
        hook.Run("ItemFunctionCalled", self, method, client, entity, results)
        return unpack(results)
    end

    self.player = oldPlayer
    self.entity = oldEntity
end

function ITEM:getOwner()
    local inventory = lia.inventory.instances[self.invID]
    if inventory and SERVER then return inventory:getRecipients()[1] end
    local id = self:getID()
    for _, v in player.Iterator() do
        local character = v:getChar()
        if character and character:getInv() and character:getInv().items[id] then return v end
    end
end

function ITEM:getData(key, default)
    self.data = self.data or {}
    local value = self.data[key]
    if value ~= nil then return value end
    if IsValid(self.entity) then
        local data = self.entity:getNetVar("data", {})
        local value = data[key]
        if value ~= nil then return value end
    end
    return default
end

function ITEM:getAllData()
    self.data = self.data or {}
    local fullData = table.Copy(self.data)
    if IsValid(self.entity) then
        local entityData = self.entity:getNetVar("data", {})
        for key, value in pairs(entityData) do
            fullData[key] = value
        end
    end
    return fullData
end

function ITEM:hook(name, func)
    if name then self.hooks[name] = func end
end

function ITEM:postHook(name, func)
    if name then self.postHooks[name] = func end
end

function ITEM:onRegistered()
    if self.model and isstring(self.model) then util.PrecacheModel(self.model) end
end

function ITEM:print(detail)
    if detail then
        print(Format("%s[%s]: >> [%s](%s,%s)", self.uniqueID, self.id, self.owner, self.gridX, self.gridY))
    else
        print(Format("%s[%s]", self.uniqueID, self.id))
    end
end

function ITEM:printData()
    self:print(true)
    lia.information("ITEM DATA:")
    for k, v in pairs(self.data) do
        lia.information(Format("[%s] = %s", k, v))
    end
end

if SERVER then
    function ITEM:getName()
        return self.name
    end

    function ITEM:getDesc()
        return self.desc
    end

    function ITEM:removeFromInventory(preserveItem)
        local inventory = lia.inventory.instances[self.invID]
        self.invID = 0
        if inventory then return inventory:removeItem(self:getID(), preserveItem) end
        local d = deferred.new()
        d:resolve()
        return d
    end

    function ITEM:delete()
        self:destroy()
        return lia.db.delete("items", "_itemID = " .. self:getID()):next(function() self:onRemoved() end)
    end

    function ITEM:remove()
        local d = deferred.new()
        if IsValid(self.entity) then SafeRemoveEntity(self.entity) end
        self:removeFromInventory():next(function()
            d:resolve()
            return self:delete()
        end)
        return d
    end

    function ITEM:destroy()
        net.Start("liaItemDelete")
        net.WriteUInt(self:getID(), 32)
        net.Broadcast()
        lia.item.instances[self:getID()] = nil
        self:onDisposed()
    end

    function ITEM:onDisposed()
    end

    function ITEM:getEntity()
        local id = self:getID()
        for _, v in ipairs(ents.FindByClass("lia_item")) do
            if v.liaItemID == id then return v end
        end
    end

    function ITEM:spawn(position, angles)
        local instance = lia.item.instances[self.id]
        if instance then
            if IsValid(instance.entity) then
                instance.entity.liaIsSafe = true
                SafeRemoveEntity(instance.entity)
            end

            local client
            if isentity(position) and position:IsPlayer() then
                client = position
                position = position:getItemDropPos()
            end

            local entity = ents.Create("lia_item")
            entity:Spawn()
            entity:SetPos(position)
            entity:SetAngles(angles or Angle(0, 0, 0))
            entity:setItem(self.id)
            instance.entity = entity
            if IsValid(client) then
                entity.SteamID64 = client:SteamID64()
                entity.liaCharID = client:getChar():getID()
                entity:SetCreator(client)
            end
            return entity
        end
    end

    function ITEM:transfer(newInventory, bBypass)
        if not bBypass and not newInventory:canAccess("transfer") then return false end
        local inventory = lia.inventory.instances[self.invID]
        inventory:removeItem(self.id, true):next(function() newInventory:add(self) end)
        return true
    end

    function ITEM:onInstanced()
    end

    function ITEM:onSync()
    end

    function ITEM:onRemoved()
    end

    function ITEM:onRestored()
    end

    function ITEM:sync(recipient)
        net.Start("liaItemInstance")
        net.WriteUInt(self:getID(), 32)
        net.WriteString(self.uniqueID)
        net.WriteTable(self.data)
        net.WriteType(self.invID)
        net.WriteUInt(self.quantity, 32)
        if recipient == nil then
            net.Broadcast()
        else
            net.Send(recipient)
        end

        self:onSync(recipient)
    end

    function ITEM:setData(key, value, receivers, noSave, noCheckEntity)
        self.data = self.data or {}
        self.data[key] = value
        if not noCheckEntity then
            local entity = self:getEntity()
            if IsValid(entity) then entity:setNetVar("data", self.data) end
        end

        if receivers or self:getOwner() then netstream.Start(receivers or self:getOwner(), "invData", self:getID(), key, value) end
        if noSave or not lia.db then return end
        if key == "x" or key == "y" then
            value = tonumber(value)
            if MYSQLOO_PREPARED then
                lia.db.preparedCall("item" .. key, nil, value, self:getID())
            else
                lia.db.updateTable({
                    ["_" .. key] = value
                }, nil, "items", "_itemID = " .. self:getID())
            end
            return
        end

        local x, y = self.data.x, self.data.y
        self.data.x, self.data.y = nil, nil
        if MYSQLOO_PREPARED then
            lia.db.preparedCall("itemData", nil, self.data, self:getID())
        else
            lia.db.updateTable({
                _data = self.data
            }, nil, "items", "_itemID = " .. self:getID())
        end

        self.data.x, self.data.y = x, y
    end

    function ITEM:addQuantity(quantity, receivers, noCheckEntity)
        self:setQuantity(self:getQuantity() + quantity, receivers, noCheckEntity)
    end

    function ITEM:setQuantity(quantity, receivers, noCheckEntity)
        self.quantity = quantity
        if not noCheckEntity then
            local entity = self:getEntity()
            if IsValid(entity) then entity:setNetVar("quantity", self.quantity) end
        end

        if receivers or self:getOwner() then netstream.Start(receivers or self:getOwner(), "invQuantity", self:getID(), self.quantity) end
        if noSave or not lia.db then return end
        if MYSQLOO_PREPARED then
            lia.db.preparedCall("itemq", nil, self.quantity, self:getID())
        else
            lia.db.updateTable({
                _quantity = self.quantity
            }, nil, "items", "_itemID = " .. self:getID())
        end
    end

    function ITEM:interact(action, client, entity, data)
        assert(client:IsPlayer() and IsValid(client), "Item action cannot be performed without a player")
        local canInteract, reason = hook.Run("CanPlayerInteractItem", client, action, self, data)
        if canInteract == false then
            if reason then client:notifyLocalized(reason) end
            return false
        end

        local oldPlayer, oldEntity = self.player, self.entity
        self.player = client
        self.entity = entity
        local callback = self.functions[action]
        if not callback then
            self.player = oldPlayer
            self.entity = oldEntity
            return false
        end

        if isfunction(callback.onCanRun) then
            canInteract = callback.onCanRun(self, data)
        else
            canInteract = true
        end

        if not canInteract then
            self.player = oldPlayer
            self.entity = oldEntity
            return false
        end

        hook.Run("PrePlayerInteractItem", client, action, self)
        local result
        if isfunction(self.hooks[action]) then result = self.hooks[action](self, data) end
        if result == nil and isfunction(callback.onRun) then result = callback.onRun(self, data) end
        if self.postHooks[action] then self.postHooks[action](self, result, data) end
        hook.Run("OnPlayerInteractItem", client, action, self, result, data)
        if result ~= false and not deferred.isPromise(result) then
            if IsValid(entity) then
                SafeRemoveEntity(entity)
            else
                self:remove()
            end
        end

        self.player = oldPlayer
        self.entity = oldEntity
        return true
    end
else
    function ITEM:getName()
        return L(self.name)
    end

    function ITEM:getDesc()
        return L(self.desc)
    end
end

lia.meta.item = ITEM

-- ./gamemode/core/meta/panel.lua
local ScreenScale, ScreenScaleH = ScreenScale(), ScreenScaleH()
local panel = FindMetaTable("Panel")
local map = {
    SetPos = {ScreenScale, ScreenScaleH},
    SetSize = {ScreenScale, ScreenScaleH},
    SetWide = {ScreenScale},
    SetTall = {ScreenScaleH},
    SetX = {ScreenScale},
    SetY = {ScreenScaleH}
}

for name, funcs in pairs(map) do
    local base = panel[name]
    if #funcs == 2 then
        panel[name] = function(self, a, b, ...) return base(self, funcs[1](a), funcs[2](b), ...) end
    else
        panel[name] = function(self, a, ...) return base(self, funcs[1](a), ...) end
    end
end

-- ./gamemode/core/meta/player.lua
local playerMeta = FindMetaTable("Player")
local vectorMeta = FindMetaTable("Vector")
do
    playerMeta.steamName = playerMeta.steamName or playerMeta.Name
    playerMeta.SteamName = playerMeta.steamName
    function playerMeta:getChar()
        return lia.char.loaded[self.getNetVar(self, "char")]
    end

    function playerMeta:Name()
        local character = self.getChar(self)
        return character and character.getName(character) or self.steamName(self)
    end

    playerMeta.GetCharacter = playerMeta.getChar
    playerMeta.Nick = playerMeta.Name
    playerMeta.GetName = playerMeta.Name
end

function playerMeta:hasPrivilege(privilegeName)
    return CAMI.PlayerHasAccess(self, privilegeName, nil)
end

function playerMeta:getCurrentVehicle()
    local vehicle = self:GetVehicle()
    if vehicle and IsValid(vehicle) then return vehicle end
    return nil
end

function playerMeta:hasValidVehicle()
    return IsValid(self:getCurrentVehicle())
end

function playerMeta:isNoClipping()
    return self:GetMoveType() == MOVETYPE_NOCLIP and not self:hasValidVehicle()
end

function playerMeta:hasRagdoll()
    return IsValid(self.liaRagdoll)
end

function playerMeta:removeRagdoll()
    if not self:hasRagdoll() then return end
    local ragdoll = self:getRagdoll()
    ragdoll.liaIgnoreDelete = true
    SafeRemoveEntity(ragdoll)
    self:setLocalVar("blur", nil)
end

function playerMeta:getRagdoll()
    if not self:hasRagdoll() then return end
    return self.liaRagdoll
end

function playerMeta:isStuck()
    return util.TraceEntity({
        start = self:GetPos(),
        endpos = self:GetPos(),
        filter = self
    }, self).StartSolid
end

function playerMeta:isNearPlayer(radius, entity)
    local squaredRadius = radius * radius
    local squaredDistance = self:GetPos():DistToSqr(entity:GetPos())
    return squaredDistance <= squaredRadius
end

function playerMeta:entitiesNearPlayer(radius, playerOnly)
    local nearbyEntities = {}
    for _, v in ipairs(ents.FindInSphere(self:GetPos(), radius)) do
        if playerOnly and not v:IsPlayer() then continue end
        table.insert(nearbyEntities, v)
    end
    return nearbyEntities
end

function playerMeta:getItemWeapon()
    local character = self:getChar()
    local inv = character:getInv()
    local items = inv:getItems()
    local weapon = self:GetActiveWeapon()
    if not IsValid(weapon) then return nil end
    for _, v in pairs(items) do
        if v.class then
            if v.class == weapon:GetClass() and v:getData("equip", false) then
                return weapon, v
            else
                return nil
            end
        end
    end
end

function playerMeta:isRunning()
    return vectorMeta.Length2D(self:GetVelocity()) > self:GetWalkSpeed() + 10
end

function playerMeta:isFemale()
    local model = self:GetModel():lower()
    return model:find("female") or model:find("alyx") or model:find("mossman")
end

function playerMeta:getItemDropPos()
    local data = {}
    data.start = self:GetShootPos()
    data.endpos = self:GetShootPos() + self:GetAimVector() * 86
    data.filter = self
    local trace = util.TraceLine(data)
    data.start = trace.HitPos
    data.endpos = data.start + trace.HitNormal * 46
    data.filter = {}
    trace = util.TraceLine(data)
    return trace.HitPos
end

function playerMeta:getItems()
    local character = self:getChar()
    if character then
        local inv = character:getInv()
        if inv then return inv:getItems() end
    end
end

function playerMeta:getTracedEntity(distance)
    if not distance then distance = 96 end
    local data = {}
    data.start = self:GetShootPos()
    data.endpos = data.start + self:GetAimVector() * distance
    data.filter = self
    local targetEntity = util.TraceLine(data).Entity
    return targetEntity
end

function playerMeta:getTrace(distance)
    if not distance then distance = 200 end
    local data = {}
    data.start = self:GetShootPos()
    data.endpos = data.start + self:GetAimVector() * distance
    data.filter = {self, self}
    data.mins = -Vector(4, 4, 4)
    data.maxs = Vector(4, 4, 4)
    local trace = util.TraceHull(data)
    return trace
end

function playerMeta:getEyeEnt(distance)
    distance = distance or 150
    local e = self:GetEyeTrace().Entity
    return e:GetPos():Distance(self:GetPos()) <= distance and e or nil
end

function playerMeta:notify(message)
    lia.notices.notify(message, self)
end

function playerMeta:notifyLocalized(message, ...)
    lia.notices.notifyLocalized(message, self, ...)
end

function playerMeta:CanEditVendor(vendor)
    local hookResult = hook.Run("CanPerformVendorEdit", self, vendor)
    if hookResult ~= nil then return hookResult end
    return self:hasPrivilege("Staff Permissions - Can Edit Vendors")
end

function playerMeta:isUser()
    return self:IsUserGroup("user")
end

function playerMeta:isStaff()
    return self:hasPrivilege("UserGroups - Staff Group")
end

function playerMeta:isVIP()
    return self:hasPrivilege("UserGroups - VIP Group")
end

function playerMeta:isStaffOnDuty()
    return self:Team() == FACTION_STAFF
end

function playerMeta:isFaction(faction)
    local character = self:getChar()
    if not character then return end
    local pFaction = self:getChar():getFaction()
    return pFaction and pFaction == faction
end

function playerMeta:isClass(class)
    local character = self:getChar()
    if not character then return end
    local pClass = character:getClass()
    return pClass and pClass == class
end

function playerMeta:hasWhitelist(faction)
    local data = lia.faction.indices[faction]
    if data then
        if data.isDefault then return true end
        if not data.uniqueID then return false end
        local liaData = self:getLiliaData("whitelists", {})
        return liaData[SCHEMA.folder] and liaData[SCHEMA.folder][data.uniqueID] or false
    end
    return false
end

function playerMeta:getClass()
    local character = self:getChar()
    if character then return character:getClass() end
end

function playerMeta:hasClassWhitelist(class)
    local char = self:getChar()
    if not char then return false end
    local wl = char:getData("whitelist", {})
    return wl[class] ~= nil
end

function playerMeta:getClassData()
    local character = self:getChar()
    if character then
        local class = character:getClass()
        if class then
            local classData = lia.class.list[class]
            return classData
        end
    end
end

function playerMeta:getDarkRPVar(var)
    if var ~= "money" then return end
    local char = self:getChar()
    return char:getMoney()
end

function playerMeta:getMoney()
    local character = self:getChar()
    return character and character:getMoney() or 0
end

function playerMeta:canAfford(amount)
    local character = self:getChar()
    return character and character:hasMoney(amount)
end

function playerMeta:hasSkillLevel(skill, level)
    local currentLevel = self:getChar():getAttrib(skill, 0)
    return currentLevel >= level
end

function playerMeta:meetsRequiredSkills(requiredSkillLevels)
    if not requiredSkillLevels then return true end
    for skill, level in pairs(requiredSkillLevels) do
        if not self:hasSkillLevel(skill, level) then return false end
    end
    return true
end

if SERVER then
    function playerMeta:restoreStamina(amount)
        local current = self:getLocalVar("stamina", 0)
        local maxStamina = self:getChar():getMaxStamina()
        local value = math.Clamp(current + amount, 0, maxStamina)
        self:setLocalVar("stamina", value)
        if value >= maxStamina * 0.5 and self:getNetVar("brth", false) then
            self:setNetVar("brth", nil)
            hook.Run("PlayerStaminaGained", self)
        end
    end

    function playerMeta:consumeStamina(amount)
        local current = self:getLocalVar("stamina", 0)
        local value = math.Clamp(current - amount, 0, self:getChar():getMaxStamina())
        self:setLocalVar("stamina", value)
        if value == 0 and not self:getNetVar("brth", false) then
            self:setNetVar("brth", true)
            hook.Run("PlayerStaminaLost", self)
        end
    end

    function playerMeta:addMoney(amount)
        local character = self:getChar()
        if not character then return false end
        local currentMoney = character:getMoney()
        local maxMoneyLimit = lia.config.get("MoneyLimit") or 0
        local totalMoney = currentMoney + amount
        if maxMoneyLimit > 0 and isnumber(maxMoneyLimit) and totalMoney > maxMoneyLimit then
            local excessMoney = totalMoney - maxMoneyLimit
            character:setMoney(maxMoneyLimit)
            self:notifyLocalized("moneyLimit", lia.currency.get(maxMoneyLimit), lia.currency.plural, lia.currency.get(excessMoney), lia.currency.plural)
            local money = lia.currency.spawn(self:getItemDropPos(), excessMoney)
            if IsValid(money) then
                money.client = self
                money.charID = character:getID()
            end

            lia.log.add(self, "money", maxMoneyLimit - currentMoney)
        else
            character:setMoney(totalMoney)
            lia.log.add(self, "money", amount)
        end
        return true
    end

    function playerMeta:takeMoney(amount)
        local character = self:getChar()
        if character then character:giveMoney(-amount) end
    end

    function playerMeta:WhitelistAllClasses()
        for class, _ in pairs(lia.class.list) do
            if lia.class.hasWhitelist(class) then self:classWhitelist(class) end
        end
    end

    function playerMeta:WhitelistAllFactions()
        for faction, _ in pairs(lia.faction.indices) do
            self:setWhitelisted(faction, true)
        end
    end

    function playerMeta:WhitelistEverything()
        self:WhitelistAllFactions()
        self:WhitelistAllClasses()
    end

    function playerMeta:classWhitelist(class)
        local wl = self:getChar():getData("whitelist", {})
        wl[class] = true
        self:getChar():setData("whitelist", wl)
    end

    function playerMeta:classUnWhitelist(class)
        local wl = self:getChar():getData("whitelist", {})
        wl[class] = false
        self:getChar():setData("whitelist", wl)
    end

    function playerMeta:setWhitelisted(faction, whitelisted)
        if not whitelisted then whitelisted = nil end
        local data = lia.faction.indices[faction]
        if data then
            local whitelists = self:getLiliaData("whitelists", {})
            whitelists[SCHEMA.folder] = whitelists[SCHEMA.folder] or {}
            whitelists[SCHEMA.folder][data.uniqueID] = whitelisted and true or nil
            self:setLiliaData("whitelists", whitelists)
            self:saveLiliaData()
            return true
        end
        return false
    end

    function playerMeta:loadLiliaData(callback)
        local name = self:steamName()
        local steamID64 = self:SteamID64()
        local timeStamp = os.date("%Y-%m-%d %H:%M:%S", os.time())
        lia.db.query("SELECT _data, _firstJoin, _lastJoin FROM lia_players WHERE _steamID = " .. steamID64, function(data)
            if IsValid(self) and data and data[1] and data[1]._data then
                lia.db.updateTable({
                    _lastJoin = timeStamp,
                }, nil, "players", "_steamID = " .. steamID64)

                self.firstJoin = data[1]._firstJoin or timeStamp
                self.lastJoin = data[1]._lastJoin or timeStamp
                self.liaData = util.JSONToTable(data[1]._data)
                if callback then callback(self.liaData) end
            else
                lia.db.insertTable({
                    _steamID = steamID64,
                    _steamName = name,
                    _firstJoin = timeStamp,
                    _lastJoin = timeStamp,
                    _data = {}
                }, nil, "players")

                if callback then callback({}) end
            end
        end)
    end

    function playerMeta:saveLiliaData()
        if self:IsBot() then return end
        local name = self:steamName()
        local steamID64 = self:SteamID64()
        local timeStamp = os.date("%Y-%m-%d %H:%M:%S", os.time())
        lia.db.updateTable({
            _steamName = name,
            _lastJoin = timeStamp,
            _data = self.liaData
        }, nil, "players", "_steamID = " .. steamID64)
    end

    function playerMeta:setLiliaData(key, value, noNetworking)
        self.liaData = self.liaData or {}
        self.liaData[key] = value
        if not noNetworking then netstream.Start(self, "liaData", key, value) end
    end

    function playerMeta:setWaypoint(name, vector)
        net.Start("setWaypoint")
        net.WriteString(name)
        net.WriteVector(vector)
        net.Send(self)
    end

    function playerMeta:setWeighPoint(name, vector)
        self:setWaypoint(name, vector)
    end

    function playerMeta:setWaypointWithLogo(name, vector, logo)
        net.Start("setWaypointWithLogo")
        net.WriteString(name)
        net.WriteVector(vector)
        net.WriteString(logo)
        net.Send(self)
    end

    function playerMeta:getLiliaData(key, default)
        local data = self.liaData and self.liaData[key]
        return data and default or data
    end

    function playerMeta:getAllLiliaData()
        self.liaData = self.liaData or {}
        return self.liaData
    end

    function playerMeta:setRagdoll(entity)
        self.liaRagdoll = entity
    end

    function playerMeta:setAction(text, time, callback)
        if time and time <= 0 then
            if callback then callback(self) end
            return
        end

        time = time or 5
        if not text then
            timer.Remove("liaAct" .. self:SteamID64())
            net.Start("actBar")
            net.WriteBool(false)
            net.Send(self)
            return
        end

        net.Start("actBar")
        net.WriteBool(true)
        net.WriteString(text)
        net.WriteFloat(time)
        net.Send(self)
        if callback then timer.Create("liaAct" .. self:SteamID64(), time, 1, function() if IsValid(self) then callback(self) end end) end
    end

    function playerMeta:doStaredAction(entity, callback, time, onCancel, distance)
        local uniqueID = "liaStare" .. self:SteamID64()
        local data = {}
        data.filter = self
        timer.Create(uniqueID, 0.1, time / 0.1, function()
            if IsValid(self) and IsValid(entity) then
                data.start = self:GetShootPos()
                data.endpos = data.start + self:GetAimVector() * (distance or 96)
                local targetEntity = self:getTracedEntity()
                if IsValid(targetEntity) and targetEntity:GetClass() == "prop_ragdoll" and IsValid(targetEntity:getNetVar("player")) then targetEntity = targetEntity:getNetVar("player") end
                if targetEntity ~= entity then
                    timer.Remove(uniqueID)
                    if onCancel then onCancel() end
                elseif callback and timer.RepsLeft(uniqueID) == 0 then
                    callback()
                end
            else
                timer.Remove(uniqueID)
                if onCancel then onCancel() end
            end
        end)
    end

    function playerMeta:stopAction()
        timer.Remove("liaAct" .. self:SteamID64())
        net.Start("actBar")
        net.Send(self)
    end

    function playerMeta:requestDropdown(title, subTitle, options, callback)
        net.Start("RequestDropdown")
        net.WriteString(title)
        net.WriteString(subTitle)
        net.WriteTable(options)
        net.Send(self)
        self.dropdownCallback = callback
    end

    function playerMeta:requestOptions(title, subTitle, options, limit, callback)
        net.Start("OptionsRequest")
        net.WriteString(title)
        net.WriteString(subTitle)
        net.WriteTable(options)
        net.WriteUInt(limit, 32)
        net.Send(self)
        self.optionsCallback = callback
    end

    function playerMeta:requestString(title, subTitle, callback, default)
        local d
        if not isfunction(callback) and default == nil then
            default = callback
            d = deferred.new()
            callback = function(value) d:resolve(value) end
        end

        self.liaStrReqs = self.liaStrReqs or {}
        local id = table.insert(self.liaStrReqs, callback)
        net.Start("StringRequest")
        net.WriteUInt(id, 32)
        net.WriteString(title)
        net.WriteString(subTitle)
        net.WriteString(default or "")
        net.Send(self)
        return d
    end

    function playerMeta:binaryQuestion(question, option1, option2, manualDismiss, callback)
        net.Start("BinaryQuestionRequest")
        net.WriteString(question)
        net.WriteString(option1)
        net.WriteString(option2)
        net.WriteBool(manualDismiss)
        net.Send(self)
        self.binaryQuestionCallback = callback
    end

    function playerMeta:getPlayTime()
        local diff = os.time(lia.time.toNumber(self.lastJoin)) - os.time(lia.time.toNumber(self.firstJoin))
        return diff + RealTime() - (self.liaJoinTime or RealTime())
    end

    function playerMeta:createRagdoll(freeze, isDead)
        local entity = ents.Create("prop_ragdoll")
        entity:SetPos(self:GetPos())
        entity:SetAngles(self:EyeAngles())
        entity:SetModel(self:GetModel())
        entity:SetSkin(self:GetSkin())
        entity:Spawn()
        local numBodyGroups = entity:GetNumBodyGroups() or 0
        for i = 0, numBodyGroups - 1 do
            entity:SetBodygroup(i, self:GetBodygroup(i))
        end

        entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
        entity:Activate()
        if isDead then self.liaRagdoll = entity end
        hook.Run("OnCreatePlayerRagdoll", self, entity, isDead)
        local velocity = self:GetVelocity()
        for i = 0, entity:GetPhysicsObjectCount() - 1 do
            local physObj = entity:GetPhysicsObjectNum(i)
            if IsValid(physObj) then
                local index = entity:TranslatePhysBoneToBone(i)
                if index then
                    local position, angles = self:GetBonePosition(index)
                    physObj:SetPos(position)
                    physObj:SetAngles(angles)
                end

                if freeze then
                    physObj:EnableMotion(false)
                else
                    physObj:SetVelocity(velocity)
                end
            end
        end
        return entity
    end

    function playerMeta:setRagdolled(state, time, getUpGrace, getUpMessage)
        getUpMessage = getUpMessage or L("wakingUp")
        local hasRagdoll = self:hasRagdoll()
        local ragdoll = self:getRagdoll()
        if state then
            if hasRagdoll then SafeRemoveEntity(ragdoll) end
            local entity = self:createRagdoll()
            entity:setNetVar("player", self)
            entity:CallOnRemove("fixer", function()
                if IsValid(self) then
                    self:setLocalVar("blur", nil)
                    self:setLocalVar("ragdoll", nil)
                    if not entity.liaNoReset then self:SetPos(entity:GetPos()) end
                    self:SetNoDraw(false)
                    self:SetNotSolid(false)
                    self:Freeze(false)
                    self:SetMoveType(MOVETYPE_WALK)
                    self:SetLocalVelocity(IsValid(entity) and entity.liaLastVelocity or vector_origin)
                end

                if IsValid(self) and not entity.liaIgnoreDelete then
                    if entity.liaWeapons then
                        for _, v in ipairs(entity.liaWeapons) do
                            self:Give(v, true)
                            if entity.liaAmmo then
                                for _, data in ipairs(entity.liaAmmo) do
                                    if v == data[1] then self:SetAmmo(data[2], tostring(data[1])) end
                                end
                            end
                        end
                    end

                    if self:isStuck() then
                        entity:DropToFloor()
                        self:SetPos(entity:GetPos() + Vector(0, 0, 16))
                        local positions = lia.util.findEmptySpace(self, {entity, self})
                        for _, pos in ipairs(positions) do
                            self:SetPos(pos)
                            if not self:isStuck() then return end
                        end
                    end
                end
            end)

            self:setLocalVar("blur", 25)
            self:setRagdoll(entity)
            entity.liaWeapons = {}
            entity.liaAmmo = {}
            entity.liaPlayer = self
            if getUpGrace then entity.liaGrace = CurTime() + getUpGrace end
            if time and time > 0 then
                entity.liaStart = CurTime()
                entity.liaFinish = entity.liaStart + time
                self:setAction(getUpMessage, time)
            end

            for _, w in ipairs(self:GetWeapons()) do
                entity.liaWeapons[#entity.liaWeapons + 1] = w:GetClass()
                local clip = w:Clip1()
                local reserve = self:GetAmmoCount(w:GetPrimaryAmmoType())
                local ammo = clip + reserve
                entity.liaAmmo[w:GetPrimaryAmmoType()] = {w:GetClass(), ammo}
            end

            self:GodDisable()
            self:StripWeapons()
            self:Freeze(true)
            self:SetNoDraw(true)
            self:SetNotSolid(true)
            self:SetMoveType(MOVETYPE_NONE)
            if time then
                local uniqueID = "liaUnRagdoll" .. self:SteamID64()
                timer.Create(uniqueID, 0.33, 0, function()
                    if not IsValid(entity) or not IsValid(self) then
                        timer.Remove(uniqueID)
                        return
                    end

                    local velocity = entity:GetVelocity()
                    entity.liaLastVelocity = velocity
                    self:SetPos(entity:GetPos())
                    time = time - 0.33
                    if time <= 0 then SafeRemoveEntity(entity) end
                end)
            end

            self:setLocalVar("ragdoll", entity:EntIndex())
            if IsValid(entity) then
                entity:SetCollisionGroup(COLLISION_GROUP_NONE)
                entity:SetCustomCollisionCheck(false)
            end
        elseif hasRagdoll then
            SafeRemoveEntity(self.liaRagdoll)
            hook.Run("OnCharFallover", self, nil, false)
        end
    end

    function playerMeta:syncVars()
        for entity, data in pairs(lia.net) do
            if entity == "globals" then
                for k, v in pairs(data) do
                    netstream.Start(self, "gVar", k, v)
                end
            elseif IsValid(entity) then
                for k, v in pairs(data) do
                    netstream.Start(self, "nVar", entity:EntIndex(), k, v)
                end
            end
        end
    end

    function playerMeta:setLocalVar(key, value)
        if checkBadType(key, value) then return end
        lia.net[self] = lia.net[self] or {}
        lia.net[self][key] = value
        netstream.Start(self, "nLcl", key, value)
    end
else
    function playerMeta:getPlayTime()
        local diff = os.time(lia.time.toNumber(lia.lastJoin)) - os.time(lia.time.toNumber(lia.firstJoin))
        return diff + RealTime() - (lia.joinTime or 0)
    end

    function playerMeta:setWaypoint(name, vector, onReach)
        hook.Add("HUDPaint", "WeighPoint", function()
            if not IsValid(self) then
                hook.Remove("HUDPaint", "WeighPoint")
                return
            end

            local dist = self:GetPos():Distance(vector)
            local spos = vector:ToScreen()
            local howclose = math.Round(dist / 40)
            if spos.visible then
                render.SuppressEngineLighting(true)
                surface.SetFont("liaBigFont")
                draw.DrawText(name .. "\n" .. howclose .. " Meters\n", "liaBigFont", spos.x, spos.y, Color(255, 255, 255), TEXT_ALIGN_CENTER)
                render.SuppressEngineLighting(false)
            end

            if howclose <= 3 then RunConsoleCommand("weighpoint_stop") end
        end)

        concommand.Add("weighpoint_stop", function()
            hook.Remove("HUDPaint", "WeighPoint")
            if onReach and isfunction(onReach) then onReach() end
        end)
    end

    function playerMeta:setWeighPoint(name, vector, onReach)
        self:setWaypoint(name, vector, onReach)
    end

    function playerMeta:setWaypointWithLogo(name, vector, logo, onReach)
        if not isstring(name) or not isvector(vector) then return end
        local logoMaterial
        if logo and isstring(logo) then
            logoMaterial = Material(logo, "smooth mips noclamp")
            if not logoMaterial or logoMaterial:IsError() then logoMaterial = nil end
        end

        if not logoMaterial then return end
        local waypointID = "Waypoint_WithLogo_" .. tostring(self:SteamID64()) .. "_" .. tostring(math.random(100000, 999999))
        hook.Add("HUDPaint", waypointID, function()
            if not IsValid(self) then
                hook.Remove("HUDPaint", waypointID)
                return
            end

            local dist = self:GetPos():Distance(vector)
            local spos = vector:ToScreen()
            local howClose = math.Round(dist / 40)
            if spos.visible then
                if logoMaterial then
                    local logoSize = 32
                    surface.SetDrawColor(255, 255, 255, 255)
                    surface.SetMaterial(logoMaterial)
                    surface.DrawTexturedRect(spos.x - logoSize / 2, spos.y - logoSize / 2 - 40, logoSize, logoSize)
                end

                draw.DrawText(name .. "\n" .. howClose .. " Meters", "liaBigFont", spos.x, spos.y - 10, Color(255, 255, 255), TEXT_ALIGN_CENTER)
            end

            if howClose <= 3 then RunConsoleCommand("waypoint_withlogo_stop_" .. waypointID) end
        end)

        concommand.Add("waypoint_withlogo_stop_" .. waypointID, function()
            hook.Remove("HUDPaint", waypointID)
            concommand.Remove("waypoint_withlogo_stop_" .. waypointID)
            if onReach and isfunction(onReach) then onReach(self) end
        end)
    end

    function playerMeta:getLiliaData(key, default)
        local data = lia.localData and lia.localData[key]
        if data == nil then
            return default
        else
            return data
        end
    end

    function playerMeta:getAllLiliaData()
        lia.localData = lia.localData or {}
        return lia.localData
    end
end

-- ./gamemode/core/meta/tool.lua
local ToolGunMeta = lia.meta.tool or {}
function ToolGunMeta:Create()
    local object = {}
    setmetatable(object, self)
    self.__index = self
    object.Mode = nil
    object.SWEP = nil
    object.Owner = nil
    object.ClientConVar = {}
    object.ServerConVar = {}
    object.Objects = {}
    object.Stage = 0
    object.Message = L("start")
    object.LastMessage = 0
    object.AllowedCVar = 0
    return object
end

function ToolGunMeta:CreateConVars()
    local mode = self:GetMode()
    if CLIENT then
        for cvar, default in pairs(self.ClientConVar) do
            CreateClientConVar(mode .. "_" .. cvar, default, true, true)
        end
        return
    else
        self.AllowedCVar = CreateConVar("toolmode_allow_" .. mode, 1, FCVAR_NOTIFY)
    end
end

function ToolGunMeta:GetServerInfo(property)
    local mode = self:GetMode()
    return ConVar(mode .. "_" .. property)
end

function ToolGunMeta:BuildConVarList()
    local mode = self:GetMode()
    local convars = {}
    for k, v in pairs(self.ClientConVar) do
        convars[mode .. "_" .. k] = v
    end
    return convars
end

function ToolGunMeta:GetClientInfo(property)
    return self:GetOwner():GetInfo(self:GetMode() .. "_" .. property)
end

function ToolGunMeta:GetClientNumber(property, default)
    return self:GetOwner():GetInfoNum(self:GetMode() .. "_" .. property, tonumber(default) or 0)
end

function ToolGunMeta:Allowed()
    if CLIENT then return true end
    return self.AllowedCVar:GetBool()
end

function ToolGunMeta:Init()
end

function ToolGunMeta:GetMode()
    return self.Mode
end

function ToolGunMeta:GetSWEP()
    return self.SWEP
end

function ToolGunMeta:GetOwner()
    return self:GetSWEP().Owner or self:GetOwner()
end

function ToolGunMeta:GetWeapon()
    return self:GetSWEP().Weapon or self.Weapon
end

function ToolGunMeta:LeftClick()
    return false
end

function ToolGunMeta:RightClick()
    return false
end

function ToolGunMeta:Reload()
    self:ClearObjects()
end

function ToolGunMeta:Deploy()
    self:ReleaseGhostEntity()
end

function ToolGunMeta:Holster()
    self:ReleaseGhostEntity()
end

function ToolGunMeta:Think()
    self:ReleaseGhostEntity()
end

function ToolGunMeta:CheckObjects()
    for _, v in pairs(self.Objects) do
        if not v.Ent:IsWorld() and not IsValid(v.Ent) then self:ClearObjects() end
    end
end

function ToolGunMeta:ClearObjects()
    self.Objects = {}
end

function ToolGunMeta:ReleaseGhostEntity()
    if IsValid(self.GhostEntity) then
        SafeRemoveEntity(self.GhostEntity)
        self.GhostEntity = nil
    end
end

lia.meta.tool = ToolGunMeta


-- ./gamemode/core/meta/vector.lua
local vectorMeta = FindMetaTable("Vector")
function vectorMeta:Center(vec2)
    return (self + vec2) / 2
end

function vectorMeta:Distance(vec2)
    local x, y, z = self.x, self.y, self.z
    local x2, y2, z2 = vec2.x, vec2.y, vec2.z
    return math.sqrt((x - x2) ^ 2 + (y - y2) ^ 2 + (z - z2) ^ 2)
end

function vectorMeta:RotateAroundAxis(axis, degrees)
    local rad = math.rad(degrees)
    local cosTheta = math.cos(rad)
    local sinTheta = math.sin(rad)
    return Vector(cosTheta * self.x + sinTheta * (axis.y * self.z - axis.z * self.y), cosTheta * self.y + sinTheta * (axis.z * self.x - axis.x * self.z), cosTheta * self.z + sinTheta * (axis.x * self.y - axis.y * self.x))
end

local right = Vector(0, -1, 0)
function vectorMeta:Right(vUp)
    if self[1] == 0 and self[2] == 0 then return right end
    if not vUp then vUp = vector_up end
    local vRet = self:Cross(self, vUp)
    vRet:Normalize()
    return vRet
end

function vectorMeta:Up(vUp)
    if self[1] == 0 and self[2] == 0 then return Vector(-self[3], 0, 0) end
    if not vUp then vUp = vector_up end
    local vRet = self:Cross(self, vUp)
    vRet = self:Cross(vRet, self)
    vRet:Normalize()
    return vRet
end


-- ./gamemode/core/netcalls/client.lua
net.Receive("liaNotifyL", function()
    local message = net.ReadString()
    local length = net.ReadUInt(8)
    if length == 0 then return lia.notices.notifyLocalized(message) end
    local args = {}
    for i = 1, length do
        args[i] = net.ReadString()
    end

    lia.notices.notifyLocalized(message, unpack(args))
end)

net.Receive("setWaypoint", function()
    local name = net.ReadString()
    local pos = net.ReadVector()
    LocalPlayer():setWaypoint(name, pos)
end)

net.Receive("setWaypointWithLogo", function()
    local name = net.ReadString()
    local pos = net.ReadVector()
    local logo = net.ReadString()
    LocalPlayer():setWaypointWithLogo(name, pos, logo)
end)

net.Receive("liaNotify", function()
    local message = net.ReadString()
    lia.notices.notify(message)
end)

net.Receive("ServerChatAddText", function()
    local args = net.ReadTable()
    chat.AddText(unpack(args))
end)

net.Receive("liaInventoryData", function()
    local id = net.ReadType()
    local key = net.ReadString()
    local value = net.ReadType()
    local instance = lia.inventory.instances[id]
    if not instance then
        ErrorNoHalt("Got data " .. key .. " for non-existent instance " .. id)
        return
    end

    local oldValue = instance.data[key]
    instance.data[key] = value
    instance:onDataChanged(key, oldValue, value)
    hook.Run("InventoryDataChanged", instance, key, oldValue, value)
end)

net.Receive("liaInventoryInit", function()
    local id = net.ReadType()
    local typeID = net.ReadString()
    local data = net.ReadTable()
    local instance = lia.inventory.new(typeID)
    instance.id = id
    instance.data = data
    instance.items = {}
    local length = net.ReadUInt(32)
    local data2 = net.ReadData(length)
    local uncompressed_data = util.Decompress(data2)
    local items = util.JSONToTable(uncompressed_data)
    local function readItem(I)
        local c = items[I]
        return c.i, c.u, c.d, c.q
    end

    local datatable = items
    local expectedItems = #datatable
    for i = 1, expectedItems do
        local itemID, itemType, data, quantity = readItem(i)
        local item = lia.item.new(itemType, itemID)
        item.data = table.Merge(item.data, data)
        item.invID = instance.id
        item.quantity = quantity
        instance.items[itemID] = item
        hook.Run("ItemInitialized", item)
    end

    lia.inventory.instances[instance.id] = instance
    hook.Run("InventoryInitialized", instance)
    for _, character in pairs(lia.char.loaded) do
        for index, inventory in pairs(character.vars.inv) do
            if inventory:getID() == id then character.vars.inv[index] = instance end
        end
    end
end)

net.Receive("liaInventoryAdd", function()
    local itemID = net.ReadUInt(32)
    local invID = net.ReadType()
    local item = lia.item.instances[itemID]
    local inventory = lia.inventory.instances[invID]
    if item and inventory then
        inventory.items[itemID] = item
        hook.Run("InventoryItemAdded", inventory, item)
    end
end)

net.Receive("liaInventoryRemove", function()
    local itemID = net.ReadUInt(32)
    local invID = net.ReadType()
    local item = lia.item.instances[itemID]
    local inventory = lia.inventory.instances[invID]
    if item and inventory and inventory.items[itemID] then
        inventory.items[itemID] = nil
        item.invID = 0
        hook.Run("InventoryItemRemoved", inventory, item)
    end
end)

net.Receive("liaInventoryDelete", function()
    local invID = net.ReadType()
    local instance = lia.inventory.instances[invID]
    if instance then hook.Run("InventoryDeleted", instance) end
    if invID then lia.inventory.instances[invID] = nil end
end)

net.Receive("liaItemInstance", function()
    local itemID = net.ReadUInt(32)
    local itemType = net.ReadString()
    local data = net.ReadTable()
    local item = lia.item.new(itemType, itemID)
    local invID = net.ReadType()
    local quantity = net.ReadUInt(32)
    item.data = table.Merge(item.data or {}, data)
    item.invID = invID
    item.quantity = quantity
    lia.item.instances[itemID] = item
    hook.Run("ItemInitialized", item)
end)

net.Receive("liaCharacterInvList", function()
    local charID = net.ReadUInt(32)
    local length = net.ReadUInt(32)
    local inventories = {}
    for i = 1, length do
        inventories[i] = lia.inventory.instances[net.ReadType()]
    end

    local character = lia.char.loaded[charID]
    if character then character.vars.inv = inventories end
end)

net.Receive("liaItemDelete", function()
    local id = net.ReadUInt(32)
    local instance = lia.item.instances[id]
    if instance and instance.invID then
        local inventory = lia.inventory.instances[instance.invID]
        if not inventory or not inventory.items[id] then return end
        inventory.items[id] = nil
        instance.invID = 0
        hook.Run("InventoryItemRemoved", inventory, instance)
    end

    lia.item.instances[id] = nil
    hook.Run("ItemDeleted", instance)
end)

netstream.Hook("charSet", function(key, value, id)
    id = id or LocalPlayer():getChar() and LocalPlayer():getChar().id
    local character = lia.char.loaded[id]
    if character then
        local oldValue = character.vars[key]
        character.vars[key] = value
        hook.Run("OnCharVarChanged", character, key, oldValue, value)
    end
end)

netstream.Hook("charVar", function(key, value, id)
    id = id or LocalPlayer():getChar() and LocalPlayer():getChar().id
    local character = lia.char.loaded[id]
    if character then
        local oldVar = character:getVar()[key]
        character:getVar()[key] = value
        hook.Run("OnCharLocalVarChanged", character, key, oldVar, value)
    end
end)

netstream.Hook("charData", function(id, key, value)
    local character = lia.char.loaded[id]
    if character then
        character.vars.data = character.vars.data or {}
        character:getData()[key] = value
    end
end)

netstream.Hook("item", function(uniqueID, id, data, invID)
    local item = lia.item.new(uniqueID, id)
    item.data = {}
    if data then item.data = data end
    item.invID = invID or 0
    hook.Run("ItemInitialized", item)
end)

netstream.Hook("invData", function(id, key, value)
    local item = lia.item.instances[id]
    if item then
        item.data = item.data or {}
        local oldValue = item.data[key]
        item.data[key] = value
        hook.Run("ItemDataChanged", item, key, oldValue, value)
    end
end)

netstream.Hook("invQuantity", function(id, quantity)
    local item = lia.item.instances[id]
    if item then
        local oldValue = item:getQuantity()
        item.quantity = quantity
        hook.Run("ItemQuantityChanged", item, oldValue, quantity)
    end
end)

netstream.Hook("liaDataSync", function(data, first, last)
    lia.localData = data
    lia.firstJoin = first
    lia.lastJoin = last
end)

netstream.Hook("liaData", function(key, value)
    lia.localData = lia.localData or {}
    lia.localData[key] = value
end)

netstream.Hook("attrib", function(id, key, value)
    local character = lia.char.loaded[id]
    if character then character:getAttribs()[key] = value end
end)

netstream.Hook("nVar", function(index, key, value)
    lia.net[index] = lia.net[index] or {}
    lia.net[index][key] = value
end)

netstream.Hook("nLcl", function(key, value)
    lia.net[LocalPlayer():EntIndex()] = lia.net[LocalPlayer():EntIndex()] or {}
    lia.net[LocalPlayer():EntIndex()][key] = value
end)

net.Receive("actBar", function()
    local hasData = net.ReadBool()
    if not hasData then
        hook.Remove("HUDPaint", "liaDrawAction")
        return
    end

    local text = net.ReadString()
    local time = net.ReadFloat()
    local display = text:sub(1, 1) == "@" and L(text:sub(2)) or text
    lia.bar.drawAction(display, time)
end)

net.Receive("OpenInvMenu", function()
    if not LocalPlayer():hasPrivilege("Commands - Check Inventories") then return end
    local target = net.ReadEntity()
    local index = net.ReadType()
    local targetInv = lia.inventory.instances[index]
    local myInv = LocalPlayer():getChar():getInv()
    local inventoryDerma = targetInv:show()
    inventoryDerma:SetTitle(target:getChar():getName() .. "'s Inventory")
    inventoryDerma:MakePopup()
    inventoryDerma:ShowCloseButton(true)
    local myInventoryDerma = myInv:show()
    myInventoryDerma:MakePopup()
    myInventoryDerma:ShowCloseButton(true)
    myInventoryDerma:SetParent(inventoryDerma)
    myInventoryDerma:MoveLeftOf(inventoryDerma, 4)
end)

net.Receive("CreateTableUI", function()
    local dataSize = net.ReadUInt(32)
    local compressedData = net.ReadData(dataSize)
    local jsonData = util.Decompress(compressedData)
    local data = util.JSONToTable(jsonData)
    lia.util.CreateTableUI(data.title, data.columns, data.data, data.options, data.characterID)
end)

net.Receive("OptionsRequest", function()
    local title = L(net.ReadString())
    local subTitle = L(net.ReadString())
    local options = net.ReadTable()
    local limit = net.ReadUInt(32)
    local frame = vgui.Create("DFrame")
    frame:SetTitle(title)
    frame:SetSize(400, 300)
    frame:Center()
    frame:MakePopup()
    local label = vgui.Create("DLabel", frame)
    label:SetText(subTitle)
    label:SetPos(10, 30)
    label:SizeToContents()
    label:SetTextColor(Color(255, 255, 255))
    local list = vgui.Create("DPanelList", frame)
    list:SetPos(10, 50)
    list:SetSize(380, 200)
    list:EnableVerticalScrollbar(true)
    list:SetSpacing(5)
    local selected = {}
    local checkboxes = {}
    for _, option in ipairs(options) do
        local localizedOption = L(option)
        local checkbox = vgui.Create("DCheckBoxLabel")
        checkbox:SetText(localizedOption)
        checkbox:SetValue(false)
        checkbox:SizeToContents()
        checkbox:SetTextColor(Color(255, 255, 255))
        checkbox.OnChange = function(self, value)
            if value then
                if #selected < limit then
                    table.insert(selected, option)
                else
                    self:SetValue(false)
                end
            else
                for i, v in ipairs(selected) do
                    if v == option then
                        table.remove(selected, i)
                        break
                    end
                end
            end
        end

        list:AddItem(checkbox)
        table.insert(checkboxes, checkbox)
    end

    local button = vgui.Create("DButton", frame)
    button:SetText(L("submit"))
    button:SetPos(10, 260)
    button:SetSize(380, 30)
    button.DoClick = function()
        net.Start("OptionsRequest")
        net.WriteTable(selected)
        net.SendToServer()
        frame:Close()
    end
end)

net.Receive("RequestDropdown", function()
    local title = L(net.ReadString())
    local subTitle = L(net.ReadString())
    local options = net.ReadTable()
    local frame = vgui.Create("DFrame")
    frame:SetTitle(title)
    frame:SetSize(300, 150)
    frame:Center()
    frame:MakePopup()
    local dropdown = vgui.Create("DComboBox", frame)
    dropdown:SetPos(10, 40)
    dropdown:SetSize(280, 20)
    dropdown:SetValue(subTitle)
    for _, option in ipairs(options) do
        dropdown:AddChoice(L(option))
    end

    dropdown.OnSelect = function(_, _, value)
        net.Start("RequestDropdown")
        net.WriteString(value)
        net.SendToServer()
        frame:Close()
    end
end)

net.Receive("StringRequest", function()
    local id = net.ReadUInt(32)
    local title = net.ReadString()
    local subTitle = net.ReadString()
    local default = net.ReadString()
    if title:sub(1, 1) == "@" then title = L(title:sub(2)) end
    if subTitle:sub(1, 1) == "@" then subTitle = L(subTitle:sub(2)) end
    Derma_StringRequest(title, subTitle, default, function(text)
        net.Start("StringRequest")
        net.WriteUInt(id, 32)
        net.WriteString(text)
        net.SendToServer()
    end)
end)

local function OrganizeNotices()
    local baseY = 10
    local list = {}
    for _, n in ipairs(lia.notices) do
        if IsValid(n) then list[#list + 1] = n end
    end

    while #list > 6 do
        local old = table.remove(list, 1)
        if IsValid(old) then old:Remove() end
    end

    local leftCount = #list > 3 and #list - 3 or 0
    for i, n in ipairs(list) do
        local h = n:GetTall()
        local x, y
        if i <= leftCount then
            x = 10
            y = baseY + (i - 1) * (h + 5)
        else
            local idx = i - leftCount
            x = ScrW() - n:GetWide() - 10
            y = baseY + (idx - 1) * (h + 5)
        end

        n:MoveTo(x, y, 0.15)
    end
end

local function RemoveNotices(notice)
    if not IsValid(notice) then return end
    for i, v in ipairs(lia.notices) do
        if v == notice then
            notice:SizeTo(notice:GetWide(), 0, 0.2, 0, -1, function() if IsValid(notice) then notice:Remove() end end)
            table.remove(lia.notices, i)
            timer.Simple(0.25, OrganizeNotices)
            break
        end
    end
end

local function CreateNoticePanel(length, notimer)
    if not notimer then notimer = false end
    local notice = vgui.Create("noticePanel")
    notice.start = CurTime() + 0.25
    notice.endTime = CurTime() + length
    notice.oh = notice:GetTall()
    function notice:Paint(w, h)
        draw.RoundedBox(4, 0, 0, w, h, Color(35, 35, 35, 200))
        if self.start then
            local progress = math.TimeFraction(self.start, self.endTime, CurTime()) * w
            draw.RoundedBox(4, 0, 0, progress, h, lia.config.get("Color"))
        end
    end

    if not notimer then timer.Simple(length, function() RemoveNotices(notice) end) end
    return notice
end

net.Receive("BinaryQuestionRequest", function()
    local question = L(net.ReadString())
    local option1 = L(net.ReadString(), "Yes")
    local option2 = L(net.ReadString(), "No")
    local manualDismiss = net.ReadBool()
    local notice = CreateNoticePanel(10, manualDismiss)
    table.insert(lia.notices, notice)
    notice.isQuery = true
    notice.text:SetText(question)
    notice:SetPos(ScrW() / 2 - notice:GetWide() / 2, 4)
    notice:SetTall(36 * 2.3)
    notice:CalcWidth(120)
    if manualDismiss then notice.start = nil end
    notice.opt1 = notice:Add("DButton")
    notice.opt1:SetAlpha(0)
    notice.opt2 = notice:Add("DButton")
    notice.opt2:SetAlpha(0)
    notice.oh = notice:GetTall()
    notice:SetTall(0)
    notice:SizeTo(notice:GetWide(), 36 * 2.3, 0.2, 0, -1, function()
        notice.text:SetPos(0, 0)
        local function styleOpt(o)
            o.color = Color(0, 0, 0, 30)
            AccessorFunc(o, "color", "Color")
            function o:Paint(w, h)
                if self.left then
                    draw.RoundedBoxEx(4, 0, 0, w + 2, h, self.color, false, false, true, false)
                else
                    draw.RoundedBoxEx(4, 0, 0, w + 2, h, self.color, false, false, false, true)
                end
            end
        end

        if notice.opt1 and IsValid(notice.opt1) then
            notice.opt1:SetAlpha(255)
            notice.opt1:SetSize(notice:GetWide() / 2, 25)
            notice.opt1:SetText(option1 .. " (F8)")
            notice.opt1:SetPos(0, notice:GetTall() - notice.opt1:GetTall())
            notice.opt1:CenterHorizontal(0.25)
            notice.opt1:SetAlpha(0)
            notice.opt1:AlphaTo(255, 0.2)
            notice.opt1:SetTextColor(color_white)
            notice.opt1.left = true
            styleOpt(notice.opt1)
            function notice.opt1:keyThink()
                if input.IsKeyDown(KEY_F8) and CurTime() - notice.lastKey >= 0.5 then
                    self:ColorTo(Color(24, 215, 37), 0.2, 0)
                    notice.respondToKeys = false
                    net.Start("BinaryQuestionRequest")
                    net.WriteUInt(0, 1)
                    net.SendToServer()
                    timer.Simple(1, function() if notice and IsValid(notice) then RemoveNotices(notice) end end)
                    notice.lastKey = CurTime()
                end
            end
        end

        if notice.opt2 and IsValid(notice.opt2) then
            notice.opt2:SetAlpha(255)
            notice.opt2:SetSize(notice:GetWide() / 2, 25)
            notice.opt2:SetText(option2 .. " (F9)")
            notice.opt2:SetPos(0, notice:GetTall() - notice.opt2:GetTall())
            notice.opt2:CenterHorizontal(0.75)
            notice.opt2:SetAlpha(0)
            notice.opt2:AlphaTo(255, 0.2)
            notice.opt2:SetTextColor(color_white)
            styleOpt(notice.opt2)
            function notice.opt2:keyThink()
                if input.IsKeyDown(KEY_F9) and CurTime() - notice.lastKey >= 0.5 then
                    self:ColorTo(Color(24, 215, 37), 0.2, 0)
                    notice.respondToKeys = false
                    net.Start("BinaryQuestionRequest")
                    net.WriteUInt(1, 1)
                    net.SendToServer()
                    timer.Simple(1, function() if notice and IsValid(notice) then RemoveNotices(notice) end end)
                    notice.lastKey = CurTime()
                end
            end
        end

        notice.lastKey = CurTime()
        notice.respondToKeys = true
        function notice:Think()
            self:SetPos(ScrW() / 2 - self:GetWide() / 2, 4)
            if not self.respondToKeys then return end
            if self.opt1 and IsValid(self.opt1) then self.opt1:keyThink() end
            if self.opt2 and IsValid(self.opt2) then self.opt2:keyThink() end
        end
    end)
end)

netstream.Hook("charInfo", function(data, id, client) lia.char.loaded[id] = lia.char.new(data, id, client == nil and LocalPlayer() or client) end)
netstream.Hook("charKick", function(id, isCurrentChar) hook.Run("KickedFromChar", id, isCurrentChar) end)
netstream.Hook("gVar", function(key, value) lia.net.globals[key] = value end)
netstream.Hook("nDel", function(index) lia.net[index] = nil end)

-- ./gamemode/core/netcalls/server.lua
net.Receive("StringRequest", function(_, client)
    local id = net.ReadUInt(32)
    local value = net.ReadString()
    if client.liaStrReqs and client.liaStrReqs[id] then
        client.liaStrReqs[id](value)
        client.liaStrReqs[id] = nil
    end
end)

net.Receive("RequestDropdown", function(_, client)
    local selectedOption = net.ReadString()
    if client.dropdownCallback then
        client.dropdownCallback(selectedOption)
        client.dropdownCallback = nil
    end
end)

net.Receive("OptionsRequest", function(_, client)
    local selectedOptions = net.ReadTable()
    if client.optionsCallback then
        client.optionsCallback(selectedOptions)
        client.optionsCallback = nil
    end
end)

net.Receive("BinaryQuestionRequest", function(_, client)
    local choice = net.ReadUInt(1)
    if client.binaryQuestionCallback then
        local callback = client.binaryQuestionCallback
        callback(choice)
        client.binaryQuestionCallback = nil
    end
end)

net.Receive("liaTransferItem", function(_, client)
    local itemID = net.ReadUInt(32)
    local x = net.ReadUInt(32)
    local y = net.ReadUInt(32)
    local invID = net.ReadType()
    hook.Run("HandleItemTransferRequest", client, itemID, x, y, invID)
end)

netstream.Hook("invAct", function(client, action, item, _, data)
    local character = client:getChar()
    if not character then return end
    local entity
    if isentity(item) then
        if not IsValid(item) then return end
        if item:GetPos():Distance(client:GetPos()) > 96 then return end
        if not item.liaItemID then return end
        entity = item
        item = lia.item.instances[item.liaItemID]
    else
        item = lia.item.instances[item]
    end

    if not item then return end
    local inventory = lia.inventory.instances[item.invID]
    local context = {
        client = client,
        item = item,
        entity = entity,
        action = action
    }

    if inventory and not inventory:canAccess("item", context) then return end
    item:interact(action, client, entity, data)
end)

netstream.Hook("cmd", function(client, command, arguments)
    if (client.liaNextCmd or 0) < CurTime() then
        local arguments2 = {}
        for _, v in ipairs(arguments) do
            if isstring(v) or isnumber(v) then arguments2[#arguments2 + 1] = tostring(v) end
        end

        lia.command.parse(client, nil, command, arguments2)
        client.liaNextCmd = CurTime() + 0.2
    end
end)

netstream.Hook("liaCharFetchNames", function(client) netstream.Start(client, "liaCharFetchNames", lia.char.names) end)

-- ./gamemode/entities/entities/lia_item/cl_init.lua
local vectorMeta = FindMetaTable("Vector")
local toScreen = vectorMeta.ToScreen
function ENT:computeDescMarkup(description)
    if self.desc ~= description then
        self.desc = description
        self.markup = lia.markup.parse("<font=liaItemDescFont>" .. description .. "</font>", ScrW() * 0.5)
    end
    return self.markup
end

function ENT:onDrawEntityInfo(alpha)
    if IsValid(lia.gui.itemPanel) then return end
    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 200 * 200 then return end
    local item = self:getItemTable()
    if not item then return end
    local oldE, oldD = item.entity, item.data
    item.entity, item.data = self, self:getNetVar("data") or oldD
    local pos = toScreen(self:LocalToWorld(self:OBBCenter()))
    local x, y = pos.x, pos.y
    local name = L(item.getName and item:getName() or item.name)
    surface.SetFont("liaHugeText")
    local tw, th = surface.GetTextSize(name)
    draw.SimpleText(name, "liaHugeText", x, y, ColorAlpha(lia.config.get("Color"), alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    y = y + th + 80
    local desc = item:getDesc()
    self:computeDescMarkup("<font=liaMediumFont>" .. desc .. "</font>", tw)
    if self.markup then self.markup:draw(x - tw / 2, y, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, alpha) end
    hook.Run("DrawItemDescription", self, x, y, ColorAlpha(color_white, alpha), alpha)
    item.data, item.entity = oldD, oldE
end

function ENT:DrawTranslucent()
    local itemTable = self:getItemTable()
    if itemTable and itemTable.drawEntity then
        itemTable:drawEntity(self)
    else
        self:DrawModel()
    end
end

-- ./gamemode/entities/entities/lia_item/init.lua
function ENT:Initialize()
    self:SetModel("models/props_junk/watermelon01.mdl")
    self:SetSolid(SOLID_VPHYSICS)
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetCollisionGroup(COLLISION_GROUP_WEAPON)
    self.health = 250
    local physObj = self:GetPhysicsObject()
    if IsValid(physObj) then physObj:EnableMotion(false) end
    timer.Simple(3, function()
        if IsValid(physObj) then
            physObj:EnableMotion(true)
            physObj:Wake()
        end
    end)

    hook.Run("OnItemSpawned", self)
end

function ENT:setHealth(amount)
    self.health = amount
end

function ENT:OnTakeDamage(dmginfo)
    local damage = dmginfo:GetDamage()
    self:setHealth(self.health - damage)
    if self.health <= 0 and not self.breaking then
        self.breaking = true
        SafeRemoveEntity(self)
    end
end

function ENT:setItem(itemID)
    local itemTable = lia.item.instances[itemID]
    if not itemTable then return SafeRemoveEntity(self) end
    itemTable:sync()
    local model = hook.Run("getItemDropModel", itemTable, self) or itemTable:getModel() or itemTable.model
    self:SetModel(model)
    self:SetSkin(itemTable.skin or 0)
    self:SetMaterial(itemTable.material or "")
    self:SetColor(itemTable.color or color_white)
    if itemTable.bodygroups and istable(itemTable.bodygroups) then
        for k, v in pairs(itemTable.bodygroups) do
            local bodygroupID
            if isnumber(k) then
                bodygroupID = k
            elseif isstring(k) then
                bodygroupID = self:FindBodygroupByName(k)
            end

            if bodygroupID and bodygroupID >= 0 then self:SetBodygroup(bodygroupID, v) end
        end
    end

    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)
    self:setNetVar("id", itemTable.uniqueID)
    self:setNetVar("instanceID", itemTable.id)
    self.liaItemID = itemID
    if table.Count(itemTable.data) > 0 then self:setNetVar("data", itemTable.data) end
    local physObj = self:GetPhysicsObject()
    if not IsValid(physObj) then
        local min, max = Vector(-8, -8, -8), Vector(8, 8, 8)
        self:PhysicsInitBox(min, max)
        self:SetCollisionBounds(min, max)
    end

    if IsValid(physObj) then
        physObj:EnableMotion(true)
        physObj:Wake()
    end

    hook.Run("OnItemCreated", itemTable, self)
end

function ENT:breakEffects()
    self:EmitSound("physics/cardboard/cardboard_box_break" .. math.random(1, 3) .. ".wav")
    local position = self:LocalToWorld(self:OBBCenter())
    local effect = EffectData()
    effect:SetStart(position)
    effect:SetOrigin(position)
    effect:SetScale(3)
    util.Effect("GlassImpact", effect)
end

function ENT:OnRemove()
    local itemTable = self:getItemTable()
    if self.breaking then
        self:breakEffects()
        if itemTable and itemTable.onDestroyed then itemTable:onDestroyed(self) end
        self.breaking = false
    end

    if not lia.shuttingDown and not self.liaIsSafe and self.liaItemID then lia.item.deleteByID(self.liaItemID) end
end

function ENT:Think()
    local itemTable = self:getItemTable()
    if itemTable and itemTable.think then return itemTable:think(self) end
    self:NextThink(CurTime() + 1)
    return true
end


-- ./gamemode/entities/entities/lia_item/shared.lua
ENT.Base = "base_entity"
ENT.Type = "anim"
ENT.PrintName = "Item"
ENT.Category = "Lilia"
ENT.Spawnable = false
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.DrawEntityInfo = true
ENT.isItem = true
ENT.noTarget = true
ENT.Holdable = true
function ENT:getItemID()
    return self:getNetVar("instanceID")
end

function ENT:getItemTable()
    return lia.item.instances[self:getItemID()]
end

function ENT:getData(key, default)
    local data = self:getNetVar("data", {})
    if data[key] == nil then return default end
    return data[key]
end

-- ./gamemode/entities/entities/lia_money/cl_init.lua
local vectorMeta = FindMetaTable("Vector")
local toScreen = vectorMeta.ToScreen
function ENT:onDrawEntityInfo(alpha)
    local position = toScreen(self:LocalToWorld(self:OBBCenter()))
    local x, y = position.x, position.y
    local color = lia.config.get("Color")
    color.a = 255
    lia.util.drawText(lia.currency.get(self:getAmount()), x, y, color, 1, 1, nil, alpha * 0.65)
end


-- ./gamemode/entities/entities/lia_money/init.lua
function ENT:Initialize()
    self:SetModel(hook.Run("GetMoneyModel", self:getAmount()) or lia.config.get("MoneyModel"))
    self:SetSolid(SOLID_VPHYSICS)
    self:PhysicsInit(SOLID_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    local physObj = self:GetPhysicsObject()
    if IsValid(physObj) then
        physObj:EnableMotion(true)
        physObj:Wake()
    else
        local min, max = Vector(-8, -8, -8), Vector(8, 8, 8)
        self:PhysicsInitBox(min, max)
        self:SetCollisionBounds(min, max)
    end
end

function ENT:Use(activator)
    local character = activator:getChar()
    if not character then return end
    if self.client == activator and character:getID() ~= self.charID then
        activator:notifyLocalized("cantUseThisOnSameChar")
        return
    end

    if hook.Run("CanPickupMoney", activator, self) ~= false then
        activator:getChar():giveMoney(self:getAmount())
        hook.Run("OnPickupMoney", activator, self)
        SafeRemoveEntity(self)
    end
end

function ENT:setAmount(amount)
    self:setNetVar("amount", amount)
end


-- ./gamemode/entities/entities/lia_money/shared.lua
ENT.Type = "anim"
ENT.PrintName = "Money"
ENT.Category = "Lilia"
ENT.Spawnable = false
ENT.DrawEntityInfo = true
ENT.isMoney = true
ENT.noTarget = true
ENT.Holdable = true
function ENT:getAmount()
    return self:getNetVar("amount", 0)
end

-- ./gamemode/init.lua
DeriveGamemode("sandbox")
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
AddCSLuaFile("core/loader.lua")
include("shared.lua")
DeriveGamemode("sandbox")

-- ./gamemode/items/base/aid.lua
ITEM.name = "Aid Items"
ITEM.desc = "Heals you bruh."
ITEM.model = "models/weapons/w_package.mdl"
ITEM.width = 1
ITEM.height = 1
ITEM.health = 0
ITEM.functions.use = {
    name = L("use"),
    sound = "items/medshot4.wav",
    onRun = function(item)
        local client = item.player
        if IsValid(client) then
            local newHealth = math.min(client:Health() + item.health, client:GetMaxHealth())
            client:SetHealth(newHealth)
        end
    end
}

ITEM.functions.target = {
    name = L("itemUseOnTarget"),
    sound = "items/medshot4.wav",
    onRun = function(item)
        local client = item.player
        if IsValid(client) then
            local target = client:getTracedEntity()
            if IsValid(target) and target:IsPlayer() and target:Alive() then
                local newHealth = math.min(target:Health() + item.health, target:GetMaxHealth())
                target:SetHealth(newHealth)
            else
                client:notifyLocalized("invalidTargetNeedLiving")
            end
        end
    end,
    onCanRun = function(item)
        local client = item.player
        local target = client:getTracedEntity()
        return not IsValid(item.entity) and IsValid(target)
    end
}

-- ./gamemode/items/base/ammo.lua
ITEM.name = "Ammo Base"
ITEM.model = "models/props_c17/SuitCase001a.mdl"
ITEM.width = 1
ITEM.height = 1
ITEM.ammo = "pistol"
ITEM.category = "Ammunition"
ITEM.functions.use = {
    name = L("load"),
    tip = L("useTip"),
    icon = "icon16/add.png",
    isMulti = true,
    multiOptions = function(item)
        local options = {}
        table.insert(options, {
            name = L("ammoLoadAll"),
            data = 0,
        })

        for _, amount in pairs({5, 10, 30, 45, 90, 150, 300}) do
            if amount <= item:getQuantity() then
                table.insert(options, {
                    name = L("ammoLoadAmount", amount),
                    data = amount,
                })
            end
        end

        table.insert(options, {
            name = L("ammoLoadCustom"),
            data = -1,
        })
        return options
    end,
    onClick = function(_, data) if data == -1 then return false end end,
    onRun = function(item, data)
        data = data or 0
        if data > 0 then
            local num = tonumber(data)
            item:addQuantity(-num)
            item.player:GiveAmmo(num, item.ammo)
            item.player:EmitSound(item.useSound or "items/ammo_pickup.wav", 110)
        elseif data == 0 then
            item.player:GiveAmmo(item:getQuantity(), item.ammo)
            item.player:EmitSound(item.useSound or "items/ammo_pickup.wav", 110)
            return true
        end
        return item:getQuantity() <= 0
    end,
}

function ITEM:getDesc()
    return L("ammoDesc", self:getQuantity())
end

function ITEM:paintOver(item)
    local quantity = item:getQuantity()
    lia.util.drawText(quantity, 8, 5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, "liaChatFont")
end

-- ./gamemode/items/base/bags.lua
ITEM.name = "Bag"
ITEM.desc = "A bag to hold more items."
ITEM.model = "models/props_c17/suitcase001a.mdl"
ITEM.category = "Storage"
ITEM.isBag = true
ITEM.invWidth = 2
ITEM.invHeight = 2
ITEM.BagSound = {"physics/cardboard/cardboard_box_impact_soft2.wav", 50}
ITEM.pacData = {}
if CLIENT then
    function ITEM:paintOver(item, w, h)
        if item:getData("equip", false) then
            surface.SetDrawColor(110, 255, 110, 100)
            surface.DrawRect(w - 14, h - 14, 8, 8)
        end
    end
end

ITEM.functions.Equip = {
    name = L("equip"),
    icon = "icon16/tick.png",
    onRun = function(item)
        local client = item.player
        local items = client:getChar():getInv():getItems()
        for _, v in pairs(items) do
            if v.id ~= item.id and v.isBag and v:getData("equip") then
                client:notifyLocalized("bagAlreadyEquipped")
                return false
            end
        end

        if item.pacData and client.addPart then client:addPart(item.uniqueID) end
        item:setData("equip", true)
        return false
    end,
    onCanRun = function(item) if not IsValid(item.entity) then return not item:getData("equip", false) end end
}

ITEM.functions.Unequip = {
    name = L("unequip"),
    icon = "icon16/cross.png",
    onRun = function(item)
        local client = item.player
        if item.pacData and client.removePart then client:removePart(item.uniqueID) end
        item:setData("equip", false)
        return false
    end,
    onCanRun = function(item) if not IsValid(item.entity) then return item:getData("equip", false) end end
}

ITEM.functions.View = {
    name = L("view"),
    icon = "icon16/briefcase.png",
    onClick = function(item)
        local inventory = item:getInv()
        if not inventory then return false end
        local panel = lia.gui["inv" .. inventory:getID()]
        local parent = item.invID and lia.gui["inv" .. item.invID] or nil
        if IsValid(panel) then panel:Remove() end
        if inventory then
            local panel = lia.inventory.show(inventory, parent)
            if IsValid(panel) then
                panel:ShowCloseButton(true)
                panel:SetTitle(item:getName())
            end
        end
        return false
    end,
    onCanRun = function(item) if not IsValid(item.entity) and item:getInv() then return item:getData("equip", false) end end
}

function ITEM:onInstanced()
    local data = {
        item = self:getID(),
        w = self.invWidth,
        h = self.invHeight
    }

    lia.inventory.instance("grid", data):next(function(inventory)
        self:setData("id", inventory:getID())
        hook.Run("SetupBagInventoryAccessRules", inventory)
        inventory:sync()
        self:resolveInvAwaiters(inventory)
    end)
end

function ITEM:onRestored()
    local invID = self:getData("id")
    if invID then
        lia.inventory.loadByID(invID):next(function(inventory)
            hook.Run("SetupBagInventoryAccessRules", inventory)
            self:resolveInvAwaiters(inventory)
        end)
    end
end

function ITEM:onRemoved()
    local invID = self:getData("id")
    if invID then lia.inventory.deleteByID(invID) end
end

function ITEM:getInv()
    return lia.inventory.instances[self:getData("id")]
end

function ITEM:onSync(recipient)
    local inventory = self:getInv()
    if inventory then inventory:sync(recipient) end
end

function ITEM.postHooks:drop()
    local invID = self:getData("id")
    if invID then
        net.Start("liaInventoryDelete")
        net.WriteType(invID)
        net.Send(self.player)
    end
end

function ITEM:onCombine(other)
    local client = self.player
    local invID = self:getInv() and self:getInv():getID() or nil
    if not invID then return end
    local res = hook.Run("HandleItemTransferRequest", client, other:getID(), nil, nil, invID)
    if not res then return end
    res:next(function(res)
        if not IsValid(client) then return end
        if istable(res) and isstring(res.error) then return client:notifyLocalized(res.error) end
        client:EmitSound(unpack(self.BagSound))
    end)
end

if SERVER then
    function ITEM:onDisposed()
        local inventory = self:getInv()
        if inventory then inventory:destroy() end
    end

    function ITEM:resolveInvAwaiters(inventory)
        if self.awaitingInv then
            for _, d in ipairs(self.awaitingInv) do
                d:resolve(inventory)
            end

            self.awaitingInv = nil
        end
    end

    function ITEM:awaitInv()
        local d = deferred.new()
        local inventory = self:getInv()
        if inventory then
            d:resolve(inventory)
        else
            self.awaitingInv = self.awaitingInv or {}
            self.awaitingInv[#self.awaitingInv + 1] = d
        end
        return d
    end
end

-- ./gamemode/items/base/books.lua
ITEM.name = "Book Base"
ITEM.desc = "A book."
ITEM.category = "Literature"
ITEM.model = "models/props_lab/bindergraylabel01b.mdl"
ITEM.contents = ""
ITEM.functions.Read = {
    name = "read",
    onClick = function(item)
        local frame = vgui.Create("DFrame")
        frame:SetSize(540, 680)
        frame:SetTitle(item.name)
        frame:MakePopup()
        frame:Center()
        frame.html = frame:Add("DHTML")
        frame.html:Dock(FILL)
        frame.html:SetHTML([[<html><body style="background-color: #ECECEC; color: #282B2D; font-family: 'Book Antiqua', Palatino, 'Palatino Linotype', 'Palatino LT STD', Georgia, serif; font-size 16px; text-align: justify;">]] .. item.contents .. [[</body></html>]])
    end,
    onRun = function() return false end,
    icon = "icon16/book_open.png"
}


-- ./gamemode/items/base/entities.lua
ITEM.name = "Entities Base"
ITEM.model = ""
ITEM.desc = ""
ITEM.category = "Entities"
ITEM.entityid = ""
ITEM.functions.Place = {
    name = "placeDownEntity",
    onRun = function(item)
        local client = item.player
        local data = {}
        data.start = client:GetShootPos()
        data.endpos = data.start + client:GetAimVector() * 96
        data.filter = client
        local entity = ents.Create(item.entityid)
        entity:SetPos(data.endpos)
        entity:Spawn()
        local physObj = entity:GetPhysicsObject()
        if IsValid(physObj) then
            physObj:EnableMotion(true)
            physObj:Wake()
        end
        return true
    end,
    onCanRun = function(item) return not IsValid(item.entity) end
}


-- ./gamemode/items/base/grenade.lua
ITEM.name = "Grenade Base"
ITEM.desc = "Base item for grenades."
ITEM.category = "Grenades"
ITEM.model = "models/weapons/w_eq_fraggrenade.mdl"
ITEM.class = "weapon_frag"
ITEM.width = 1
ITEM.height = 1
ITEM.DropOnDeath = true
ITEM.functions.Use = {
    name = L("useGrenade"),
    icon = "icon16/tick.png",
    onRun = function(item)
        local client = item.player
        if client:hasRagdoll() then
            client:notifyLocalized("noRagdollAction")
            return false
        end

        if client:HasWeapon(item.class) then
            client:notifyLocalized("alreadyHaveGrenade")
            return false
        end

        client:Give(item.class)
        return true
    end,
}

-- ./gamemode/items/base/outfit.lua
ITEM.name = "Outfit"
ITEM.desc = "A Outfit Base."
ITEM.category = "Outfit"
ITEM.model = "models/props_c17/BriefCase001a.mdl"
ITEM.width = 1
ITEM.height = 1
ITEM.outfitCategory = "model"
ITEM.pacData = {}
ITEM.isOutfit = true
if CLIENT then
    function ITEM:paintOver(item, w, h)
        if item:getData("equip") then
            surface.SetDrawColor(110, 255, 110, 100)
            surface.DrawRect(w - 14, h - 14, 8, 8)
        end
    end
else
    ITEM.visualData = {
        model = {},
        skin = {},
        bodygroups = {}
    }
end

function ITEM:removeOutfit(client)
    local character = client:getChar()
    self:setData("equip", nil)
    if hook.Run("CanOutfitChangeModel", self) ~= false then
        character:setModel(self:getData("oldMdl", character:getModel()))
        self:setData("oldMdl", nil)
        client:SetSkin(self:getData("oldSkin", character:getData("skin", 0)))
        self:setData("oldSkin", nil)
        local oldGroups = character:getData("oldGroups", {})
        for k in pairs(self.bodyGroups or {}) do
            local index = client:FindBodygroupByName(k)
            if index > -1 then
                client:SetBodygroup(index, oldGroups[index] or 0)
                oldGroups[index] = nil
                local groups = character:getData("groups", {})
                if groups[index] then
                    groups[index] = nil
                    character:setData("groups", groups)
                end
            end
        end

        character:setData("oldGroups", oldGroups)
    end

    if self.pacData and client.removePart then client:removePart(self.uniqueID) end
    if self.attribBoosts then
        for k, _ in pairs(self.attribBoosts) do
            character:removeBoost(self.uniqueID, k)
        end
    end

    if isnumber(self.armor) then client:SetArmor(math.max(client:Armor() - self.armor, 0)) end
    self:getOwner():SetupHands()
    self:call("onTakeOff", client)
end

function ITEM:wearOutfit(client, isForLoadout)
    if isnumber(self.armor) then client:SetArmor(client:Armor() + self.armor) end
    if self.pacData and client.addPart then client:addPart(self.uniqueID) end
    self:getOwner():SetupHands()
    self:call("onWear", client, nil, isForLoadout)
end

ITEM.functions.EquipUn = {
    name = L("unequip"),
    tip = L("equipTip"),
    icon = "icon16/cross.png",
    onRun = function(item)
        item:removeOutfit(item.player)
        return false
    end,
    onCanRun = function(item) return not IsValid(item.entity) and item:getData("equip", false) end
}

ITEM.functions.Equip = {
    name = L("equip"),
    tip = L("equipTip"),
    icon = "icon16/tick.png",
    onRun = function(item)
        local character = item.player:getChar()
        local items = character:getInv():getItems()
        for _, other in pairs(items) do
            if item ~= other and item.outfitCategory == other.outfitCategory and other:getData("equip") then
                item.player:notifyLocalized("sameOutfitCategory")
                return false
            end
        end

        item:setData("equip", true)
        if hook.Run("CanOutfitChangeModel", item) ~= false then
            if isfunction(item.onGetReplacement) then
                character:setModel(item:onGetReplacement())
                item:setData("oldMdl", item.player:GetModel())
            elseif item.replacement or item.replacements then
                if istable(item.replacements) then
                    item:setData("oldMdl", item.player:GetModel())
                    if #item.replacements == 2 and isstring(item.replacements[1]) then
                        local newModel = item.player:GetModel():lower():gsub(item.replacement[1], item.replacements[2]):lower()
                        character:setModel(newModel)
                    else
                        for _, v in ipairs(item.replacements) do
                            character:setModel(item.player:GetModel():gsub(v[1], v[2]))
                        end
                    end
                else
                    item:setData("oldMdl", item.player:GetModel())
                    character:setModel(tostring(item.replacement or item.replacements))
                end
            end

            if isnumber(item.newSkin) then
                item:setData("oldSkin", item.player:GetSkin())
                character:setData("skin", item.newSkin)
                item.player:SetSkin(item.newSkin)
            end

            if istable(item.bodyGroups) then
                local oldGroups = character:getData("oldGroups", {})
                local groups = {}
                for k, value in pairs(item.bodyGroups) do
                    local index = item.player:FindBodygroupByName(k)
                    if index > -1 then
                        oldGroups[index] = item.player:GetBodygroup(index)
                        groups[index] = value
                    end
                end

                character:setData("oldGroups", oldGroups)
                item:setData("oldGroups", oldGroups)
                local newGroups = character:getData("groups", {})
                for index, value in pairs(groups) do
                    newGroups[index] = value
                    item.player:SetBodygroup(index, value)
                end

                if table.Count(newGroups) > 0 then character:setData("groups", newGroups) end
            end
        end

        if istable(item.attribBoosts) then
            for attribute, boost in pairs(item.attribBoosts) do
                character:addBoost(item.uniqueID, attribute, boost)
            end
        end

        item:wearOutfit(item.player, false)
        return false
    end,
    onCanRun = function(item) return not IsValid(item.entity) and item:getData("equip") ~= true end
}

function ITEM:OnCanBeTransfered(_, newInventory)
    if newInventory and self:getData("equip") then return false end
    return true
end

function ITEM:onLoadout()
    if self:getData("equip") then self:wearOutfit(self.player, true) end
end

function ITEM:onRemoved()
    if IsValid(receiver) and receiver:IsPlayer() and self:getData("equip") then self:removeOutfit(receiver) end
end

ITEM:hook("drop", function(item) if item:getData("equip") then item:removeOutfit(item.player) end end)

-- ./gamemode/items/base/pacoutfit.lua
if not pac then return end
ITEM.name = "PAC Outfit"
ITEM.desc = "A PAC Outfit Base."
ITEM.category = "Outfit"
ITEM.model = "models/Gibs/HGIBS.mdl"
ITEM.width = 1
ITEM.height = 1
ITEM.outfitCategory = "hat"
ITEM.pacData = {}
if CLIENT then
    function ITEM:paintOver(item, w, h)
        if item:getData("equip") then
            surface.SetDrawColor(110, 255, 110, 100)
            surface.DrawRect(w - 14, h - 14, 8, 8)
        end
    end
end

function ITEM:removePart(client)
    local char = client:getChar()
    self:setData("equip", false)
    if client.removePart then client:removePart(self.uniqueID) end
    if self.attribBoosts then
        for k, _ in pairs(self.attribBoosts) do
            char:removeBoost(self.uniqueID, k)
        end
    end
end

ITEM.functions.EquipUn = {
    name = L("unequip"),
    tip = L("equipTip"),
    icon = "icon16/cross.png",
    onRun = function(item)
        local client = item.player
        item:removePart(client)
        return false
    end,
    onCanRun = function(item) return not IsValid(item.entity) and item:getData("equip", false) end
}

ITEM.functions.Equip = {
    name = L("equip"),
    tip = L("equipTip"),
    icon = "icon16/tick.png",
    onRun = function(item)
        local client = item.player
        local char = client:getChar()
        local items = char:getInv():getItems()
        for _, v in pairs(items) do
            if v.id ~= item.id and v.pacData and v.outfitCategory == item.outfitCategory and v:getData("equip") then
                client:notifyLocalized("outfitTypeEquipAlready")
                return false
            end
        end

        item:setData("equip", true)
        if client.addPart then client:addPart(item.uniqueID) end
        if istable(item.attribBoosts) then
            for attribute, boost in pairs(item.attribBoosts) do
                char:addBoost(item.uniqueID, attribute, boost)
            end
        end
        return false
    end,
    onCanRun = function(item) return not IsValid(item.entity) and item:getData("equip") ~= true end
}

function ITEM:onCanBeTransfered(_, newInventory)
    if newInventory and self:getData("equip") then return false end
    return true
end

function ITEM:onLoadout()
    if self:getData("equip") and self.player.addPart then self.player:addPart(self.uniqueID) end
end

function ITEM:onRemoved()
    local inv = lia.item.inventories[self.invID]
    local receiver = inv.getReceiver and inv:getReceiver()
    if IsValid(receiver) and receiver:IsPlayer() and self:getData("equip") then self:removePart(receiver) end
end

ITEM:hook("drop", function(item)
    local client = item.player
    if item:getData("equip") then item:removePart(client) end
end)

-- ./gamemode/items/base/url.lua
ITEM.name = "Generic Item"
ITEM.desc = "Generic Description"
ITEM.model = "models/props_interiors/pot01a.mdl"
ITEM.url = ""
ITEM.functions.use = {
    name = L("open"),
    icon = "icon16/book_link.png",
    onRun = function()
        if CLIENT then gui.OpenURL(url) end
        return false
    end,
}

-- ./gamemode/items/base/weapons.lua
ITEM.name = "Weapon"
ITEM.desc = "A Weapon."
ITEM.category = L("weapons")
ITEM.model = "models/weapons/w_pistol.mdl"
ITEM.class = "weapon_pistol"
ITEM.width = 2
ITEM.height = 2
ITEM.isWeapon = true
ITEM.weaponCategory = "sidearm"
ITEM.RequiredSkillLevels = {}
ITEM.DropOnDeath = true
function ITEM.postHooks:drop()
    local client = self.player
    if client:HasWeapon(self.class) then
        client:notifyLocalized("invalidWeapon")
        client:StripWeapon(self.class)
    end
end

ITEM:hook("drop", function(item)
    local client = item.player
    if client:hasRagdoll() then
        client:notifyLocalized("noRagdollAction")
        return false
    end

    if item:getData("equip") then
        item:setData("equip", nil)
        client.carryWeapons = client.carryWeapons or {}
        local weapon = client.carryWeapons[item.weaponCategory]
        if IsValid(weapon) then
            item:setData("ammo", weapon:Clip1())
            client:StripWeapon(item.class)
            client.carryWeapons[item.weaponCategory] = nil
            client:EmitSound(item.unequipSound or "items/ammo_pickup.wav", 80)
        end
    end
end)

ITEM.functions.EquipUn = {
    name = L("unequip"),
    tip = L("equipTip"),
    icon = "icon16/cross.png",
    onRun = function(item)
        local client = item.player
        if client:hasRagdoll() then
            client:notifyLocalized("noRagdollAction")
            return false
        end

        client.carryWeapons = client.carryWeapons or {}
        local weapon = client.carryWeapons[item.weaponCategory]
        if not weapon or not IsValid(weapon) then weapon = client:GetWeapon(item.class) end
        if weapon and IsValid(weapon) then
            item:setData("ammo", weapon:Clip1())
            client:StripWeapon(item.class)
        else
            print(L("weaponDoesNotExist", item.class))
        end

        client:EmitSound(item.unequipSound or "items/ammo_pickup.wav", 80)
        client.carryWeapons[item.weaponCategory] = nil
        item:setData("equip", nil)
        if item.onUnequipWeapon then item:onUnequipWeapon(client, weapon) end
        return false
    end,
    onCanRun = function(item) return not IsValid(item.entity) and item:getData("equip", false) end
}

ITEM.functions.Equip = {
    name = L("equip"),
    tip = L("equipTip"),
    icon = "icon16/tick.png",
    onRun = function(item)
        local client = item.player
        if client:hasRagdoll() then
            client:notifyLocalized("noRagdollAction")
            return false
        end

        local items = client:getChar():getInv():getItems()
        client.carryWeapons = client.carryWeapons or {}
        for _, v in pairs(items) do
            if v.id ~= item.id and v.isWeapon and client.carryWeapons[item.weaponCategory] and v:getData("equip") then
                client:notifyLocalized("weaponSlotFilled")
                return false
            end
        end

        if client:HasWeapon(item.class) then client:StripWeapon(item.class) end
        local weapon = client:Give(item.class, true)
        if IsValid(weapon) then
            timer.Simple(0, function() client:SelectWeapon(weapon:GetClass()) end)
            client.carryWeapons[item.weaponCategory] = weapon
            client:EmitSound(item.equipSound or "items/ammo_pickup.wav", 80)
            local ammoCount = client:GetAmmoCount(weapon:GetPrimaryAmmoType())
            if ammoCount == weapon:Clip1() and item:getData("ammo", 0) == 0 then client:RemoveAmmo(weapon:Clip1(), weapon:GetPrimaryAmmoType()) end
            item:setData("equip", true)
            weapon:SetClip1(item:getData("ammo", 0))
            if item.onEquipWeapon then item:onEquipWeapon(client, weapon) end
        else
            print(L("weaponDoesNotExist", item.class))
        end
        return false
    end,
    onCanRun = function(item) return not IsValid(item.entity) and not item:getData("equip", false) end
}

function ITEM:OnCanBeTransfered(_, newInventory)
    if newInventory and self:getData("equip") then return false end
    return true
end

function ITEM:onLoadout()
    if self:getData("equip") then
        local client = self.player
        client.carryWeapons = client.carryWeapons or {}
        local weapon = client:Give(self.class, true)
        if IsValid(weapon) then
            client:RemoveAmmo(weapon:Clip1(), weapon:GetPrimaryAmmoType())
            client.carryWeapons[self.weaponCategory] = weapon
            weapon:SetClip1(self:getData("ammo", 0))
        else
            print(L("weaponDoesNotExist", self.class))
        end
    end
end

function ITEM:OnSave()
    local client = self.player
    local weapon = client:GetWeapon(self.class)
    if IsValid(weapon) then self:setData("ammo", weapon:Clip1()) end
end

if CLIENT then
    function ITEM:paintOver(item, w, h)
        if item:getData("equip") then
            surface.SetDrawColor(110, 255, 110, 100)
            surface.DrawRect(w - 14, h - 14, 8, 8)
        end
    end
end

-- ./gamemode/languages/english.lua
NAME = "English"
LANGUAGE = {
    mustProvideString = "Must Provide a String",
    use = "Use",
    modules = "Modules",
    faction = "Faction",
    none = "None",
    class = "Class",
    leave = "Leave",
    name = "Name",
    model = "Model",
    flag = "Flag",
    search = "Search...",
    storagelockDesc = "Lock or unlock the storage container youre looking at. Provide a password to set the lock, or run without a password to remove it.",
    trunkOpenDesc = "Open the vehicle trunk youre looking at to access its storage inventory.",
    ok = "ok",
    okay = "okay",
    noAccess = "No Access",
    mecloseDesc = "Displays a close-range emote action.",
    actionsDesc = "Displays a general action.",
    mefarDesc = "Displays a far-range emote action.",
    itcloseDesc = "Displays an in-character message at close range.",
    itfarDesc = "Displays an in-character message at far range.",
    coinflipDesc = "Flips a coin and displays the result.",
    icDesc = "Says something in-character.",
    meDesc = "Performs an emote action.",
    itDesc = "Displays an in-character descriptive message.",
    wDesc = "Whispers a message.",
    yDesc = "Yells a message.",
    loocDesc = "Out-of-character chat with a cooldown.",
    adminchatDesc = "Sends a message to admin chat.",
    rollDesc = "Rolls a dice and displays the result.",
    pmDesc = "Sends a private message to a specified player.",
    eventlocalDesc = "Sends a local event message (admin only).",
    eventDesc = "Sends an event message to everyone (admin only).",
    oocDesc = "Out-of-character chat for general discussion.",
    mesDesc = "Displays an action in possessive form.",
    mefarfarDesc = "Displays an exaggerated far-range action.",
    helpDesc = "Sends a help message to staff.",
    unnamed = "Unnamed",
    desc = "Description",
    isDefaultLabel = "Is Default",
    yes = "Yes",
    no = "No",
    baseHealth = "Base Health",
    vendorYourItems = "Your Items",
    vendorItems = "Vendor Items",
    vendorMoney = "Money",
    vendorSellScale = "Sell Scale",
    vendorItemCount = "Item Count",
    vendorEditorButton = "Edit Vendor",
    vendorShowAll = "Show All",
    vendorFree = "Free",
    vendorSellAction = "Sell (%s)",
    vendorBuyAction = "Buy (%s)",
    vendorEditor = "Vendor Editor",
    vendorEditorWelcomeMessage = "Welcome Message",
    vendorUseMoney = "Use Money",
    vendorFaction = "Faction Access",
    vendorMode = "Mode",
    vendorCategory = "Category",
    mode = "Trade Mode",
    moneyTaken = "You picked up %s.",
    forbiddenActionStorage = "You can't perform this action from storage.",
    playerCharBelonging = "This item belongs to another one of your characters.",
    cantDropBagHasEquipped = "You can't drop a bag with equipped items inside.",
    waitDrop = "You need to wait before dropping something again!",
    waitPickup = "You need to wait before picking something up again!",
    waitEquip = "You need to wait before equipping something again!",
    waitUnequip = "You need to wait before unequipping something again!",
    tooLongMessage = "Your message is too long and has not been sent.",
    criticalCondition = "Critical Condition",
    seriousInjury = "Serious Injury",
    moderateInjury = "Moderate Injury",
    minorInjury = "Minor Injury",
    healthyStatus = "Healthy",
    switchTo64Bit = "We recommend the use of the x86-64 Garry's Mod Branch for this server, consider swapping as soon as possible.",
    buyOnlynSell = "Buy and Sell",
    buyOnly = "Buy Only",
    sellOnly = "Sell Only",
    price = "Price",
    vendorPriceReq = "Set the item's price.",
    stock = "Stock",
    disable = "Disable Stock",
    edit = "Edit Max Stock",
    vendorStockReq = "Set max stock quantity.",
    vendorEditCurStock = "Edit Current Stock",
    vendorStockCurReq = "Set current stock quantity.",
    unassignedLabel = "Unassigned",
    playersOnline = "Players Online: %s",
    staffOnDuty = "Staff on Duty: %s",
    staffOnline = "Staff Online: %s",
    sbOptions = "Options for %s",
    selectFaction = "Select a faction",
    selectModel = "Select a model",
    factionDescription = "desc",
    noDesc = "No Description",
    modelLabel = "Model",
    requiredFieldError = "The field '%s' is required and cannot be empty.",
    baseArmor = "Base Armor",
    weapons = "Weapons",
    modelScale = "Model Scale",
    runSpeed = "Run Speed",
    walkSpeed = "Walk Speed",
    jumpPower = "Jump Power",
    status = "Status",
    bloodColor = "Blood Color",
    bloodNo = "No blood",
    bloodRed = "Red blood",
    bloodYellow = "Yellow blood",
    bloodGreenRed = "Green-red blood",
    bloodSparks = "Sparks",
    bloodAntlion = "Antlion yellow blood",
    bloodZombie = "Zombie green-red blood",
    bloodAntlionBright = "Antlion worker bright green blood",
    requirements = "Requirements",
    alreadyInClass = "You are already in this class",
    joinClass = "Join Class",
    classRequirementsNotMet = "You do not meet the class requirements or this class isn't default.",
    createCharacter = "Create Character",
    loadCharacter = "Load Character",
    discord = "Discord",
    steamWorkshop = "Steam Workshop",
    charDeletionCannotUndoned = "charDeletionCannotUndoned",
    cannotDeleteChar = "You cannot delete this character!",
    selectCharacter = "Select Character",
    alreadyUsingCharacter = "You are already using this character",
    bannedCharacter = "This character is banned",
    moneyLabel = "Money",
    alreadyHaveGrenade = "You already have this type of grenade.",
    generatedWeapon = "Generated weapon: %s",
    invalidFaction = "The specified faction is not valid.",
    submit = "Submit",
    cfgSet = "%s has set \"%s\" to %s.",
    create = "Create",
    invalid = "You have provided an invalid %s",
    descMinLen = "Your description must be at least %d character(s).",
    unknown = "Unknown",
    wakingUp = "Waking Up",
    unknownError = "An unknown error has occurred",
    author = "Author",
    version = "Version",
    damageInCarsDesc = "Whether or not you take damage while in cars",
    carEntryDelayEnabledDesc = "Whether or not you take damage while in cars",
    timeToEnterVehicleDesc = "Defines the time it takes to enter a vehicle.",
    simfphysEditPermission = "Allows access to Editing Simfphys Cars",
    needModel = "You need to select a model.",
    illegalAccess = "You are not whitelisted for this faction.",
    charNameExists = "A character with this name already exists.",
    fixInventoryError = "A server error occurred while loading your inventories. Check server log for details.",
    modelTooHigh = "%s too high",
    characterGeneric = "Character:",
    settings = "Settings",
    config = "Config",
    chat = "Chat",
    appearance = "Appearance",
    misc = "Miscellaneous",
    home = "Home",
    quickSettings = "Quick Settings",
    altLower = "Hide hands when lowered?",
    you = "You",
    flags = "Flags",
    help = "Help",
    searchAddons = "Search addons...",
    searchModules = "Search Modules...",
    searchEntities = "Search Entities...",
    searchOptions = "Search Options...",
    commands = "Commands",
    helpDefault = "Select a category",
    classes = "Classes",
    tooFar = "Too Far!",
    searchFlags = "Search Flags",
    searchCommands = "Search Commands",
    targetTooFar = "The target is too far away!",
    mustBeOnCharacter = "You must be on a character to use this.",
    lookToUseAt = "You need to be looking at someone to use '@'",
    plyNotValid = "You are not looking at a valid player.",
    commandCooldown = "This command is on cooldown!",
    commandCooldownTimed = "This command is on cooldown! Time remaining: %d seconds.",
    dbError = "Database connection failed",
    itemNoExist = "Sorry, the item that you requested does not exist.",
    cmdNoExist = "Sorry, that command does not exist.",
    plyNoExist = "Sorry, a matching player could not be found.",
    itemInfo = "Name: %s\nDescription: %s",
    itemCreated = "Item successfully created.",
    inv = "Inventory",
    drop = "Drop",
    dropTip = "Drops this item from your inventory.",
    take = "Take",
    takeTip = "Take this item and place it in your inventory.",
    canNotAfford = "You can not afford to purchase this.",
    notOwner = "You are not the owner of this.",
    invalidArg = "Invalid argument.",
    noFit = "This item can not fit in your inventory.",
    noOwner = "The owner is invalid.",
    invalidIndex = "The Item Index is Invalid.",
    invalidItem = "The Item Object is Invalid.",
    invalidInventory = "The Inventory Object is Invalid.",
    equippedBag = "Equipped items cannot be moved between inventories.",
    useTip = "Uses the item.",
    equipTip = "Equips the item.",
    unequipTip = "Unequips the item.",
    moneyLimit = "You've reached your money limit of %s%s. %s%s has been dropped.",
    playtimeYour = "Your playtime is %s hours, %s minutes, and %s seconds.",
    playtimeError = "Could not retrieve your playtime.",
    playtimeFor = "%s's playtime is %s hours, %s minutes, and %s seconds.",
    specifyPlayer = "Please specify a player.",
    targetNotFound = "Target player could not be found.",
    adminStickGetPlayTimeName = "Get Player Playtime",
    staffPermissionDenied = "You do not have permission to use this command.",
    staffRestrictedCommand = "You must be on duty or have bypass permissions to use this command.",
    displayStaffCommandsDesc = "Controls whether notifications and commands for staff are displayed.",
    adminOnlyNotificationDesc = "Restricts certain notifications to admins with specific permissions or those on duty.",
    samEnforceStaffDesc = "Determines whether staff enforcement for SAM commands is enabled",
    cleardecalsDesc = "Clears all decals (blood, bullet holes, etc.) for every player.",
    playtimeDesc = "Displays your total playtime on the server.",
    plygetplaytimeDesc = "Shows the total playtime of the specified character.",
    staffNotificationPermission = "Allows access to Seeing SAM Notifications Outside Staff Character.",
    bypassWhitelistPermission = "Allows staff to bypass the SAM command whitelist for the Staff Faction.",
    workshopDownloading = "Downloading workshop content...",
    workshopNoCollection = "No Collection Defined!",
    workshopAddons = "Addons",
    workshopCollectionPreviewTitle = "Workshop Collection Preview  Confirm You Are Using the Correct Collection",
    itemOnGround = "Your item has been placed on the ground.",
    fixpac_success = "PAC has been restarted and caches cleared.",
    pacenable_success = "PAC has been enabled.",
    pacdisable_message = "PAC has been disabled.",
    pacFixCommandDesc = "Clears PAC caches and restarts PAC to fix any outfit issues.",
    pacEnableCommandDesc = "Enables PAC (Player Appearance Customizer).",
    pacDisableCommandDesc = "Disables PAC (Player Appearance Customizer).",
    creating = "Your character is being created...",
    enteringVehicle = "Entering Vehicle...",
    carOccupiedNotice = "Someone is entering this car!",
    usingChar = "You are already using this character.",
    descChanged = "You have changed your character's description.",
    charMoney = "You currently have %s.",
    charFaction = "You are a member of the %s faction.",
    charClass = "You are %s of the faction.",
    charKick = "%s kicked character %s.",
    charBan = "%s banned the character %s.",
    charBanned = "This character is banned.",
    charUnBan = "%s has unbanned the character %s.",
    charNotBanned = "This character isn't banned!",
    limitFaction = "This faction is full. Try again later.",
    salary = "You have received %s from your salary.",
    locking = "Locking this entity...",
    unlocking = "Unlocking this entity...",
    notNow = "You are not allowed to do this right now.",
    areYouSure = "Are you sure?",
    banned = "Banned",
    descChangedTarget = "%s has changed %s's character description.",
    disconnect = "Disconnect",
    mapRepeat = "Pairing started. Use the command again to finish pairing.",
    mapAdd = "Scene added.",
    mapDel = "%d scenes removed.",
    gettingUp = "You are now getting up...",
    noPerm = "You are not allowed to do this.",
    chgName = "Change Name",
    chgNameDesc = "Enter the character's new name below.",
    whitelist = "%s has whitelisted %s for the %s faction.",
    unwhitelist = "%s has unwhitelisted %s from the %s faction.",
    load = "Load",
    equip = "Equip",
    unequip = "Unequip",
    view = "View",
    ["goto"] = "Go to",
    ["return"] = "Return",
    bagIntoBagError = "A bag cannot be placed into another bag.",
    nestedItemTransferError = "An item in the bag cannot be transferred.",
    freeze = "Freeze",
    bring = "Bring",
    oocDelay = "You must wait %s more second(s) before using OOC again.",
    loocDelay = "You must wait %s more second(s) before using LOOC again.",
    becomeClassFail = "Failed to become %s.",
    becomeClass = "You have become %s.",
    characters = "Characters",
    characterLabel = "Character",
    weaponSelector = "Weapon Selector",
    scoreboard = "Scoreboard",
    flagGive = "%s has given %s '%s' flags.",
    flagGiveTitle = "Give Flags",
    flagGiveDesc = "Give the following flags to the player.",
    flagTake = "%s has taken '%s' flags from %s.",
    flagTakeTitle = "Take Flags",
    flagTakeDesc = "Remove the following flags from the player.",
    flagNoMatch = "You must have \"%s\" Flag(s) to do this action.",
    spawnAdd = "You have added a spawn for the %s.",
    spawnDeleted = "You have removed %s spawn point(s).",
    spawnAdded = "You added spawn for %s.",
    attribSet = "You set %s's %s to %s.",
    attribUpdate = "You added %s's %s by %s.",
    toggleObserverTP = "Toggle Observer teleport",
    toggleESP = "Toggle Admin ESP",
    toggleESPAdvanced = "ESP Advanced Mode",
    Contact = "Contact",
    Purpose = "Purpose",
    Instructions = "Instructions",
    invertWeaponScroll = "Invert Weapon Scroll",
    invertWeaponScrollDesc = "Invert the weapon selection scroll direction",
    sbWidth = "Scoreboard Width",
    sbWidthDesc = "Scoreboard Width",
    sbHeight = "Scoreboard Height",
    sbHeightDesc = "Scoreboard Height",
    showStaff = "Show Staff in Scoreboard",
    showStaffDesc = "Should Staff Show In Scoreboard",
    displayServerName = "Display Server Name in Scoreboard",
    displayServerNameDesc = "Should Server Name Show In Scoreboard",
    useSolidBackground = "Use Solid Background in Scoreboard",
    useSolidBackgroundDesc = "Use a solid background for the scoreboard",
    scoreboardBackgroundColor = "Scoreboard Background Color",
    scoreboardBackgroundColorDesc = "Sets the background color of the scoreboard. This only applies if 'Use Solid Background' is enabled.",
    sbPing = "Ping: %s",
    thirdpersonToggle = "Toggle Thirdperson",
    thirdpersonClassic = "Use Classic Thirdperson",
    thirdpersonConfig = "Thirdperson Configuration",
    thirdPersonEnabled = "Enable Third-Person View",
    thirdPersonEnabledDesc = "Allows players to toggle third-person view on or off.",
    thirdPersonEnabledOption = "Third Person Enabled",
    thirdPersonEnabledOptionDesc = "Toggle third-person view.",
    thirdPersonClassicModeOption = "Third Person Classic Mode",
    thirdPersonClassicModeOptionDesc = "Enable classic third-person view mode.",
    thirdPersonHeightOption = "Third Person Height",
    thirdPersonHeightOptionDesc = "Adjust the vertical height of the third-person camera.",
    thirdPersonHorizontalOption = "Third Person Horizontal",
    thirdPersonHorizontalOptionDesc = "Adjust the horizontal offset of the third-person camera.",
    thirdPersonDistanceOption = "Third Person Distance",
    thirdPersonDistanceOptionDesc = "Adjust the camera distance in third-person view.",
    thirdPersonCategory = "Third Person",
    owner = "Owner",
    doorTitle = "Unowned Door",
    lockDoor = "Client [%s] %s locked door %s.",
    unlockDoor = "Client [%s] %s unlocked door %s.",
    toggleLock = "Client [%s] %s toggled door %s to %s.",
    doorTitleOwned = "Owned Door",
    doorIsNotOwnable = "This door cannot be owned.",
    doorIsOwnable = "You can purchase this door by pressing F2.",
    doorMadeUnownable = "This door is now unownable.",
    doorMadeOwnable = "This door is now ownable.",
    doorNotAllowedToOwn = "You are not allowed to own this door.",
    doorSetDisabled = "This door is now disabled.",
    doorSetNotDisabled = "This door is no longer disabled.",
    doorSetHidden = "This door is now hidden.",
    doorSetNotHidden = "This door is no longer hidden.",
    doorSetParentDoor = "This door has been set as the parent door.",
    doorCanNotSetAsChild = "The parent door cannot be set as a child.",
    doorAddChildDoor = "This door has been added as a child.",
    doorRemoveChildren = "All child doors have been removed.",
    doorRemoveChildDoor = "This door has been removed as a child.",
    doorNoParentDoor = "No parent door has been set.",
    doorOwnedBy = "This door is owned by %s.",
    doorConfigName = "Doors",
    doorSetFaction = "This door now belongs to the '%s' faction.",
    doorRemoveFaction = "This door no longer belongs to any faction.",
    doorSettings = "Door Settings",
    doorPurchased = "You have purchased this door for %s.",
    doorSold = "You have sold this door for %s.",
    doorNotValid = "You are not looking at a valid door.",
    doorNotOwner = "You do not own this door.",
    doorCanNotAfford = "You cannot afford this door.",
    doorAlreadyDisabled = "This door is already disabled.",
    doorAlreadyEnabled = "This door is already enabled.",
    doorToggleLocked = "The door has been %s.",
    doorSetTitle = "The door title has been set to '%s'.",
    invalidClass = "The specified class is not valid.",
    doorDisabled = "This door is disabled.",
    doorDisableAll = "All doors have been disabled (%d total).",
    doorEnableAll = "All doors have been enabled (%d total).",
    doorForceLock = "The door has been forcibly locked.",
    doorForceUnlock = "The door has been forcibly unlocked.",
    doorSetClass = "This door now belongs to the '%s' class.",
    doorRemoveClass = "This door no longer belongs to any class.",
    doorSaveData = "Door data has been saved.",
    doorLogSetClass = "Client [%s] %s set door class to %s on door %s.",
    doorLogRemoveClass = "Client [%s] %s removed door class from door %s.",
    doorLogSaveData = "Client [%s] %s saved door data on door %s.",
    doorLogToggleOwnable = "Client [%s] %s set door %s to %s.",
    doorLogSetFaction = "Client [%s] %s set door faction to %s on door %s.",
    doorLogRemoveFaction = "Client [%s] %s removed door faction %s from door %s.",
    doorLogSetHidden = "Client [%s] %s set door %s to %s.",
    doorLogSetTitle = "Client [%s] %s set door title to '%s' on door %s.",
    doorLogResetData = "Client [%s] %s reset door data on door %s.",
    doorLogSetParent = "Client [%s] %s set door parent for door %s.",
    doorLogAddChild = "Client [%s] %s added child door %s to parent door %s.",
    doorLogRemoveChild = "Client [%s] %s removed child door %s from parent door %s.",
    doorLogForceLock = "Client [%s] %s forcibly locked door %s.",
    doorLogForceUnlock = "Client [%s] %s forcibly unlocked door %s.",
    doorLogDisable = "Client [%s] %s disabled door %s.",
    doorLogEnable = "Client [%s] %s enabled door %s.",
    doorLogDisableAll = "Client [%s] %s disabled all doors (%d total).",
    doorLogEnableAll = "Client [%s] %s enabled all doors (%d total).",
    locked = "Locked",
    unlocked = "Unlocked",
    priceLabel = "Price: %s",
    doorAccess = "Access",
    tenant = "Tenant",
    guest = "Guest",
    doorSell = "Sell",
    doorFactions = "Factions:",
    doorAddFaction = "Add Faction to Door",
    doorRemoveFactionAdmin = "Remove Faction from Door",
    doorNoFactions = "No factions assigned to this door",
    doorSetDoorClass = "Set Door Class",
    doorRemoveDoorClass = "Remove Class",
    doorLockTime = "Door Lock Time",
    doorLockTimeDesc = "Time it takes to lock a door",
    doorSellRatio = "Door Sell Ratio",
    doorSellRatioDesc = "Percentage you can sell a door for",
    recognize = "Allow this character to recognize you.",
    recognized = "You gave this character your identity.",
    recognizeInWhisperRange = "Recognize in Whisper Range",
    recognizeInTalkRange = "Recognize in Talk Range",
    recognizeInYellRange = "Recognize in Yell Range",
    recognizeOption = "Recognize",
    recognizeWithFakeNameOption = "Recognize With Fake Name",
    recogMenuOptionWhisper = "Recognize in Whisper Range",
    recogMenuOptionTalk = "Recognize in Talk Range",
    recogMenuOptionYell = "Recognize in Yell Range",
    recogFakeNamePrompt = "Enter fake name",
    recogMenuOptionFakeWhisper = "Fake Whisper",
    recogMenuOptionFakeTalk = "Fake Talk",
    recogMenuOptionFakeYell = "Fake Yell",
    already_recognized = "This character already knows you.",
    noRecog = "You do not recognize this person.",
    someone = "Someone",
    giveForward = "Give Forward",
    options = "Options",
    tableListDefaultTitle = "Table List",
    copyRow = "Copy Row",
    keybinds = "Keybinds",
    itemUse = "Use",
    itemUseOnTarget = "Use on Target",
    invalidTargetNeedLiving = "You must be looking at a valid, living player to use this.",
    ammoLoadAll = "Load All",
    ammoLoadCustom = "Custom Amount",
    ammoLoadAmount = "Load %s",
    ammoDesc = "Remaining: %s",
    bagAlreadyEquipped = "You already have a bag equipped.",
    read = "Read",
    placeDownEntity = "Place Down Entity",
    useGrenade = "Use Grenade",
    noRagdollAction = "You cannot do that while ragdolled.",
    sameOutfitCategory = "You are already wearing something in this outfit category.",
    open = "Open",
    outfitTypeEquipAlready = "You are already wearing an item of this type.",
    weaponDoesNotExist = "Weapon '%s' does not exist",
    invalidWeapon = "You cannot drop this weapon while it's equipped.",
    weaponSlotFilled = "You already have a weapon equipped in that slot.",
    invalidDate = "Invalid date",
    invalidInput = "Invalid input",
    secondsAgo = "%s seconds ago",
    minutesAgo = "%s minutes ago",
    hoursAgo = "%s hours ago",
    daysAgo = "%s days ago",
    weekdaySunday = "Sunday",
    weekdayMonday = "Monday",
    weekdayTuesday = "Tuesday",
    weekdayWednesday = "Wednesday",
    weekdayThursday = "Thursday",
    weekdayFriday = "Friday",
    weekdaySaturday = "Saturday",
    monthJanuary = "January",
    monthFebruary = "February",
    monthMarch = "March",
    monthApril = "April",
    monthMay = "May",
    monthJune = "June",
    monthJuly = "July",
    monthAugust = "August",
    monthSeptember = "September",
    monthOctober = "October",
    monthNovember = "November",
    monthDecember = "December",
    anonymous = "Anonymous",
    resetAllKeybinds = "Reset All Keybinds",
    giveForwardTip = "Directly give the item to the person in front of you",
    flagSpawnVehicles = "Spawn vehicles.",
    flagSpawnSweps = "Spawn SWEPS.",
    flagSpawnSents = "Spawn SENTs.",
    flagSpawnEffects = "Spawn Effects.",
    flagSpawnRagdolls = "Spawn ragdolls.",
    flagSpawnProps = "Spawn props.",
    flagSpawnNpcs = "Spawn NPCs.",
    flagPhysgun = "Gives Acess to Physgun.",
    flagToolgun = "Gives Acess to Toolgun",
    classNoInfo = "Class information not found.",
    classWrongTeam = "You are not in the correct team to join this class.",
    classAlreadyIn = "You are already in this class.",
    classFull = "This class is currently full.",
    classInvalidFaction = "Class '%s' does not have a valid faction!",
    someoneUnrecognized = "Someone you don't recognize",
    pktoggle_true = "You have toggled this character's PK State to True. They will be PK'ed the next time they die!",
    pktoggle_false = "You have toggled this character's PK State to False.",
    charPK_target_not_found = "Target player not found or they do not have an active character.",
    charPK_success_admin = "You have permanently killed %s's character.",
    charPK_success_target = "Your character has been permanently killed by %s.",
    storPass = "You've set this storage's password to %s.",
    storPassRmv = "You've removed this storage's password.",
    storPassWrite = "Enter the password.",
    wrongPassword = "You've entered the wrong password.",
    notLookingAtVehicle = "You're not looking at any vehicle!",
    tooFarToOpenTrunk = "You're too far to open the trunk!",
    openingTrunk = "Opening...",
    unauthorizedNetMessage = "Unauthorized use of net message: %s",
    unprotectedVJNetCallLog = "[%s] %s triggered unprotected net message '%s'",
    logCategoryVJNet = "VJ Base",
    logTypeUnprotectedVJNetCall = "Unprotected VJ Net Call",
    DisplayStaffCommands = "Display Staff Commands",
    DisplayStaffCommandsDesc = "Controls whether notifications and commands for staff are displayed.",
    AdminOnlyNotification = "Admin Only Notifications",
    AdminOnlyNotificationDesc = "Restricts certain notifications to admins with specific permissions or those on duty.",
    StaffCategory = "Staff",
    ProtectionCategory = "Protection",
    playerNotFound = "Player not found.",
    playtimeTargetError = "Could not retrieve playtime for the specified target.",
    adminStickCategoryModeration = "Moderation Tools",
    pmsDisabled = "Private Messages are Disabled",
    adminStickSubCategoryMisc = "Miscellaneous",
    vehicleLocked = "This vehicle is locked!",
    someoneEnteringCar = "Someone is entering this car!",
    configDamageInCars = "Take Damage in Cars",
    configDamageInCarsDesc = "Whether or not you take damage while in cars",
    vendorWelcomeMessage = "Default Vendor Welcome Message",
    vendorNoTrade = "You are not able to trade with this vendor.",
    vendorNoMoney = "This vendor cannot afford that item.",
    vendorNoStock = "This vendor does not have that item in stock.",
    vendorWelcome = "Welcome to my store, what can I get you today?",
    vendorNoSellItems = "There are no items available for sale.",
    vendorNoBuyItems = "There are no items available for purchase.",
    vendorSettings = "Vendor Settings",
    vendorTradeRestrictedFlag = "You do not have the required permissions to trade this item.",
    vendorYouSoldItem = "You sold %s for %s.",
    vendorYouBoughtItem = "You bought %s for %s.",
    vendorSteamIDWhitelist = "You are not whitelisted via SteamID.",
    vendorFactionWhitelist = "You are not whitelisted for this faction.",
    vendorUserGroupWhitelist = "You are not whitelisted for this user group.",
    vendorVIPOnly = "This item is available for VIPs only.",
    vendorNotWhitelisted = "You are not whitelisted to trade this item.",
    vendorError = "An error occurred during the transaction.",
    vendorMaxStock = "Maximum Stock",
    vendorBye = "Come again soon!",
    vendorChangePlayermodel = "Change Playermodel",
    vendorShowCategories = "Show Categories",
    vendorHideCategories = "Hide Categories",
    vendorFactionLabel = "Faction:",
    vendorYourItemCount = "Your Items: %d %s",
    vendorDoesNotHaveItem = "The vendor does not have this item.",
    vendorSellOnly = "This vendor only allows selling this item.",
    vendorPlayerDoesNotHaveItem = "You do not have this item.",
    vendorNoInventorySpace = "You don't have enough space for this item!",
    vendorRestocked = "The vendor has been restocked.",
    NotLookingAtValidVendor = "You are not looking at a valid vendor.",
    vendorAllVendorsRestocked = "All vendors have been restocked. Total vendors restocked: %d.",
    vendorInvalidAmount = "Invalid amount specified.",
    vendorAllMoneyReset = "All vendors' money has been reset to %s. Total vendors updated: %d.",
    vendorMoneyRestocked = "Vendor's money has been restocked to %s.",
    vendorNoMoneyVariable = "This vendor does not have a money variable.",
    vendorDataSaved = "All vendor data has been saved.",
    vendorInvalidItem = "Invalid item.",
    vendorCanNotAfford = "You cannot afford that item.",
    vendorLogAccess = "[%s] %s accessed vendor %s [CharID: %s]",
    vendorLogExit = "[%s] %s exited vendor %s [CharID: %s]",
    vendorLogSell = "[%s] %s sold a %s to %s [CharID: %s]",
    vendorLogEdit = "[%s] %s edited vendor %s with key %s [CharID: %s]",
    vendorLogBuySuccess = "[%s] %s bought a %s from %s [CharID: %s]",
    vendorLogBuyFail = "[%s] %s tried to buy a %s from %s but it failed. They likely had no space! [CharID: %s]",
    respawnKey = "Press %s to respawn",
    respawnIn = "You can respawn in %s",
    youHaveDied = "You have died",
    factionStaffName = "Staff on Duty",
    factionStaffDesc = "The Staff",
    cleaningFinished = "You cleaned up %s: %s entities removed.",
    noMoreThan3Money = "You can't drop more than 3 pieces of money at a time.",
    invalidTarget = "Invalid Target!",
    noRagdoll = "You don't have a ragdoll to get up from!",
    invCheckSelf = "This isn't meant for checking your own inventory.",
    noValidPlayers = "No valid players found!",
    noOnDutyStaff = "No on-duty staff members found!",
    noBodygroups = "No bodygroups available for this model.",
    mustSpecifyItem = "You must specify an item to give.",
    freezeAllProps = "You have frozen all of %s's Entities.",
    freezeAllPropsCount = "Frozen %s Entities belonging to %s.",
    enterNewDesc = "Enter new description",
    mustSpecifySound = "You must specify a sound to play.",
    invalidTargetOrSound = "Invalid target or sound.",
    waitRespawn = "Wait until you respawn.",
    noDeathPosition = "No death position saved.",
    death = "Death",
    money_model = "Money Model",
    money_model_desc = "Defines the model used for representing money in the game.",
    money_limit = "Money Limit",
    money_limit_desc = "Sets the limit of money a player can have [0 for infinite].",
    currency_symbol = "Currency Symbol",
    currency_symbol_desc = "Specifies the currency symbol used in the game.",
    currency_singular_name = "Currency Singular Name",
    currency_singular_name_desc = "Singular name of the in-game currency.",
    currency_plural_name = "Currency Plural Name",
    currency_plural_name_desc = "Plural name of the in-game currency.",
    money_category = "Money",
    inventory_width = "Inventory Width",
    inventory_width_desc = "Defines the width of the default inventory.",
    inventory_height = "Inventory Height",
    inventory_height_desc = "Defines the height of the default inventory.",
    walkSpeedDesc = "Sets the walking speed for players.",
    walk_ratio = "Walk Ratio",
    walk_ratio_desc = "Defines the walk speed ratio when holding the Alt key.",
    allow_duplicate_names = "Allow Duplicate Names",
    allow_duplicate_names_desc = "Determines whether duplicate character names are allowed.",
    max_characters = "Max Characters",
    max_characters_desc = "Sets the maximum number of characters a player can have.",
    min_desc_length = "Minimum Description Length",
    min_desc_length_desc = "Minimum length required for a character's description.",
    save_interval = "Save Interval",
    save_interval_desc = "Interval for character saves in seconds.",
    default_money = "Default Money",
    start = "Start",
    default_money_desc = "Specifies the default amount of money a player starts with.",
    data_save_interval = "Data Save Interval",
    data_save_interval_desc = "Time interval between data saves.",
    character_data_save_interval = "Character Data Save Interval",
    character_data_save_interval_desc = "Time interval between character data saves.",
    spawn_time = "Respawn Time",
    spawn_time_desc = "Time to respawn after death.",
    font = "Font",
    fontDesc = "Specifies the main font used for UI elements.",
    generic_font = "Generic Font",
    generic_font_desc = "Specifies the secondary font used for UI elements.",
    max_chat_length = "Max Chat Length",
    max_chat_length_desc = "Sets the maximum length of chat messages.",
    schema_year = "Schema Year",
    schema_year_desc = "Year of the gamemode's schema.",
    american_dates = "American Dates",
    american_dates_desc = "Determines whether to use the American date format.",
    american_timestamp = "American Timestamp",
    american_timestamp_desc = "Determines whether to use the American timestamp format.",
    admin_console_network_logs = "Admin Console Network Logs",
    admin_console_network_logs_desc = "Specifies if the logging system should replicate to admins' consoles.",
    theme_color = "Theme Color",
    theme_color_desc = "Sets the theme color used throughout the gamemode.",
    auto_download_workshop = "Auto Download Workshop Content",
    auto_download_workshop_desc = "Determines whether Workshop content is automatically downloaded by the server and clients.",
    character = "Character",
    visuals = "Visuals",
    server = "Server",
    staff = "Staff",
    data = "Data",
    invalidAmount = "Invalid amount.",
    noMoney = "You don't have enough money.",
    needLookAt = "You need to be looking at someone!",
    cmdCooldown = "This Command Is In Cooldown!",
    cmdFrozen = "You cannot use this while frozen!",
    cmdDead = "You cannot use this while dead!",
    cmdVehicle = "You cannot use this as you are in a vehicle!",
    cmdNoclip = "You cannot use this while in noclip!",
    moneyCooldown = "You can't use this command yet. Cooldown remaining: %s seconds.",
    lackFunds = "You lack the funds for this!",
    resetInv = "You have cleared %s's inventory!",
    searchingChar = "Searching for character...",
    noAvailableFlags = "No available flags to give.",
    gaveAllFlags = "You gave this player all flags!",
    tookAllFlags = "You took this player's flags!",
    itemGiven = "You gave the item to %s: %s",
    charInvEmpty = "Character Inventory is empty.",
    changedScale = "You changed %s's model scale to %s.",
    changedJump = "You changed %s's jump power to %s.",
    setMoney = "You set %s's money to %s.",
    addMoney = "You gave %s an additional %s. Total: %s",
    noMessage = "You must specify a message.",
    needBotAndMessage = "You must specify a bot and a message.",
    botNotFound = "No bot found with the name: %s",
    givenMoneyTarget = "You were given %s by %s",
    givenMoneyClient = "You gave %s to %s",
    changeModel = "%s changed %s's model to %s.",
    changeName = "%s changed %s's name to %s.",
    changeSkin = "%s changed %s's skin to %s.",
    changeBodygroups = "%s changed %s's \"%s\" bodygroup to %s.",
    exploitDropWarning = "Player %s attempted to drop more than 3 pieces of money. Potential exploit!",
    adminStickCheckInventoryName = "Check Inventory",
    adminStickChangeName = "Change Name",
    doorsellDesc = "Sell a door you own and receive a refund based on the door's price.",
    admindoorsellDesc = "Admin command to sell a door on behalf of its owner and refund the owner.",
    doortogglelockDesc = "Toggle a door's lock state between locked and unlocked.",
    doorbuyDesc = "Purchase a door if it is available and you can afford it.",
    doortoggleownableDesc = "Toggle whether a door can be owned by players.",
    doorresetdataDesc = "Reset door data to default settings.",
    doortoggleenabledDesc = "Toggle door enabled state (active/inactive).",
    doortogglehiddenDesc = "Toggle the hidden state of a door.",
    doorsetpriceDesc = "Set the price for a door.",
    doorsettitleDesc = "Set the title for a door.",
    doorsetparentDesc = "Designate the targeted door as a parent door for grouping child doors.",
    doorsetchildDesc = "Set the targeted door as a child of the designated parent door.",
    doorremovechildDesc = "Remove a door from its parent or remove all child associations if it's a parent.",
    savedoorsDesc = "Save door data persistently.",
    doorinfoDesc = "Display information about the targeted door.",
    dooraddfactionDesc = "Add a faction restriction to a door, allowing only specific factions to access it.",
    doorremovefactionDesc = "Remove a faction restriction from a door, or clear all restrictions.",
    doorsetclassDesc = "Set a class (job) restriction for a door.",
    togglealldoorsDesc = "Toggle the enabled state for all doors in the map.",
    adminStickClearInventoryName = "Clear Inventory",
    adminStickKickCharacterName = "Kick Character",
    adminStickBanCharacterName = "Ban Character",
    adminStickCategoryCharManagement = "Character Management",
    adminStickSubCategoryItems = "Items",
    adminStickSubCategoryBans = "Bans",
    adminStickCategoryPlayerInfos = "Player Information",
    adminStickSubCategoryGetInfos = "Get Information",
    adminStickSubCategorySetInfos = "Set Information",
    adminStickSetCharSpeedName = "Set Character Speed",
    adminStickSetCharModelName = "Set Character Model",
    adminStickGiveItemName = "Give Item",
    adminStickSetCharDescName = "Set Character Description",
    adminStickSetCharNameName = "Set Character Name",
    adminStickSetCharScaleName = "Set Character Scale",
    adminStickSetCharJumpName = "Set Character Jump Height",
    adminStickTakeAllFlagsName = "Take All Flags",
    adminStickGiveAllFlagsName = "Give All Flags",
    adminStickCheckMoneyName = "Check Money",
    adminStickGetCharFlagsName = "Get Character Flags",
    uiItemList = "Item List",
    uiModulesList = "Modules List",
    uiEntityList = "Entity List",
    uiStaffList = "Staff List",
    uiOnDutyStaffFlags = "On Duty Staff Flags",
    uiOnDutyStaffList = "On Duty Staff List",
    uiVIPList = "VIP List",
    uiUserList = "User List",
    uiBodygroupsFor = "Bodygroups for %s",
    groupID = "Group ID",
    range = "Range",
    characterID = "Character ID",
    usergroup = "Usergroup",
    playerMoney = "%s has %s",
    adminStickGetCharModelName = "Get Character Model",
    adminStickGetCharNameName = "Get Character Name",
    adminStickGetCharHealthName = "Get Character Health",
    adminStickGetCharMoneyName = "Get Character Money",
    adminStickGetCharInventoryName = "Get Character Inventory",
    sendToSitRoom = "Send To Sit Room",
    cancel = "Cancel",
    reason = "Reason",
    reasonFor = "Reason for %s",
    lengthInDays = "Length In Days",
    SalaryInterval = "Salary Interval",
    SalaryIntervalDesc = "Interval in seconds between salary payouts.",
    SalaryThreshold = "Salary Threshold",
    SalaryThresholdDesc = "Money threshold above which salaries will not be given.",
    SalaryLimitReached = "Your salary could not be paid because you've reached the maximum balance.",
    PKWorldTitle = "Dying from the world affects your PK status",
    PKWorldDesc = "When marked for Perma Kill, do deaths caused by the world count as a perma kill?",
    RecognitionEnabled = "Character Recognition Enabled",
    RecognitionEnabledDesc = "Whether or not character recognition is enabled?",
    FakeNamesEnabled = "Fake Names Enabled",
    FakeNamesEnabledDesc = "Are fake names enabled?",
    Endurance = "Endurance",
    EnduranceDesc = "A measure of stamina and resilience, affecting physical endurance and fatigue resistance.",
    Stamina = "Stamina",
    StaminaDesc = "A measure of endurance and energy, affecting fatigue resistance and physical activity.",
    Strength = "Strength",
    StrengthDesc = "A measure of physical power, affecting melee damage and carrying capacity.",
    invalidAttributeKey = "Invalid attribute key.",
    characterNotFound = "Character not found.",
    attribNonNegative = "Attribute value must be non-negative.",
    attribPositive = "Attribute value to add must be positive.",
    attribCalculationError = "Error: Invalid attribute value calculated.",
    invalidMode = "Invalid mode selected.",
    yourAttributeSet = "Your attribute '%s' has been set to %s by %s.",
    yourAttributeIncreased = "Your attribute '%s' has been increased by %s by %s.",
    staminaBlur = "Stamina Blur Enabled",
    staminaBlurDesc = "Is Stamina Blur Enabled?",
    staminaSlowdown = "Stamina Slowdown Enabled",
    staminaSlowdownDesc = "Is Stamina Slowdown Enabled?",
    defaultStamina = "Default Stamina Value",
    defaultStaminaDesc = "Sets Default Stamina Value",
    staminaBlurThreshold = "Stamina Blur Threshold",
    staminaBlurThresholdDesc = "Sets Stamina Threshold for Blur to Show",
    staminaBreathingThreshold = "Stamina Breathing Threshold",
    staminaBreathingThresholdDesc = "Sets Stamina Threshold for Breathing to Happen",
    maxAttributePoints = "Max Attribute Points",
    maxAttributePointsDesc = "Maximum number of points that can be allocated across an attribute.",
    maxStartingAttributes = "Max Starting Attributes",
    maxStartingAttributesDesc = "Maximum value of each attribute at character creation.",
    startingAttributePoints = "Starting Attribute Points",
    startingAttributePointsDesc = "Total number of points available for starting attribute allocation.",
    punchStamina = "Punch Stamina",
    punchStaminaDesc = "Stamina usage for punches.",
    attributes = "Attributes",
    setAttributes = "Set Attributes",
    characterManagement = "Character Management",
    checkAttributes = "Check Attributes",
    attributeName = "Attribute Name",
    currentValue = "Current Value",
    maxValue = "Max Value",
    progress = "Progress",
    changeAttribute = "Change Attribute",
    add = "Add",
    set = "Set",
    addAttributes = "Add Attributes",
    changeToWhisper = "Change voice mode to Whispering range.",
    changeToTalk = "Change voice mode to Talking range.",
    changeToYell = "Change voice mode to Yelling range.",
    voiceModeWhisper = "You have changed your voice mode to Whispering!",
    voiceModeTalk = "You have changed your voice mode to Talking!",
    voiceModeYell = "You have changed your voice mode to Yelling!",
    toggleVoice = "Toggle Voice",
    moderationTools = "Moderation Tools",
    miscellaneous = "Miscellaneous",
    changePlayerModel = "Change Playermodel",
    cannotMuteSelf = "You cannot toggle mute on yourself.",
    voiceUnmuted = "You have unmuted %s.",
    voiceUnmutedByAdmin = "You have been unmuted by an admin.",
    voiceMuted = "You have muted %s.",
    voiceMutedByAdmin = "You have been muted by an admin.",
    noValidCharacter = "The target does not have a valid character.",
    permanentClasses = "Permanent Classes",
    permanentClassesDesc = "Whether or not classes are saved in characters.",
    displayClasses = "Display Classes on Characters",
    displayClassesDesc = "Whether or not classes are displayed on characters.",
    generalInfo = "General Info",
    invalidClassError = "[Error] Invalid class '%s' provided for client.",
    charAlreadyInFaction = "This player already has another character in this faction!",
    undefinedClass = "Undefined Class",
    classListTitle = "Classes List",
    factionListTitle = "Factions List",
    intoxicatedStatus = "This Person Is Heavily Intoxicated",
    drunkness = "Drunkness",
    bodygroupMenuTitle = "Bodygroup Menu",
    rotateInstruction = "[%s] Rotate Left | [%s] Rotate Right",
    bodygroups = "Bodygroups",
    noBodygroupsnSkins = "This model has no manipulatable bodygroups or skins!",
    bodygroupChanged = "You have changed %s bodygroups and/or skin.",
    bodygroupChangedBy = "%s has changed your bodygroups and/or skin.",
    invalidSkin = "Invalid skin!",
    invalidBodygroup = "Invalid bodygroup!",
    color = "Color",
    classBroadcastNoPermission = "You don't have permission to use this!",
    classBroadcastNoValidClasses = "No valid classes selected",
    classBroadcastSent = "Broadcast sent.",
    factionBroadcastNoPermission = "You don't have permission to use this!",
    factionBroadcastNoValidFactions = "No valid factions selected",
    factionBroadcastSent = "Broadcast sent.",
    selectClassesPrompt = "Select classes to broadcast to:",
    selectFactionsPrompt = "Select factions to broadcast to:",
    classBroadcastTitle = "Class Broadcast",
    sendCaptionDesc = "Sends a caption message to a specific player for a set duration.",
    broadcastCaptionDesc = "Broadcasts a caption message to all players for a set duration.",
    sendCaptionError = "You must provide a valid player and caption text.",
    broadcastCaptionError = "You must provide a caption text.",
    factionBroadcastTitle = "Faction Broadcast",
    factionBroadcastLabel = "[Faction Broadcast]",
    classBroadcastLabel = "[Class Broadcast]",
    factionBroadcastSentTo = "This message was sent to %s.",
    classBroadcastSentTo = "This message was sent to %s.",
    skin = "Skin",
    viewBodygroupsDesc = "Opens a menu displaying the bodygroups of the specified players character.",
    plyTransferDesc = "Transfers the specified player to a new faction.",
    plyWhitelistDesc = "Adds the specified player to a faction whitelist.",
    plyUnwhitelistDesc = "Removes the specified player from a faction whitelist.",
    beClassDesc = "Changes your current class to the specified class.",
    setClassDesc = "Sets the specified player's class, bypassing requirements.",
    classWhitelistDesc = "Grants the specified player whitelist access to a class.",
    classUnwhitelistDesc = "Revokes the specified player's whitelist access to a class.",
    transferSuccess = "%s has been transferred to %s.",
    transferNotification = "You have been transferred to %s by %s.",
    default = "Default",
    actionInProgress = "Action in progress",
    killedBy = "You were killed by",
    itemsLostOnDeath = "You lost %s item(s) on death.",
    inspect = "Inspect",
    itemInspectHint = "Drag to Pan      A / D to Rotate      Scroll to Zoom",
    exit = "Exit",
    previous = "Previous",
    unTying = "Untying...",
    adminModeDesc = "Toggles between your current character and your staff character if you have one.",
    noPrevChar = "No previous character to swap to.",
    noStaffChar = "No staff character found. Create one in the staff faction.",
    setSitroomDesc = "Sets your current location as the sitroom spawn point for this map.",
    sitroomSet = "Sitroom location for this map has been set.",
    plyViewClaimsDesc = "Displays detailed claim information for the specified player.",
    viewAllClaimsDesc = "Displays a summary table of claim data for all admins.",
    viewClaimsDesc = "Prints detailed claim information for every admin to chat.",
    viewTicketClaims = "View Ticket Claims",
    mustSpecifyPlayer = "You must specify a player name.",
    noClaimsFound = "No claims found for the specified player.",
    noClaimsRecorded = "No claims have been recorded yet.",
    adminClaimsHeader = "=== Admin Claims ===",
    noClaimsData = "No claims data available.",
    steamID = "SteamID",
    warnDesc = "Issues a warning to the specified player with a given reason.",
    viewWarnsDesc = "Displays all warnings issued to the specified player.",
    warnPlayer = "Warn Player",
    viewPlayerWarnings = "View Player Warnings",
    warnings = "Warnings",
    warningField = "Warning",
    warnUsage = "Usage: warn [player] [reason]",
    playerWarned = "You have been warned by %s for: %s",
    warningIssued = "Warning issued to %s",
    noWarnings = "%s has no warnings.",
    idField = "ID",
    timestampField = "Timestamp",
    reasonField = "Reason",
    adminField = "Admin",
    noSound = "You must specify a sound path or name.",
    removeWarning = "Remove Warning",
    spawnAddDesc = "Adds a spawn point at your current position for the specified faction.",
    spawnRemoveInRadiusDesc = "Removes all spawn points within the given radius of your position (default 120).",
    spawnRemoveByNameDesc = "Removes all spawn points for the specified faction.",
    returnItemsDesc = "Returns items lost on death to the specified player, if any.",
    returnItemsName = "Return Items",
    returnItemsCategory = "Character Management",
    returnItemsSubCategory = "Items",
    returnItemsTargetNoItems = "The target hasn't lost any items or they've already been returned.",
    returnItemsReturnedToPlayer = "Your items have been returned.",
    returnItemsAdminConfirmed = "Returned the items.",
    returnItemsNotEnabled = "Item loss on death is not enabled!",
    adminName = "Admin Name",
    cinematicMenuTitle = "Cinematic Splash Text Menu",
    splashTextLabel = "Splash Text",
    bigSplashTextLabel = "Big Splash Text (Appears under normal text)",
    durationLabel = "Splash Text Duration",
    drawBlackBars = "Draw Black Bars",
    doorKickTooWeak = "You are too weak to kick this door in!",
    doorKickTooClose = "You are too close to kick the door down!",
    doorKickTooFar = "You are too far to kick the door down!",
    doorKickInvalid = "You are looking at an invalid door",
    doorKickCannotKick = "This door can not be kicked in!",
    doorKickDisabled = "This door is disabled and cannot be kicked!",
    detailedDescTitle = "Detailed Description - %s",
    editDescTitle = "Edit Detailed Description",
    refImagePlaceholder = "Reference Image URL",
    moneyLossMessage = "You lost %s on death.",
    openDetDescFallback = "No detailed description found.",
    freelookEnabled = "Free look Enabled",
    npcSpawnOldAlive = "Old NPCs still alive",
    freelookStatus = "Free look is now %s.",
    partyTier = "Party Tier",
    partyTierDisplay = "Party Tier: %s",
    ToggleViewBob = "Toggle ViewBob.",
    radioFrequencyTitle = "Adjust Radio Frequency",
    sabotage = "Sabotage",
    radioTurnOn = "Turn On",
    radioTurnOff = "Turn Off",
    radioChangeFreq = "Change Frequency",
    radioDescFormat = "Status: %s\nFrequency: %s",
    radioDescEntityFormat = "Entity Status: %s\nFrequency: %s",
    radioNoRadioComm = "You don't have an active radio to transmit with.",
    noRadio = "You don't have a radio to adjust!",
    WarrantIssued = "You have been issued an active warrant.",
    WarrantRemoved = "You have had an active warrant removed.",
    WarrantIssuedNotify = "You have issued an active warrant.",
    WarrantRemovedNotify = "You have removed an active warrant.",
    WarrantExpirationIssued = "A warrant has been issued for someone with the physical description of %s.",
    WarrantExpirationExpired = "A warrant has expired for someone with the physical description of %s.",
    UnknownDescription = "unknown description",
    WarrantedText = "Criminal - Wanted by the Government - Dead or Alive",
    wanted = "Wanted",
    upstanding = "Upstanding",
    isTied = "This person has been tied up",
    tying = "Tying",
    untying = "Untying",
    cuffed = "Cuffed",
    beingUntied = "You are being untied",
    beingTied = "You are being tied",
    youAreTied = "You're currently handcuffed.",
    restricted = "You have been restrained",
    charSearching = "You are already searching for another character, please wait",
    needAimPlayer = "You need to be aiming at a player",
    staffRestrained = "You were just attempted to be restrained by %s",
    cantRestrainStaff = "You can't tie a staff member",
    alreadyCuffed = "This person is already cuffed",
    handcuffedCharSwitch = "You're currently handcuffed",
    cuffCannotChangeClass = "You cannot change classes when you are cuffed",
    searchDenied = "Player denied your request to view their inventory",
    requestSearch = "Request Search",
    requestSearchSent = "Request to search sent",
    requestSearchInventory = "A player is requesting to search your inventory",
    requestSearchInventoryConfirm = "Are you sure you want to allow this player to search your inventory",
    beingSearched = "Being Searched",
    alreadyBeingSearched = "This person is already being searched",
    putInVehicle = "Put in vehicle",
    removeCuffedPassengers = "Remove Cuffed Passengers",
    tie = "Tie",
    unTie = "Untie",
    accept = "Accept",
    deny = "Deny",
    ClearWarTable = "Clear out table.",
    CustomizeMarker = "Customize Marker",
    SetNewMapTitle = "Set new map",
    SetNewMapPrompt = "Input the link to set a new map",
    generalinfo = "General Info",
    reputationField = "Reputation",
    issued = "issued",
    expired = "expired",
    warrantCommandDesc = "Toggles a wanted warrant on the specified player.",
    blacklistKick = "You are blacklisted from this server!",
    whitelistKick = "Sorry, you are not whitelisted for %s.",
    on = "On",
    off = "Off",
    radio = "Radio",
    frequency = "Frequency",
    post = "Post",
    radioNotOwned = "You don't own a radio!",
    radioAlreadyEquipped = "You already have a radio equipped!",
    radioBreakAction = "breaks the radio, placing it on the floor. This radio is now broken beyond repair",
    rumourNotAllowed = "You are not allowed to use /rumour.",
    stunAttempted = "You were just attempted to be stunned by %s.",
    cannotStunStaff = "You can't stun a staff member!",
    tasedBy = "You have been tased by %s",
    targetTooStunned = "Target is too stunned to react! You have time to tie him up!",
    targetStunnedMove = "You have been able to stand up but you are now too stunned to move!",
    nowAbleToMove = "You are now able to move!",
    targetAbleToMove = "Target is now able to move!",
    rumourNoMessage = "You must provide a message for /rumour.",
    rumourMessagePrefix = "[Rumour]: %s",
    rumourCommandDesc = "Broadcasts a secret rumour to criminal factions, with a small chance of alerting police.",
    permRemoveSuccess = "Map entity removed.",
    realisticViewEnabled = "Realistic View Enabled",
    realisticViewUsesFullBody = "Realistic View Uses Full Body",
    permRemoveInvalid = "This is not a valid map entity.",
    permRemoveDesc = "Permanently removes the targeted map entity.",
    playerJoined = "%s entered the server.",
    forceNPCSpawnDesc = "Force-spawns NPCs at the chosen spawn zone, overriding cooldown if possible.",
    noNPCSpawns = "No NPC Spawns here",
    selectSpawnerTitle = "Select Spawner",
    selectSpawnerPrompt = "Choose a spawner zone to force a spawn:",
    forcedSpawnSuccess = "Forced spawn on spawner: %s",
    forcedSpawnBlocked = "Force spawn did not occur on spawner: %s because old NPCs are still alive.",
    forcedSpawnFailed = "Force spawn did not occur on spawner: %s",
    spawnerNotFound = "Spawner not found!",
    playerLeft = "%s left the server.",
    wardrobeNoModels = "There are no models available for your faction & class.",
    freeLookError = "Free look is not enabled or cannot be used right now.",
    enableFreelookLabel = "Enable Freelook",
    wardrobeModelChanged = "Your model has been changed successfully.",
    wardrobeModelInvalid = "Invalid model selected.",
    partyTierUpdated = "You have updated %s's Party Tier to %s.",
    wardrobeSelectTitle = "Select Your Model",
    wardrobeSelectPrompt = "Select a Model",
    wardrobeConfirmButton = "Confirm",
    wardrobeSelectError = "Please select a valid model.",
    partyTierRemoved = "%s has removed your Party Tier!",
    partyTierSet = "You have been set as Party Tier %s.",
    itemCleanupWarning = "[ WARNING ]  Item Cleanup Inbound in 60 seconds!",
    mapCleanupWarning = "[ WARNING ]  Map Cleanup Inbound in 60 seconds!",
    itemCleanupFinalWarning = "[ WARNING ]  Item Cleanup Inbound! Brace for impact!",
    mapCleanupFinalWarning = "[ WARNING ]  Map Cleanup Inbound! Brace for impact!",
    partytierCommandDesc = "Assigns or removes a party tier for the specified player.",
    invalidPartyTier = "You must specify a valid tier number.",
    freelookOnMessage = "Freelook has been enabled.",
    freelookOffMessage = "Freelook has been disabled.",
    viewExtDescCommand = "Opens a window displaying your characters detailed description and URL.",
    setExtDescCommand = "Opens the interface to edit your characters detailed description and URL.",
    openDetDescLabel = "Open Detailed Description",
    doorkickCommandDesc = "Attempts to kick open the targeted door if youre the correct distance away and not blacklisted.",
    subtractCharSlotsDesc = "Removes one character slot from the specified player.",
    addCharSlotsDesc = "Grants one extra character slot to the specified player.",
    setCharSlotsDesc = "Sets the total number of character slots for the specified player.",
    invalidSlotCount = "You didn't specify a valid slot count!",
    playAudio = "Play audio",
    errorPanelReload = "Something went horribly wrong. Try reloading this panel",
    errorMissingText = "Text is missing. Enter some text to display",
    splashTextSent = "Splash Text Sent",
    permaWeaponsNPC = "Perma Weapons NPC",
    donatorEnjoyWeapons = "Enjoy your weapons, donator!",
    noPermanentWeapons = "You have no permanent weapons!",
    totalClaims = "Total Claims",
    urlCommandDesc = "Opens the %s URL in your browser.",
    urlNotConfig = "URL not configured",
    devServerUnauthorized = "You are not authorized to join the server during development periods.",
    devServerActive = "The development module is still active!",
    invalidURLReceived = "Invalid URL received.",
    identifyCorpseQuestion = "Do you want to identify this corpse?",
    identifyCorpse = "Press E to identify corpse",
    identifyCorpseDeclined = "You decided not to identify the corpse.",
    identifyingCorpse = "Identifying corpse...",
    identifiedCorpseMessage = "This corpse appears to belong to %s.",
    doorResetData = "The door data has been reset.",
    lastClaimDate = "Last Claim Date",
    timeSinceLastClaim = "Time Since Last Claim",
    claimedFor = "Claimed For",
    sendToSitRoomDesc = "Teleports the specified player to the sitroom location for this map.",
    sitroomTeleport = "%s has been teleported to the sitroom.",
    sitroomArrive = "You have been teleported to the sitroom.",
    sitroomNotSet = "Sitroom location for this map has not been set.",
    charVoiceToggleDesc = "Toggles voice chat ban for the specified character.",
    upgradeNotice = "Hey there, we noticed that you're running an older version of Garry's Mod. We highly recommend switch to the updated, more stable x64 branch of the game.\nSwitching comes with a ton of benefits, including less risk of crashing, increased performance, and more!",
    upgradeTitle = "Garry's Mod 32-bit Client detected!",
    tookDamageSwitchCooldown = "You took damage too recently to switch characters!",
    switchCooldown = "You are on cooldown!",
    exploitAttempt = "%s (%s) may be attempting to run exploits! Used %s",
    steamIDMissing = "The SteamID of player %s (%s) wasn't received properly. This can signify tampering with net messages.",
    steamIDMismatch = "The SteamID of player %s (%s) is different than the saved one (%s).",
    kickedForInfractionPeriod = "Kicked for %s.",
    bannedForInfractionPeriod = "Banned for %s.",
    kickedForInfraction = "Kicked for ",
    bannedForInfraction = "Banned for ",
    togglePermakillDesc = "Toggles a characters permanent kill flag (marks or unmarks them for permanent death).",
    playGlobalSoundDesc = "Play a global sound for all players.",
    playSoundDesc = "Play the specified sound on a specific player.",
    returnToDeathPosDesc = "Return to your last recorded death position.",
    forceFalloverDesc = "Force another player to fall over (go into ragdoll).",
    forceGetUpDesc = "Force another player to get up from ragdoll.",
    changeCharDesc = "Change your character's description.",
    forceSelfGetUpDesc = "Force yourself to get up from ragdoll (if possible).",
    fallOverDesc = "Fall over (ragdoll) for a certain duration.",
    toggleCharLockDesc = "Toggle whether players can swap characters.",
    charSwapEnabled = "Now the players will be able to change character",
    charSwapDisabled = "Now the players won't be able to change character until the server is restarted or until you re-enable it",
    checkInventoryDesc = "Check another player's inventory.",
    flagGiveDescPrompt = "Enter the flags to give:",
    flagTakeDescPrompt = "Enter the flags to take:",
    giveAllFlagsDesc = "Give all possible flags to a character.",
    takeAllFlagsDesc = "Remove all flags from a character.",
    bringLostItemsDesc = "Bring lost items in a 500 radius to your position.",
    cleanItemsDesc = "Remove all item entities from the map.",
    cleanPropsDesc = "Remove all prop entities from the map.",
    cleanNPCsDesc = "Remove all NPC entities from the map.",
    charUnbanDesc = "Unban a character by name or ID.",
    clearInvDesc = "Clear a player's entire inventory.",
    kickCharDesc = "Kick the target's active character to the character menu.",
    freezeAllPropsDesc = "Freeze all props owned by a specific player.",
    banCharDesc = "Ban a character by name or ID.",
    checkMoneyDesc = "Check how much money the target player has.",
    listBodygroupsDesc = "List the available bodygroups for a target player.",
    setSpeedDesc = "Set a player's run speed.",
    setModelDesc = "Set a player's model.",
    giveItemDesc = "Give an item to a player's inventory.",
    setDescDesc = "Set a player's character description.",
    setNameDesc = "Set a player's character name.",
    setScaleDesc = "Set a player's model scale.",
    setJumpDesc = "Set a player's jump power.",
    setBodygroupDesc = "Set a specific bodygroup on a player's model.",
    setSkinDesc = "Set a player's skin.",
    setMoneyDesc = "Set a player's money to a specific amount.",
    addMoneyDesc = "Add a certain amount of money to a player's balance.",
    globalBotSayDesc = "Force all bots on the server to say something.",
    botSayDesc = "Force a specific bot to say something.",
    forceSayDesc = "Force a player to say something in chat.",
    getModelDesc = "Get the model of the entity you are looking at.",
    getCharModelDesc = "Get the model of a player's character.",
    checkAllMoneyDesc = "Check every player's money balance.",
    checkFlagsDesc = "Check which flags a player has.",
    getCharNameDesc = "Get a player's character name.",
    getHealthDesc = "Get a player's current health.",
    getMoneyDesc = "Get how much money a player has.",
    getInventoryDesc = "Get the contents of a player's inventory.",
    bannedCheaterNotify = "%s (%s) was banned for cheating or using an alt of a cheater.",
    kickedAltNotify = "%s (%s) was kicked for family sharing.",
    bannedAltNotify = "%s (%s) was banned for using a family-shared account that is blacklisted.",
    ipInChat = "Typing IP addresses in chat",
    notifyLuaRun = "[Notify] lua_run entity detected and will be removed.",
    notifyPointServer = "[Notify] point_servercommand entity detected and will be removed.",
    damageSwitchCooldown = "You took damage too recently to switch characters!",
    cooldownSwitchMessage = "You are on cooldown!",
    ipAddressWarning = "Typing IP addresses in chat",
    cloneNSFilter = "Filtered message containing inappropriate terms.",
    kickedForCheating = "Kicked for using third-party cheats",
    bannedForCheating = "Banned for using third-party cheats",
    kickedForAlting = "Kicked for family sharing (alts are disabled)",
    bannedForAlting = "Banned for using a family-shared account that is blacklisted",
    spawnDeletedByName = "Deleted %s spawn point(s) for faction: %s.",
    noSpawnsForFaction = "No spawn points exist for this faction.",
    returnItems = "Return Items",
    itemsCategory = "Items",
    itemsReturnedToYou = "Your items have been returned.",
    itemsReturnedToTarget = "Returned the items.",
    noItemsLost = "The target hasn't lost any items or they've already been returned.",
    itemLossNotEnabled = "Item loss on death is not enabled!",
    spawner = "Spawner",
    pointsLeft = "Points Left",
    deleteCharacter = "Delete Character",
    charDeletionCannotUndone = "This action cannot be undone. Are you sure you want to delete this character?",
    unableToJoinFactions = "You are unable to join any factions",
    maxCharactersReached = "You have reached the maximum number of characters",
    finish = "Finish",
    next = "Next",
    back = "Back",
    noCharacterSteps = "No character creation steps have been set up",
    viewClasses = "View Classes",
    classSet = "Your class was set to %s%s.",
    classSetOther = "You set %s class to %s.",
    classFactionMismatch = "The class does not match the target's faction!",
    noWhitelistNeeded = "This faction doesn't require a whitelist!",
    whitelistFactionMismatch = "You cannot whitelist a class outside the faction.",
    alreadyWhitelisted = "This player is already whitelisted.",
    whitelistedSuccess = "Successfully whitelisted the player.",
    classAssigned = "Class '%s' has been assigned to your current character.",
    notWhitelisted = "This player is not whitelisted.",
    unwhitelistedSuccess = "Successfully removed the player's whitelist.",
    classUnassigned = "Class '%s' has been removed from your character.",
    factionNotFound = "Faction not found. Using default method.",
    copiedToClipboard = "Copied %s's %s to Clipboard",
    copiedCharID = "Copied CharID: %s to Clipboard",
    recognition = "Recognition",
    characterCategory = "Character",
    damage = "Damage",
    spawn = "Spawn",
    chatCategory = "Chat",
    moneyCategory = "Money",
    itemCategory = "Item",
    protection = "Protection",
    toolgun = "Toolgun",
    swep = "SWEP",
    connections = "Connections",
    doors = "Doors",
    itemSpawner = "Item Spawner",
    vendors = "Vendors",
    adminActions = "Admin Actions",
    sitRooms = "Sit Rooms",
    charRecognizeLog = "Player [%s] '%s' recognized character with ID %s and name '%s'. (Active CharID: %s)",
    charCreateLog = "Player [%s] '%s' created a new character named '%s' (CharID: %s).",
    charLoadLog = "Player [%s] '%s' loaded character '%s' (CharID: %s).",
    charDeleteLog = "Player [%s] '%s' has deleted character ID %s. (Active CharID: %s)",
    playerHurtLog = "Player [%s] '%s' took %s damage from '%s'. Current Health: %s (CharID: %s)",
    playerDeathLog = "Player [%s] '%s' was killed by '%s'. (CharID: %s)",
    spawned_propLog = "Player [%s] '%s' spawned prop: %s. (CharID: %s)",
    spawned_ragdollLog = "Player [%s] '%s' spawned ragdoll: %s. (CharID: %s)",
    spawned_effectLog = "Player [%s] '%s' spawned effect: %s. (CharID: %s)",
    spawned_vehicleLog = "Player [%s] '%s' spawned vehicle '%s' with model '%s'. (CharID: %s)",
    spawned_npcLog = "Player [%s] '%s' spawned NPC '%s' with model '%s'. (CharID: %s)",
    swep_spawningLog = "Player [%s] '%s' spawned SWEP '%s'. (CharID: %s)",
    chatLog = "[%s] (Chat Type: %s) %s said: '%s' (CharID: %s)",
    chatOOCLog = "Player [%s] '%s' said (OOC): '%s'. (CharID: %s)",
    chatLOOCLog = "Player [%s] '%s' said (LOOC): '%s'. (CharID: %s)",
    commandLog = "Player [%s] '%s' ran command: %s. (CharID: %s)",
    moneyLog = "Player [%s] '%s' changed money by: %s. (CharID: %s)",
    moneyGivenLog = "Player [%s] '%s' gave '%s' an amount of %s. (CharID: %s)",
    moneyPickedUpLog = "Player [%s] '%s' picked up %s %s. (CharID: %s)",
    itemTakeLog = "Player [%s] '%s' took item '%s'. (CharID: %s)",
    itemUseLog = "Player [%s] '%s' used item '%s'. (CharID: %s)",
    itemDropLog = "Player [%s] '%s' dropped item '%s'. (CharID: %s)",
    itemInteractionLog = "Player [%s] '%s' %s item '%s'. (CharID: %s)",
    itemEquipLog = "Player [%s] '%s' equipped item '%s'. (CharID: %s)",
    itemUnequipLog = "Player [%s] '%s' unequipped item '%s'. (CharID: %s)",
    toolgunUseLog = "Player [%s] '%s' used toolgun: '%s'. (CharID: %s)",
    playerConnectedLog = "Player connected: [%s] '%s'.",
    playerDisconnectedLog = "Player disconnected: [%s] '%s'.",
    spawnItemLog = "Player [%s] spawned an item: '%s' %s.",
    chargiveItemLog = "Player [%s] gave item '%s' to %s. Info: %s",
    configChangeLog = "Configuration changed: '%s' from '%s' to '%s'.",
    warningIssuedLog = "Warning issued at %s by admin [%s] to player [%s] for: '%s'.",
    warningRemovedLog = "Warning removed at %s by admin [%s] for player [%s]. Reason: '%s'.",
    adminModeLog = "Admin Mode toggled at %s by admin [%s]: %s. (ID: %s)",
    sitRoomSetLog = "Sit room set at %s by admin [%s]: %s. Position: %s",
    sendToSitRoomLog = "Admin action at %s by [%s]: %s. Sent player %s to Sit Room.",
    youWillBeDisconnected = "You will disconnect from the server.",
    category = "Category",
    change = "Change",
    delete = "Delete",
    health = "Health",
    invalidEntity = "Invalid entity!",
    cantUseThisOnSameChar = "Can't use this on the same character.",
    noChar = "No character found!",
    passwordTooQuick = "Please wait before setting another password!",
    uiColumnUniqueID = "Unique ID",
    characterAttributes = "Character Attributes",
    carTrunk = "Car Trunk",
    invalidBagItem = "Invalid bag item",
    vendorSaved = "Vendors saved: %s",
    restockVendorDesc = "Restocks all items for the vendor you are looking at to their default quantities.",
    restockVendorStickName = "Restock Selected Vendor",
    restockAllVendorsDesc = "Restocks all items on every vendor on the map to their default quantities.",
    resetAllVendorMoneyDesc = "Sets every vendors money to the specified amount.",
    resetAllVendorMoneyStickName = "Reset Money for All Vendors",
    resetAllVendorMoneyAmount = "Amount",
    restockVendorMoneyDesc = "Sets the money of the vendor youre looking at to the specified amount.",
    restockVendorMoneyStickName = "Restock Money for Selected Vendor",
    restockVendorMoneyAmount = "Amount",
    saveVendorsDesc = "Saves current vendor data to disk.",
    wFormat = "%s whispers \"%s\"",
    yFormat = "%s yells \"%s\"",
    rollFormat = "%s has rolled %s.",
    pmFormat = "[PM] %s: %s.",
    sFormat = "%s screams \"%s\"",
    mesFormat = "**%s's %s",
    mefarfarFormat = "**%s %s",
    banOOCCommandDesc = "Bans the specified player from using outofcharacter chat.",
    banOOCCommandName = "Ban OOC",
    oocCategory = "OOC",
    messageTooLong = "Your message has been shortened due to being longer than %s characters!",
    hasBeenBannedFromOOC = "has been banned from OOC.",
    unbanOOCCommandDesc = "Unbans the specified player from outofcharacter chat.",
    unbanOOCCommandName = "Unban OOC",
    hasBeenUnbannedFromOOC = "has been unbanned from OOC.",
    blockOOCCommandDesc = "Toggles a global block on all outofcharacter chat.",
    unlockedOOC = "Unlocked OOC!",
    blockedOOC = "Blocked OOC!",
    clearChatCommandDesc = "Clears chat for all players.",
    nameField = "Name",
    descField = "Description",
    factionField = "Faction",
    classField = "Class",
    moneyField = "Money",
    entitiesTab = "Entities",
    teleportedToEntity = "Teleported to entity: %s",
    alreadyUsingChar = "You are already using this character!",
    youAreDead = "You are dead!",
    youAreRagdolled = "You are ragdolled!",
    cannotSwitchInVehicle = "You cannot switch characters while in a vehicle or sitting!",
    noCharacterFound = "No character found!",
    pressInstructions = "Press A/D to rotate | W/S to move camera vertically | Press SPACE to exit",
    viewButton = "View",
    AdvertDeductedMessage = "%d %s have been deducted from your wallet for advertising.",
    AdvertInsufficientFunds = "You lack sufficient funds to make an advertisement.",
    AdvertFormat = "[Advertisement by %s]:",
    alcoholDesc = "A alcoholic beverage with %d%% ABV.",
    drinkAction = "drink",
    entities = "Entities",
    drinkTip = "drinkTip",
    teleportButton = "Teleport",
    waypointButton = "Waypoint",
    information = "Information",
    cinematicMenuDesc = "Opens the cinematic menu for camera controls.",
    invalidCommand = "This command is invalid.",
    invalidply = "This player is invalid.",
    ["Moderation Tools"] = "Moderation Tools",
    ["Player Information"] = "Player Information",
    ["Character Management"] = "Character Management",
    ["Flags Management"] = "Flags Management",
    ["Give Flags"] = "Give Flags",
    ["Take Flags"] = "Take Flags",
}

-- ./gamemode/shared.lua
GM.Name = "Lilia"
GM.Author = "Samael"
GM.Website = "https://discord.gg/esCRH5ckbQ"
include("core/loader.lua")

-- ./hooks.lua
--[[
    ShouldHideBars()

    Description:
        Determines whether the player's HUD bars (action/status) should be hidden.
        If this hook returns true, lia.bar.drawAll will skip rendering all bars.

    Parameters:
        None

    Realm:
        Client

    Returns:
        boolean  Return true to hide bars, false or nil to show them.
]]
--[[
    ShouldBarDraw(bar)

    Description:
        Determines whether a specific HUD bar should be drawn.
        Called for each bar individually during lia.bar.drawAll.
        If this hook returns false, the bar will not be rendered.

    Parameters:
        bar (table)  The bar data table. Contains fields such as .priority, .color, .getValue, etc.

    Realm:
        Client

    Returns:
        boolean  Return false to skip drawing this bar. Return true or nil to allow drawing.
]]
--[[
    InitializedOptions()

    Description:
        Called after the lia.option.load function has finished loading and applying saved option values.
        Use this hook to perform any setup or updates that rely on options being initialized.

    Parameters:
        None

    Realm:
        Client

    Returns:
        None
]]
--[[
    InitializedConfig()

    Description:
        Called after the config system finishes loading stored configuration values.
        Useful for executing logic that depends on finalized config state.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    InitializedModules()

    Description:
        Called after all modules have been loaded and initialized.
        Use this hook to perform any final setup or adjustments that require all modules to be available.
        Useful for inter-module interactions or post-initialization configuration.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    InitializedSchema()

    Description:
        Invoked after the schema (core game mode) has been loaded.
        Use this hook to execute any logic or initialization that depends on the schema being fully set up.
        This is typically one of the first hooks called during module initialization.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    DoModuleIncludes(path, MODULE)

    Description:
        Called during the module loading process to allow custom file includes or additional initialization.
        This hook is executed after extras like languages, factions, classes, entities, and items have been loaded.
        Use this hook to include extra files or perform custom setup for a module.

    Parameters:
        path (string)  The file system path of the module being processed.
        MODULE (table)  The module table containing all loaded data and functions.

    Realm:
        Shared

    Returns:
        None
]]
--[[
    OnServerLog(client, logType, logString, category)

    Description:
        Called when a server log event is generated. Triggered during the logging process (typically within lia.log.add)
        after a log string has been produced. Allows other modules or systems to process, display, or modify the log event
        before it is saved or further handled.

    Parameters:
        client (Player)  The player associated with the log event.
        logType (string)  The identifier for the type of log event.
        logString (string)  The formatted log message.
        category (string)  The category for the log event, used to organize log files.

    Realm:
        Server

    Returns:
        None
]]
--[[
    OnLocalizationLoaded()

    Description:
        Triggered after all language files have been loaded and processed by the localization system.
        This hook signals that the language data is fully available and that any further initialization
        or updates depending on localization can now be safely performed.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    InitializedKeybinds()

    Description:
        Triggered once the keybind system has finished loading and initializing keybind configurations.
        This hook indicates that keybind settings are now available and ready for use or further modifications,
        allowing other modules or systems to perform additional setup or adjustments related to keybinds.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    EasyIconsLoaded()

    Description:
        Triggered once the easy icons have been loaded and processed.
        This hook indicates that icon data is now available for use by other systems that require icon fonts.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    OnMySQLOOConnected()

    Description:
        Called when MySQLOO successfully connects to the database.
        This hook is triggered after all connection pools are connected and is used
        to perform post-connection setup such as registering prepared statements.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    LiliaTablesLoaded()

    Description:
        Triggered after the database tables have been loaded or updated.
        This hook indicates that the database schema is now ready for use and
        allows further initialization routines to run.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    OnLoadTables()

    Description:
        Called immediately after the database tables have been loaded.
        Use this hook to perform additional setup actions that depend on the database schema.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    RegisterPreparedStatements()

    Description:
        Triggered to register prepared SQL statements for database operations.
        This hook is typically called after a successful database connection to prepare
        commonly used queries for improved performance.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    LoadData()

    Description:
        Triggered to load persistent data from storage.
        This hook is typically called during initialization or when the map changes
        to restore saved data.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    PostLoadData()

    Description:
        Triggered immediately after data is loaded.
        Use this hook for any post-loading initialization that requires the loaded data.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    SaveData()

    Description:
        Triggered to save persistent data to storage.
        This hook is commonly called during shutdown or at regular intervals to ensure data persistence.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    PersistenceSave()

    Description:
        Triggered to perform additional persistence operations.
        This hook can be used to save supplementary data that may not be covered by the standard SaveData hook.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    ShouldDataBeSaved()

    Description:
        Triggered to determine whether data should be saved.
        Handlers of this hook can return false to prevent data from being saved.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        boolean  Return false to cancel data saving; otherwise, true or nil to proceed.
]]
--[[
    CanPlayerUseCommand(client, command)

    Description:
        Triggered to determine if a player has permission to execute a specific command.
        Invoked within the command access check function. If any callback returns false,
        the command is considered not accessible to the player.

    Parameters:
        client (Player)  The player attempting to execute the command.
        command (string)  The command being executed.

    Realm:
        Shared

    Returns:
        boolean  Return false to deny access, or true or nil to allow access.
]]
--[[
    CanPlayerJoinClass(client, class, info)

    Description:
        Triggered during the class join process to allow custom logic.
        If any callback returns false, the player is prevented from joining the specified class.

    Parameters:
        client (Player)  The player attempting to join the class.
        class (string)  The identifier of the class being joined.
        info (table)  The table containing metadata about the class (e.g., name, description, attributes).

    Realm:
        Shared

    Returns:
        boolean  Return false to block the class change; return true or nil to allow it.
]]
--[[
    GetDisplayedName(speaker, chatType)

    Description:
        Called when the chatbox needs to determine what name to display for a speaker.
        Allows overriding the default player name or providing a custom label.

    Parameters:
        speaker (Player or Entity)  The entity sending the chat message.
        chatType (string)  The type/category of chat (e.g., "say", "yell", "pm").

    Realm:
        Shared

    Returns:
        string  A custom display name. Returning nil falls back to speaker:Name() or Console.
]]
--[[
    PlayerMessageSend(sender, chatType, text, anonymous, receivers)

    Description:
        Fired just before a chat message is broadcast (server) or echoed locally (client).
        Allows modifying or blocking the outgoing message text.

    Parameters:
        sender (Player or Entity)  The entity sending the message.
        chatType (string)  The chat category (e.g., "say", "yell").
        text (string)  The original message content.
        anonymous (boolean)  True if the sender should be hidden.
        receivers (table<Player>)  (Server only) List of recipients.

    Realm:
        Shared

    Returns:
        string or boolean  Return a modified message string to replace the original, false to block sending, or nil to leave unchanged.
]]
--[[
    CreateInventoryPanel(inventory, parent)

    Description:
        Called to create the inventory UI panel for a given inventory.

    Parameters:
        inventory (table)  The inventory instance to display.
        parent (Panel)  The parent VGUI element.

    Realm:
        Client

    Returns:
        Panel  The newly created inventory UI panel.
]]
--[[
    CanPlayerViewInventory()

    Description:
        Determines whether the local player is allowed to view their inventory.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        boolean or nil  Return false to block inventory viewing; anything else allows it.
]]
--[[
    PostDrawInventory(mainPanel)

    Description:
        Called after the inventory panel is rendered each frame, for drawing custom overlays or effects.

    Parameters:
        mainPanel (Panel)  The inventory UI panel that was drawn.

    Realm:
        Client

    Returns:
        None
]]
--[[
    OnCharVarChanged(self, key, oldVar, value)

    Description:
        Called whenever a character variable changes. Provides the old and new values.

    Parameters:
        self (table)  The character object whose variable changed.
        key (string)  The name of the variable that changed.
        oldVar (any)  The previous value of the variable.
        value (any)  The new value of the variable.

    Realm:
        Shared

    Returns:
        None
]]
--[[
    GetDefaultCharName(client, faction, data)

    Description:
        Called to retrieve a default name for a newly created or adjusted character.
        If a string and an override are returned, the character's name will be set to that string.

    Parameters:
        client (Player)  The player creating or adjusting the character.
        faction (any)  The faction of the character (number/index or string).
        data (table)  Additional data relevant to the character creation process.

    Realm:
        Shared

    Returns:
        string or nil, boolean or nil  name and override flag. Name to set if returned, override determines forced use.
]]
--[[
    GetDefaultCharDesc(client, faction)

    Description:
        Called to retrieve a default description for a newly created or adjusted character.
        If a string and an override are returned, the character's description will be set to that string.

    Parameters:
        client (Player)  The player creating or adjusting the character.
        faction (any)  The faction of the character (number/index or string).

    Realm:
        Shared

    Returns:
        string or nil, boolean or nil  desc and override flag. Description to set if returned, override determines forced use.
]]
--[[
    PlayerModelChanged(client, newModel)

    Description:
        Called when a character's model is changed, allowing for custom logic like updating UI or applying extra changes.

    Parameters:
        client (Player)  The player whose model changed.
        newModel (string)  The new model path.

    Realm:
        Shared

    Returns:
        None
]]
--[[
    GetAttributeStartingMax(client, attribKey)

    Description:
        Called when determining the maximum starting value for a particular attribute during character creation.

    Parameters:
        client (Player)  The player creating or adjusting the character.
        attribKey (string)  The attribute key to check for a maximum.

    Realm:
        Shared

    Returns:
        number or nil  The maximum allowed attribute value. Return nil to ignore.
]]
--[[
    GetMaxStartingAttributePoints(client, currentTotal)

    Description:
        Called when validating total attribute points during character creation.

    Parameters:
        client (Player)  The player creating or adjusting the character.
        currentTotal (number)  The current total of assigned attribute points.

    Realm:
        Shared

    Returns:
        number or nil  The maximum total attribute points allowed. Return nil to ignore.
]]
--[[
    CharRestored(character)

    Description:
        Fired after a character is successfully loaded from the database. Useful for post-load operations or modifications.

    Parameters:
        character (table)  The character object that was restored.

    Realm:
        Shared

    Returns:
        None
]]
--[[
    CreateDefaultInventory(character)

    Description:
        Called when a newly created or restored character needs a default inventory setup.
        Should return a promise object resolving to an inventory, or nil if handling is deferred.

    Parameters:
        character (table)  The character object that needs a default inventory.

    Realm:
        Shared

    Returns:
        promise or nil  A promise resolving to the default inventory, or nil if not handled.
]]
--[[
    CharCleanUp(character)

    Description:
        Called when a character is removed or cleaned up from memory. Allows for custom cleanup operations.

    Parameters:
        character (table)  The character object being cleaned up.

    Realm:
        Shared

    Returns:
        None
]]
--[[
    PreCharDelete(id)

    Description:
        Called before a character is fully deleted. Useful for final checks or additional removal logic.

    Parameters:
        id (number)  The unique ID of the character about to be deleted.

    Realm:
        Shared

    Returns:
        None
]]
--[[
    OnCharDelete(client, id)

    Description:
        Called after a character has been deleted from the database and cleaned up.

    Parameters:
        client (Player or nil)  The player associated with the deleted character, or nil if not valid.
        id (number)  The unique ID of the character that was deleted.

    Realm:
        Shared

    Returns:
        None
]]
--[[
    InitializedItems()

    Description:
        Fired once all items have been loaded and registered. Useful for performing any setup or initialization logic that depends on the complete item list.

    Parameters:
        None

    Realm:
        Shared

    Returns:
        None
]]
--[[
    OnItemRegistered(ITEM)

    Description:
        Fired immediately after a single item definition has been registered into the system.

    Parameters:
        ITEM (table)  The item table that was just registered.

    Realm:
        Shared

    Returns:
        None
]]
--[[
    HandleItemTransferRequest(client, itemID, fromInvID, fromSlotX, fromSlotY, toInvID)

    Description:
        Fired when an item transfer is requested (e.g., via giving or moving items between inventories).
        Handlers should return a deferred that resolves when the transfer is allowed/completed, or return false to cancel the transfer.

    Parameters:
        client (Player)  The player initiating the transfer.
        itemID (number)  The ID of the item being transferred.
        fromInvID (number or nil)  The ID of the source inventory, if any.
        fromSlotX (number or nil)  The X coordinate in a grid inventory, if applicable.
        fromSlotY (number or nil)  The Y coordinate in a grid inventory, if applicable.
        toInvID (number)  The ID of the destination inventory.

    Realm:
        Shared

    Returns:
        promise or boolean  A deferred resolving when allowed, or false to cancel the transfer.
]]

-- ./modules/characters/attributes/attributes/endurance.lua
ATTRIBUTE.name = L("Endurance")
ATTRIBUTE.desc = L("EnduranceDesc")


-- ./modules/characters/attributes/attributes/stamina.lua
ATTRIBUTE.name = L("Stamina")
ATTRIBUTE.desc = L("StaminaDesc")


-- ./modules/characters/attributes/attributes/strength.lua
ATTRIBUTE.name = L("Strength")
ATTRIBUTE.desc = L("StrengthDesc")


-- ./modules/characters/attributes/commands.lua
lia.command.add("charsetattrib", {
    superAdminOnly = true,
    desc = L("setAttributes"),
    syntax = "[string charname] [string attribname] [number level]",
    privilege = "Manage Attributes",
    AdminStick = {
        Name = L("setAttributes"),
        Category = L("characterManagement"),
        SubCategory = L("attributes"),
        Icon = "icon16/wrench.png",
        ExtraFields = {
            ["attribute"] = function()
                local attributes = {}
                for _, v in pairs(lia.attribs.list) do
                    table.insert(attributes, L(v.name))
                end
                return attributes, "combo"
            end,
            ["value"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local attribName = arguments[2]
        local attribNumber = tonumber(arguments[3])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local character = target:getChar()
        if character then
            for k, v in pairs(lia.attribs.list) do
                if lia.util.stringMatches(L(v.name), attribName) or lia.util.stringMatches(k, attribName) then
                    character:setAttrib(k, math.abs(attribNumber))
                    client:notifyLocalized("attribSet", target:Name(), L(v.name), math.abs(attribNumber))
                    return
                end
            end
        end
    end
})

lia.command.add("checkattributes", {
    adminOnly = true,
    desc = L("checkAttributes"),
    syntax = "[string charname]",
    privilege = "Manage Attributes",
    AdminStick = {
        Name = L("checkAttributes"),
        Category = L("characterManagement"),
        SubCategory = L("attributes"),
        Icon = "icon16/zoom.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local attributesData = {}
        for attrKey, attrData in SortedPairsByMemberValue(lia.attribs.list, "name") do
            local currentValue = target:getChar():getAttrib(attrKey, 0) or 0
            local maxValue = hook.Run("GetAttributeMax", target, attrKey) or 100
            local progress = math.Round(currentValue / maxValue * 100, 1)
            table.insert(attributesData, {
                charID = attrData.name,
                name = L(attrData.name),
                current = currentValue,
                max = maxValue,
                progress = progress .. "%"
            })
        end

        lia.util.CreateTableUI(client, L("characterAttributes"), {
            {
                name = L("attributeName"),
                field = "name"
            },
            {
                name = L("currentValue"),
                field = "current"
            },
            {
                name = L("maxValue"),
                field = "max"
            },
            {
                name = L("progress"),
                field = "progress"
            }
        }, attributesData, {
            {
                name = L("changeAttribute"),
                ExtraFields = {
                    ["Amount"] = "text",
                    ["Mode"] = {L("add"), L("set")}
                },
                net = "ChangeAttribute"
            }
        }, client:getChar():getID())
    end
})

lia.command.add("charaddattrib", {
    superAdminOnly = true,
    desc = L("addAttributes"),
    syntax = "[string charname] [string attribname] [number level]",
    privilege = "Manage Attributes",
    AdminStick = {
        Name = L("addAttributes"),
        Category = L("characterManagement"),
        SubCategory = L("attributes"),
        Icon = "icon16/add.png",
        ExtraFields = {
            ["attribute"] = function()
                local attributes = {}
                for _, v in pairs(lia.attribs.list) do
                    table.insert(attributes, L(v.name))
                end
                return attributes, "combo"
            end,
            ["value"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local attribName = arguments[2]
        local attribNumber = tonumber(arguments[3])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local character = target:getChar()
        if character then
            for k, v in pairs(lia.attribs.list) do
                if lia.util.stringMatches(L(v.name), attribName) or lia.util.stringMatches(k, attribName) then
                    character:updateAttrib(k, math.abs(attribNumber))
                    client:notifyLocalized("attribUpdate", target:Name(), L(v.name), math.abs(attribNumber))
                    return
                end
            end
        end
    end
})

-- ./modules/characters/attributes/config.lua
lia.config.add("StaminaBlur", "Stamina Blur Enabled", false, nil, {
    desc = "Is Stamina Blur Enabled?",
    category = "Attributes",
    type = "Boolean"
})

lia.config.add("StaminaSlowdown", "Stamina Slowdown Enabled", true, nil, {
    desc = "Is Stamina Slowdown Enabled?",
    category = "Attributes",
    type = "Boolean"
})

lia.config.add("DefaultStamina", "Default Stamina Value", 100, nil, {
    desc = "Sets Default Stamina Value",
    category = "Attributes",
    type = "Int",
    min = 0,
    max = 1000
})

lia.config.add("StaminaBlurThreshold", "Stamina Blur Threshold", 25, nil, {
    desc = "Sets Stamina Threshold for Blur to Show",
    category = "Attributes",
    type = "Int",
    min = 0,
    max = 100
})

lia.config.add("StaminaBreathingThreshold", "Stamina Breathing Threshold", 50, nil, {
    desc = "Sets Stamina Threshold for Breathing to Happen",
    category = "Attributes",
    type = "Int",
    min = 0,
    max = 100
})

lia.config.add("MaxAttributePoints", "Max Attribute Points", 30, nil, {
    desc = "Maximum number of points that can be allocated across an attribute.",
    category = "Attributes",
    isGlobal = true,
    type = "Int",
    min = 1,
    max = 100
})

lia.config.add("MaxStartingAttributes", "Max Starting Attributes", 30, nil, {
    desc = "Maximum value of each attribute at character creation.",
    category = "Attributes",
    isGlobal = true,
    type = "Int",
    min = 1,
    max = 100
})

lia.config.add("StartingAttributePoints", "Starting Attribute Points", 30, nil, {
    desc = "Total number of points available for starting attribute allocation.",
    category = "Attributes",
    isGlobal = true,
    type = "Int",
    min = 1,
    max = 100
})

lia.config.add("PunchStamina", "Punch Stamina", 10, nil, {
    desc = "Stamina usage for punches.",
    category = "Attributes",
    isGlobal = true,
    type = "Int",
    min = 0,
    max = 100
})

lia.config.add("MaxHoldWeight", "Maximum Hold Weight", 100, nil, {
    desc = "The maximum weight that a player can carry in their hands.",
    category = "General",
    type = "Int",
    min = 1,
    max = 500
})

lia.config.add("ThrowForce", "Throw Force", 100, nil, {
    desc = "How hard a player can throw the item that they're holding.",
    category = "General",
    type = "Int",
    min = 1,
    max = 500
})

lia.config.add("AllowPush", "Allow Push", true, nil, {
    desc = "Whether or not pushing with hands is allowed",
    category = "General",
    type = "Boolean"
})


-- ./modules/characters/attributes/entities/weapons/lia_hands/cl_init.lua
include("shared.lua")
SWEP.NextAllowedPlayRateChange = 0
function SWEP:DoDrawCrosshair(x, y)
    surface.SetDrawColor(255, 255, 255, 66)
    surface.DrawRect(x - 2, y - 2, 4, 4)
end

function SWEP:Holster()
    if not IsValid(self:GetOwner()) then return end
    local viewModel = self:GetOwner():GetViewModel()
    if IsValid(viewModel) then
        viewModel:SetPlaybackRate(1)
        viewModel:ResetSequence(ACT_VM_FISTS_HOLSTER)
        self.NextAllowedPlayRateChange = CurTime() + viewModel:SequenceDuration()
    end
    return true
end


-- ./modules/characters/attributes/entities/weapons/lia_hands/init.lua
AddCSLuaFile("cl_init.lua")
AddCSLuaFile("shared.lua")
include("shared.lua")
function SWEP:Holster()
    if not IsFirstTimePredicted() then return end
    self:DropObject()
    return true
end

function SWEP:OnRemove()
    self:DropObject()
end

function SWEP:OwnerChanged()
    self:DropObject()
end


-- ./modules/characters/attributes/entities/weapons/lia_hands/shared.lua
SWEP.PrintName = "Hands"
SWEP.Slot = 0
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.Author = "Samael"
SWEP.Instructions = [[Primary Fire: Throw/Punch
Secondary Fire: Knock/Pickup
Secondary Fire + Mouse: Rotate Object
Reload: Drop]]
SWEP.Purpose = "Hitting things and knocking on doors."
SWEP.Drop = false
SWEP.ViewModelFOV = 45
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"
SWEP.ViewTranslation = 4
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""
SWEP.Primary.Damage = 5
SWEP.Primary.Delay = 0.75
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""
SWEP.Secondary.Delay = 0.5
SWEP.ViewModel = Model("models/weapons/c_arms.mdl")
SWEP.WorldModel = ""
SWEP.UseHands = true
SWEP.LowerAngles = Angle(0, 5, -14)
SWEP.LowerAngles2 = Angle(0, 5, -19)
SWEP.KnockViewPunchAngle = Angle(-1.3, 1.8, 0)
SWEP.FireWhenLowered = true
SWEP.HoldType = "fist"
SWEP.holdDistance = 64
SWEP.maxHoldDistance = 96
SWEP.maxHoldStress = 4000
ACT_VM_FISTS_DRAW = 2
ACT_VM_FISTS_HOLSTER = 1
function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
    self.lastHand = 0
    self.maxHoldDistanceSquared = self.maxHoldDistance ^ 2
    self.heldObjectAngle = Angle(angle_zero)
end

function SWEP:Deploy()
    if not IsValid(self:GetOwner()) then return end
    local viewModel = self:GetOwner():GetViewModel()
    if IsValid(viewModel) then
        viewModel:SetPlaybackRate(1)
        viewModel:ResetSequence(ACT_VM_FISTS_DRAW)
        if CLIENT then self.NextAllowedPlayRateChange = CurTime() + viewModel:SequenceDuration() end
    end

    self:DropObject()
    return true
end

function SWEP:Precache()
    util.PrecacheSound("npc/vort/claw_swing1.wav")
    util.PrecacheSound("npc/vort/claw_swing2.wav")
    util.PrecacheSound("physics/plastic/plastic_box_impact_hard1.wav")
    util.PrecacheSound("physics/plastic/plastic_box_impact_hard2.wav")
    util.PrecacheSound("physics/plastic/plastic_box_impact_hard3.wav")
    util.PrecacheSound("physics/plastic/plastic_box_impact_hard4.wav")
    util.PrecacheSound("physics/wood/wood_crate_impact_hard2.wav")
    util.PrecacheSound("physics/wood/wood_crate_impact_hard3.wav")
end

function SWEP:OnReloaded()
    self.maxHoldDistanceSquared = self.maxHoldDistance ^ 2
    self:DropObject()
end

function SWEP:Think()
    if not IsValid(self:GetOwner()) then return end
    if CLIENT then
        local viewModel = self:GetOwner():GetViewModel()
        if IsValid(viewModel) and self.NextAllowedPlayRateChange < CurTime() then viewModel:SetPlaybackRate(1) end
    else
        if self:IsHoldingObject() then
            local physics = self:GetHeldPhysicsObject()
            local bIsRagdoll = self.heldEntity:IsRagdoll()
            local holdDistance = bIsRagdoll and self.holdDistance * 0.5 or self.holdDistance
            local targetLocation = self:GetOwner():GetShootPos() + self:GetOwner():GetForward() * holdDistance
            if bIsRagdoll then targetLocation.z = math.min(targetLocation.z, self:GetOwner():GetShootPos().z - 32) end
            if not IsValid(physics) then
                self:DropObject()
                return
            end

            if physics:GetPos():DistToSqr(targetLocation) > self.maxHoldDistanceSquared then
                self:DropObject()
            else
                local physicsObject = self.holdEntity:GetPhysicsObject()
                local currentPlayerAngles = self:GetOwner():EyeAngles()
                local client = self:GetOwner()
                if client:KeyDown(IN_ATTACK2) then
                    local cmd = client:GetCurrentCommand()
                    self.heldObjectAngle:RotateAroundAxis(currentPlayerAngles:Forward(), cmd:GetMouseX() / 15)
                    self.heldObjectAngle:RotateAroundAxis(currentPlayerAngles:Right(), cmd:GetMouseY() / 15)
                end

                self.lastPlayerAngles = self.lastPlayerAngles or currentPlayerAngles
                self.heldObjectAngle.y = self.heldObjectAngle.y - math.AngleDifference(self.lastPlayerAngles.y, currentPlayerAngles.y)
                self.lastPlayerAngles = currentPlayerAngles
                physicsObject:Wake()
                physicsObject:ComputeShadowControl({
                    secondstoarrive = 0.01,
                    pos = targetLocation,
                    angle = self.heldObjectAngle,
                    maxangular = 256,
                    maxangulardamp = 10000,
                    maxspeed = 256,
                    maxspeeddamp = 10000,
                    dampfactor = 0.8,
                    teleportdistance = self.maxHoldDistance * 0.75,
                    deltatime = FrameTime()
                })

                if physics:GetStress() > self.maxHoldStress then self:DropObject() end
            end
        end

        if not IsValid(self.heldEntity) and self:GetOwner():getLocalVar("IsHoldingObject", true) then self:GetOwner():setLocalVar("IsHoldingObject", false) end
    end
end

function SWEP:GetHeldPhysicsObject()
    return IsValid(self.heldEntity) and IsValid(self.heldEntity.ixHeldOwner) and self.heldEntity.ixHeldOwner == self:GetOwner() and self.heldEntity:GetPhysicsObject() or nil
end

function SWEP:CanHoldObject(entity)
    local physics = entity:GetPhysicsObject()
    return IsValid(physics) and physics:GetMass() <= lia.config.get("MaxHoldWeight", 100) and physics:IsMoveable() and not self:IsHoldingObject() and not IsValid(entity.ixHeldOwner) and hook.Run("CanPlayerHoldObject", self:GetOwner(), entity)
end

function SWEP:IsHoldingObject()
    return IsValid(self.heldEntity) and IsValid(self.heldEntity.ixHeldOwner) and self.heldEntity.ixHeldOwner == self:GetOwner()
end

function SWEP:PickupObject(entity)
    if self:IsHoldingObject() or not IsValid(entity) or not IsValid(entity:GetPhysicsObject()) then return end
    local physics = entity:GetPhysicsObject()
    physics:EnableGravity(false)
    physics:AddGameFlag(FVPHYSICS_PLAYER_HELD)
    entity.ixHeldOwner = self:GetOwner()
    entity.ixCollisionGroup = entity:GetCollisionGroup()
    entity:StartMotionController()
    entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
    self.heldObjectAngle = entity:GetAngles()
    self.heldEntity = entity
    self.holdEntity = ents.Create("prop_physics")
    self.holdEntity:SetPos(self.heldEntity:LocalToWorld(self.heldEntity:OBBCenter()))
    self.holdEntity:SetAngles(self.heldEntity:GetAngles())
    self.holdEntity:SetModel("models/weapons/w_bugbait.mdl")
    self.holdEntity:SetOwner(self:GetOwner())
    self.holdEntity:SetNoDraw(true)
    self.holdEntity:SetNotSolid(true)
    self.holdEntity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    self.holdEntity:DrawShadow(false)
    self.holdEntity:Spawn()
    local trace = self:GetOwner():GetEyeTrace()
    local physicsObject = self.holdEntity:GetPhysicsObject()
    if IsValid(physicsObject) then
        physicsObject:SetMass(2048)
        physicsObject:SetDamping(0, 1000)
        physicsObject:EnableGravity(false)
        physicsObject:EnableCollisions(false)
        physicsObject:EnableMotion(false)
    end

    if trace.Entity:IsRagdoll() then
        local tracedEnt = trace.Entity
        self.holdEntity:SetPos(tracedEnt:GetBonePosition(tracedEnt:TranslatePhysBoneToBone(trace.PhysicsBone)))
    end

    self.constraint = constraint.Weld(self.holdEntity, self.heldEntity, 0, trace.Entity:IsRagdoll() and trace.PhysicsBone or 0, 0, true, true)
end

function SWEP:DropObject(bThrow)
    if not IsValid(self.heldEntity) or self.heldEntity.ixHeldOwner ~= self:GetOwner() then return end
    self.lastPlayerAngles = nil
    self:GetOwner():setLocalVar("IsHoldingObject", false)
    SafeRemoveEntity(self.constraint)
    SafeRemoveEntity(self.holdEntity)
    self.heldEntity:StopMotionController()
    self.heldEntity:SetCollisionGroup(self.heldEntity.ixCollisionGroup or COLLISION_GROUP_NONE)
    local physics = self:GetHeldPhysicsObject()
    physics:EnableGravity(true)
    physics:Wake()
    physics:ClearGameFlag(FVPHYSICS_PLAYER_HELD)
    if bThrow then
        timer.Simple(0, function()
            if IsValid(physics) and IsValid(self:GetOwner()) then
                physics:AddGameFlag(FVPHYSICS_WAS_THROWN)
                physics:ApplyForceCenter(self:GetOwner():GetAimVector() * lia.config.get("ThrowForce", 732))
            end
        end)
    end

    self.heldEntity.ixHeldOwner = nil
    self.heldEntity.ixCollisionGroup = nil
    self.heldEntity = nil
end

function SWEP:PlayPickupSound(surfaceProperty)
    local result = "Flesh.ImpactSoft"
    if surfaceProperty ~= nil then
        local surfaceName = util.GetSurfacePropName(surfaceProperty)
        local soundName = surfaceName:gsub("^metal$", "SolidMetal") .. ".ImpactSoft"
        if sound.GetProperties(soundName) then result = soundName end
    end

    self:GetOwner():EmitSound(result, 75, 100, 40)
end

function SWEP:DoPunchAnimation()
    self.lastHand = math.abs(1 - self.lastHand)
    local sequence = 3 + self.lastHand
    local viewModel = self:GetOwner():GetViewModel()
    if IsValid(viewModel) then
        viewModel:SetPlaybackRate(0.5)
        viewModel:SetSequence(sequence)
        if CLIENT then self.NextAllowedPlayRateChange = CurTime() + viewModel:SequenceDuration() * 2 end
    end
end

function SWEP:PrimaryAttack()
    if not IsFirstTimePredicted() then return end
    if SERVER and self:IsHoldingObject() then
        self:DropObject(true)
        return
    end

    self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
    if hook.Run("CanPlayerThrowPunch", self:GetOwner()) == false then return end
    local staminaUse = lia.config.get("PunchStamina")
    if staminaUse > 0 then
        local owner = self:GetOwner()
        local currentStamina = owner:getLocalVar("stamina", 0)
        if currentStamina < staminaUse then return end
        if SERVER then owner:consumeStamina(staminaUse) end
    end

    if SERVER then self:GetOwner():EmitSound("npc/vort/claw_swing" .. math.random(1, 2) .. ".wav") end
    self:DoPunchAnimation()
    self:GetOwner():SetAnimation(PLAYER_ATTACK1)
    self:GetOwner():ViewPunch(Angle(self.lastHand + 2, self.lastHand + 5, 0.125))
    timer.Simple(0.055, function()
        if not IsValid(self) or not IsValid(self:GetOwner()) then return end
        local damage = self.Primary.Damage
        local context = {
            damage = damage
        }

        local result = hook.Run("GetPlayerPunchDamage", self:GetOwner(), damage, context)
        damage = result ~= nil and result or context.damage
        self:GetOwner():LagCompensation(true)
        local startPos = self:GetOwner():GetShootPos()
        local endPos = startPos + self:GetOwner():GetAimVector() * 96
        local trace = util.TraceLine({
            start = startPos,
            endpos = endPos,
            filter = self:GetOwner()
        })

        if SERVER and trace.Hit and IsValid(trace.Entity) then
            local dmgInfo = DamageInfo()
            dmgInfo:SetAttacker(self:GetOwner())
            dmgInfo:SetInflictor(self)
            dmgInfo:SetDamage(damage)
            dmgInfo:SetDamageType(DMG_GENERIC)
            dmgInfo:SetDamagePosition(trace.HitPos)
            dmgInfo:SetDamageForce(self:GetOwner():GetAimVector() * 1024)
            trace.Entity:DispatchTraceAttack(dmgInfo, startPos, endPos)
            self:GetOwner():EmitSound("physics/body/body_medium_impact_hard" .. math.random(1, 6) .. ".wav", 80)
        end

        hook.Run("PlayerThrowPunch", self:GetOwner(), trace)
        self:GetOwner():LagCompensation(false)
    end)
end

function SWEP:SecondaryAttack()
    if not IsFirstTimePredicted() then return end
    local data = {}
    data.start = self:GetOwner():GetShootPos()
    data.endpos = data.start + self:GetOwner():GetAimVector() * 84
    data.filter = {self, self:GetOwner()}
    local trace = util.TraceLine(data)
    local entity = trace.Entity
    if CLIENT then
        local viewModel = self:GetOwner():GetViewModel()
        if IsValid(viewModel) then
            viewModel:SetPlaybackRate(0.5)
            self.NextAllowedPlayRateChange = CurTime() + viewModel:SequenceDuration() * 2
        end
    end

    if SERVER and IsValid(entity) then
        if entity:isDoor() then
            if hook.Run("CanPlayerKnock", self:GetOwner(), entity) == false then return end
            self:GetOwner():ViewPunch(self.KnockViewPunchAngle)
            self:GetOwner():EmitSound("physics/wood/wood_crate_impact_hard" .. math.random(2, 3) .. ".wav")
            self:GetOwner():SetAnimation(PLAYER_ATTACK1)
            self:DoPunchAnimation()
            self:SetNextSecondaryFire(CurTime() + 0.4)
            self:SetNextPrimaryFire(CurTime() + 1)
        elseif entity:IsPlayer() and lia.config.get("AllowPush", true) then
            local direction = self:GetOwner():GetAimVector() * (300 + self:GetOwner():getChar():getAttrib("strength", 0) * 3)
            direction.z = 0
            entity:SetVelocity(direction)
            self:GetOwner():EmitSound("Weapon_Crossbow.BoltHitBody")
            self:SetNextSecondaryFire(CurTime() + 1.5)
            self:SetNextPrimaryFire(CurTime() + 1.5)
        elseif not entity:IsNPC() and self:CanHoldObject(entity) then
            self:GetOwner():setLocalVar("IsHoldingObject", true)
            self:PickupObject(entity)
            self:PlayPickupSound(trace.SurfaceProps)
            self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
        end
    end
end

function SWEP:Reload()
    if not IsFirstTimePredicted() then return end
    if SERVER and IsValid(self.heldEntity) then self:DropObject() end
end


-- ./modules/characters/attributes/libraries/client.lua
local predictedStamina = 100
local stmBlurAmount = 0
local stmBlurAlpha = 0
function MODULE:ConfigureCharacterCreationSteps(panel)
    panel:addStep(vgui.Create("liaCharacterAttribs"), 98)
end

function MODULE:Think()
    local client = LocalPlayer()
    if not client:getChar() then return end
    local character = client:getChar()
    local maxStamina = character:getMaxStamina()
    local offset = self:CalcStaminaChange(client)
    offset = math.Remap(FrameTime(), 0, 0.25, 0, offset)
    if offset ~= 0 then predictedStamina = math.Clamp(predictedStamina + offset, 0, maxStamina) end
end

function MODULE:HUDPaintBackground()
    local client = LocalPlayer()
    if not lia.config.get("StaminaBlur", false) or not client:getChar() then return end
    local character = client:getChar()
    local maxStamina = character:getMaxStamina()
    local Stamina = client:getLocalVar("stamina", maxStamina)
    if Stamina <= lia.config.get("StaminaBlurThreshold", 25) then
        stmBlurAlpha = Lerp(RealFrameTime() / 2, stmBlurAlpha, 255)
        stmBlurAmount = Lerp(RealFrameTime() / 2, stmBlurAmount, 5)
        lia.util.drawBlurAt(0, 0, ScrW(), ScrH(), stmBlurAmount, 0.2, stmBlurAlpha)
    end
end

function MODULE:LoadCharInformation()
    local client = LocalPlayer()
    if not IsValid(client) then return end
    local char = client:getChar()
    if not char then return end
    hook.Run("AddSection", L("attributes"), Color(0, 0, 0), 2, 1)
    local attrs = {}
    for id, attr in pairs(lia.attribs.list) do
        attrs[#attrs + 1] = {
            id = id,
            attr = attr
        }
    end

    table.sort(attrs, function(a, b) return a.attr.name < b.attr.name end)
    for _, entry in ipairs(attrs) do
        local id, attr = entry.id, entry.attr
        local minVal = attr.min or 0
        local maxVal = attr.max or 100
        hook.Run("AddBarField", L("attributes"), id, attr.name, function() return minVal end, function() return maxVal end, function() return char:getAttrib(id) end)
    end
end

lia.bar.add(function()
    local client = LocalPlayer()
    return client:getLocalVar("stamina", 0) / 100
end, Color(200, 200, 40), nil, "stamina")

-- ./modules/characters/attributes/libraries/server.lua
function MODULE:PostPlayerLoadout(client)
    local uniqueID = "StamCheck" .. client:SteamID64()
    local character = client:getChar()
    if character and character:getInv() then
        lia.attribs.setup(client)
        for _, item in pairs(character:getInv():getItems()) do
            item:call("onLoadout", client)
            if item:getData("equip") and istable(item.attribBoosts) then
                for attribute, boost in pairs(item.attribBoosts) do
                    character:addBoost(item.uniqueID, attribute, boost)
                end
            end
        end
    end

    timer.Create(uniqueID, 0.25, 0, function()
        if not IsValid(client) then
            timer.Remove(uniqueID)
            return
        end

        self:CalcStaminaChange(client)
    end)
end

function MODULE:KeyRelease(client, key)
    if key == IN_ATTACK2 then
        local wep = client:GetActiveWeapon()
        if IsValid(wep) and wep.IsHands and wep.ReadyToPickup then wep:Pickup() end
    end

    if lia.config.get("StaminaSlowdown", true) and key == IN_JUMP and not client:isNoClipping() and client:getChar() and not client:InVehicle() and client:Alive() then
        client:consumeStamina(15)
        local stm = client:getLocalVar("stamina", 0)
        if stm == 0 then
            client:setNetVar("brth", true)
            client:ConCommand("-speed")
        end
    end
end

function MODULE:KeyPress(client, key)
    if key == IN_ATTACK2 and IsValid(client.Grabbed) then
        client:DropObject(client.Grabbed)
        client.Grabbed = NULL
    end
end

function MODULE:PlayerLoadedChar(client, character)
    local maxstm = character:getMaxStamina()
    timer.Simple(0.25, function() client:setLocalVar("stamina", maxstm) end)
end

function MODULE:PlayerStaminaLost(client)
    if client.isBreathing then return end
    client:EmitSound("player/breathe1.wav", 35, 100)
    client.isBreathing = true
    timer.Create("liaStamBreathCheck" .. client:SteamID64(), 1, 0, function()
        if client:getLocalVar("stamina", 0) < lia.config.get("StaminaBreathingThreshold", 50) then return end
        client:StopSound("player/breathe1.wav")
        client.isBreathing = nil
        timer.Remove("liaStamBreathCheck" .. client:SteamID64())
    end)
end

function MODULE:OnCharAttribBoosted(client, character, attribID)
    local attribute = lia.attribs.list[attribID]
    if attribute and isfunction(attribute.OnSetup) then attribute:OnSetup(client, character:getAttrib(attribID, 0)) end
end

net.Receive("ChangeAttribute", function(_, client)
    if not client:hasPrivilege("Commands - Manage Attributes") then return end
    local charID = net.ReadInt(32)
    local _ = net.ReadTable()
    local attribKey = net.ReadString()
    local amountStr = net.ReadString()
    local mode = net.ReadString()
    if not attribKey or not lia.attribs.list[attribKey] then
        for k, v in pairs(lia.attribs.list) do
            if lia.util.stringMatches(L(v.name), attribKey) or lia.util.stringMatches(k, attribKey) then
                attribKey = k
                break
            end
        end
    end

    if not attribKey or not lia.attribs.list[attribKey] then
        client:notifyLocalized("invalidAttributeKey")
        return
    end

    local attribValue = tonumber(amountStr)
    if not attribValue then
        client:notifyLocalized("invalidAmount")
        return
    end

    local targetClient = lia.char.getBySteamID(charID)
    if not IsValid(targetClient) then
        client:notifyLocalized("characterNotFound")
        return
    end

    local targetChar = targetClient:getChar()
    if not targetChar then
        client:notifyLocalized("characterNotFound")
        return
    end

    if mode == "Set" then
        if attribValue < 0 then
            client:notifyLocalized("attribNonNegative")
            return
        end

        targetChar:setAttrib(attribKey, attribValue)
        client:notifyLocalized("attribSet", targetChar:getPlayer():Name(), L(lia.attribs.list[attribKey].name), attribValue)
        targetChar:getPlayer():notifyLocalized("yourAttributeSet", lia.attribs.list[attribKey].name, attribValue, client:Nick())
    elseif mode == "Add" then
        if attribValue <= 0 then
            client:notifyLocalized("attribPositive")
            return
        end

        local current = targetChar:getAttrib(attribKey, 0) or 0
        local newValue = current + attribValue
        if not isnumber(newValue) or newValue < 0 then
            client:notifyLocalized("attribCalculationError")
            return
        end

        targetChar:updateAttrib(attribKey, newValue)
        client:notifyLocalized("attribUpdate", targetChar:getPlayer():Name(), L(lia.attribs.list[attribKey].name), attribValue)
        targetChar:getPlayer():notifyLocalized("yourAttributeIncreased", lia.attribs.list[attribKey].name, attribValue, client:Nick())
    else
        client:notifyLocalized("invalidMode")
    end
end)

-- ./modules/characters/attributes/libraries/shared.lua
function MODULE:CalcStaminaChange(client)
    local character = client:getChar()
    if not character or client:isNoClipping() then return 0 end
    local walkSpeed = client:GetWalkSpeed()
    local offset = 0
    if not client:getNetVar("brth", false) and client:KeyDown(IN_SPEED) and client:GetVelocity():LengthSqr() >= walkSpeed * walkSpeed and client:OnGround() then
        offset = -1
        offset = hook.Run("AdjustStaminaOffsetRunning", client, offset) or -1
    else
        offset = hook.Run("AdjustStaminaRegeneration", client, offset) or 2
    end

    offset = hook.Run("AdjustStaminaOffset", client, offset) or offset
    if CLIENT then
        return offset
    else
        local maxStamina = character:getMaxStamina()
        local current = client:getLocalVar("stamina", 0)
        local value = math.Clamp(current + offset, 0, maxStamina)
        if current ~= value then
            client:setLocalVar("stamina", value)
            if value == 0 and not client:getNetVar("brth", false) then
                client:setNetVar("brth", true)
                hook.Run("PlayerStaminaLost", client)
            elseif value >= maxStamina * 0.5 and client:getNetVar("brth", false) then
                client:setNetVar("brth", nil)
                hook.Run("PlayerStaminaGained", client)
            end
        end
    end
end

function MODULE:StartCommand(client, cmd)
    if lia.config.get("StaminaSlowdown", true) and not client:isNoClipping() and client:getNetVar("brth", false) and cmd:KeyDown(IN_JUMP) then cmd:RemoveKey(IN_JUMP) end
end

function MODULE:SetupMove(client, cMoveData)
    if not lia.config.get("StaminaSlowdown", true) then return end
    if client:getNetVar("brth", false) then
        cMoveData:SetMaxClientSpeed(client:GetWalkSpeed())
    elseif client:WaterLevel() > 1 then
        cMoveData:SetMaxClientSpeed(client:GetRunSpeed() * 0.775)
    end
end

function MODULE:GetAttributeMax(_, attribute)
    local attribTable = lia.attribs.list[attribute]
    if not attribTable then return lia.config.get("MaxAttributePoints") end
    if istable(attribTable) and isnumber(attribTable.maxValue) then return attribTable.maxValue end
    return lia.config.get("MaxAttributePoints")
end

function MODULE:GetAttributeStartingMax(_, attribute)
    local attribTable = lia.attribs.list[attribute]
    if not attribTable then return lia.config.get("MaxStartingAttributes") end
    if istable(attribTable) and isnumber(attribTable.startingMax) then return attribTable.startingMax end
    return lia.config.get("MaxStartingAttributes")
end

function MODULE:GetMaxStartingAttributePoints()
    return lia.config.get("StartingAttributePoints")
end

-- ./modules/characters/attributes/module.lua
MODULE.name = "Attributes"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds Several Character Tied Attributes That Influence Gameplay"


-- ./modules/characters/inventory/libraries/client.lua
function MODULE:CreateInventoryPanel(inventory, parent)
    local panel = vgui.Create("liaGridInventory", parent)
    panel:setInventory(inventory)
    panel:Center()
    return panel
end

function MODULE:getItemStackKey(item)
    local elements = {}
    for key, value in SortedPairs(item.data) do
        elements[#elements + 1] = key
        elements[#elements + 1] = value
    end
    return item.uniqueID .. pon.encode(elements)
end

function MODULE:getItemStacks(inventory)
    local stacks = {}
    local stack, key
    for _, item in SortedPairs(inventory:getItems()) do
        key = self:getItemStackKey(item)
        stack = stacks[key] or {}
        stack[#stack + 1] = item
        stacks[key] = stack
    end
    return stacks
end

local panelMeta = FindMetaTable("Panel")
function panelMeta:liaListenForInventoryChanges(inventory)
    assert(inventory, "No inventory has been set!")
    local id = inventory:getID()
    self:liaDeleteInventoryHooks(id)
    _LIA_INV_PANEL_ID = (_LIA_INV_PANEL_ID or 0) + 1
    local hookID = "liaInventoryListener" .. _LIA_INV_PANEL_ID
    self.liaHookID = self.liaHookID or {}
    self.liaHookID[id] = hookID
    self.liaToRemoveHooks = self.liaToRemoveHooks or {}
    self.liaToRemoveHooks[id] = {}
    local function listenForInventoryChange(name, panelHook)
        panelHook = panelHook or name
        hook.Add(name, hookID, function(inventory, ...)
            if not IsValid(self) then return end
            if not isfunction(self[panelHook]) then return end
            local args = {...}
            args[#args + 1] = inventory
            self[panelHook](self, unpack(args))
            if name == "InventoryDeleted" and self.deleteInventoryHooks then self:deleteInventoryHooks(id) end
        end)

        table.insert(self.liaToRemoveHooks[id], name)
    end

    listenForInventoryChange("InventoryInitialized")
    listenForInventoryChange("InventoryDeleted")
    listenForInventoryChange("InventoryDataChanged")
    listenForInventoryChange("InventoryItemAdded")
    listenForInventoryChange("InventoryItemRemoved")
    hook.Add("ItemDataChanged", hookID, function(item, key, oldValue, newValue)
        if not IsValid(self) or not inventory.items[item:getID()] then return end
        if not isfunction(self.InventoryItemDataChanged) then return end
        self:InventoryItemDataChanged(item, key, oldValue, newValue, inventory)
    end)

    table.insert(self.liaToRemoveHooks[id], "ItemDataChanged")
end

function panelMeta:liaDeleteInventoryHooks(id)
    if not self.liaHookID then return end
    if id == nil then
        for invID, hookIDs in pairs(self.liaToRemoveHooks) do
            for i = 1, #hookIDs do
                if IsValid(self.liaHookID) then hook.Remove(hookIDs[i], self.liaHookID) end
            end

            self.liaToRemoveHooks[invID] = nil
        end
        return
    end

    if not self.liaHookID[id] then return end
    for i = 1, #self.liaToRemoveHooks[id] do
        hook.Remove(self.liaToRemoveHooks[id][i], self.liaHookID[id])
    end

    self.liaToRemoveHooks[id] = nil
end

-- ./modules/characters/inventory/libraries/server.lua
local function CanAccessIfPlayerHasAccessToBag(inventory, action, context)
    local bagItemID = inventory:getData("item")
    if not bagItemID then return end
    local bagItem = lia.item.instances[bagItemID]
    if not bagItem then return false, L("invalidBagItem") end
    local parentInv = lia.inventory.instances[bagItem.invID]
    if parentInv == inventory then return end
    local contextWithBagInv = {}
    for key, value in pairs(context) do
        contextWithBagInv[key] = value
    end

    contextWithBagInv.bagInv = inventory
    return parentInv and parentInv:canAccess(action, contextWithBagInv) or false, L("noAccess")
end

local function CanNotTransferBagIntoBag(_, action, context)
    if action ~= "transfer" then return end
    local item, toInventory = context.item, context.to
    if toInventory and toInventory:getData("item") and item.isBag then return false, L("bagIntoBagError") end
end

local function CanNotTransferBagIfNestedItemCanNotBe(_, action, context)
    if action ~= "transfer" then return end
    local item = context.item
    if not item.isBag then return end
    local bagInventory = item:getInv()
    if not bagInventory then return end
    for _, item in pairs(bagInventory:getItems()) do
        local canTransferItem, reason = hook.Run("CanItemBeTransfered", item, bagInventory, bagInventory, context.client)
        if canTransferItem == false then return false, reason or L("nestedItemTransferError") end
    end
end

function MODULE:SetupBagInventoryAccessRules(inventory)
    inventory:addAccessRule(CanNotTransferBagIntoBag, 1)
    inventory:addAccessRule(CanNotTransferBagIfNestedItemCanNotBe, 1)
    inventory:addAccessRule(CanAccessIfPlayerHasAccessToBag)
end

function MODULE:ItemCombine(client, item, target)
    if target.onCombine and target:call("onCombine", client, nil, item) then return end
    if item.onCombineTo and item and item:call("onCombineTo", client, nil, target) then return end
end

function MODULE:ItemDraggedOutOfInventory(client, item)
    item:interact("drop", client)
end

function MODULE:HandleItemTransferRequest(client, itemID, x, y, invID)
    local inventory = lia.inventory.instances[invID]
    local item = lia.item.instances[itemID]
    if not item then return end
    local oldInventory = lia.inventory.instances[item.invID]
    if not oldInventory or not oldInventory.items[itemID] then return end
    local status, reason = hook.Run("CanItemBeTransfered", item, oldInventory, inventory, client)
    if status == false then
        client:notify(reason or L("notNow"))
        return
    end

    local context = {
        client = client,
        item = item,
        from = oldInventory,
        to = inventory
    }

    local canTransfer, reason = oldInventory:canAccess("transfer", context)
    if not inventory then return hook.Run("ItemDraggedOutOfInventory", client, item) end
    if not canTransfer then
        if isstring(reason) then client:notifyLocalized(reason) end
        return
    end

    local oldX, oldY = item:getData("x"), item:getData("y")
    local failItemDropPos = client:getItemDropPos()
    if client.invTransferTransaction and client.invTransferTransactionTimeout > RealTime() then return end
    client.invTransferTransaction = true
    client.invTransferTransactionTimeout = RealTime()
    local function fail(err)
        client.invTransferTransaction = nil
        if err then
            print(err)
            debug.Trace()
        end

        if IsValid(client) then client:notifyLocalized("itemOnGround") end
        item:spawn(failItemDropPos)
    end

    local tryCombineWith
    local originalAddRes
    return oldInventory:removeItem(itemID, true):next(function() return inventory:add(item, x, y) end):next(function(res)
        if not res or not res.error then return end
        local conflictingItem = istable(res.error) and res.error.item
        if conflictingItem then tryCombineWith = conflictingItem end
        originalAddRes = res
        return oldInventory:add(item, oldX, oldY)
    end):next(function(res)
        if res and res.error then return res end
        if tryCombineWith and IsValid(client) and hook.Run("ItemCombine", client, item, tryCombineWith) then return end
    end):next(function(res)
        client.invTransferTransaction = nil
        if res and res.error then
            fail()
        else
            hook.Run("ItemTransfered", context)
        end
        return originalAddRes
    end):catch(fail)
end

-- ./modules/characters/inventory/module.lua
MODULE.name = "Inventory"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds Lilia's Grid Inventory"


-- ./modules/characters/inventory/submodules/storage/commands.lua
lia.command.add("storagelock", {
    privilege = "Lock Storage",
    adminOnly = true,
    desc = L("storagelockDesc"),
    syntax = "[string password]",
    onRun = function(client, arguments)
        local entity = client:getTracedEntity()
        if entity and IsValid(entity) then
            local password = table.concat(arguments, " ")
            if password ~= "" then
                entity:setNetVar("locked", true)
                entity.password = password
                client:notifyLocalized("storPass", password)
            else
                entity:setNetVar("locked", nil)
                entity.password = nil
                client:notifyLocalized("storPassRmv")
            end

            MODULE:SaveData()
        else
            client:notifyLocalized("invalidEntity")
        end
    end
})

lia.command.add("trunk", {
    adminOnly = false,
    desc = L("trunkOpenDesc"),
    syntax = nil,
    onRun = function(client)
        local entity = client:getTracedEntity()
        local maxDistance = 110
        local openTime = 0.7
        if not hook.Run("isSuitableForTrunk", entity) then
            client:notifyLocalized("notLookingAtVehicle")
            return
        end

        if client:GetPos():Distance(entity:GetPos()) > maxDistance then
            client:notifyLocalized("tooFarToOpenTrunk")
            return
        end

        client.liaStorageEntity = entity
        client:setAction(L("openingTrunk"), openTime, function()
            if client:GetPos():Distance(entity:GetPos()) > maxDistance then
                client.liaStorageEntity = nil
                return
            end

            entity.receivers[client] = true
            lia.inventory.instances[entity:getNetVar("inv")]:sync(client)
            net.Start("liaStorageOpen")
            net.WriteBool(true)
            net.WriteEntity(entity)
            net.Send(client)
            entity:EmitSound("items/ammocrate_open.wav")
        end)
    end
})

-- ./modules/characters/inventory/submodules/storage/config.lua
MODULE.Vehicles = MODULE.Vehicles or {}
MODULE.StorageDefinitions = {
    ["models/props_junk/wood_crate001a.mdl"] = {
        name = "Wood Crate",
        desc = "A crate made out of wood.",
        invType = "grid",
        invData = {
            w = 4,
            h = 4
        }
    },
    ["models/props_c17/lockers001a.mdl"] = {
        name = "Locker",
        desc = "A white locker.",
        invType = "grid",
        invData = {
            w = 4,
            h = 6
        }
    },
    ["models/props_wasteland/controlroom_storagecloset001a.mdl"] = {
        name = "Metal Closet",
        desc = "A green storage closet.",
        invType = "grid",
        invData = {
            w = 5,
            h = 7
        }
    },
    ["models/props_wasteland/controlroom_filecabinet002a.mdl"] = {
        name = "File Cabinet",
        desc = "A metal file cabinet.",
        invType = "grid",
        invData = {
            w = 3,
            h = 6
        }
    },
    ["models/props_c17/furniturefridge001a.mdl"] = {
        name = "Refrigerator",
        desc = "A metal box to keep food in",
        invType = "grid",
        invData = {
            w = 3,
            h = 4
        }
    },
    ["models/props_wasteland/kitchen_fridge001a.mdl"] = {
        name = "Large Refrigerator",
        desc = "A large metal box to keep even more food in.",
        invType = "grid",
        invData = {
            w = 4,
            h = 5
        }
    },
    ["models/props_junk/trashbin01a.mdl"] = {
        name = "Trash Bin",
        desc = "A container for junk.",
        invType = "grid",
        invData = {
            w = 1,
            h = 3
        }
    },
    ["models/items/ammocrate_smg1.mdl"] = {
        name = "Ammo Crate",
        desc = "A heavy crate for storing ammunition.",
        invType = "grid",
        invData = {
            w = 5,
            h = 3
        },
        onOpen = function(entity)
            entity:ResetSequence("Close")
            timer.Create("CloseLid" .. entity:EntIndex(), 2, 1, function() if IsValid(entity) then entity:ResetSequence("Open") end end)
        end
    }
}

MODULE.VehicleTrunk = {
    name = "Trunk",
    desc = "A car's trunk.",
    invType = "grid",
    invData = {
        w = 6,
        h = 6
    }
}


-- ./modules/characters/inventory/submodules/storage/entities/entities/lia_storage/cl_init.lua
local vectorMeta = FindMetaTable("Vector")
local toScreen = vectorMeta.ToScreen
function ENT:onDrawEntityInfo(alpha)
    local locked = self.getNetVar(self, "locked", false)
    local position = toScreen(self.LocalToWorld(self, self.OBBCenter(self)))
    local x, y = position.x, position.y
    y = y - 20
    local _, ty = lia.util.drawText(locked and "P" or "Q", x, y, ColorAlpha(locked and Color(242, 38, 19) or Color(135, 211, 124), alpha), 1, 1, "liaIconsMedium", alpha * 0.65)
    y = y + ty * .9
    local def = self:getStorageInfo()
    if def then
        y = y + ty + 1
        if def.desc then lia.util.drawText(L(def.desc), x, y, ColorAlpha(color_white, alpha), 1, 1, nil, alpha * 0.65) end
    end
end

-- ./modules/characters/inventory/submodules/storage/entities/entities/lia_storage/init.lua
local MODULE = MODULE
function ENT:Initialize()
    self:SetModel("models/props_junk/watermelon01.mdl")
    self:SetSolid(SOLID_VPHYSICS)
    self:SetUseType(SIMPLE_USE)
    self.receivers = {}
    self:getNetVar("locked", false)
    if isfunction(self.PostInitialize) then self:PostInitialize() end
    self:PhysicsInit(SOLID_VPHYSICS)
    local physObj = self:GetPhysicsObject()
    if IsValid(physObj) then
        physObj:EnableMotion(true)
        physObj:Wake()
    end
end

function ENT:setInventory(inventory)
    assert(inventory, "Storage setInventory called without an inventory!")
    self:setNetVar("id", inventory:getID())
    hook.Run("StorageInventorySet", self, inventory, false)
end

function ENT:deleteInventory()
    local inventory = self:getInv()
    if inventory then
        inventory:delete()
        if not self.liaForceDelete then hook.Run("StorageEntityRemoved", self, inventory) end
        self:setNetVar("id", nil)
    end
end

function ENT:OnRemove()
    if not self.liaForceDelete then
        if not lia.entityDataLoaded or not MODULE.loadedData then return end
        if self.liaIsSafe then return end
        if lia.shuttingDown then return end
    end

    self:deleteInventory()
    MODULE:SaveData()
end

function ENT:openInv(activator)
    local inventory = self:getInv()
    local storage = self:getStorageInfo()
    if isfunction(storage.onOpen) then storage.onOpen(self, activator) end
    if activator:GetPos():Distance(self:GetPos()) > 96 then
        activator.liaStorageEntity = nil
        return
    end

    self.receivers[activator] = true
    inventory:sync(activator)
    net.Start("liaStorageOpen")
    net.WriteBool(false)
    net.WriteEntity(self)
    net.Send(activator)
    local openSound = self:getStorageInfo().openSound
    self:EmitSound(openSound or "items/ammocrate_open.wav")
end

function ENT:Use(activator)
    if not activator:getChar() then return end
    if (activator.liaNextOpen or 0) > CurTime() then return end
    if IsValid(activator.liaStorageEntity) and (activator.liaNextOpen or 0) <= CurTime() then activator.liaStorageEntity = nil end
    local inventory = self:getInv()
    if not inventory then return end
    activator.liaStorageEntity = self
    if self:getNetVar("locked") then
        local lockSound = self:getStorageInfo().lockSound
        self:EmitSound(lockSound or "doors/default_locked.wav")
        if self.keypad then
            client.liaStorageEntity = nil
        else
            net.Start("liaStorageUnlock")
            net.WriteEntity(self)
            net.Send(activator)
        end
    else
        self:openInv(activator)
    end

    activator.liaNextOpen = CurTime() + 0.7 * 1.5
end


-- ./modules/characters/inventory/submodules/storage/entities/entities/lia_storage/shared.lua
local MODULE = MODULE
ENT.Type = "anim"
ENT.PrintName = "Storage"
ENT.Category = "Lilia"
ENT.Spawnable = false
ENT.isStorageEntity = true
ENT.DrawEntityInfo = true
function ENT:getInv()
    return lia.inventory.instances[self:getNetVar("id")]
end

function ENT:getStorageInfo()
    self.lowerModel = self.lowerModel or self:GetModel()
    return MODULE.StorageDefinitions[self.lowerModel]
end

-- ./modules/characters/inventory/submodules/storage/libraries/client.lua
local MODULE = MODULE
function MODULE:exitStorage()
    net.Start("liaStorageExit")
    net.SendToServer()
end

function MODULE:StorageUnlockPrompt()
    Derma_StringRequest(L("storPassWrite"), L("storPassWrite"), "", function(val)
        net.Start("liaStorageUnlock")
        net.WriteString(val)
        net.SendToServer()
    end)
end

function MODULE:StorageOpen(storage, isCar)
    local client = LocalPlayer()
    if isCar then
        local localInv = client:getChar() and client:getChar():getInv()
        if not localInv then return MODULE:exitStorage() end
        local localInvPanel = localInv:show()
        local storageInvPanel = storage:show()
        storageInvPanel:SetTitle(L("carTrunk"))
        localInvPanel:ShowCloseButton(true)
        storageInvPanel:ShowCloseButton(true)
        local extraWidth = (storageInvPanel:GetWide() + 4) / 2
        localInvPanel:Center()
        storageInvPanel:Center()
        localInvPanel.x = localInvPanel.x + extraWidth
        storageInvPanel:MoveLeftOf(localInvPanel, 4)
        local firstToRemove = true
        localInvPanel.oldOnRemove = localInvPanel.OnRemove
        storageInvPanel.oldOnRemove = storageInvPanel.OnRemove
        local function exitStorageOnRemove(panel)
            if firstToRemove then
                firstToRemove = false
                MODULE:exitStorage()
                local otherPanel = panel == localInvPanel and storageInvPanel or localInvPanel
                if IsValid(otherPanel) then otherPanel:Remove() end
            end

            panel:oldOnRemove()
        end

        hook.Run("OnCreateStoragePanel", localInvPanel, storageInvPanel, storage)
        localInvPanel.OnRemove = exitStorageOnRemove
        storageInvPanel.OnRemove = exitStorageOnRemove
    else
        if not IsValid(storage) then return end
        local localInv = client:getChar() and client:getChar():getInv()
        local storageInv = storage:getInv()
        if not localInv or not storageInv then return MODULE:exitStorage() end
        local localInvPanel = localInv:show()
        local storageInvPanel = storageInv:show()
        storageInvPanel:SetTitle(L(storage:getStorageInfo().name))
        localInvPanel:ShowCloseButton(true)
        storageInvPanel:ShowCloseButton(true)
        local extraWidth = (storageInvPanel:GetWide() + 4) / 2
        localInvPanel:Center()
        storageInvPanel:Center()
        localInvPanel.x = localInvPanel.x + extraWidth
        storageInvPanel:MoveLeftOf(localInvPanel, 4)
        local firstToRemove = true
        localInvPanel.oldOnRemove = localInvPanel.OnRemove
        storageInvPanel.oldOnRemove = storageInvPanel.OnRemove
        local function exitStorageOnRemove(panel)
            if firstToRemove then
                firstToRemove = false
                MODULE:exitStorage()
                local otherPanel = panel == localInvPanel and storageInvPanel or localInvPanel
                if IsValid(otherPanel) then otherPanel:Remove() end
            end

            panel:oldOnRemove()
        end

        hook.Run("OnCreateStoragePanel", localInvPanel, storageInvPanel, storage)
        localInvPanel.OnRemove = exitStorageOnRemove
        storageInvPanel.OnRemove = exitStorageOnRemove
    end
end

function MODULE:transferItem(itemID)
    if not lia.item.instances[itemID] then return end
    net.Start("liaStorageTransfer")
    net.WriteUInt(itemID, 32)
    net.SendToServer()
end


-- ./modules/characters/inventory/submodules/storage/libraries/server.lua
local RULES = {
    AccessIfStorageReceiver = function(inventory, _, context)
        local client = context.client
        if not IsValid(client) then return end
        local storage = context.storage or client.liaStorageEntity
        if not IsValid(storage) then return end
        if storage:getInv() ~= inventory then return end
        local distance = storage:GetPos():Distance(client:GetPos())
        if distance > 128 then return false end
        if storage.receivers[client] then return true end
    end,
    AccessIfCarStorageReceiver = function(_, _, context)
        local client = context.client
        if not IsValid(client) then return end
        local storage = context.storage or client.liaStorageEntity
        if not IsValid(storage) then return end
        local distance = storage:GetPos():Distance(client:GetPos())
        if distance > 128 then return false end
        if storage.receivers[client] then return true end
    end
}

function MODULE:PlayerSpawnedProp(client, model, entity)
    local data = self.StorageDefinitions[model:lower()]
    if not data then return end
    if hook.Run("CanPlayerSpawnStorage", client, entity, data) == false then return end
    local storage = ents.Create("lia_storage")
    storage:SetPos(entity:GetPos())
    storage:SetAngles(entity:GetAngles())
    storage:Spawn()
    storage:SetModel(model)
    storage:SetSolid(SOLID_VPHYSICS)
    storage:PhysicsInit(SOLID_VPHYSICS)
    lia.inventory.instance(data.invType, data.invData):next(function(inventory)
        if IsValid(storage) then
            inventory.isStorage = true
            storage:setInventory(inventory)
            self:SaveData()
            if isfunction(data.OnSpawn) then data.OnSpawn(storage) end
        end
    end, function(err)
        ErrorNoHalt("Unable to create storage entity for " .. client:Name() .. "\n" .. err .. "\n")
        if IsValid(storage) then SafeRemoveEntity(storage) end
    end)

    SafeRemoveEntity(entity)
end

function MODULE:CanPlayerSpawnStorage(client, _, info)
    if not client then return true end
    if not client:hasPrivilege("Staff Permissions - Can Spawn Storage") then return false end
    if not info.invType or not lia.inventory.types[info.invType] then return false end
end

function MODULE:CanSaveData()
    return self.SaveData
end

function MODULE:SaveData()
    local data = {}
    for _, entity in ipairs(ents.FindByClass("lia_storage")) do
        if hook.Run("CanSaveData", entity, entity:getInv()) == false then
            entity.liaForceDelete = true
            continue
        end

        if entity:getInv() then data[#data + 1] = {entity:GetPos(), entity:GetAngles(), entity:getNetVar("id"), entity:GetModel():lower(), entity.password} end
    end

    self:setData(data)
end

function MODULE:StorageItemRemoved()
    self:SaveData()
end

function MODULE:LoadData()
    local data = self:getData()
    if not data then return end
    for _, info in ipairs(data) do
        local position, angles, invID, model, password = unpack(info)
        local storage = self.StorageDefinitions[model]
        if not storage then continue end
        local storage = ents.Create("lia_storage")
        storage:SetPos(position)
        storage:SetAngles(angles)
        storage:Spawn()
        storage:SetModel(model)
        storage:SetSolid(SOLID_VPHYSICS)
        storage:PhysicsInit(SOLID_VPHYSICS)
        if password then
            storage.password = password
            storage:setNetVar("locked", true)
        end

        lia.inventory.loadByID(invID):next(function(inventory)
            if inventory and IsValid(storage) then
                inventory.isStorage = true
                storage:setInventory(inventory)
                hook.Run("StorageRestored", storage, inventory)
            elseif IsValid(storage) then
                SafeRemoveEntityDelayed(storage, 1)
            end
        end)

        local physObject = storage:GetPhysicsObject()
        if physObject then physObject:EnableMotion() end
    end

    self.loadedData = true
end

local PROHIBITED_ACTIONS = {
    ["Equip"] = true,
    ["EquipUn"] = true,
}

function MODULE:CanPlayerInteractItem(_, action, itemObject)
    local inventory = lia.inventory.instances[itemObject.invID]
    if inventory and inventory.isStorage and PROHIBITED_ACTIONS[action] then return false, "forbiddenActionStorage" end
end

function MODULE:EntityRemoved(entity)
    self.Vehicles[entity] = nil
    if not self:isSuitableForTrunk(entity) then return end
    local storageInv = lia.inventory.instances[entity:getNetVar("inv")]
    if storageInv then storageInv:delete() end
end

function MODULE:OnEntityCreated(entity)
    if not self:isSuitableForTrunk(entity) then return end
    if entity:isSimfphysCar() then
        net.Start("trunkInitStorage")
        net.WriteBool(false)
        net.WriteEntity(entity)
        net.Broadcast()
    end

    self:InitializeStorage(entity)
end

function MODULE:PlayerInitialSpawn(client)
    net.Start("trunkInitStorage")
    net.WriteBool(true)
    net.WriteTable(self.Vehicles)
    net.Send(client)
end

function MODULE:StorageInventorySet(_, inventory, isCar)
    if isCar then
        inventory:addAccessRule(RULES.AccessIfCarStorageReceiver)
    else
        inventory:addAccessRule(RULES.AccessIfStorageReceiver)
    end
end
return RULES

-- ./modules/characters/inventory/submodules/storage/libraries/shared.lua
function MODULE:isSuitableForTrunk(entity)
    if IsValid(entity) and entity:IsVehicle() then return true end
    return false
end

function MODULE:InitializeStorage(entity)
    if self.Vehicles[entity] then return end
    self.Vehicles[entity] = true
    if SERVER then
        entity.receivers = {}
        lia.inventory.instance(self.VehicleTrunk.invType, self.VehicleTrunk.invData):next(function(inv)
            inv.isStorage = true
            entity:setNetVar("inv", inv:getID())
            hook.Run("StorageInventorySet", self, inv, true)
        end)
    end
end


-- ./modules/characters/inventory/submodules/storage/module.lua
MODULE.name = "Storage"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds Storage Options for Lilia's Inventory."
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Can Spawn Storage",
        MinAccess = "superadmin",
        Description = "Allows access to Spawning Storage.",
    }
}


-- ./modules/characters/inventory/submodules/storage/netcalls/client.lua
net.Receive("liaStorageUnlock", function()
    local entity = net.ReadEntity()
    hook.Run("StorageUnlockPrompt", entity)
end)

net.Receive("liaStorageOpen", function()
    local isCar = net.ReadBool() or false
    local entity = net.ReadEntity()
    local carInv = lia.inventory.instances[entity:getNetVar("inv")]
    hook.Run("StorageOpen", isCar and carInv or entity, isCar)
end)

-- ./modules/characters/inventory/submodules/storage/netcalls/server.lua
net.Receive("liaStorageExit", function(_, client)
    local storage = client.liaStorageEntity
    if IsValid(storage) then storage.receivers[client] = nil end
    client.liaStorageEntity = nil
end)

net.Receive("liaStorageUnlock", function(_, client)
    local password = net.ReadString()
    local storageFunc = function()
        if not IsValid(client.liaStorageEntity) then return end
        if client:GetPos():Distance(client.liaStorageEntity:GetPos()) > 128 then return end
        return client.liaStorageEntity
    end

    local passwordDelay = 1
    local storage = storageFunc()
    if not storage then return end
    if client.lastPasswordAttempt and CurTime() < client.lastPasswordAttempt + passwordDelay then
        client:notifyLocalized("passwordTooQuick")
    else
        if storage.password == password then
            storage:openInv(client)
        else
            client:notifyLocalized("wrongPassword")
            client.liaStorageEntity = nil
        end

        client.lastPasswordAttempt = CurTime()
    end
end)

net.Receive("liaStorageTransfer", function(_, client)
    local itemID = net.ReadUInt(32)
    if not client:getChar() then return end
    local storageFunc = function()
        if not IsValid(client.liaStorageEntity) then return end
        if client:GetPos():Distance(client.liaStorageEntity:GetPos()) > 128 then return end
        return client.liaStorageEntity
    end

    local storage = storageFunc()
    if not storage or not storage.receivers[client] then return end
    local clientInv = client:getChar():getInv()
    local storageInv = storage:getInv()
    if not clientInv or not storageInv then return end
    local item = clientInv.items[itemID] or storageInv.items[itemID]
    if not item then return end
    local toInv = clientInv:getID() == item.invID and storageInv or clientInv
    local fromInv = toInv == clientInv and storageInv or clientInv
    if hook.Run("StorageCanTransferItem", client, storage, item) == false then return end
    local context = {
        client = client,
        item = item,
        storage = storage,
        from = fromInv,
        to = toInv
    }

    if clientInv:canAccess("transfer", context) == false or storageInv:canAccess("transfer", context) == false then return end
    if client.storageTransaction and client.storageTransactionTimeout > RealTime() then return end
    client.storageTransaction = true
    client.storageTransactionTimeout = RealTime() + 0.1
    local failItemDropPos = client:getItemDropPos()
    fromInv:removeItem(itemID, true):next(function() return toInv:add(item) end):next(function(res)
        client.storageTransaction = nil
        hook.Run("ItemTransfered", context)
        return res
    end):catch(function(err)
        client.storageTransaction = nil
        if IsValid(client) then client:notifyLocalized(err) end
        return fromInv:add(item)
    end):catch(function()
        client.storageTransaction = nil
        item:spawn(failItemDropPos)
        if IsValid(client) then client:notifyLocalized("itemOnGround") end
    end)
end)

-- ./modules/characters/inventory/submodules/storage/netcalls/shared.lua
local MODULE = MODULE
net.Receive("trunkInitStorage", function()
    local isTable = net.ReadBool()
    if isTable then
        local vehicles = net.ReadTable()
        for _, vehicle in pairs(vehicles) do
            MODULE:InitializeStorage(vehicle)
        end
    else
        local entity = net.ReadEntity()
        MODULE:InitializeStorage(entity)
    end
end)

-- ./modules/characters/recognition/config.lua
lia.config.add("RecognitionEnabled", "Character Recognition Enabled", true, nil, {
    desc = "Whether or not character recognition is enabled?",
    category = "Recognition",
    type = "Boolean"
})

lia.config.add("FakeNamesEnabled", "Fake Names Enabled", false, nil, {
    desc = "Are fake names enabled?",
    category = "Recognition",
    type = "Boolean"
})


-- ./modules/characters/recognition/libraries/client.lua
local ChatIsRecognized = {
    ic = true,
    y = true,
    w = true,
    me = true,
}

function MODULE:isRecognizedChatType(chatType)
    return ChatIsRecognized[chatType] or false
end

function MODULE:GetDisplayedDescription(client, isHUD)
    local lp = LocalPlayer()
    if not IsValid(client) or not IsValid(lp) then return L("unknown") end
    if client:getChar() and client ~= lp and lp:getChar() and not lp:getChar():doesRecognize(client:getChar():getID()) then
        if isHUD then return client:getChar():getDesc() end
        return L("noRecog")
    end
end

function MODULE:GetDisplayedName(client, chatType)
    local lp = LocalPlayer()
    if not IsValid(client) or not IsValid(lp) then return L("unknown") end
    local character = client:getChar()
    local ourCharacter = lp:getChar()
    if not character or not ourCharacter then return L("unknown") end
    local myReg = ourCharacter:getRecognizedAs()
    local characterID = character:getID()
    if not ourCharacter:doesRecognize(characterID) then
        if ourCharacter:doesFakeRecognize(characterID) and myReg[characterID] then return myReg[characterID] end
        if chatType and hook.Run("isRecognizedChatType", chatType) then return "[" .. L("unknown") .. "]" end
        return L("unknown")
    end
end

function MODULE:ShouldAllowScoreboardOverride(client, var)
    if client == LocalPlayer() then return false end
    if not IsValid(client) or not IsValid(LocalPlayer()) then return false end
    local character = client:getChar()
    local ourCharacter = LocalPlayer():getChar()
    if not character or not ourCharacter then return false end
    local isRecognitionEnabled = lia.config.get("RecognitionEnabled", true)
    local isVarHiddenInScoreboard = var == "name" or var == "model" or var == "desc" or var == "classlogo"
    local isNotRecognized = not (ourCharacter:doesRecognize(character:getID()) or ourCharacter:doesFakeRecognize(character:getID()))
    return isRecognitionEnabled and isVarHiddenInScoreboard and isNotRecognized
end

function MODULE:OnCharRecognized()
    surface.PlaySound("buttons/button17.wav")
end

function MODULE:CharRecognize(level, name)
    netstream.Start("rgn", level, name)
end

-- ./modules/characters/recognition/libraries/server.lua
function MODULE:ShowSpare1(client)
    if client:getChar() then
        net.Start("rgnMenu")
        net.Send(client)
    end
end

-- ./modules/characters/recognition/libraries/shared.lua
function MODULE:isCharRecognized(character, id)
    local client = character:getPlayer()
    local recognized = character:getData("rgn", "")
    local other = lia.char.loaded[id]
    local otherclient = other and other:getPlayer()
    if not IsValid(otherclient) then return false end
    if character.id == id then return true end
    local factionID = character:getFaction()
    local faction = factionID and lia.faction.indices[factionID]
    if faction and faction.RecognizesGlobally then return true end
    local otherFactionID = other and other:getFaction()
    local otherFaction = otherFactionID and lia.faction.indices[otherFactionID]
    if otherFaction then
        if otherFaction.isGloballyRecognized then return true end
        if factionID == otherFactionID and otherFaction.MemberToMemberAutoRecognition then return true end
    end

    if client:isStaffOnDuty() or otherclient:isStaffOnDuty() then return true end
    if recognized ~= "" and recognized:find("," .. id .. ",") then return true end
    return false
end

function MODULE:isCharFakeRecognized(character, id)
    local other = lia.char.loaded[id]
    local CharNameList = character:getRecognizedAs()
    local clientName = CharNameList[other:getID()]
    return lia.config.get("FakeNamesEnabled", false) and self:isFakeNameExistant(clientName, CharNameList)
end

function MODULE:isFakeNameExistant(name, nameList)
    for _, n in pairs(nameList) do
        if n == name then return true end
    end
    return false
end


-- ./modules/characters/recognition/module.lua
MODULE.name = "Recognition"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds the ability to recognize people / You can also allow auto faction recognition."


-- ./modules/characters/recognition/netcalls/client.lua
local MODULE = MODULE
net.Receive("rgnDone", function()
    local client = LocalPlayer()
    hook.Run("OnCharRecognized", client, client:getChar():getID())
end)

net.Receive("rgnMenu", function()
    local menu = DermaMenu()
    menu:AddOption(L("recogMenuOptionWhisper"), function() MODULE:CharRecognize(2) end)
    menu:AddOption(L("recogMenuOptionTalk"), function() MODULE:CharRecognize(3) end)
    menu:AddOption(L("recogMenuOptionYell"), function() MODULE:CharRecognize(4) end)
    if lia.config.get("FakeNamesEnabled", false) then
        menu:AddOption(L("recogMenuOptionFakeWhisper"), function() Derma_StringRequest(L("recogMenuOptionFakeWhisper"), L("recogFakeNamePrompt"), "", function(text) if text then MODULE:CharRecognize(2, text) end end) end)
        menu:AddOption(L("recogMenuOptionFakeTalk"), function() Derma_StringRequest(L("recogMenuOptionFakeTalk"), L("recogFakeNamePrompt"), "", function(text) if text then MODULE:CharRecognize(3, text) end end) end)
        menu:AddOption(L("recogMenuOptionFakeYell"), function() Derma_StringRequest(L("recogMenuOptionFakeYell"), L("recogFakeNamePrompt"), "", function(text) if text then MODULE:CharRecognize(4, text) end end) end)
    end

    menu:Open()
    menu:MakePopup()
    menu:Center()
end)

-- ./modules/characters/recognition/netcalls/server.lua
net.Receive("rgnDirect", function(_, client)
    local target = net.ReadEntity()
    local name = net.ReadString()
    if target:GetPos():DistToSqr(client:GetPos()) > 100000 then return end
    if target:getChar():recognize(client:getChar(), name) then
        net.Start("rgnDone")
        net.Send(client)
        hook.Run("OnCharRecognized", client, client:getChar())
        lia.log.add(client, "charRecognize", target:getChar():getID(), name)
        client:notifyLocalized("recognized")
    else
        client:notifyLocalized("already_recognized")
    end
end)

net.Receive("rgn", function(_, client)
    local level = net.ReadInt(32)
    local name = net.ReadString()
    local targets = {}
    if isnumber(level) then
        local class = "w"
        if level == 3 then
            class = "ic"
        elseif level == 4 then
            class = "y"
        end

        class = lia.chat.classes[class]
        for _, v in player.Iterator() do
            if client == v then continue end
            if v:getChar() and class.onCanHear(client, v) then targets[#targets + 1] = v end
        end
    end

    if targets[1] then
        local i = 0
        for _, v in ipairs(targets) do
            if v:getChar():recognize(client:getChar(), name) then i = i + 1 end
        end

        if i > 0 then
            for _, v in ipairs(targets) do
                lia.log.add(client, "charRecognize", v:getChar():getID(), name)
            end

            net.Start("rgnDone")
            net.Send(client)
            hook.Run("OnCharRecognized", client)
        end
    end
end)

-- ./modules/characters/recognition/pim.lua
local MODULE = MODULE
AddAction(L("recognizeInWhisperRange"), {
    shouldShow = function(client) return client:getChar() and client:Alive() end,
    onRun = function() MODULE:CharRecognize(2) end,
    runServer = false
})

AddAction(L("recognizeInTalkRange"), {
    shouldShow = function(client) return client:getChar() and client:Alive() end,
    onRun = function() MODULE:CharRecognize(3) end,
    runServer = false
})

AddAction(L("recognizeInYellRange"), {
    shouldShow = function(client) return client:getChar() and client:Alive() end,
    onRun = function() MODULE:CharRecognize(4) end,
    runServer = false
})

AddInteraction(L("recognizeOption"), {
    runServer = false,
    shouldShow = function(client, target)
        local ourChar = client:getChar()
        local tarCharID = target:getChar():getID()
        return not hook.Run("isCharRecognized", ourChar, tarCharID)
    end,
    onRun = function(_, target) if CLIENT then netstream.Start("rgnDirect", target) end end
})

AddInteraction(L("recognizeWithFakeNameOption"), {
    runServer = false,
    shouldShow = function(client, target)
        local ourChar = client:getChar()
        local tarCharID = target:getChar():getID()
        return not hook.Run("isCharRecognized", ourChar, tarCharID) and lia.config.get("FakeNamesEnabled", false)
    end,
    onRun = function(_, target)
        local tarChar = target:getChar()
        if CLIENT then Derma_StringRequest(L("recogMenuOptionFakeWhisper"), L("recogFakeNamePrompt"), tarChar:getName(), function(text) if text then netstream.Start("rgnDirect", target, text) end end) end
    end
})

-- ./modules/core/administration/commands.lua
lia.command.add("adminmode", {
    desc = L("adminModeDesc"),
    onRun = function(client)
        if not IsValid(client) then return end
        local steamID = client:SteamID64()
        if client:isStaffOnDuty() then
            local oldCharID = client:getNetVar("OldCharID", 0)
            if oldCharID > 0 then
                net.Start("AdminModeSwapCharacter")
                net.WriteInt(oldCharID, 32)
                net.Send(client)
                client:setNetVar("OldCharID", nil)
                lia.log.add(client, "adminMode", oldCharID, "Switched back to their IC character")
            else
                client:ChatPrint(L("noPrevChar"))
            end
        else
            lia.db.query(string.format("SELECT * FROM lia_characters WHERE _steamID = \"%s\"", lia.db.escape(steamID)), function(data)
                for _, row in ipairs(data) do
                    local id = tonumber(row._id)
                    if row._faction == "staff" then
                        client:setNetVar("OldCharID", client:getChar():getID())
                        net.Start("AdminModeSwapCharacter")
                        net.WriteInt(id, 32)
                        net.Send(client)
                        lia.log.add(client, "adminMode", id, "Switched to their staff character")
                        return
                    end
                end

                client:ChatPrint(L("noStaffChar"))
            end)
        end
    end
})

lia.command.add("setsitroom", {
    superAdminOnly = true,
    privilege = "Manage SitRooms",
    desc = L("setSitroomDesc"),
    onRun = function(client)
        local pos = client:GetPos()
        local mapName = game.GetMap()
        local sitrooms = lia.data.get("sitrooms", {}, true, true)
        sitrooms[mapName] = pos
        lia.data.set("sitrooms", sitrooms, true, true)
        client:notifyLocalized("sitroomSet")
        lia.log.add(client, "sitRoomSet", string.format("Map: %s | Position: %s", mapName, tostring(pos)), "Set the sitroom location for the current map")
    end
})

lia.command.add("sendtositroom", {
    adminOnly = true,
    privilege = "Manage SitRooms",
    desc = L("sendToSitRoomDesc"),
    syntax = "[string charname]",
    AdminStick = {
        Name = L("sendToSitRoom"),
        Category = L("Moderation Tools"),
        SubCategory = L("misc"),
        Icon = "icon16/arrow_down.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local mapName = game.GetMap()
        local sitrooms = lia.data.get("sitrooms", {}, true, true)
        local pos = sitrooms[mapName]
        if pos then
            target:SetPos(pos)
            client:notifyLocalized("sitroomTeleport", target:Nick())
            target:notifyLocalized("sitroomArrive")
            lia.log.add(client, "sendToSitRoom", string.format("Map: %s | Target: %s | Position: %s", mapName, target:Nick(), tostring(pos)), "Teleported player to the sitroom for the current map")
        else
            client:notifyLocalized("sitroomNotSet")
        end
    end
})

-- ./modules/core/administration/libraries/client.lua
function MODULE:ShowPlayerOptions(target, options)
    local client = LocalPlayer()
    if (client:hasPrivilege("Staff Permissions - Can Access Scoreboard Info Out Of Staff") or client:hasPrivilege("Staff Permissions - Can Access Scoreboard Admin Options") and client:isStaffOnDuty()) and IsValid(target) then
        local orderedOptions = {
            {
                name = "Name: " .. target:Name() .. " (copy)",
                image = "icon16/page_copy.png",
                func = function()
                    client:ChatPrint("Copied " .. target:Name() .. " to Clipboard!")
                    SetClipboardText(target:Name())
                end
            },
            {
                name = "CharID: " .. (target:getChar() and target:getChar():getID() or "N/A") .. " (copy)",
                image = "icon16/page_copy.png",
                func = function()
                    if target:getChar() then
                        client:ChatPrint("Copied CharID: " .. target:getChar():getID() .. " to Clipboard!")
                        SetClipboardText(target:getChar():getID())
                    end
                end
            },
            {
                name = "SteamID: " .. target:SteamID() .. " (copy)",
                image = "icon16/page_copy.png",
                func = function()
                    client:ChatPrint("Copied SteamID: " .. target:SteamID() .. " to Clipboard!")
                    SetClipboardText(target:SteamID())
                end
            },
            {
                name = "SteamID64: " .. target:SteamID64() .. " (copy)",
                image = "icon16/page_copy.png",
                func = function()
                    client:ChatPrint("Copied SteamID64: " .. target:SteamID64() .. " to Clipboard!")
                    SetClipboardText(target:SteamID64())
                end
            },
            {
                name = "Blind",
                image = "icon16/eye.png",
                func = function() RunConsoleCommand("say", "!blind " .. target:SteamID()) end
            },
            {
                name = "Freeze",
                image = "icon16/lock.png",
                func = function() RunConsoleCommand("say", "!freeze " .. target:SteamID()) end
            },
            {
                name = "Gag",
                image = "icon16/sound_mute.png",
                func = function() RunConsoleCommand("say", "!gag " .. target:SteamID()) end
            },
            {
                name = "Ignite",
                image = "icon16/fire.png",
                func = function() RunConsoleCommand("say", "!ignite " .. target:SteamID()) end
            },
            {
                name = "Jail",
                image = "icon16/lock.png",
                func = function() RunConsoleCommand("say", "!jail " .. target:SteamID()) end
            },
            {
                name = "Mute",
                image = "icon16/sound_delete.png",
                func = function() RunConsoleCommand("say", "!mute " .. target:SteamID()) end
            },
            {
                name = "Slay",
                image = "icon16/bomb.png",
                func = function() RunConsoleCommand("say", "!slay " .. target:SteamID()) end
            },
            {
                name = "Unblind",
                image = "icon16/eye.png",
                func = function() RunConsoleCommand("say", "!unblind " .. target:SteamID()) end
            },
            {
                name = "Ungag",
                image = "icon16/sound_low.png",
                func = function() RunConsoleCommand("say", "!ungag " .. target:SteamID()) end
            },
            {
                name = "Unfreeze",
                image = "icon16/accept.png",
                func = function() RunConsoleCommand("say", "!unfreeze " .. target:SteamID()) end
            },
            {
                name = "Unmute",
                image = "icon16/sound_add.png",
                func = function() RunConsoleCommand("say", "!unmute " .. target:SteamID()) end
            },
            {
                name = "Bring",
                image = "icon16/arrow_down.png",
                func = function() RunConsoleCommand("say", "!bring " .. target:SteamID()) end
            },
            {
                name = "Goto",
                image = "icon16/arrow_right.png",
                func = function() RunConsoleCommand("say", "!goto " .. target:SteamID()) end
            },
            {
                name = "Respawn",
                image = "icon16/arrow_refresh.png",
                func = function() RunConsoleCommand("say", "!respawn " .. target:SteamID()) end
            },
            {
                name = "Return",
                image = "icon16/arrow_redo.png",
                func = function() RunConsoleCommand("say", "!return " .. target:SteamID()) end
            }
        }

        for _, option in ipairs(orderedOptions) do
            table.insert(options, option)
        end
    end
end

-- ./modules/core/administration/libraries/server.lua
function MODULE:OnReloaded()
    for _, client in player.Iterator() do
        if IsValid(client) and client:IsPlayer() then client:ConCommand("spawnmenu_reload") end
    end
end

function MODULE:PlayerSpawn(client)
    if IsValid(client) and client:IsPlayer() then client:ConCommand("spawnmenu_reload") end
end




-- ./modules/core/administration/libraries/shared.lua
function MODULE:CanPlayerUseConfig(client)
    return client:hasPrivilege("Staff Permissions - Access Configuration Menu")
end

function MODULE:CanPlayerModifyConfig(client)
    return client:hasPrivilege("Staff Permissions - Access Edit Configuration Menu")
end


-- ./modules/core/administration/module.lua
MODULE.name = "Administration Utilities"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds some Administration Utilities"
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Can Remove Warnrs",
        MinAccess = "superadmin",
        Description = "Allows access to Removing Player Warnings.",
    },
    {
        Name = "Staff Permissions - Access Configuration Menu",
        MinAccess = "superadmin",
        Description = "Allows access to Access Configuration Menu.",
    },
    {
        Name = "Staff Permissions - Access Edit Configuration Menu",
        MinAccess = "superadmin",
        Description = "Allows access to Access Configuration Menu.",
    },
}

hook.Remove("PlayerSay", "ULXMeCheck")


-- ./modules/core/administration/netcalls/client.lua
netstream.Hook("cfgList", function(data)
    for k, v in pairs(data) do
        if lia.config.stored[k] then lia.config.stored[k].value = v end
    end

    hook.Run("InitializedConfig", data)
end)

netstream.Hook("cfgSet", function(key, value)
    local config = lia.config.stored[key]
    if config then
        if config.callback then config.callback(config.value, value) end
        config.value = value
        local properties = lia.gui.properties
        if IsValid(properties) then
            local row = properties:GetCategory(L(config.data and config.data.category or "misc")):GetRow(key)
            if IsValid(row) then
                if istable(value) and value.r and value.g and value.b then value = Vector(value.r / 255, value.g / 255, value.b / 255) end
                row:SetValue(value)
            end
        end
    end
end)

net.Receive("AdminModeSwapCharacter", function()
    local id = net.ReadInt(32)
    assert(isnumber(id), "id must be a number")
    local d = deferred.new()
    net.Receive("liaCharChoose", function()
        local message = net.ReadString()
        if message == "" then
            d:resolve()
            hook.Run("CharLoaded", lia.char.loaded[id])
        else
            d:reject(message)
        end
    end)

    net.Start("liaCharChoose")
    net.WriteUInt(id, 32)
    net.SendToServer()
end)


-- ./modules/core/administration/netcalls/server.lua
netstream.Hook("cfgSet", function(client, key, name, value)
    if type(lia.config.stored[key].default) == type(value) and hook.Run("CanPlayerModifyConfig", client, key) ~= false then
        local oldValue = lia.config.stored[key].value
        lia.config.set(key, value)
        if istable(value) then
            local value2 = "["
            local count = table.Count(value)
            local i = 1
            for _, v in SortedPairs(value) do
                value2 = value2 .. v .. (i == count and "]" or ", ")
                i = i + 1
            end

            value = value2
        end

        client:notifyLocalized("cfgSet", client:Name(), name, tostring(value))
        lia.log.add(client, "configChange", name, tostring(oldValue), tostring(value))
    end
end)

-- ./modules/core/administration/submodules/adminstick/entities/weapons/adminstick/cl_init.lua
local MODULE = MODULE

function SWEP:PrimaryAttack()
    local target = self:GetTarget()
    local client = LocalPlayer()
    if IsValid(target) then
        client.AdminStickTarget = target
        MODULE:OpenAdminStickUI(target)
    end
end

function SWEP:SecondaryAttack()
    local client = LocalPlayer()
    if not IsFirstTimePredicted() then return end
    local target = self:GetTarget()
    if IsValid(target) and target:IsPlayer() and target ~= client then
        local cmd = target:IsFrozen() and (sam and "sam unfreeze" or ulx and "ulx unfreeze") or sam and "sam freeze" or ulx and "ulx freeze"
        client:ConCommand(cmd .. " " .. target:SteamID())
    else
        client:notify("You cannot freeze this!")
    end
end

function SWEP:GetTarget()
    local client = LocalPlayer()
    local target = IsValid(client.AdminStickTarget) and client.AdminStickTarget or client:GetEyeTrace().Entity
    return target
end

function SWEP:DrawHUD()
    local client = LocalPlayer()
    local x, y = ScrW() / 2, ScrH() / 2
    local target = IsValid(client.AdminStickTarget) and client.AdminStickTarget or client:GetEyeTrace().Entity
    local crossColor = Color(0, 255, 0)
    local information = {}
    if IsValid(target) then
        if not target:IsPlayer() then
            if target.GetCreator and IsValid(target:GetCreator()) then table.Add(information, {"Entity Class: " .. target:GetClass(), "Creator: " .. tostring(target:GetCreator())}) end
            if target:IsVehicle() and IsValid(target:GetDriver()) then target = target:GetDriver() end
        end

        if target:IsPlayer() then
            information = {"Nickname: " .. target:Nick(), "Steam Name: " .. (target.SteamName and target:SteamName() or target:Name()), "Steam ID: " .. target:SteamID(), "SteamID64: " .. target:SteamID64(), "Health: " .. target:Health(), "Armor: " .. target:Armor(), "Usergroup: " .. target:GetUserGroup()}
            if target:getChar() then
                local char = target:getChar()
                local faction = lia.faction.indices[target:Team()]
                table.Add(information, {"Character Name: " .. char:getName(), "Character Faction: " .. faction.name})
            else
                table.insert(information, "No Loaded Character")
            end
        end
    end

    local length, thickness = 20, 1
    surface.SetDrawColor(crossColor)
    surface.DrawRect(x - length / 2, y - thickness / 2, length, thickness)
    surface.DrawRect(x - thickness / 2, y - length / 2, thickness, length)
    local startPosX, startPosY, buffer = x - 250, y + 10, 0
    for _, v in pairs(information) do
        surface.SetFont("DebugFixed")
        surface.SetTextColor(color_black)
        surface.SetTextPos(startPosX + 1, startPosY + buffer + 1)
        surface.DrawText(v)
        surface.SetTextColor(crossColor)
        surface.SetTextPos(startPosX, startPosY + buffer)
        surface.DrawText(v)
        local _, t_h = surface.GetTextSize(v)
        buffer = buffer + t_h + 4
    end
end

function SWEP:Reload()
    if self.NextReload and self.NextReload > SysTime() then return end
    self.NextReload = SysTime() + 0.5
    local client = LocalPlayer()
    if client:KeyDown(IN_SPEED) then
        client.AdminStickTarget = client
        MODULE:OpenAdminStickUI(client)
    end
end

-- ./modules/core/administration/submodules/adminstick/entities/weapons/adminstick/shared.lua
SWEP.Author = "Samael"
SWEP.PrintName = "Admin Stick"
SWEP.Purpose = "Instructions: Press R when looking at someone to select them \nPress Shift R to select yourself \nLeft click to open menu \nRight click with selection to freeze."
SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.IsAlwaysRaised = true
SWEP.Spawnable = true
SWEP.ViewModel = Model("models/weapons/v_stunstick.mdl")
SWEP.WorldModel = Model("models/weapons/w_stunbaton.mdl")
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
function SWEP:DrawWorldModel()
    if self:GetOwner():isNoClipping() then return end
    self:DrawModel()
end

function SWEP:Initialize()
    self:SetHoldType("melee")
end


-- ./modules/core/administration/submodules/adminstick/libraries/client.lua
local MODULE = MODULE
AdminStickIsOpen = false
local subMenuIcons = {
    ["Moderation Tools"] = "icon16/wrench.png",
    ["Player Information"] = "icon16/information.png",
    ["Character Management"] = "icon16/user_gray.png",
    ["Flags Management"] = "icon16/flag_blue.png",
    ["Give Flags"] = "icon16/flag_blue.png",
    ["Take Flags"] = "icon16/flag_red.png",
}

local function GetOrCreateSubMenu(parentMenu, name, submenusTable)
    if not submenusTable[name] then
        local newSubMenu, newSubMenuPanel = parentMenu:AddSubMenu(L(name))
        if subMenuIcons[name] then newSubMenuPanel:SetIcon(subMenuIcons[name]) end
        submenusTable[name] = newSubMenu
    end
    return submenusTable[name]
end

local function GetIdentifier(target)
    if not IsValid(target) or not target:IsPlayer() then return "" end
    if target:IsBot() then return target:Name() end
    return target:SteamID64()
end

local function HandleExtraFields(commandKey, commandData, target, commandName)
    local client = LocalPlayer()
    local frame = vgui.Create("DFrame")
    frame:SetTitle(L(commandName))
    frame:SetSize(500, 150 + table.Count(commandData.AdminStick.ExtraFields) * 40 + 100)
    frame:Center()
    frame:MakePopup()
    frame:ShowCloseButton(false)
    local yPos = 40
    local inputs = {}
    for field, fieldType in pairs(commandData.AdminStick.ExtraFields) do
        local label = vgui.Create("DLabel", frame)
        label:SetPos(25, yPos)
        label:SetSize(150, 30)
        label:SetFont("DermaDefaultBold")
        label:SetText(L(field))
        if isfunction(fieldType) then
            local options, typeField = fieldType()
            if typeField == "combo" then
                local comboBox = vgui.Create("DComboBox", frame)
                comboBox:SetPos(100, yPos)
                comboBox:SetSize(300, 30)
                for _, option in ipairs(options) do
                    comboBox:AddChoice(option)
                end

                inputs[field] = comboBox
            end
        elseif fieldType == "text" then
            local input = vgui.Create("DTextEntry", frame)
            input:SetPos(100, yPos)
            input:SetSize(300, 30)
            input:SetFont("DermaDefault")
            input:SetValue("")
            input:SetPaintBackground(true)
            inputs[field] = input
        end

        yPos = yPos + 40
    end

    local submitBtn = vgui.Create("DButton", frame)
    submitBtn:SetText(L("submit"))
    submitBtn:SetPos(100, frame:GetTall() - 70)
    submitBtn:SetSize(150, 50)
    submitBtn:SetFont("DermaDefaultBold")
    submitBtn:SetColor(Color(255, 255, 255))
    submitBtn:SetMaterial("icon16/tick.png")
    submitBtn.DoClick = function()
        local args = {}
        for field, fieldType in pairs(commandData.AdminStick.ExtraFields) do
            local value
            if isfunction(fieldType) then
                local selected = inputs[field]:GetSelected()
                value = selected
            elseif fieldType == "text" then
                value = inputs[field]:GetValue()
            end

            table.insert(args, value)
        end

        local identifier = GetIdentifier(target)
        local commandStr = "/" .. commandKey
        if identifier ~= "" then table.insert(args, 1, identifier) end
        for _, arg in ipairs(args) do
            commandStr = commandStr .. " " .. arg
        end

        client:ConCommand("say " .. commandStr)
        frame:Close()
        AdminStickIsOpen = false
    end

    local cancelBtn = vgui.Create("DButton", frame)
    cancelBtn:SetText(L("cancel"))
    cancelBtn:SetPos(250, frame:GetTall() - 70)
    cancelBtn:SetSize(150, 50)
    cancelBtn:SetFont("DermaDefaultBold")
    cancelBtn:SetColor(Color(255, 255, 255))
    cancelBtn:SetMaterial("icon16/cross.png")
    cancelBtn.DoClick = function() frame:Close() end
end

local function OpenPlayerModelUI(target)
    AdminStickIsOpen = true
    local frame = vgui.Create("DFrame")
    frame:SetTitle(L("changePlayerModel"))
    frame:SetSize(450, 300)
    frame:Center()
    function frame:OnClose()
        frame:Remove()
        AdminStickIsOpen = false
    end

    local scroll = vgui.Create("DScrollPanel", frame)
    scroll:Dock(FILL)
    local wrapper = vgui.Create("DIconLayout", scroll)
    wrapper:Dock(FILL)
    local edit = vgui.Create("DTextEntry", frame)
    edit:Dock(BOTTOM)
    edit:SetText(target:GetModel())
    local button = vgui.Create("DButton", frame)
    button:SetText(L("change"))
    button:Dock(TOP)
    function button:DoClick()
        local txt = edit:GetValue()
        local identifier = GetIdentifier(target)
        if identifier ~= "" then RunConsoleCommand("say", "/charsetmodel " .. identifier .. " " .. txt) end
        frame:Remove()
        AdminStickIsOpen = false
    end

    local sortedModels = {}
    for name, model in SortedPairs(player_manager.AllValidModels()) do
        table.insert(sortedModels, {
            name = name,
            model = model
        })
    end

    table.sort(sortedModels, function(a, b) return a.name < b.name end)
    for _, mdl in ipairs(sortedModels) do
        local icon = wrapper:Add("SpawnIcon")
        icon:SetModel(mdl.model)
        icon:SetSize(64, 64)
        icon:SetTooltip(mdl.name)
        icon.playermodel = mdl.name
        icon.model_path = mdl.model
        icon.DoClick = function(self) edit:SetValue(self.model_path) end
    end

    frame:MakePopup()
end

local function OpenReasonUI(target, cmd)
    AdminStickIsOpen = true
    local frame = vgui.Create("DFrame")
    frame:SetTitle(L("reasonFor", cmd))
    frame:SetSize(300, 150)
    frame:Center()
    function frame:OnClose()
        frame:Remove()
        AdminStickIsOpen = false
    end

    local edit = vgui.Create("DTextEntry", frame)
    edit:Dock(FILL)
    edit:SetMultiline(true)
    edit:SetPlaceholderText(L("reason"))
    local timeedit
    if cmd == "banid" then
        local time = vgui.Create("DNumSlider", frame)
        time:Dock(TOP)
        time:SetText(L("lengthInDays"))
        time:SetMin(0)
        time:SetMax(365)
        time:SetDecimals(0)
        timeedit = time
    end

    local button = vgui.Create("DButton", frame)
    button:Dock(BOTTOM)
    button:SetText(L("change"))
    function button:DoClick()
        local txt = edit:GetValue()
        local identifier = GetIdentifier(target)
        if cmd == "banid" then
            if identifier ~= "" then
                if timeedit then
                    local length = timeedit:GetValue() * 60 * 24
                    RunConsoleCommand("say", "!banid " .. identifier .. " " .. length .. " " .. txt)
                else
                    RunConsoleCommand("say", "!banid " .. identifier .. " " .. txt)
                end
            end
        elseif cmd == "kick" then
            if identifier ~= "" then RunConsoleCommand("say", "!kick " .. identifier .. " " .. txt) end
        end

        frame:Remove()
        AdminStickIsOpen = false
    end

    frame:MakePopup()
end

local function HandleModerationOption(option, target)
    if option.name == "Ban" then
        OpenReasonUI(target, "banid")
    elseif option.name == "Kick" then
        OpenReasonUI(target, "kick")
    else
        RunConsoleCommand("say", option.cmd)
    end

    AdminStickIsOpen = false
end

local function IncludeAdminMenu(target, AdminMenu, submenus)
    local client = LocalPlayer()
    if client:GetUserGroup() == "user" then return end
    local moderationMenu = GetOrCreateSubMenu(AdminMenu, "Moderation Tools", submenus)
    local teleportationOptions = {
        {
            name = "Bring",
            cmd = "!bring " .. GetIdentifier(target),
            icon = "icon16/arrow_down.png"
        },
        {
            name = "Goto",
            cmd = "!goto " .. GetIdentifier(target),
            icon = "icon16/arrow_right.png"
        },
        {
            name = "Return",
            cmd = "!return " .. GetIdentifier(target),
            icon = "icon16/arrow_redo.png"
        },
        {
            name = "Respawn",
            cmd = "!respawn " .. GetIdentifier(target),
            icon = "icon16/arrow_refresh.png"
        }
    }

    local moderationOptions = {
        {
            action = {
                name = "Blind",
                cmd = "!blind " .. GetIdentifier(target),
                icon = "icon16/eye.png"
            },
            inverse = {
                name = "Unblind",
                cmd = "!unblind " .. GetIdentifier(target),
                icon = "icon16/eye.png"
            }
        },
        {
            action = {
                name = "Freeze",
                cmd = "!freeze " .. GetIdentifier(target),
                icon = "icon16/lock.png"
            },
            inverse = {
                name = "Unfreeze",
                cmd = "!unfreeze " .. GetIdentifier(target),
                icon = "icon16/accept.png"
            }
        },
        {
            action = {
                name = "Gag",
                cmd = "!gag " .. GetIdentifier(target),
                icon = "icon16/sound_mute.png"
            },
            inverse = {
                name = "Ungag",
                cmd = "!ungag " .. GetIdentifier(target),
                icon = "icon16/sound_low.png"
            }
        },
        {
            action = {
                name = "Mute",
                cmd = "!mute " .. GetIdentifier(target),
                icon = "icon16/sound_delete.png"
            },
            inverse = {
                name = "Unmute",
                cmd = "!unmute " .. GetIdentifier(target),
                icon = "icon16/sound_add.png"
            }
        },
        {
            name = "Ignite",
            cmd = "!ignite " .. GetIdentifier(target),
            icon = "icon16/fire.png"
        },
        {
            name = "Jail",
            cmd = "!jail " .. GetIdentifier(target),
            icon = "icon16/lock.png"
        },
        {
            name = "Slay",
            cmd = "!slay " .. GetIdentifier(target),
            icon = "icon16/bomb.png"
        }
    }

    table.sort(moderationOptions, function(a, b)
        local nameA = a.action and a.action.name or a.name
        local nameB = b.action and b.action.name or b.name
        return nameA < nameB
    end)

    table.sort(teleportationOptions, function(a, b) return a.name < b.name end)
    for _, optionPair in ipairs(moderationOptions) do
        if optionPair.action then
            moderationMenu:AddOption(L(optionPair.action.name), function() HandleModerationOption(optionPair.action, target) end):SetIcon(optionPair.action.icon)
            if optionPair.inverse then moderationMenu:AddOption(L(optionPair.inverse.name), function() HandleModerationOption(optionPair.inverse, target) end):SetIcon(optionPair.inverse.icon) end
        else
            moderationMenu:AddOption(L(optionPair.name), function() HandleModerationOption(optionPair, target) end):SetIcon(optionPair.icon)
        end
    end

    for _, option in ipairs(teleportationOptions) do
        moderationMenu:AddOption(L(option.name), function()
            client:ChatPrint(option.cmd)
            RunConsoleCommand("say", option.cmd)
            AdminStickIsOpen = false
        end):SetIcon(option.icon)
    end
end

local function IncludeCharacterManagement(target, AdminMenu, submenus)
    local client = LocalPlayer()
    local factionMenuAllowed = client:hasPrivilege("Commands - Manage Transfers")
    local classMenuAllowed = client:hasPrivilege("Commands - Manage Classes")
    local characterMenu = GetOrCreateSubMenu(AdminMenu, "Character Management", submenus)
    local factionOptions = {}
    local char = target:getChar()
    if char and factionMenuAllowed then
        local currentFactionID = char:getFaction()
        local currentFactionName = L("unknown")
        if currentFactionID then
            for _, fac in pairs(lia.faction.teams) do
                if fac.index == currentFactionID then
                    currentFactionName = fac.name
                    for _, v in pairs(lia.faction.teams) do
                        table.insert(factionOptions, {
                            name = v.name,
                            cmd = 'say /plytransfer ' .. GetIdentifier(target) .. ' ' .. v.name
                        })
                    end

                    break
                end
            end

            table.sort(factionOptions, function(a, b) return a.name < b.name end)
            if #factionOptions > 0 then
                local factionMenu = GetOrCreateSubMenu(characterMenu, "Set Faction (" .. currentFactionName .. ")", submenus)
                for _, option in ipairs(factionOptions) do
                    factionMenu:AddOption(L(option.name), function()
                        client:ConCommand(option.cmd)
                        AdminStickIsOpen = false
                    end):SetIcon("icon16/group.png")
                end
            end

            local classes = lia.faction.getClasses and lia.faction.getClasses(currentFactionID)
            if classes and #classes > 1 and classMenuAllowed then
                local classOptions = {}
                for _, class in ipairs(classes) do
                    table.insert(classOptions, {
                        name = class.name,
                        cmd = 'say /setclass ' .. GetIdentifier(target) .. ' ' .. class.uniqueID
                    })
                end

                table.sort(classOptions, function(a, b) return a.name < b.name end)
                local classMenu = GetOrCreateSubMenu(characterMenu, "Set Class", submenus)
                for _, option in ipairs(classOptions) do
                    classMenu:AddOption(L(option.name), function()
                        client:ConCommand(option.cmd)
                        AdminStickIsOpen = false
                    end):SetIcon("icon16/user.png")
                end
            end
        end
    end

    if client:hasPrivilege("Commands - Manage Character Information") then
        local changeModelOption = {
            name = "Change Playermodel",
            cmd = "",
            icon = "icon16/user_suit.png"
        }

        characterMenu:AddOption(L(changeModelOption.name), function()
            OpenPlayerModelUI(target)
            AdminStickIsOpen = false
        end):SetIcon(changeModelOption.icon)
    end
end

local function IncludeFlagManagement(target, AdminMenu, submenus)
    local client = LocalPlayer()
    if not client:hasPrivilege("Commands - Manage Flags") then return end
    local flagsMenu = GetOrCreateSubMenu(AdminMenu, "Flags Management", submenus)
    local giveFlagsSubMenu = GetOrCreateSubMenu(flagsMenu, "Give Flags", submenus)
    local takeFlagsSubMenu = GetOrCreateSubMenu(flagsMenu, "Take Flags", submenus)
    local giveFlags, takeFlags = {}, {}
    for flag, _ in pairs(lia.flag.list) do
        if not target:getChar():hasFlags(flag) then
            table.insert(giveFlags, {
                name = "Give Flag " .. flag,
                cmd = 'say /giveflag ' .. GetIdentifier(target) .. ' ' .. flag,
                icon = "icon16/flag_blue.png"
            })
        end

        if target:getChar():hasFlags(flag) then
            table.insert(takeFlags, {
                name = "Take Flag " .. flag,
                cmd = 'say /takeflag ' .. GetIdentifier(target) .. ' ' .. flag,
                icon = "icon16/flag_red.png"
            })
        end
    end

    table.sort(giveFlags, function(a, b) return a.name < b.name end)
    table.sort(takeFlags, function(a, b) return a.name < b.name end)
    for _, flag in ipairs(giveFlags) do
        giveFlagsSubMenu:AddOption(L(flag.name), function()
            client:ConCommand(flag.cmd)
            AdminStickIsOpen = false
        end):SetIcon(flag.icon)
    end

    for _, flag in ipairs(takeFlags) do
        takeFlagsSubMenu:AddOption(L(flag.name), function()
            client:ConCommand(flag.cmd)
            AdminStickIsOpen = false
        end):SetIcon(flag.icon)
    end
end

local function AddCommandToMenu(AdminMenu, commandData, commandKey, target, commandName, submenus)
    local client = LocalPlayer()
    local canUse, _ = lia.command.hasAccess(client, commandKey, commandData)
    if not canUse then return end
    local category = commandData.AdminStick.Category
    local subCategory = commandData.AdminStick.SubCategory
    local categoryMenu = AdminMenu
    if category then categoryMenu = GetOrCreateSubMenu(AdminMenu, category, submenus) end
    if subCategory then categoryMenu = GetOrCreateSubMenu(categoryMenu, subCategory, submenus) end
    local iconPath = commandData.AdminStick.Icon or "icon16/page.png"
    local commandOption = categoryMenu:AddOption(L(commandName), function()
        if commandData.AdminStick.ExtraFields and table.Count(commandData.AdminStick.ExtraFields) > 0 then
            HandleExtraFields(commandKey, commandData, target, commandName)
        else
            local identifier = GetIdentifier(target)
            if identifier ~= "" then
                local cmd = "/" .. commandKey .. " " .. identifier
                client:ConCommand("say " .. cmd)
            end

            AdminStickIsOpen = false
        end
    end)

    commandOption:SetImage(iconPath)
end

local function hasAdminStickTargetClass(targetClassName)
    for _, cmd in pairs(lia.command.list) do
        if istable(cmd.AdminStick) and cmd.AdminStick.TargetClass == targetClassName then return true end
    end
    return false
end

function MODULE:OpenAdminStickUI(target)
    local client = LocalPlayer()
    if not IsValid(target) or not target:isDoor() and not target:IsPlayer() and not hasAdminStickTargetClass(target:GetClass()) then return end
    AdminStickIsOpen = true
    local AdminMenu = DermaMenu()
    AdminMenu:Center()
    AdminMenu:MakePopup()
    local submenus = {}
    if target:IsPlayer() then
        local playerOptions = {
            {
                name = "CharID: " .. (target:getChar() and target:getChar():getID() or "N/A") .. " (copy)",
                cmd = function()
                    if target:getChar() then
                        local msg = L("copiedCharID", target:getChar():getID())
                        client:ChatPrint(msg)
                        SetClipboardText(target:getChar():getID())
                    end

                    AdminStickIsOpen = false
                end,
                icon = "icon16/page_copy.png"
            },
            {
                name = "Name: " .. target:Name() .. " (copy)",
                cmd = function()
                    local msg = L("copiedToClipboard", target:Name(), "Name")
                    client:ChatPrint(msg)
                    SetClipboardText(target:Name())
                    AdminStickIsOpen = false
                end,
                icon = "icon16/page_copy.png"
            },
            {
                name = "SteamID: " .. target:SteamID() .. " (copy)",
                cmd = function()
                    local msg = L("copiedToClipboard", target:Name(), "SteamID")
                    client:ChatPrint(msg)
                    SetClipboardText(target:SteamID64())
                    AdminStickIsOpen = false
                end,
                icon = "icon16/page_copy.png"
            },
            {
                name = "SteamID64: " .. target:SteamID64() .. " (copy)",
                cmd = function()
                    local msg = L("copiedToClipboard", target:Name(), "SteamID64")
                    client:ChatPrint(msg)
                    SetClipboardText(target:SteamID64())
                    AdminStickIsOpen = false
                end,
                icon = "icon16/page_copy.png"
            }
        }

        table.sort(playerOptions, function(a, b) return a.name < b.name end)
        local playerInfoMenu = GetOrCreateSubMenu(AdminMenu, "Player Information", submenus)
        for _, option in ipairs(playerOptions) do
            playerInfoMenu:AddOption(L(option.name), option.cmd):SetIcon(option.icon)
        end

        IncludeAdminMenu(target, AdminMenu, submenus)
        IncludeCharacterManagement(target, AdminMenu, submenus)
        IncludeFlagManagement(target, AdminMenu, submenus)
    end

    local targetClassName = target:GetClass()
    local commands = {}
    for k, v in pairs(lia.command.list) do
        if v.AdminStick and istable(v.AdminStick) then
            local commandTargetClass = v.AdminStick.TargetClass
            if commandTargetClass then
                if commandTargetClass == "Door" and target:isDoor() then
                    table.insert(commands, {
                        name = v.AdminStick.Name or k,
                        data = v,
                        key = k
                    })
                elseif commandTargetClass == targetClassName then
                    table.insert(commands, {
                        name = v.AdminStick.Name or k,
                        data = v,
                        key = k
                    })
                end
            else
                if target:IsPlayer() then
                    table.insert(commands, {
                        name = v.AdminStick.Name or k,
                        data = v,
                        key = k
                    })
                end
            end
        end
    end

    table.sort(commands, function(a, b) return a.name < b.name end)
    for _, cmd in ipairs(commands) do
        AddCommandToMenu(AdminMenu, cmd.data, cmd.key, target, cmd.name, submenus)
    end

    hook.Run("PopulateAdminStick", AdminMenu, target)
    function AdminMenu:OnRemove()
        client.AdminStickTarget = nil
        AdminStickIsOpen = false
    end

    AdminMenu:Open()
end


-- ./modules/core/administration/submodules/adminstick/libraries/server.lua
local MODULE = MODULE
function MODULE:PostPlayerLoadout(client)
    if client:hasPrivilege("Staff Permissions - Use Admin Stick") or client:isStaffOnDuty() then client:Give("adminstick") end
end


-- ./modules/core/administration/submodules/adminstick/module.lua
MODULE.name = "Admin Stick"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a module that facilitates Adminstration"
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Use Admin Stick",
        MinAccess = "superadmin",
        Description = "Allows access to using Admin Stick."
    },
}


-- ./modules/core/administration/submodules/itemspawner/libraries/client.lua
local function textWrap(text, font, maxWidth)
    text = text or ""
    local totalWidth = 0
    surface.SetFont(font)
    local spaceWidth = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
        local char = string.sub(word, 1, 1)
        if char == "\n" or char == "\t" then totalWidth = 0 end
        local wordlen = surface.GetTextSize(word)
        totalWidth = totalWidth + wordlen
        if wordlen >= maxWidth then
            local splitWord, splitPoint = charWrap(word, maxWidth - (totalWidth - wordlen), maxWidth)
            totalWidth = splitPoint
            return splitWord
        elseif totalWidth < maxWidth then
            return word
        end

        if char == ' ' then
            totalWidth = wordlen - spaceWidth
            return '\n' .. string.sub(word, 2)
        end

        totalWidth = wordlen
        return '\n' .. word
    end)
    return text
end

spawnmenu.AddContentType("inventoryitem", function(container, data)
    local client = LocalPlayer()
    if not client:hasPrivilege("Staff Permissions - Can Use Item Spawner") then return end
    local icon = vgui.Create("ContentIcon", container)
    icon:SetContentType("inventoryitem")
    icon:SetSpawnName(data.id)
    icon:SetName(data.name)
    local itemData = lia.item.list[data.id]
    local model = itemData.model or "default.mdl"
    local matName = string.Replace(model, ".mdl", "")
    icon.Image:SetMaterial(Material("spawnicons/" .. matName .. ".png"))
    icon:SetColor(Color(205, 92, 92, 255))
    icon:SetTooltip(textWrap(itemData.desc or "", "DermaDefault", 560))
    icon.DoClick = function()
        net.Start("SpawnMenuSpawnItem")
        net.WriteString(data.id)
        net.SendToServer()
        surface.PlaySound("outlands-rp/ui/ui_return.wav")
    end

    icon.OpenMenu = function()
        local menu = DermaMenu()
        menu:AddOption("Copy", function() SetClipboardText(icon:GetSpawnName()) end):SetIcon("icon16/page_copy.png")
        menu:AddOption("Give To Character...", function()
            local popup = vgui.Create("DFrame")
            popup:SetTitle("Spawn " .. data.id)
            popup:SetSize(300, 100)
            popup:Center()
            popup:MakePopup()
            local label = vgui.Create("DLabel", popup)
            label:Dock(TOP)
            label:SetText("Give to:")
            local combo = vgui.Create("DComboBox", popup)
            combo:Dock(TOP)
            for _, character in pairs(lia.char.getAll()) do
                local ply = character:getPlayer()
                if IsValid(ply) then
                    local steamID = ply:SteamID() or ""
                    local name = character:getName() or L("unknown")
                    combo:AddChoice(string.format("[%s] [%s]", name, steamID), steamID)
                end
            end

            local button = vgui.Create("liaSmallButton", popup)
            button:Dock(BOTTOM)
            button:SetText("Spawn item")
            button.DoClick = function()
                local _, target = combo:GetSelected()
                net.Start("SpawnMenuGiveItem")
                net.WriteString(data.id)
                net.WriteString(target or "")
                net.SendToServer()
                popup:Remove()
            end
        end)

        menu:Open()
    end

    container:Add(icon)
    return icon
end)

function MODULE:PopulateInventoryItems(pnlContent, tree)
    local allItems = lia.item.list
    local categorized = {
        Unsorted = {}
    }

    for uniqueID, itemData in pairs(allItems) do
        if itemData.category then
            categorized[itemData.category] = categorized[itemData.category] or {}
            table.insert(categorized[itemData.category], {
                id = uniqueID,
                name = itemData.name
            })
        else
            table.insert(categorized.Unsorted, {
                id = uniqueID,
                name = itemData.name
            })
        end
    end

    for category, itemList in SortedPairs(categorized) do
        if category ~= "Unsorted" or #itemList > 0 then
            local node = tree:AddNode(category, "icon16/picture.png")
            node.DoPopulate = function(btn)
                if btn.PropPanel then return end
                btn.PropPanel = vgui.Create("ContentContainer", pnlContent)
                btn.PropPanel:SetVisible(false)
                btn.PropPanel:SetTriggerSpawnlistChange(false)
                for _, itemListData in SortedPairsByMemberValue(itemList, "name") do
                    spawnmenu.CreateContentIcon("inventoryitem", btn.PropPanel, {
                        name = itemListData.name,
                        id = itemListData.id
                    })
                end
            end

            node.DoClick = function(btn)
                btn:DoPopulate()
                pnlContent:SwitchPanel(btn.PropPanel)
            end
        end
    end
end

spawnmenu.AddCreationTab("Inventory Items", function()
    local client = LocalPlayer()
    if not IsValid(client) or not client.hasPrivilege or not client:hasPrivilege("Staff Permissions - Can Use Item Spawner") then
        local pnl = vgui.Create("DPanel")
        pnl:Dock(FILL)
        pnl.Paint = function(_, w, h) draw.SimpleText("You don't have permission to use this.", "DermaDefault", w / 2, h / 2, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end
        return pnl
    else
        local ctrl = vgui.Create("SpawnmenuContentPanel")
        ctrl:CallPopulateHook("PopulateInventoryItems")
        return ctrl
    end
end, "icon16/briefcase.png")

-- ./modules/core/administration/submodules/itemspawner/libraries/server.lua
local function fixupProp(client, ent, mins, maxs)
    local pos = ent:GetPos()
    local down, up = ent:LocalToWorld(mins), ent:LocalToWorld(maxs)
    local trD = util.TraceLine({
        start = pos,
        endpos = down,
        filter = {ent, client}
    })

    local trU = util.TraceLine({
        start = pos,
        endpos = up,
        filter = {ent, client}
    })

    if trD.Hit and trU.Hit then return end
    if trD.Hit then ent:SetPos(pos + trD.HitPos - down) end
    if trU.Hit then ent:SetPos(pos + trU.HitPos - up) end
end

local function tryFixPropPosition(client, ent)
    local m, M = ent:OBBMins(), ent:OBBMaxs()
    fixupProp(client, ent, Vector(m.x, 0, 0), Vector(M.x, 0, 0))
    fixupProp(client, ent, Vector(0, m.y, 0), Vector(0, M.y, 0))
    fixupProp(client, ent, Vector(0, 0, m.z), Vector(0, 0, M.z))
end

net.Receive("SpawnMenuSpawnItem", function(_, client)
    local id = net.ReadString()
    if not IsValid(client) or not id or not client:hasPrivilege("Staff Permissions - Can Use Item Spawner") then return end
    local startPos, dir = client:EyePos(), client:GetAimVector()
    local tr = util.TraceLine({
        start = startPos,
        endpos = startPos + dir * 4096,
        filter = client
    })

    if not tr.Hit then return end
    lia.item.spawn(id, tr.HitPos, function(_, ent)
        if not IsValid(ent) then return end
        tryFixPropPosition(client, ent)
        undo.Create("item")
        undo.SetPlayer(client)
        undo.AddEntity(ent)
        local name = lia.item.list[id] and lia.item.list[id].name or id
        undo.Finish("Item (" .. name .. ")")
        lia.log.add(client, "spawnItem", name, "SpawnMenuSpawnItem")
    end, angle_zero, {})
end)

net.Receive("SpawnMenuGiveItem", function(_, client)
    local id, targetID = net.ReadString(), net.ReadString()
    if not IsValid(client) then return end
    if not id then return end
    if not client:hasPrivilege("Staff Permissions - Can Use Item Spawner") then return end
    local targetChar = lia.char.getBySteamID(targetID)
    local target = targetChar:getPlayer()
    if not targetChar then return end
    targetChar:getInv():add(id)
    lia.log.add(client, "chargiveItem", id, target:Nick(), "SpawnMenuGiveItem")
end)

-- ./modules/core/administration/submodules/itemspawner/module.lua
MODULE.name = "Item Spawner"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a Item Spawner to assist on spawning items."
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Can Use Item Spawner",
        MinAccess = "admin",
        Description = "Allows access to Spawning Menu Items.",
    }
}


-- ./modules/core/administration/submodules/logging/config.lua
lia.config.add("LogRetentionDays", "Log Retention Period", 7, nil, {
    desc = "Determines how many days of logs should be read",
    category = "Logging",
    type = "Int",
    min = 3,
    max = 30,
})

lia.config.add("MaxLogLines", "Maximum Log Lines", 1000, nil, {
    desc = "Determines the maximum number of log lines to retrieve",
    category = "Logging",
    type = "Int",
    min = 500,
    max = 1000000,
})


-- ./modules/core/administration/submodules/logging/libraries/client.lua
local receivedChunks = {}
local receivedPanel
net.Receive("send_logs", function()
    local chunkIndex = net.ReadUInt(16)
    local numChunks = net.ReadUInt(16)
    local chunkLen = net.ReadUInt(16)
    local chunkData = net.ReadData(chunkLen)
    receivedChunks[chunkIndex] = chunkData
    for i = 1, numChunks do
        if not receivedChunks[i] then return end
    end

    local fullData = table.concat(receivedChunks)
    receivedChunks = {}
    local jsonData = util.Decompress(fullData)
    local categorizedLogs = util.JSONToTable(jsonData)
    if not categorizedLogs then
        chat.AddText(Color(255, 0, 0), "Failed to retrieve logs.")
        return
    end

    if IsValid(receivedPanel) then OpenLogsUI(receivedPanel, categorizedLogs) end
end)

function OpenLogsUI(panel, categorizedLogs)
    panel:Clear()
    local sidebar = panel:Add("DScrollPanel")
    sidebar:Dock(LEFT)
    sidebar:SetWide(200)
    sidebar:DockMargin(20, 20, 0, 20)
    local contentPanel = panel:Add("DPanel")
    contentPanel:Dock(FILL)
    contentPanel:DockMargin(10, 10, 10, 10)
    local search = contentPanel:Add("DTextEntry")
    search:Dock(TOP)
    search:SetPlaceholderText("Search logs...")
    search:SetTextColor(Color(255, 255, 255))
    local list = contentPanel:Add("DListView")
    list:Dock(FILL)
    list:SetMultiSelect(false)
    list:AddColumn("Timestamp"):SetFixedWidth(150)
    list:AddColumn("Message")
    local copy = contentPanel:Add("liaMediumButton")
    copy:Dock(BOTTOM)
    copy:SetText("Copy Selected Row")
    copy:SetTall(40)
    local currentLogs = {}
    local currentSelected = nil
    for category, logs in pairs(categorizedLogs) do
        local btn = sidebar:Add("liaMediumButton")
        btn:Dock(TOP)
        btn:SetText(category)
        btn:DockMargin(0, 0, 0, 10)
        btn:SetTall(40)
        btn.DoClick = function()
            if IsValid(currentSelected) then currentSelected:SetSelected(false) end
            btn:SetSelected(true)
            currentSelected = btn
            list:Clear()
            currentLogs = logs
            for _, log in ipairs(logs) do
                list:AddLine(log.timestamp, log.message)
            end
        end
    end

    search.OnChange = function()
        local q = string.lower(search:GetValue())
        list:Clear()
        for _, log in ipairs(currentLogs) do
            if q == "" or string.find(string.lower(log.message), q, 1, true) then list:AddLine(log.timestamp, log.message) end
        end
    end

    copy.DoClick = function()
        local sel = list:GetSelectedLine()
        if sel then
            local line = list:GetLine(sel)
            SetClipboardText("[" .. line:GetColumnText(1) .. "] " .. line:GetColumnText(2))
        end
    end

    local firstCategory = next(categorizedLogs)
    if firstCategory then
        for _, btn in ipairs(sidebar:GetChildren()) do
            if btn:GetText() == firstCategory then
                btn:DoClick()
                break
            end
        end
    end
end

function MODULE:CreateMenuButtons(tabs)
    if LocalPlayer():hasPrivilege("Staff Permissions - Can See Logs") then
        tabs["Logs"] = function(panel)
            receivedPanel = panel
            net.Start("send_logs_request")
            net.SendToServer()
        end
    end
end

-- ./modules/core/administration/submodules/logging/libraries/server.lua
local MODULE = MODULE
function MODULE:SendLogsInChunks(client, categorizedLogs)
    local json = util.TableToJSON(categorizedLogs)
    local data = util.Compress(json)
    local chunks = netstream.Split(data)
    for i, chunk in ipairs(chunks) do
        net.Start("send_logs")
        net.WriteUInt(i, 16)
        net.WriteUInt(#chunks, 16)
        net.WriteUInt(#chunk, 16)
        net.WriteData(chunk, #chunk)
        net.Send(client)
    end
end

function MODULE:ReadLogFiles(category)
    local maxDays = lia.config.get("LogRetentionDays", 7)
    local maxLines = lia.config.get("MaxLogLines", 1000)
    local logs = {}
    local fnameCat = string.lower(category:gsub("%s+", "_"))
    local path = "lilia/logs/" .. engine.ActiveGamemode() .. "/" .. fnameCat .. ".txt"
    if not file.Exists(path, "DATA") then return logs end
    local content = file.Read(path, "DATA")
    local lines = {}
    local cutoff = os.time() - maxDays * 86400
    for line in content:gmatch("[^\r\n]+") do
        lines[#lines + 1] = line
    end

    local startIdx = math.max(#lines - maxLines + 1, 1)
    for i = startIdx, #lines do
        local ts, msg = lines[i]:match("^%[([^%]]+)%]%s*(.+)")
        if ts and msg then
            local y, m, d, H, M, S = ts:sub(1, 4), ts:sub(6, 7), ts:sub(9, 10), ts:sub(12, 13), ts:sub(15, 16), ts:sub(18, 19)
            local logTime = os.time{
                year = tonumber(y),
                month = tonumber(m),
                day = tonumber(d),
                hour = tonumber(H),
                min = tonumber(M),
                sec = tonumber(S)
            }

            if logTime >= cutoff then
                logs[#logs + 1] = {
                    timestamp = ts,
                    message = msg
                }
            end
        end
    end
    return logs
end

net.Receive("send_logs_request", function(_, client)
    if not MODULE:CanPlayerSeeLog(client) then return end
    local logsByCategory = {}
    for _, logType in pairs(lia.log.types) do
        local cat = logType.category or "Uncategorized"
        logsByCategory[cat] = logsByCategory[cat] or {}
        for _, entry in ipairs(MODULE:ReadLogFiles(cat)) do
            logsByCategory[cat][#logsByCategory[cat] + 1] = entry
        end
    end

    MODULE:SendLogsInChunks(client, logsByCategory)
end)

function MODULE:CanPlayerSeeLog(client)
    return lia.config.get("AdminConsoleNetworkLogs", true) and client:hasPrivilege("Staff Permissions - Can See Logs")
end

function MODULE:OnCharDelete(client, id)
    lia.log.add(client, "charDelete", id)
end

function MODULE:OnPlayerInteractItem(client, action, item)
    if isentity(item) then
        if IsValid(item) then
            local itemID = item.liaItemID
            item = lia.item.instances[itemID]
        else
            return
        end
    elseif isnumber(item) then
        item = lia.item.instances[item]
    end

    action = string.lower(action)
    if not item then return end
    local name = item.name
    if action == "use" then
        lia.log.add(client, "use", name)
    elseif action == "drop" then
        lia.log.add(client, "itemDrop", name)
    elseif action == "take" then
        lia.log.add(client, "itemTake", name)
    elseif action == "unequip" then
        lia.log.add(client, "itemUnequip", name)
    elseif action == "equip" then
        lia.log.add(client, "itemEquip", name)
    else
        lia.log.add(client, "itemInteraction", action, item)
    end
end

function MODULE:PlayerInitialSpawn(client)
    lia.log.add(client, "playerConnected")
end

function MODULE:PlayerDisconnect(client)
    lia.log.add(client, "playerDisconnected")
end

function MODULE:PlayerHurt(client, attacker, health, damage)
    lia.log.add(client, "playerHurt", attacker:IsPlayer() and attacker:Name() or attacker:GetClass(), damage, health)
end

function MODULE:PlayerDeath(client, attacker)
    lia.log.add(client, "playerDeath", attacker:IsPlayer() and attacker:Name() or attacker:GetClass())
end

function MODULE:OnCharCreated(client, character)
    lia.log.add(client, "charCreate", character)
end

function MODULE:PostPlayerLoadedChar(client, character)
    lia.log.add(client, "charLoad", character:getName(), character:getID())
end

function MODULE:PlayerSpawnedProp(client, model)
    lia.log.add(client, "spawned_prop", model)
end

function MODULE:PlayerSpawnedRagdoll(client, model)
    lia.log.add(client, "spawned_ragdoll", model)
end

function MODULE:PlayerSpawnedEffect(client, model)
    lia.log.add(client, "spawned_effect", model)
end

function MODULE:PlayerSpawnedVehicle(client, vehicle)
    lia.log.add(client, "spawned_vehicle", vehicle:GetClass(), vehicle:GetModel())
end

function MODULE:PlayerSpawnedNPC(client, npc)
    lia.log.add(client, "spawned_npc", npc:GetClass(), npc:GetModel())
end

function MODULE:PlayerGiveSWEP(client, swep)
    lia.log.add(client, "swep_spawning", swep)
end

function MODULE:PlayerSpawnSWEP(client, swep)
    lia.log.add(client, "swep_spawning", swep)
end

function MODULE:CanTool(client, _, tool)
    lia.log.add(client, "toolgunUse", tool)
end

-- ./modules/core/administration/submodules/logging/logs.lua
lia.log.types = {
    ["charRecognize"] = {
        func = function(client, id, name) return L("charRecognizeLog", client:SteamID64(), client:Name(), id, name, client:getChar():getID()) end,
        category = L("recognition")
    },
    ["charCreate"] = {
        func = function(client, character) return L("charCreateLog", client:SteamID64(), client:Name(), character:getName(), character:getID()) end,
        category = L("characterCategory")
    },
    ["charLoad"] = {
        func = function(client, name) return L("charLoadLog", client:SteamID64(), client:Name(), name, client:getChar():getID()) end,
        category = L("characterCategory")
    },
    ["charDelete"] = {
        func = function(client, id) return L("charDeleteLog", IsValid(client) and client:SteamID64() or "CONSOLE", IsValid(client) and client:Name() or "CONSOLE", id, IsValid(client) and client:getChar():getID() or L("unknown")) end,
        category = L("characterCategory")
    },
    ["playerHurt"] = {
        func = function(client, attacker, damage, health) return L("playerHurtLog", client:SteamID64(), client:Name(), damage, attacker, health, client:getChar():getID()) end,
        category = L("damage")
    },
    ["playerDeath"] = {
        func = function(client, attacker) return L("playerDeathLog", client:SteamID64(), client:Name(), attacker, client:getChar():getID()) end,
        category = L("death")
    },
    ["spawned_prop"] = {
        func = function(client, model) return L("spawned_propLog", client:SteamID64(), client:Name(), model, client:getChar():getID()) end,
        category = L("spawn")
    },
    ["spawned_ragdoll"] = {
        func = function(client, model) return L("spawned_ragdollLog", client:SteamID64(), client:Name(), model, client:getChar():getID()) end,
        category = L("spawn")
    },
    ["spawned_effect"] = {
        func = function(client, effect) return L("spawned_effectLog", client:SteamID64(), client:Name(), effect, client:getChar():getID()) end,
        category = L("spawn")
    },
    ["spawned_vehicle"] = {
        func = function(client, vehicle, model) return L("spawned_vehicleLog", client:SteamID64(), client:Name(), vehicle, model, client:getChar():getID()) end,
        category = L("spawn")
    },
    ["spawned_npc"] = {
        func = function(client, npc, model) return L("spawned_npcLog", client:SteamID64(), client:Name(), npc, model, client:getChar():getID()) end,
        category = L("spawn")
    },
    ["swep_spawning"] = {
        func = function(client, swep) return L("swep_spawningLog", client:SteamID64(), client:Name(), swep, client:getChar():getID()) end,
        category = L("swep")
    },
    ["chat"] = {
        func = function(client, chatType, message) return L("chatLog", client:SteamID64(), chatType, client:Name(), message, client:getChar():getID()) end,
        category = L("chatCategory")
    },
    ["chatOOC"] = {
        func = function(client, msg) return L("chatOOCLog", client:SteamID64(), client:Name(), msg, client:getChar():getID()) end,
        category = L("chatCategory")
    },
    ["chatLOOC"] = {
        func = function(client, msg) return L("chatLOOCLog", client:SteamID64(), client:Name(), msg, client:getChar():getID()) end,
        category = L("chatCategory")
    },
    ["command"] = {
        func = function(client, text) return L("commandLog", client:SteamID64(), client:Name(), text, client:getChar():getID()) end,
        category = L("chatCategory")
    },
    ["money"] = {
        func = function(client, amount) return L("moneyLog", client:SteamID64(), client:Name(), amount, client:getChar():getID()) end,
        category = L("moneyCategory")
    },
    ["moneyGiven"] = {
        func = function(client, name, amount) return L("moneyGivenLog", client:SteamID64(), client:Name(), name, lia.currency.get(amount), client:getChar():getID()) end,
        category = L("moneyCategory")
    },
    ["moneyPickedUp"] = {
        func = function(client, amount) return L("moneyPickedUpLog", client:SteamID64(), client:Name(), lia.currency.get(amount), amount > 1 and lia.currency.plural or lia.currency.singular, client:getChar():getID()) end,
        category = L("moneyCategory")
    },
    ["itemTake"] = {
        func = function(client, item) return L("itemTakeLog", client:SteamID64(), client:Name(), item, client:getChar():getID()) end,
        category = L("itemCategory")
    },
    ["use"] = {
        func = function(client, item) return L("itemUseLog", client:SteamID64(), client:Name(), item, client:getChar():getID()) end,
        category = L("itemCategory")
    },
    ["itemDrop"] = {
        func = function(client, item) return L("itemDropLog", client:SteamID64(), client:Name(), item, client:getChar():getID()) end,
        category = L("itemCategory")
    },
    ["itemInteraction"] = {
        func = function(client, action, item) return L("itemInteractionLog", client:SteamID64(), client:Name(), action, item.name, client:getChar():getID()) end,
        category = L("itemCategory")
    },
    ["itemEquip"] = {
        func = function(client, item) return L("itemEquipLog", client:SteamID64(), client:Name(), item, client:getChar():getID()) end,
        category = L("itemCategory")
    },
    ["itemUnequip"] = {
        func = function(client, item) return L("itemUnequipLog", client:SteamID64(), client:Name(), item, client:getChar():getID()) end,
        category = L("itemCategory")
    },
    ["toolgunUse"] = {
        func = function(client, tool) return L("toolgunUseLog", client:SteamID64(), client:Name(), tool, client:getChar():getID()) end,
        category = L("toolgun")
    },
    ["playerConnected"] = {
        func = function(client) return L("playerConnectedLog", client:SteamID64(), client:Name()) end,
        category = L("connections")
    },
    ["playerDisconnected"] = {
        func = function(client) return L("playerDisconnectedLog", client:SteamID64(), client:Name()) end,
        category = L("connections")
    },
    ["doorSetClass"] = {
        func = function(client, door, className) return L("doorLogSetClass", client:SteamID64(), client:Name(), className, door:GetClass()) end,
        category = L("doors")
    },
    ["doorRemoveClass"] = {
        func = function(client, door) return L("doorLogRemoveClass", client:SteamID64(), client:Name(), door:GetClass()) end,
        category = L("doors")
    },
    ["doorSaveData"] = {
        func = function(client) return L("doorLogSaveData", client:Nick(), client:SteamID64(), client:Name()) end,
        category = L("doors")
    },
    ["doorToggleOwnable"] = {
        func = function(client, door, state) return L("doorLogToggleOwnable", client:SteamID64(), client:Name(), door:GetClass(), state and "unownable" or "ownable") end,
        category = L("doors")
    },
    ["doorSetFaction"] = {
        func = function(client, door, factionName) return L("doorLogSetFaction", client:SteamID64(), client:Name(), factionName, door:GetClass()) end,
        category = L("doors")
    },
    ["doorRemoveFaction"] = {
        func = function(client, door, factionName) return L("doorLogRemoveFaction", client:SteamID64(), client:Name(), factionName, door:GetClass()) end,
        category = L("doors")
    },
    ["doorSetHidden"] = {
        func = function(client, door, state) return L("doorLogSetHidden", client:SteamID64(), client:Name(), door:GetClass(), state and "hidden" or "visible") end,
        category = L("doors")
    },
    ["doorSetTitle"] = {
        func = function(client, door, title) return L("doorLogSetTitle", client:SteamID64(), client:Name(), title, door:GetClass()) end,
        category = L("doors")
    },
    ["doorResetData"] = {
        func = function(client, door) return L("doorLogResetData", client:SteamID64(), client:Name(), door:GetClass()) end,
        category = L("doors")
    },
    ["doorSetParent"] = {
        func = function(client, door) return L("doorLogSetParent", client:SteamID64(), client:Name(), door:GetClass()) end,
        category = L("doors")
    },
    ["doorAddChild"] = {
        func = function(client, parentDoor, childDoor) return L("doorLogAddChild", client:SteamID64(), client:Name(), childDoor:GetClass(), parentDoor:GetClass()) end,
        category = L("doors")
    },
    ["doorRemoveChild"] = {
        func = function(client, parentDoor, childDoor) return L("doorLogRemoveChild", client:SteamID64(), client:Name(), childDoor:GetClass(), parentDoor:GetClass()) end,
        category = L("doors")
    },
    ["doorForceLock"] = {
        func = function(client, door) return L("doorLogForceLock", client:SteamID64(), client:Name(), door:GetClass()) end,
        category = L("doors")
    },
    ["doorForceUnlock"] = {
        func = function(client, door) return L("doorLogForceUnlock", client:SteamID64(), client:Name(), door:GetClass()) end,
        category = L("doors")
    },
    ["doorDisable"] = {
        func = function(client, door) return L("doorLogDisable", client:SteamID64(), client:Name(), door:GetClass()) end,
        category = L("doors")
    },
    ["doorEnable"] = {
        func = function(client, door) return L("doorLogEnable", client:SteamID64(), client:Name(), door:GetClass()) end,
        category = L("doors")
    },
    ["doorDisableAll"] = {
        func = function(client, count) return L("doorLogDisableAll", client:SteamID64(), client:Name(), count) end,
        category = L("doors")
    },
    ["doorEnableAll"] = {
        func = function(client, count) return L("doorLogEnableAll", client:SteamID64(), client:Name(), count) end,
        category = L("doors")
    },
    ["spawnItem"] = {
        func = function(client, displayName, message) return L("spawnItemLog", client:SteamID64(), displayName, message) end,
        category = L("itemSpawner")
    },
    ["chargiveItem"] = {
        func = function(client, itemName, target, message) return L("chargiveItemLog", client:SteamID64(), target:Name(), itemName, message) end,
        category = L("itemSpawner")
    },
    ["vendorAccess"] = {
        func = function(client, vendor)
            local vendorName = vendor:getNetVar("name") or L("unknown")
            return L("vendorLogAccess", client:SteamID64(), client:Name(), vendorName, client:getChar():getID())
        end,
        category = L("vendors")
    },
    ["vendorExit"] = {
        func = function(client, vendor)
            local vendorName = vendor:getNetVar("name") or L("unknown")
            return L("vendorLogExit", client:SteamID64(), client:Name(), vendorName, client:getChar():getID())
        end,
        category = L("vendors")
    },
    ["vendorSell"] = {
        func = function(client, item, vendor)
            local vendorName = vendor:getNetVar("name") or L("unknown")
            return L("vendorLogSell", client:SteamID64(), client:Name(), item, vendorName, client:getChar():getID())
        end,
        category = L("vendors")
    },
    ["vendorEdit"] = {
        func = function(client, vendor, key)
            local vendorName = vendor:getNetVar("name") or L("unknown")
            return L("vendorLogEdit", client:SteamID64(), client:Name(), vendorName, key, client:getChar():getID())
        end,
        category = L("vendors")
    },
    ["vendorBuy"] = {
        func = function(client, item, vendor, isFailed)
            local vendorName = vendor:getNetVar("name") or L("unknown")
            if isFailed then
                return L("vendorLogBuyFail", client:SteamID64(), client:Name(), item, vendorName, client:getChar():getID())
            else
                return L("vendorLogBuySuccess", client:SteamID64(), client:Name(), item, vendorName, client:getChar():getID())
            end
        end,
        category = L("vendors")
    },
    ["configChange"] = {
        func = function(name, oldValue, value) return L("configChangeLog", name, tostring(oldValue), tostring(value)) end,
        category = L("adminActions")
    },
    ["warningIssued"] = {
        func = function(client, target, reason) return L("warningIssuedLog", os.date("%Y-%m-%d %H:%M:%S"), client:SteamID64(), target:SteamID64(), reason) end,
        category = L("warnings")
    },
    ["warningRemoved"] = {
        func = function(client, target, warning) return L("warningRemovedLog", os.date("%Y-%m-%d %H:%M:%S"), client:SteamID64(), target:SteamID64(), warning.reason) end,
        category = L("warnings")
    },
    ["adminMode"] = {
        func = function(client, id, message) return L("adminModeLog", os.date("%Y-%m-%d %H:%M:%S"), client:SteamID64(), message, id) end,
        category = L("adminActions")
    },
    ["sitRoomSet"] = {
        func = function(client, pos, message) return L("sitRoomSetLog", os.date("%Y-%m-%d %H:%M:%S"), client:SteamID64(), message, pos) end,
        category = L("sitRooms")
    },
    ["sendToSitRoom"] = {
        func = function(client, target, message) return L("sendToSitRoomLog", os.date("%Y-%m-%d %H:%M:%S"), client:SteamID64(), message, target) end,
        category = L("sitRooms")
    },
    ["unprotectedVJNetCall"] = {
        func = function(client, netMessage) return L("unprotectedVJNetCallLog", client:SteamID64(), client:Name(), netMessage) end,
        category = L("logCategoryVJNet")
    }
}

-- ./modules/core/administration/submodules/logging/module.lua
MODULE.name = "Logger"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a Module that implements a action logger"
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Can See Logs",
        MinAccess = "superadmin",
        Description = "Allows access to Seeing Logs In Console.",
    }
}

MODULE.Dependencies = {
    {
        File = MODULE.path .. "/logs.lua",
        Realm = "server",
    },
}


-- ./modules/core/administration/submodules/permissions/commands.lua
lia.command.add("pktoggle", {
    adminOnly = true,
    privilege = "Toggle Permakill",
    desc = L("togglePermakillDesc"),
    syntax = "[string charname]",
    AdminStick = {
        Name = "Toggle Character Killing (Ban)",
        Category = "Character Management",
        SubCategory = "Bans",
        Icon = "icon16/user_delete.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local character = target:getChar()
        if not character then
            client:notifyLocalized("invalid", "Character")
            return
        end

        local currentState = character:getData("markedForDeath", false)
        local newState = not currentState
        character:setData("markedForDeath", newState)
        if newState then
            client:notifyLocalized("pktoggle_true")
        else
            client:notifyLocalized("pktoggle_false")
        end
    end
})

lia.command.add("playglobalsound", {
    superAdminOnly = true,
    privilege = "Play Sounds",
    desc = L("playGlobalSoundDesc"),
    syntax = "[string sound]",
    onRun = function(client, arguments)
        local sound = arguments[1]
        if not sound or sound == "" then
            client:notifyLocalized("mustSpecifySound")
            return
        end

        for _, target in player.Iterator() do
            target:PlaySound(sound)
        end
    end
})

lia.command.add("playsound", {
    superAdminOnly = true,
    privilege = "Play Sounds",
    desc = L("playSoundDesc"),
    syntax = "[string player] [string sound]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local sound = arguments[2]
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if not sound or sound == "" then
            client:notifyLocalized("noSound")
            return
        end

        target:PlaySound(sound)
    end
})

lia.command.add("returntodeathpos", {
    adminOnly = true,
    privilege = "Return Players",
    desc = L("returnToDeathPosDesc"),
    onRun = function(client)
        if IsValid(client) and client:Alive() then
            local character = client:getChar()
            local oldPos = character and character:getData("deathPos")
            if oldPos then
                client:SetPos(oldPos)
                character:setData("deathPos", nil)
            else
                client:notifyLocalized("noDeathPosition")
            end
        else
            client:notifyLocalized("waitRespawn")
        end
    end
})

lia.command.add("roll", {
    adminOnly = false,
    desc = L("rollDesc"),
    onRun = function(client)
        local rollValue = math.random(0, 100)
        lia.chat.send(client, "roll", rollValue)
    end
})

lia.command.add("forcefallover", {
    adminOnly = true,
    privilege = "Force Fallover",
    desc = L("forceFalloverDesc"),
    syntax = "[player target] [number time]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if target:getNetVar("FallOverCooldown", false) then
            target:notifyLocalized("cmdCooldown")
            return
        elseif target:IsFrozen() then
            target:notifyLocalized("cmdFrozen")
            return
        elseif not target:Alive() then
            target:notifyLocalized("cmdDead")
            return
        elseif target:hasValidVehicle() then
            target:notifyLocalized("cmdVehicle")
            return
        elseif target:isNoClipping() then
            target:notifyLocalized("cmdNoclip")
            return
        end

        local time = tonumber(arguments[2])
        if not time or time < 1 then
            time = 5
        else
            time = math.Clamp(time, 1, 60)
        end

        target:setNetVar("FallOverCooldown", true)
        if not target:hasRagdoll() then
            target:setRagdolled(true, time)
            timer.Simple(10, function() if IsValid(target) then target:setNetVar("FallOverCooldown", false) end end)
        end
    end
})

lia.command.add("forcegetup", {
    adminOnly = true,
    privilege = "Force GetUp",
    desc = L("forceGetUpDesc"),
    syntax = "[player target]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if not target:hasRagdoll() then
            target:notifyLocalized("noRagdoll")
            return
        end

        local entity = target:getRagdoll()
        if IsValid(entity) and entity.liaGrace and entity.liaGrace < CurTime() and entity:GetVelocity():Length2D() < 8 and not entity.liaWakingUp then
            entity.liaWakingUp = true
            target:setAction("gettingUp", 5, function()
                if IsValid(entity) then
                    hook.Run("OnCharGetup", target, entity)
                    SafeRemoveEntity(entity)
                end
            end)
        end
    end
})

lia.command.add("chardesc", {
    adminOnly = false,
    desc = L("changeCharDesc"),
    syntax = "[string desc]",
    onRun = function(client, arguments)
        local desc = table.concat(arguments, " ")
        if not desc:find("%S") then return client:requestString(L("chgName"), L("chgNameDesc"), function(text) lia.command.run(client, "chardesc", {text}) end, client:getChar() and client:getChar():getDesc() or "") end
        local character = client:getChar()
        if character then character:setDesc(desc) end
        return "descChanged"
    end
})

lia.command.add("chargetup", {
    adminOnly = false,
    desc = L("forceSelfGetUpDesc"),
    onRun = function(client)
        if not client:hasRagdoll() then
            client:notifyLocalized("noRagdoll")
            return
        end

        local entity = client:getRagdoll()
        if IsValid(entity) and entity.liaGrace and entity.liaGrace < CurTime() and entity:GetVelocity():Length2D() < 8 and not entity.liaWakingUp then
            entity.liaWakingUp = true
            client:setAction("gettingUp", 5, function()
                if IsValid(entity) then
                    hook.Run("OnCharGetup", client, entity)
                    SafeRemoveEntity(entity)
                end
            end)
        end
    end,
    alias = {"getup"}
})

lia.command.add("fallover", {
    adminOnly = false,
    desc = L("fallOverDesc"),
    syntax = "[number time]",
    onRun = function(client, arguments)
        if client:getNetVar("FallOverCooldown", false) then
            client:notifyLocalized("cmdCooldown")
            return
        end

        if client:IsFrozen() then
            client:notifyLocalized("cmdFrozen")
            return
        end

        if not client:Alive() then
            client:notifyLocalized("cmdDead")
            return
        end

        if client:hasValidVehicle() then
            client:notifyLocalized("cmdVehicle")
            return
        end

        if client:isNoClipping() then
            client:notifyLocalized("cmdNoclip")
            return
        end

        local t = tonumber(arguments[1])
        if not t or t < 1 then
            t = 5
        else
            t = math.Clamp(t, 1, 60)
        end

        client:setNetVar("FallOverCooldown", true)
        if not client:hasRagdoll() then
            client:setRagdolled(true, t)
            timer.Simple(10, function() if IsValid(client) then client:setNetVar("FallOverCooldown", false) end end)
        end
    end
})

lia.command.add("togglelockcharacters", {
    superAdminOnly = true,
    privilege = "Toggle Character Lock",
    desc = L("toggleCharLockDesc"),
    syntax = "[boolean lock]",
    onRun = function()
        local newVal = not GetGlobalBool("characterSwapLock", false)
        SetGlobalBool("characterSwapLock", newVal)
        if not newVal then
            return "Now the players will be able to change character"
        else
            return "Now the players won't be able to change character until the server is restarted or until you re-enable it"
        end
    end
})

lia.command.add("checkinventory", {
    adminOnly = true,
    privilege = "Check Inventories",
    desc = L("checkInventoryDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickCheckInventoryName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryItems"),
        Icon = "icon16/box.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if target == client then
            client:notifyLocalized("invCheckSelf")
            return
        end

        local inventory = target:getChar():getInv()
        inventory:addAccessRule(function(_, action, _) return action == "transfer" end, 1)
        inventory:addAccessRule(function(_, action, _) return action == "repl" end, 1)
        inventory:sync(client)
        net.Start("OpenInvMenu")
        net.WriteEntity(target)
        net.WriteType(inventory:getID())
        net.Send(client)
    end
})

lia.command.add("flaggive", {
    adminOnly = true,
    privilege = "Manage Flags",
    desc = L("flagGiveDesc"),
    syntax = "[string playerName] [string flags]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local flags = arguments[2]
        if not flags then
            local available = ""
            for k in SortedPairs(lia.flag.list) do
                if not target:getChar():hasFlags(k) then available = available .. k .. " " end
            end

            available = available:Trim()
            if available == "" then
                client:notifyLocalized("noAvailableFlags")
                return
            end
            return client:requestString(L("flagGiveTitle"), L("flagGiveDesc"), function(text) lia.command.run(client, "flaggive", {target:Name(), text}) end, available)
        end

        target:getChar():giveFlags(flags)
        client:notifyLocalized("flagGive", client:Name(), flags, target:Name())
    end,
    alias = {"giveflag", "chargiveflag"}
})

lia.command.add("flaggiveall", {
    adminOnly = true,
    privilege = "Manage Flags",
    desc = L("giveAllFlagsDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickGiveAllFlagsName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/flag_blue.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local character = target:getChar()
        for k, _ in SortedPairs(lia.flag.list) do
            if not character:hasFlags(k) then character:giveFlags(k) end
        end

        client:notifyLocalized("gaveAllFlags")
    end
})

lia.command.add("flagtakeall", {
    adminOnly = true,
    privilege = "Manage Flags",
    desc = L("takeAllFlagsDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickTakeAllFlagsName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/flag_green.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local character = target:getChar()
        if not character then
            client:notifyLocalized("invalidTarget")
            return
        end

        for k, _ in SortedPairs(lia.flag.list) do
            if character:hasFlags(k) then character:takeFlags(k) end
        end

        client:notifyLocalized("tookAllFlags")
    end
})

lia.command.add("flagtake", {
    adminOnly = true,
    privilege = "Manage Flags",
    desc = L("flagTakeDesc"),
    syntax = "[string playerName] [string flags]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local flags = arguments[2]
        if not flags then
            local currentFlags = target:getChar():getFlags()
            return client:requestString(L("flagTakeTitle"), L("flagTakeDesc"), function(text) lia.command.run(client, "flagtake", {target:Name(), text}) end, table.concat(currentFlags, ", "))
        end

        target:getChar():takeFlags(flags)
        client:notifyLocalized("flagTake", client:Name(), flags, target:Name())
    end,
    alias = {"takeflag"}
})

lia.command.add("bringlostitems", {
    superAdminOnly = true,
    privilege = "Manage Items",
    desc = L("bringLostItemsDesc"),
    onRun = function(client)
        for _, v in ipairs(ents.FindInSphere(client:GetPos(), 500)) do
            if v:isItem() then v:SetPos(client:GetPos()) end
        end
    end
})

lia.command.add("cleanitems", {
    superAdminOnly = true,
    privilege = "Clean Entities",
    desc = L("cleanItemsDesc"),
    onRun = function(client)
        local count = 0
        for _, v in ipairs(ents.FindByClass("lia_item")) do
            count = count + 1
            SafeRemoveEntity(v)
        end

        client:notifyLocalized("cleaningFinished", "Items", count)
    end
})

lia.command.add("cleanprops", {
    superAdminOnly = true,
    privilege = "Clean Entities",
    desc = L("cleanPropsDesc"),
    onRun = function(client)
        local count = 0
        for _, entity in ents.Iterator() do
            if IsValid(entity) and entity:isProp() then
                count = count + 1
                SafeRemoveEntity(entity)
            end
        end

        client:notifyLocalized("cleaningFinished", "Props", count)
    end
})

lia.command.add("cleannpcs", {
    superAdminOnly = true,
    privilege = "Clean Entities",
    desc = L("cleanNPCsDesc"),
    onRun = function(client)
        local count = 0
        for _, entity in ents.Iterator() do
            if IsValid(entity) and entity:IsNPC() then
                count = count + 1
                SafeRemoveEntity(entity)
            end
        end

        client:notifyLocalized("cleaningFinished", "NPCs", count)
    end
})

lia.command.add("charunban", {
    superAdminOnly = true,
    privilege = "Manage Characters",
    desc = L("charUnbanDesc"),
    syntax = "[string name or number id]",
    onRun = function(client, arguments)
        if (client.liaNextSearch or 0) >= CurTime() then return L("searchingChar") end
        local queryArg = table.concat(arguments, " ")
        local charFound
        local id = tonumber(queryArg)
        if id then
            for _, v in pairs(lia.char.loaded) do
                if v:getID() == id then
                    charFound = v
                    break
                end
            end
        else
            for _, v in pairs(lia.char.loaded) do
                if lia.util.stringMatches(v:getName(), queryArg) then
                    charFound = v
                    break
                end
            end
        end

        if charFound then
            if charFound:getData("banned") then
                charFound:setData("banned", nil)
                charFound:setData("permakilled", nil)
                client:notifyLocalized("charUnBan", client:Name(), charFound:getName())
            else
                return L("charNotBanned")
            end
        end

        client.liaNextSearch = CurTime() + 15
        local sqlCondition = id and "_id = " .. id or "_name LIKE \"%" .. lia.db.escape(queryArg) .. "%\""
        lia.db.query("SELECT _id, _name, _data FROM lia_characters WHERE " .. sqlCondition .. " LIMIT 1", function(data)
            if data and data[1] then
                local charID = tonumber(data[1]._id)
                local charData = util.JSONToTable(data[1]._data or "[]")
                client.liaNextSearch = 0
                if not charData.banned then
                    client:notifyLocalized("charNotBanned")
                    return
                end

                charData.banned = nil
                lia.db.updateTable({
                    _data = util.TableToJSON(charData)
                }, nil, nil, "_id = " .. charID)

                client:notifyLocalized("charUnBan", client:Name(), data[1]._name)
            end
        end)
    end
})

lia.command.add("clearinv", {
    superAdminOnly = true,
    privilege = "Manage Characters",
    desc = L("clearInvDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickClearInventoryName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryItems"),
        Icon = "icon16/bin.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        target:getChar():getInv():wipeItems()
        client:notifyLocalized("resetInv", target:getChar():getName())
    end
})

lia.command.add("charkick", {
    adminOnly = true,
    privilege = "Kick Characters",
    desc = L("kickCharDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickKickCharacterName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryBans"),
        Icon = "icon16/user_delete.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local character = target:getChar()
        if character then
            for _, targets in player.Iterator() do
                targets:notifyLocalized("charKick", client:Name(), target:Name())
            end

            character:kick()
        else
            client:notifyLocalized("noChar")
        end
    end
})

lia.command.add("freezeallprops", {
    superAdminOnly = true,
    privilege = "Manage Characters",
    desc = L("freezeAllPropsDesc"),
    syntax = "[string playerName]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local count = 0
        local tbl = cleanup.GetList(target)[target:UniqueID()] or {}
        for _, propTable in pairs(tbl) do
            for _, ent in pairs(propTable) do
                if IsValid(ent) and IsValid(ent:GetPhysicsObject()) then
                    ent:GetPhysicsObject():EnableMotion(false)
                    count = count + 1
                end
            end
        end

        client:notifyLocalized("freezeAllProps", target:Name())
        client:ChatPrint(L("freezeAllPropsCount", count, target:Name()))
    end
})

lia.command.add("charban", {
    superAdminOnly = true,
    privilege = "Manage Characters",
    desc = L("banCharDesc"),
    syntax = "[string name or number id]",
    AdminStick = {
        Name = L("adminStickBanCharacterName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryBans"),
        Icon = "icon16/user_red.png"
    },
    onRun = function(client, arguments)
        local queryArg = table.concat(arguments, " ")
        local target
        local id = tonumber(queryArg)
        if id then
            for _, ply in player.Iterator() do
                if IsValid(ply) and ply:getChar() and ply:getChar():getID() == id then
                    target = ply
                    break
                end
            end
        else
            target = lia.util.findPlayer(client, arguments[1])
        end

        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local character = target:getChar()
        if character then
            character:setData("banned", true)
            character:setData("charBanInfo", {
                name = client.steamName and client:steamName() or client:Name(),
                steamID = client:SteamID64(),
                rank = client:GetUserGroup()
            })

            character:save()
            character:kick()
            client:notifyLocalized("charBan", client:Name(), target:Name())
        else
            client:notifyLocalized("noChar")
        end
    end
})

lia.command.add("checkmoney", {
    adminOnly = true,
    privilege = "Get Character Info",
    desc = L("checkMoneyDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickCheckMoneyName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryItems"),
        Icon = "icon16/money.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local money = target:getChar():getMoney()
        client:ChatPrint(L("playerMoney", target:GetName(), lia.currency.get(money)))
    end
})

lia.command.add("listbodygroups", {
    adminOnly = true,
    privilege = "Get Character Info",
    desc = L("listBodygroupsDesc"),
    syntax = "[string playerName]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local bodygroups = {}
        for i = 0, target:GetNumBodyGroups() - 1 do
            if target:GetBodygroupCount(i) > 1 then
                table.insert(bodygroups, {
                    group = i,
                    name = target:GetBodygroupName(i),
                    range = "0-" .. target:GetBodygroupCount(i) - 1
                })
            end
        end

        if #bodygroups > 0 then
            local title = L("uiBodygroupsFor", target:Nick())
            lia.util.CreateTableUI(client, title, {
                {
                    name = L("groupID"),
                    field = "group"
                },
                {
                    name = L("name"),
                    field = "name"
                },
                {
                    name = L("range"),
                    field = "range"
                }
            }, bodygroups)
        else
            client:notifyLocalized("noBodygroups")
        end
    end
})

lia.command.add("charsetspeed", {
    adminOnly = true,
    privilege = "Manage Character Stats",
    desc = L("setSpeedDesc"),
    syntax = "[string playerName] [number speed]",
    AdminStick = {
        Name = L("adminStickSetCharSpeedName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/lightning.png",
        ExtraFields = {
            ["speed"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local speed = tonumber(arguments[2]) or lia.config.get("WalkSpeed")
        target:SetRunSpeed(speed)
    end
})

lia.command.add("charsetmodel", {
    adminOnly = true,
    privilege = "Manage Character Information",
    desc = L("setModelDesc"),
    syntax = "[string playerName] [string model]",
    AdminStick = {
        Name = L("adminStickSetCharModelName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/user_gray.png",
        ExtraFields = {
            ["model"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local oldModel = target:getChar():getModel()
        target:getChar():setModel(arguments[2] or oldModel)
        target:SetupHands()
        client:notifyLocalized("changeModel", client:Name(), target:Name(), arguments[2] or oldModel)
        lia.log.add(client, "charsetmodel", target:Name(), arguments[2], oldModel)
    end
})

lia.command.add("chargiveitem", {
    superAdminOnly = true,
    privilege = "Manage Items",
    desc = L("giveItemDesc"),
    syntax = "[string playerName] [string itemNameOrID]",
    AdminStick = {
        Name = L("adminStickGiveItemName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryItems"),
        Icon = "icon16/user_gray.png",
        ExtraFields = {
            ["item"] = function()
                local items = {}
                for _, v in pairs(lia.item.list) do
                    table.insert(items, v.name)
                end
                return items, "combo"
            end
        }
    },
    onRun = function(client, arguments)
        local itemName = arguments[2]
        if not itemName or itemName == "" then
            client:notifyLocalized("mustSpecifyItem")
            return
        end

        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local uniqueID
        for _, v in SortedPairs(lia.item.list) do
            if lia.util.stringMatches(v.name, itemName) or lia.util.stringMatches(v.uniqueID, itemName) then
                uniqueID = v.uniqueID
                break
            end
        end

        if not uniqueID then
            client:notifyLocalized("itemNoExist")
            return
        end

        local inv = target:getChar():getInv()
        local succ, err = inv:add(uniqueID)
        if succ then
            target:notifyLocalized("itemCreated")
            if target ~= client then client:notifyLocalized("itemCreated") end
        else
            target:notify(tostring(succ))
            target:notify(tostring(err))
        end
    end
})

lia.command.add("charsetdesc", {
    adminOnly = true,
    privilege = "Manage Character Information",
    desc = L("setDescDesc"),
    syntax = "[string playerName] [string description]",
    AdminStick = {
        Name = L("adminStickSetCharDescName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/user_comment.png",
        ExtraFields = {
            ["desc"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if not target:getChar() then
            client:notifyLocalized("noChar")
            return
        end

        local desc = table.concat(arguments, " ", 2)
        if not desc:find("%S") then return client:requestString("Change " .. target:Name() .. "'s Description", L("enterNewDesc"), function(text) lia.command.run(client, "charsetdesc", {arguments[1], text}) end, target:getChar():getDesc()) end
        target:getChar():setDesc(desc)
        return L("descChangedTarget", client:Name(), target:Name())
    end
})

lia.command.add("charsetname", {
    adminOnly = true,
    privilege = "Manage Character Information",
    desc = L("setNameDesc"),
    syntax = "[string playerName] [string newName]",
    AdminStick = {
        Name = L("adminStickSetCharNameName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/user_edit.png",
        ExtraFields = {
            ["newName"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local newName = table.concat(arguments, " ", 2)
        if newName == "" then return client:requestString(L("chgName"), L("chgNameDesc"), function(text) lia.command.run(client, "charsetname", {target:Name(), text}) end, target:Name()) end
        target:getChar():setName(newName:gsub("#", "#?"))
        client:notifyLocalized("changeName", client:Name(), target:Name(), newName)
    end
})

lia.command.add("charsetscale", {
    adminOnly = true,
    privilege = "Manage Character Stats",
    desc = L("setScaleDesc"),
    syntax = "[string playerName] [number scale]",
    AdminStick = {
        Name = L("adminStickSetCharScaleName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/arrow_out.png",
        ExtraFields = {
            ["value"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local scale = tonumber(arguments[2]) or 1
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        target:SetModelScale(scale, 0)
        client:notifyLocalized("changedScale", client:Name(), target:Name(), scale)
    end
})

lia.command.add("charsetjump", {
    adminOnly = true,
    privilege = "Manage Character Stats",
    desc = L("setJumpDesc"),
    syntax = "[string playerName] [number power]",
    AdminStick = {
        Name = L("adminStickSetCharJumpName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/arrow_up.png",
        ExtraFields = {
            ["power"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local power = tonumber(arguments[2]) or 200
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        target:SetJumpPower(power)
        client:notifyLocalized("changedJump", client:Name(), target:Name(), power)
    end
})

lia.command.add("charsetbodygroup", {
    adminOnly = true,
    privilege = "Manage Bodygroups",
    desc = L("setBodygroupDesc"),
    syntax = "[string playerName] [string bodyGroupName] [number value]",
    onRun = function(client, arguments)
        local name = arguments[1]
        local bodyGroup = arguments[2]
        local value = tonumber(arguments[3])
        local target = lia.util.findPlayer(client, name)
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local index = target:FindBodygroupByName(bodyGroup)
        if index > -1 then
            if value and value < 1 then value = nil end
            local groups = target:getChar():getData("groups", {})
            groups[index] = value
            target:getChar():setData("groups", groups)
            target:SetBodygroup(index, value or 0)
            client:notifyLocalized("changeBodygroups", client:Name(), target:Name(), bodyGroup, value or 0)
        else
            client:notifyLocalized("invalidArg")
        end
    end
})

lia.command.add("charsetskin", {
    adminOnly = true,
    privilege = "Manage Character Stats",
    desc = L("setSkinDesc"),
    syntax = "[string playerName] [number skin]",
    AdminStick = {
        Name = L("adminStickChangeName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategorySetInfos"),
        Icon = "icon16/user_gray.png",
        ExtraFields = {
            ["skin"] = "text"
        }
    },
    onRun = function(client, arguments)
        local name = arguments[1]
        local skin = tonumber(arguments[2])
        local target = lia.util.findPlayer(client, name)
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        target:getChar():setData("skin", skin)
        target:SetSkin(skin or 0)
        client:notifyLocalized("changeSkin", client:Name(), target:Name(), skin or 0)
    end
})

lia.command.add("charsetmoney", {
    superAdminOnly = true,
    privilege = "Manage Characters",
    desc = L("setMoneyDesc"),
    syntax = "[string playerName] [number amount]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local amount = tonumber(arguments[2])
        if not amount or amount < 0 then
            client:notifyLocalized("invalidArg")
            return
        end

        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        target:getChar():setMoney(math.floor(amount))
        client:notifyLocalized("setMoney", target:Name(), lia.currency.get(math.floor(amount)))
    end
})

lia.command.add("charaddmoney", {
    superAdminOnly = true,
    privilege = "Manage Characters",
    desc = L("addMoneyDesc"),
    syntax = "[string playerName] [number amount]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local amount = tonumber(arguments[2])
        if not amount then
            client:notifyLocalized("invalidArg")
            return
        end

        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        amount = math.Round(amount)
        local currentMoney = target:getChar():getMoney()
        target:getChar():setMoney(currentMoney + amount)
        client:notifyLocalized("addMoney", target:Name(), lia.currency.get(amount), lia.currency.get(currentMoney + amount))
    end,
    alias = {"chargivemoney"}
})

lia.command.add("globalbotsay", {
    superAdminOnly = true,
    privilege = "Bot Say",
    desc = L("globalBotSayDesc"),
    syntax = "[string message]",
    onRun = function(client, arguments)
        local message = table.concat(arguments, " ")
        if message == "" then
            client:notifyLocalized("noMessage")
            return
        end

        for _, bot in player.Iterator() do
            if bot:IsBot() then bot:Say(message) end
        end
    end
})

lia.command.add("botsay", {
    superAdminOnly = true,
    privilege = "Bot Say",
    desc = L("botSayDesc"),
    syntax = "[string botName] [string message]",
    onRun = function(client, arguments)
        if #arguments < 2 then
            client:notifyLocalized("needBotAndMessage")
            return
        end

        local botName = arguments[1]
        local message = table.concat(arguments, " ", 2)
        local targetBot
        for _, bot in player.Iterator() do
            if bot:IsBot() and string.find(string.lower(bot:Nick()), string.lower(botName)) then
                targetBot = bot
                break
            end
        end

        if not targetBot then
            client:notifyLocalized("botNotFound", botName)
            return
        end

        targetBot:Say(message)
    end
})

lia.command.add("forcesay", {
    superAdminOnly = true,
    privilege = "Force Say",
    desc = L("forceSayDesc"),
    syntax = "[string playerName] [string message]",
    AdminStick = {
        Name = "Force Say",
        Category = L("adminStickCategoryModeration"),
        SubCategory = L("adminStickSubCategoryMisc"),
        Icon = "icon16/comments.png",
        ExtraFields = {
            ["message"] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local message = table.concat(arguments, " ", 2)
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if message == "" then
            client:notifyLocalized("noMessage")
            return
        end

        target:Say(message)
    end
})

lia.command.add("getmodel", {
    desc = L("getModelDesc"),
    onRun = function(client)
        local entity = client:getTracedEntity()
        if not IsValid(entity) then
            client:notify("No valid entity found in front of you.")
            return
        end

        local model = entity:GetModel() or "No model found."
        client:ChatPrint("The model is: " .. model)
    end
})

lia.command.add("pm", {
    desc = L("pmDesc"),
    syntax = "[string playerName] [string message]",
    onRun = function(client, arguments)
        if not lia.config.get("AllowPMs") then
            client:notifyLocalized("pmsDisabled")
            return
        end

        local targetName = arguments[1]
        local message = table.concat(arguments, " ", 2)
        local target = lia.util.findPlayer(client, targetName)
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if not message:find("%S") then
            client:notifyLocalized("noMessage")
            return
        end

        lia.chat.send(client, "pm", message, false, {client, target})
    end
})

lia.command.add("chargetmodel", {
    adminOnly = true,
    privilege = "Get Character Info",
    desc = L("getCharModelDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickGetCharModelName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryGetInfos"),
        Icon = "icon16/user_gray.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        client:ChatPrint("Character Model: " .. target:GetModel())
    end
})

lia.command.add("checkallmoney", {
    superAdminOnly = true,
    privilege = "Get Character Info",
    desc = L("checkAllMoneyDesc"),
    onRun = function(client)
        for _, target in player.Iterator() do
            local char = target:getChar()
            if char then client:ChatPrint(L("playerMoney", target:GetName(), lia.currency.get(char:getMoney()))) end
        end
    end
})

lia.command.add("checkflags", {
    adminOnly = true,
    privilege = "Get Character Info",
    desc = L("checkFlagsDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickGetCharFlagsName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryGetInfos"),
        Icon = "icon16/flag_yellow.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local flags = target:getChar():getFlags()
        if flags and #flags > 0 then
            client:ChatPrint(target:Name() .. "  " .. table.concat(flags, ", "))
        else
            client:ChatPrint(target:Name() .. " has no flags.")
        end
    end
})

lia.command.add("chargetname", {
    adminOnly = true,
    privilege = "Get Character Info",
    desc = L("getCharNameDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickGetCharNameName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryGetInfos"),
        Icon = "icon16/user.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        client:ChatPrint("Character Name: " .. target:getChar():getName())
    end
})

lia.command.add("chargethealth", {
    adminOnly = true,
    privilege = "Get Character Info",
    desc = L("getHealthDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickGetCharHealthName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryGetInfos"),
        Icon = "icon16/heart.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        client:ChatPrint("Character Health: " .. target:Health() .. "/" .. target:GetMaxHealth())
    end
})

lia.command.add("chargetmoney", {
    adminOnly = true,
    privilege = "Get Character Info",
    desc = L("getMoneyDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickGetCharMoneyName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryGetInfos"),
        Icon = "icon16/money.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local money = target:getChar():getMoney()
        client:ChatPrint("Character Money: " .. lia.currency.get(money))
    end
})

lia.command.add("chargetinventory", {
    adminOnly = true,
    privilege = "Get Character Info",
    desc = L("getInventoryDesc"),
    syntax = "[string playerName]",
    AdminStick = {
        Name = L("adminStickGetCharInventoryName"),
        Category = L("adminStickCategoryCharManagement"),
        SubCategory = L("adminStickSubCategoryGetInfos"),
        Icon = "icon16/box.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local inventory = target:getChar():getInv()
        local items = inventory:getItems()
        if not items or table.Count(items) < 1 then
            client:notifyLocalized("charInvEmpty")
            return
        end

        local result = {}
        for _, item in pairs(items) do
            table.insert(result, item.name)
        end

        client:ChatPrint("Character Inventory: " .. table.concat(result, ", "))
    end
})

-- ./modules/core/administration/submodules/permissions/config.lua
lia.config.add("SpawnMenuLimit", "Limit Spawn Menu Access", false, nil, {
    desc = "Determines if the spawn menu is limited to PET flag holders or staff",
    category = "Staff",
    type = "Boolean"
})

MODULE.RestrictedEnts = {
    ["func_button"] = true,
    ["class C_BaseEntity"] = true,
    ["func_brush"] = true,
    ["func_tracktrain"] = true,
    ["func_door"] = true,
    ["func_door_rotating"] = true,
    ["prop_static"] = true,
    ["prop_physics_override"] = true,
    ["prop_dynamic"] = true,
    ["func_movelinear"] = true,
    ["prop_door_rotating"] = true,
    ["lia_vendor"] = true,
}

MODULE.RemoverBlockedEntities = {
    ["lia_bodygroupcloset"] = true,
    ["lia_vendor"] = true,
}

MODULE.BlackListedProps = {
    ["models/props_c17/FurnitureCupboard001a.mdl"] = true,
    ["models/props_c17/FurnitureDresser001a.mdl"] = true,
}

MODULE.RestrictedVehicles = {}
MODULE.CanNotPermaProp = {
    ["lia_vendor"] = true,
    ["lia_bodygrouper"] = true,
}

MODULE.DuplicatorBlackList = {
    ["lia_storage"] = true,
    ["lia_money"] = true,
}

lia.option.add("espActive", "ESP Active", "Enable ESP to highlight entities", false, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("espPlayers", "ESP Players", "Enable ESP for players", false, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("espItems", "ESP Items", "Enable ESP for items", false, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("espProps", "ESP Props", "Enable ESP for props", false, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("espEntities", "ESP Entities", "Enable ESP for entities", false, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("espItemsColor", "ESP Items Color", "Sets the ESP color for items", {
    r = 0,
    g = 255,
    b = 0,
    a = 255
}, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("espEntitiesColor", "ESP Entities Color", "Sets the ESP color for entities", {
    r = 255,
    g = 255,
    b = 0,
    a = 255
}, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("espPropsColor", "ESP Props Color", "Sets the ESP color for props", {
    r = 255,
    g = 0,
    b = 0,
    a = 255
}, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("espPlayersColor", "ESP Players Color", "Sets the ESP color for players", {
    r = 0,
    g = 0,
    b = 255,
    a = 255
}, nil, {
    category = "ESP",
    visible = function()
        local ply = LocalPlayer()
        if not IsValid(ply) then return false end
        return ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")
    end
})

lia.option.add("BarsAlwaysVisible", "Bars Always Visible", "Make all bars always visible", false, nil, {
    category = "General"
})

lia.option.add("descriptionWidth", "Description Width", "Adjust the description width on the HUD", 0.5, nil, {
    category = "HUD",
    min = 0.1,
    max = 1,
    decimals = 2
})

-- ./modules/core/administration/submodules/permissions/factions/staff.lua
FACTION.name = L("factionStaffName")
FACTION.desc = L("factionStaffDesc")
FACTION.color = Color(255, 56, 252)
FACTION.isDefault = false
FACTION.models = {"models/Humans/Group02/male_07.mdl", "models/Humans/Group02/male_07.mdl", "models/Humans/Group02/male_07.mdl", "models/Humans/Group02/male_07.mdl", "models/Humans/Group02/male_07.mdl"}
FACTION.weapons = {"weapon_physgun", "gmod_tool"}
FACTION_STAFF = FACTION.index


-- ./modules/core/administration/submodules/permissions/libraries/client.lua

local ESP_DrawnEntities = {
    lia_bodygrouper = true,
    lia_vendor = true,
}

function MODULE:PrePlayerDraw(client)
    if not IsValid(client) then return end
    if client:isNoClipping() then return true end
end

function MODULE:HUDPaint()
    if not lia.option.get("espActive") then return end
    local client = LocalPlayer()
    if not client:getChar() or not client:IsValid() or not client:IsPlayer() then return end
    if not client:isNoClipping() and not client:hasValidVehicle() then return end
    if not (client:hasPrivilege("Staff Permissions - No Clip ESP Outside Staff Character") or client:isStaffOnDuty()) then return end
    local marginx, marginy = ScrW() * 0.1, ScrH() * 0.1
    local maxDistanceSq = 4096
    for _, ent in ents.Iterator() do
        if not IsValid(ent) or ent == client then continue end
        local entityType, label
        if ent:IsPlayer() and lia.option.get("espPlayers") then
            entityType, label = "Players", ent:Name():gsub("#", "\226\128\139#")
        elseif ent.isItem and ent:isItem() and lia.option.get("espItems") then
            entityType = "Items"
            local itemTable = ent.getItemTable and ent:getItemTable()
            label = "Item: " .. (itemTable and itemTable.name or "Invalid")
        elseif ent.isProp and ent:isProp() and lia.option.get("espProps") then
            entityType = "Props"
            label = "Prop Model: " .. (ent:GetModel() or L("unknown"))
        elseif ESP_DrawnEntities[ent:GetClass()] and lia.option.get("espEntities") then
            entityType = "Entities"
            label = "Entity Class: " .. (ent:GetClass() or L("unknown"))
        end

        if not entityType then continue end
        local vPos, clientPos = ent:GetPos(), client:GetPos()
        if not vPos or not clientPos then continue end
        local scrPos = vPos:ToScreen()
        if not scrPos.visible then continue end
        local distanceSq = clientPos:DistToSqr(vPos)
        local factor = 1 - math.Clamp(distanceSq / maxDistanceSq, 0, 1)
        local size = math.max(20, 48 * factor)
        local alpha = math.Clamp(255 * factor, 120, 255)
        local colorToUse = ColorAlpha(lia.config.get("esp" .. entityType .. "Color") or Color(255, 255, 255), alpha)
        local x, y = math.Clamp(scrPos.x, marginx, ScrW() - marginx), math.Clamp(scrPos.y, marginy, ScrH() - marginy)
        surface.SetDrawColor(colorToUse.r, colorToUse.g, colorToUse.b, colorToUse.a)
        surface.DrawRect(x - size / 2, y - size / 2, size, size)
        draw.SimpleTextOutlined(label, "liaMediumFont", x, y - size, ColorAlpha(colorToUse, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(0, 0, 0, 200))
    end
end

concommand.Add("dev_GetCameraOrigin", function(client)
    if client:isStaff() then
        lia.information("origin = (" .. math.ceil(client:GetPos().x) .. ", " .. math.ceil(client:GetPos().y) .. ", " .. math.ceil(client:GetPos().z) .. ")")
        lia.information("angles = (" .. math.ceil(client:GetAngles().x) .. ", " .. math.ceil(client:GetAngles().y) .. ", " .. math.ceil(client:GetAngles().z) .. ")")
    end
end)

concommand.Add("vgui_cleanup", function()
    for _, v in pairs(vgui.GetWorldPanel():GetChildren()) do
        if not (v.Init and debug.getinfo(v.Init, "Sln").short_src:find("chatbox")) then v:Remove() end
    end
end, nil, "Removes every panel that you have left over (like that errored DFrame filling up your screen)")

concommand.Add("weighpoint_stop", function() hook.Add("HUDPaint", "WeighPoint", function() end) end)
concommand.Add("dev_GetEntPos", function(client) if client:isStaff() then lia.information(client:getTracedEntity():GetPos().x, client:getTracedEntity():GetPos().y, client:getTracedEntity():GetPos().z) end end)
concommand.Add("dev_GetEntAngles", function(client) if client:isStaff() then lia.information(math.ceil(client:getTracedEntity():GetAngles().x) .. ", " .. math.ceil(client:getTracedEntity():GetAngles().y) .. ", " .. math.ceil(client:getTracedEntity():GetAngles().z)) end end)
concommand.Add("dev_GetRoundEntPos", function(client) if client:isStaff() then lia.information(math.ceil(client:getTracedEntity():GetPos().x) .. ", " .. math.ceil(client:getTracedEntity():GetPos().y) .. ", " .. math.ceil(client:getTracedEntity():GetPos().z)) end end)
concommand.Add("dev_GetPos", function(client) if client:isStaff() then lia.information(math.ceil(client:GetPos().x) .. ", " .. math.ceil(client:GetPos().y) .. ", " .. math.ceil(client:GetPos().z)) end end)

-- ./modules/core/administration/submodules/permissions/libraries/server.lua
local GM = GM or GAMEMODE
local MODULE = MODULE
local resetCalled = 0
function GM:PlayerSpawnProp(client, model)
    if MODULE.BlackListedProps and MODULE.BlackListedProps[model] and not client:hasPrivilege("Spawn Permissions - Can Spawn Blacklisted Props") then
        client:notify("Blacklisted Prop!")
        return false
    end

    local weapon = client:GetActiveWeapon()
    if IsValid(weapon) and weapon:GetClass() == "gmod_tool" then
        local toolobj = weapon:GetToolObject()
        if toolobj and (client.AdvDupe2 and client.AdvDupe2.Entities or client.CurrentDupe and client.CurrentDupe.Entities or toolobj.Entities) then return true end
    end

    local canSpawn = client:IsSuperAdmin() or client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn Props") or client:getChar():hasFlags("e")
    if not canSpawn then client:notify("You do not have permission to spawn props.") end
    return canSpawn
end

function GM:CanProperty(client, property, entity)
    local restrictedProperties = {
        persist = true,
        drive = true,
        bonemanipulate = true
    }

    if restrictedProperties[property] then
        client:notify("This is disabled to avoid issues with Lilia's Core Features")
        return false
    end

    if entity:IsWorld() and IsValid(entity) then
        if client:hasPrivilege("Staff Permissions - Can Property World Entities") then return true end
        client:notify("You do not have permission to modify world entities.")
        return false
    end

    local entityClass = entity:GetClass()
    if MODULE.RemoverBlockedEntities and MODULE.RemoverBlockedEntities[entityClass] or MODULE.RestrictedEnts and MODULE.RestrictedEnts[entityClass] then
        if client:hasPrivilege("Staff Permissions - Use Entity Properties on Blocked Entities") then return true end
        client:notify("You do not have permission to modify properties on this entity.")
        return false
    end

    if entity:GetCreator() == client and (property == "remover" or property == "collision") then return true end
    if client:IsSuperAdmin() or client:hasPrivilege("Staff Permissions - Access Property " .. property:gsub("^%l", string.upper)) and client:isStaffOnDuty() then return true end
    client:notify("You do not have permission to modify this property.")
    return false
end

function GM:PhysgunPickup(client, entity)
    local entityClass = entity:GetClass()
    if (client:hasPrivilege("Staff Permissions - Physgun Pickup") or client:isStaffOnDuty()) and MODULE.RestrictedEnts and MODULE.RestrictedEnts[entityClass] then
        if not client:hasPrivilege("Staff Permissions - Physgun Pickup on Restricted Entities") then
            client:notify("You do not have permission to pick up restricted entities with the physgun.")
            return false
        end
        return true
    end

    if client:IsSuperAdmin() then return true end
    if entity:GetCreator() == client and (entity:isProp() or entity:isItem()) then return true end
    if client:hasPrivilege("Staff Permissions - Physgun Pickup") then
        if entity:IsVehicle() then
            if not client:hasPrivilege("Staff Permissions - Physgun Pickup on Vehicles") then
                client:notify("You do not have permission to pick up vehicles with the physgun.")
                return false
            end
            return true
        elseif entity:IsPlayer() then
            if entity:hasPrivilege("Staff Permissions - Can't be Grabbed with PhysGun") or not client:hasPrivilege("Staff Permissions - Can Grab Players") then
                client:notify("You do not have permission to pick up this player with the physgun.")
                return false
            end
            return true
        elseif entity:IsWorld() or entity:CreatedByMap() then
            if not client:hasPrivilege("Staff Permissions - Can Grab World Props") then
                client:notify("You do not have permission to pick up world props with the physgun.")
                return false
            end
            return true
        end
        return true
    end

    client:notify("You do not have permission to pick up this entity with the physgun.")
    return false
end

function GM:PlayerSpawnVehicle(client, _, name)
    if MODULE.RestrictedVehicles and MODULE.RestrictedVehicles[name] and not client:hasPrivilege("Spawn Permissions - Can Spawn Restricted Cars") then
        client:notify("You can't spawn this vehicle since it's restricted!")
        return false
    end

    if not client:hasPrivilege("Spawn Permissions - No Car Spawn Delay") then client.NextVehicleSpawn = SysTime() + lia.config.get("PlayerSpawnVehicleDelay", 30) end
    local canSpawn = client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn Cars") or client:getChar():hasFlags("C")
    if not canSpawn then client:notify("You do not have permission to spawn vehicles.") end
    return canSpawn
end

function GM:PlayerNoClip(ply, enabled)
    if not (ply:isStaffOnDuty() or ply:hasPrivilege("Staff Permissions - No Clip Outside Staff Character")) then
        ply:notify("You do not have permission to noclip.")
        return false
    end

    ply:DrawShadow(not enabled)
    ply:SetNoTarget(enabled)
    ply:AddFlags(FL_NOTARGET)
    hook.Run("OnPlayerObserve", ply, enabled)
    return true
end

function GM:PlayerSpawnEffect(client)
    local canSpawn = client:IsSuperAdmin() or client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn Effects") or client:getChar():hasFlags("L")
    if not canSpawn then client:notify("You do not have permission to spawn effects.") end
    return canSpawn
end

function GM:PlayerSpawnNPC(client)
    local canSpawn = client:IsSuperAdmin() or client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn NPCs") or client:getChar():hasFlags("n")
    if not canSpawn then client:notify("You do not have permission to spawn NPCs.") end
    return canSpawn
end

function GM:PlayerSpawnRagdoll(client)
    local canSpawn = client:IsSuperAdmin() or client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn Ragdolls") or client:getChar():hasFlags("r")
    if not canSpawn then client:notify("You do not have permission to spawn ragdolls.") end
    return canSpawn
end

function GM:PlayerSpawnSENT(client)
    local canSpawn = client:IsSuperAdmin() or client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn SENTs") or client:getChar():hasFlags("E")
    if not canSpawn then client:notify("You do not have permission to spawn SENTs.") end
    return canSpawn
end

function GM:PlayerSpawnSWEP(client)
    local canSpawn = client:IsSuperAdmin() or client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn SWEPs") or client:getChar():hasFlags("z")
    if not canSpawn then client:notify("You do not have permission to spawn SWEPs.") end
    return canSpawn
end

function GM:PlayerGiveSWEP(client)
    local canGive = client:IsSuperAdmin() or client:isStaffOnDuty() or client:hasPrivilege("Spawn Permissions - Can Spawn SWEPs") or client:getChar():hasFlags("W")
    if not canGive then client:notify("You do not have permission to give SWEPs.") end
    return canGive
end

function GM:OnPhysgunReload(_, client)
    local canReload = client:hasPrivilege("Staff Permissions - Can Physgun Reload")
    if not canReload then client:notify("You do not have permission to reload the physgun.") end
    return canReload
end

function GM:CanTool(client, _, tool)
    local DisallowedTools = {
        rope = true,
        light = true,
        lamp = true,
        dynamite = true,
        physprop = true,
        faceposer = true,
        stacker = true
    }

    local function CheckDuplicationScale(client, entities)
        entities = entities or {}
        for _, v in pairs(entities) do
            if v.ModelScale and v.ModelScale > 10 then
                client:notify("A model within this duplication exceeds the size limit!")
                print("[Server Warning] Potential server crash using dupes attempt by player: " .. client:Name() .. " (" .. client:SteamID64() .. ")")
                return false
            end

            v.ModelScale = 1
        end
        return true
    end

    if DisallowedTools[tool] and not client:IsSuperAdmin() then
        client:notify("You are not allowed to use the " .. tool .. " tool.")
        return false
    end

    local privilege = "Staff Permissions - Access Tool " .. tool:gsub("^%l", string.upper)
    local isSuperAdmin = client:IsSuperAdmin()
    local isStaffOrFlagged = client:isStaffOnDuty() or client:getChar():hasFlags("t")
    local hasPriv = client:hasPrivilege(privilege)
    if not isSuperAdmin and not (isStaffOrFlagged and hasPriv) then
        local reasons = {}
        if not isSuperAdmin then table.insert(reasons, "SuperAdmin") end
        if not isStaffOrFlagged then table.insert(reasons, "Onduty staff or flag 't'") end
        if not hasPriv then table.insert(reasons, "Privilege '" .. privilege .. "'") end
        client:notify("You do not have permission to access tool '" .. tool .. "'. Missing: " .. table.concat(reasons, ", "))
        return false
    end

    local weapon = client:GetActiveWeapon()
    local toolobj = IsValid(weapon) and weapon:GetToolObject() or nil
    local entity = client:getTracedEntity()
    if IsValid(entity) then
        local entClass = entity:GetClass()
        if tool == "remover" then
            if MODULE.RemoverBlockedEntities and MODULE.RemoverBlockedEntities[entClass] then
                if not client:hasPrivilege("Staff Permissions - Can Remove Blocked Entities") then
                    client:notify("You do not have permission to remove blocked entities.")
                    return false
                end
                return true
            elseif entity:IsWorld() then
                if not client:hasPrivilege("Staff Permissions - Can Remove World Entities") then
                    client:notify("You do not have permission to remove world entities.")
                    return false
                end
                return true
            end
            return true
        end

        if (tool == "permaall" or tool == "permaprops" or tool == "blacklistandremove") and (string.StartWith(entClass, "lia_") or MODULE.CanNotPermaProp and MODULE.CanNotPermaProp[entClass] or entity:isLiliaPersistent() or entity:CreatedByMap()) then
            client:notify("You cannot use " .. tool .. " on this entity.")
            return false
        end

        if (tool == "adv_duplicator" or tool == "advdupe2" or tool == "duplicator" or tool == "blacklistandremove") and (MODULE.DuplicatorBlackList and MODULE.DuplicatorBlackList[entClass] or entity.NoDuplicate) then
            client:notify("This entity cannot be duplicated using " .. tool .. ".")
            return false
        end

        if tool == "weld" and entClass == "sent_ball" then
            client:notify("You cannot weld this entity with the weld tool.")
            return false
        end
    end

    if tool == "duplicator" and client.CurrentDupe and not CheckDuplicationScale(client, client.CurrentDupe.Entities) then return false end
    if tool == "advdupe2" and client.AdvDupe2 and not CheckDuplicationScale(client, client.AdvDupe2.Entities) then return false end
    if tool == "adv_duplicator" and toolobj and toolobj.Entities and not CheckDuplicationScale(client, toolobj.Entities) then return false end
    return true
end

function GM:PlayerSpawnedNPC(client, entity)
    entity:SetCreator(client)
end

function GM:PlayerSpawnedEffect(client, _, entity)
    entity:SetCreator(client)
end

function GM:PlayerSpawnedProp(client, _, entity)
    entity:SetCreator(client)
end

function GM:PlayerSpawnedRagdoll(client, _, entity)
    entity:SetCreator(client)
end

function GM:PlayerSpawnedSENT(client, entity)
    entity:SetCreator(client)
end

function GM:PlayerSpawnedSWEP(client, entity)
    entity:SetCreator(client)
end

function GM:PlayerSpawnedVehicle(client, entity)
    entity:SetCreator(client)
end

function GM:CanPlayerUseChar(client)
    if GetGlobalBool("characterSwapLock", false) and not client:hasPrivilege("Staff Permissions - Can Bypass Character Lock") then return false, "Currently the server is in an event and you're unable to change characters." end
end

concommand.Add("kickbots", function()
    for _, bot in player.Iterator() do
        if bot:IsBot() then bot:Kick("All bots kicked") end
    end
end)

concommand.Add("stopsoundall", function(client)
    if client:IsSuperAdmin() then
        for _, v in player.Iterator() do
            v:ConCommand("stopsound")
        end
    else
        client:notify("You must be a Super Admin to forcefully stopsound everyone!")
    end
end)

local function handleDatabaseWipe(commandName)
    concommand.Add(commandName, function(client)
        if IsValid(client) then
            client:notify("This command can only be run from the server console.")
            return
        end

        if resetCalled < RealTime() then
            resetCalled = RealTime() + 3
            MsgC(Color(255, 0, 0), "[Lilia] TO CONFIRM DATABASE RESET, RUN '" .. commandName .. "' AGAIN in 3 SECONDS.\n")
        else
            resetCalled = 0
            MsgC(Color(255, 0, 0), "[Lilia] DATABASE WIPE IN PROGRESS.\n")
            hook.Run("OnWipeTables")
            lia.db.wipeTables(lia.db.loadTables)
            game.ConsoleCommand("changelevel " .. game.GetMap() .. "\n")
        end
    end)
end

handleDatabaseWipe("lia_recreatedb")
handleDatabaseWipe("lia_wipedb")

-- ./modules/core/administration/submodules/permissions/libraries/shared.lua
function MODULE:InitializedModules()
    local defaultUserTools = {
        adv_duplicator = true,
        duplicator = true,
        advdupe2 = true,
        remover = true,
    }

    if properties.List then
        for name in pairs(properties.List) do
            if name ~= "persist" and name ~= "drive" and name ~= "bonemanipulate" then
                local privilege = "Staff Permissions - Access Property " .. name:gsub("^%l", string.upper)
                if not CAMI.GetPrivilege(privilege) then
                    CAMI.RegisterPrivilege({
                        Name = privilege,
                        MinAccess = "admin",
                        Description = "Allows access to Entity Property " .. name:gsub("^%l", string.upper)
                    })
                end
            end
        end
    end

    for _, wep in ipairs(weapons.GetList()) do
        if wep.ClassName == "gmod_tool" and wep.Tool then
            for tool in pairs(wep.Tool) do
                local privilege = "Staff Permissions - Access Tool " .. tool:gsub("^%l", string.upper)
                if not CAMI.GetPrivilege(privilege) then
                    CAMI.RegisterPrivilege({
                        Name = privilege,
                        MinAccess = defaultUserTools[string.lower(tool)] and "user" or "admin",
                        Description = "Allows access to " .. tool:gsub("^%l", string.upper)
                    })
                end
            end
        end
    end
end

concommand.Add("list_entities", function(client)
    local entityCount = {}
    local totalEntities = 0
    if not IsValid(client) then
        lia.information("Entities on the server:")
        for _, entity in ents.Iterator() do
            local className = entity:GetClass() or L("unknown")
            entityCount[className] = (entityCount[className] or 0) + 1
            totalEntities = totalEntities + 1
        end

        for className, count in pairs(entityCount) do
            lia.information(string.format("Class: %s | Count: %d", className, count))
        end

        lia.information("Total entities on the server: " .. totalEntities)
    end
end)

lia.flag.add("p", "Access to the physgun.", function(client, isGiven)
    if isGiven then
        client:Give("weapon_physgun")
        client:SelectWeapon("weapon_physgun")
    else
        client:StripWeapon("weapon_physgun")
    end
end)

lia.flag.add("t", "Access to the toolgun", function(client, isGiven)
    if isGiven then
        client:Give("gmod_tool")
        client:SelectWeapon("gmod_tool")
    else
        client:StripWeapon("gmod_tool")
    end
end)

lia.flag.add("C", "Access to spawn vehicles.")
lia.flag.add("z", "Access to spawn SWEPS.")
lia.flag.add("E", "Access to spawn SENTs.")
lia.flag.add("L", "Access to spawn Effects.")
lia.flag.add("r", "Access to spawn ragdolls.")
lia.flag.add("e", "Access to spawn props.")
lia.flag.add("n", "Access to spawn NPCs.")


-- ./modules/core/administration/submodules/permissions/module.lua
MODULE.name = "Permissions"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Implements CAMI Based Permissions."
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Can Bypass Character Lock",
        MinAccess = "superadmin",
        Description = "Allows access to bypassing character lock."
    },
    {
        Name = "Staff Permissions - Can Grab World Props",
        MinAccess = "superadmin",
        Description = "Allows access to grabbing world props."
    },
    {
        Name = "Staff Permissions - Can Grab Players",
        MinAccess = "superadmin",
        Description = "Allows access to grabbing players props."
    },
    {
        Name = "Staff Permissions - Physgun Pickup",
        MinAccess = "admin",
        Description = "Allows access to picking up entities with Physgun."
    },
    {
        Name = "Staff Permissions - Can Access Item Informations",
        MinAccess = "superadmin",
        Description = "Allows access to knowing special item informations."
    },
    {
        Name = "Staff Permissions - Physgun Pickup on Restricted Entities",
        MinAccess = "superadmin",
        Description = "Allows access to picking up restricted entities with Physgun."
    },
    {
        Name = "Staff Permissions - Physgun Pickup on Vehicles",
        MinAccess = "admin",
        Description = "Allows access to picking up Vehicles with Physgun."
    },
    {
        Name = "Staff Permissions - Can't be Grabbed with PhysGun",
        MinAccess = "superadmin",
        Description = "Allows access to not being Grabbed with PhysGun."
    },
    {
        Name = "Staff Permissions - Can Physgun Reload",
        MinAccess = "superadmin",
        Description = "Allows access to Reloading Physgun.",
    },
    {
        Name = "Staff Permissions - No Clip Outside Staff Character",
        MinAccess = "superadmin",
        Description = "Allows access to No Clip ESP Outside Staff Character.",
    },
    {
        Name = "Staff Permissions - No Clip ESP Outside Staff Character",
        MinAccess = "superadmin",
        Description = "Allows access to No Clip ESP Outside Staff Character.",
    },
    {
        Name = "Staff Permissions - Can Property World Entities",
        MinAccess = "superadmin",
        Description = "Allows access to propertying world props."
    },
    {
        Name = "Staff Permissions - Use Entity Properties on Blocked Entities",
        MinAccess = "admin",
        Description = "Allows access to using Entity Properties on Blocked Entities."
    },
    {
        Name = "Spawn Permissions - Can Spawn Ragdolls",
        MinAccess = "admin",
        Description = "Allows access to spawning ."
    },
    {
        Name = "Spawn Permissions - Can Spawn SWEPs",
        MinAccess = "superadmin",
        Description = "Allows access to spawning SWEPs."
    },
    {
        Name = "Spawn Permissions - Can Spawn Effects",
        MinAccess = "admin",
        Description = "Allows access to spawning Effects."
    },
    {
        Name = "Spawn Permissions - Can Spawn Props",
        MinAccess = "admin",
        Description = "Allows access to spawning Props."
    },
    {
        Name = "Spawn Permissions - Can Spawn Blacklisted Props",
        MinAccess = "superadmin",
        Description = "Allows access to spawning Blacklisted Props."
    },
    {
        Name = "Spawn Permissions - Can Spawn NPCs",
        MinAccess = "superadmin",
        Description = "Allows access to spawning NPCs."
    },
    {
        Name = "Spawn Permissions - No Car Spawn Delay",
        MinAccess = "superadmin",
        Description = "Allows a user to not have car spawn delay."
    },
    {
        Name = "Spawn Permissions - No Spawn Delay",
        MinAccess = "admin",
        Description = "Allows a user to not have spawn delay."
    },
    {
        Name = "Spawn Permissions - Can Spawn Cars",
        MinAccess = "admin",
        Description = "Allows access to Spawning Cars."
    },
    {
        Name = "Spawn Permissions - Can Spawn Restricted Cars",
        MinAccess = "superadmin",
        Description = "Allows access to Spawning Restricted Cars."
    },
    {
        Name = "Spawn Permissions - Can Spawn SENTs",
        MinAccess = "admin",
        Description = "Allows access to Spawning SENTs."
    },
    {
        Name = "UserGroups - Staff Group",
        MinAccess = "admin",
        Description = "Defines Player as Staff."
    },
    {
        Name = "UserGroups - VIP Group",
        MinAccess = "superadmin",
        Description = "Defines Player as VIP."
    },
    {
        Name = "Staff Permissions - List Entities",
        MinAccess = "superadmin",
        Description = "Allows a User to List Entities."
    },
    {
        Name = "Staff Permissions - Can Remove Blocked Entities",
        MinAccess = "admin",
        Description = "Allows access to removing blocked entities."
    },
    {
        Name = "Staff Permissions - Can Remove World Entities",
        MinAccess = "superadmin",
        Description = "Allows access to removing world props."
    },
}

-- ./modules/core/administration/submodules/tickets/commands.lua
lia.command.add("plyviewclaims", {
    adminOnly = true,
    privilege = "View Claims",
    desc = L("plyViewClaimsDesc"),
    syntax = "[string charname]",
    AdminStick = {
        Name = L("viewTicketClaims"),
        Category = L("moderationTools"),
        SubCategory = L("miscellaneous"),
        Icon = "icon16/page_white_text.png"
    },
    onRun = function(client, arguments)
        local targetName = arguments[1]
        if not targetName then
            client:ChatPrint(L("mustSpecifyPlayer"))
            return
        end

        local target = lia.util.findPlayer(client, targetName)
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local steamID = target:SteamID64()
        local caseclaims = lia.data.get("caseclaims", {}, true)
        local claim = caseclaims[steamID]
        if not claim then
            client:ChatPrint(L("noClaimsFound"))
            return
        end

        local claimedForList = ""
        if next(claim.claimedFor) then
            for sid, name in pairs(claim.claimedFor) do
                claimedForList = claimedForList .. string.format("- %s (%s)\n", name, sid)
            end
        else
            claimedForList = "None"
        end

        local message = string.format("=== Claims for %s ===\n%s: %s\n%s: %s\n%s: %d\n%s: %s\n%s: %s\n%s:\n%s", target:Nick(), L("steamID"), steamID, L("adminName"), claim.name, L("totalClaims"), claim.claims, L("lastClaimDate"), os.date("%Y-%m-%d %H:%M:%S", claim.lastclaim), L("timeSinceLastClaim"), lia.time.TimeSince(claim.lastclaim), L("claimedFor"), claimedForList)
        client:ChatPrint(message)
    end
})

lia.command.add("viewallclaims", {
    adminOnly = true,
    privilege = "View Claims",
    desc = L("viewAllClaimsDesc"),
    onRun = function(client)
        local caseclaims = lia.data.get("caseclaims", {}, true)
        if not next(caseclaims) then
            client:ChatPrint(L("noClaimsRecorded"))
            return
        end

        local claimsData = {}
        for steamID, claim in pairs(caseclaims) do
            local claimedFor = "None"
            if next(claim.claimedFor) then
                claimedFor = table.concat((function()
                    local t = {}
                    for sid, name in pairs(claim.claimedFor) do
                        table.insert(t, string.format("%s (%s)", name, sid))
                    end
                    return t
                end)(), ", ")
            end

            table.insert(claimsData, {
                steamID = steamID,
                name = claim.name,
                claims = claim.claims,
                lastclaim = os.date("%Y-%m-%d %H:%M:%S", claim.lastclaim),
                timeSinceLastClaim = lia.time.TimeSince(claim.lastclaim),
                claimedFor = claimedFor
            })
        end

        lia.util.CreateTableUI(client, "Admin Claims", {
            {
                name = L("steamID"),
                field = "steamID"
            },
            {
                name = L("adminName"),
                field = "name"
            },
            {
                name = L("totalClaims"),
                field = "claims"
            },
            {
                name = L("lastClaimDate"),
                field = "lastclaim"
            },
            {
                name = L("timeSinceLastClaim"),
                field = "timeSinceLastClaim"
            },
            {
                name = L("claimedFor"),
                field = "claimedFor"
            }
        }, claimsData)
    end
})

lia.command.add("viewclaims", {
    adminOnly = true,
    privilege = "View Claims",
    desc = L("viewClaimsDesc"),
    onRun = function(client)
        local caseclaims = lia.data.get("caseclaims", {}, true)
        if not next(caseclaims) then
            client:ChatPrint(L("noClaimsData"))
            return
        end

        client:ChatPrint(L("adminClaimsHeader"))
        for steamID, claim in pairs(caseclaims) do
            local claimedForList = "None"
            if next(claim.claimedFor) then
                claimedForList = ""
                for sid, name in pairs(claim.claimedFor) do
                    claimedForList = claimedForList .. string.format("- %s (%s)\n", name, sid)
                end
            end

            local message = string.format("%s: %s\n%s: %s\n%s: %d\n%s: %s\n%s: %s\n%s:\n%s\n-------------------------", L("steamID"), steamID, L("adminName"), claim.name, L("totalClaims"), claim.claims, L("lastClaimDate"), os.date("%Y-%m-%d %H:%M:%S", claim.lastclaim), L("timeSinceLastClaim"), lia.time.TimeSince(claim.lastclaim), L("claimedFor"), claimedForList)
            client:ChatPrint(message)
        end
    end
})

-- ./modules/core/administration/submodules/tickets/libraries/client.lua
local xpos = xpos or 20
local ypos = ypos or 20
local xpos = xpos or 20
local ypos = ypos or 20
function MODULE:TicketFrame(requester, message, claimed)
    local mat_lightning = Material("icon16/lightning_go.png")
    local mat_arrow = Material("icon16/arrow_left.png")
    local mat_link = Material("icon16/link.png")
    local mat_case = Material("icon16/briefcase.png")
    if not IsValid(requester) or not requester:IsPlayer() then return end
    for _, v in pairs(TicketFrames) do
        if v.idiot == requester then
            local txt = v:GetChildren()[5]
            txt:AppendText("\n" .. message)
            txt:GotoTextEnd()
            timer.Remove("ticketsystem-" .. requester:SteamID64())
            timer.Create("ticketsystem-" .. requester:SteamID64(), 60, 1, function() if IsValid(v) then v:Remove() end end)
            surface.PlaySound("ui/hint.wav")
            return
        end
    end

    local w, h = 300, 120
    local frm = vgui.Create("DFrame")
    frm:SetSize(w, h)
    frm:SetPos(xpos, ypos)
    frm.idiot = requester
    function frm:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(10, 10, 10, 230))
    end

    frm.lblTitle:SetColor(Color(255, 255, 255))
    frm.lblTitle:SetFont("ticketsystem")
    frm.lblTitle:SetContentAlignment(7)
    if claimed and IsValid(claimed) and claimed:IsPlayer() then
        frm:SetTitle(requester:Nick() .. " - Claimed by " .. claimed:Nick())
        if claimed == LocalPlayer() then
            function frm:Paint(w, h)
                draw.RoundedBox(0, 0, 0, w, h, Color(10, 10, 10, 230))
                draw.RoundedBox(0, 2, 2, w - 4, 16, Color(38, 166, 91))
            end
        else
            function frm:Paint(w, h)
                draw.RoundedBox(0, 0, 0, w, h, Color(10, 10, 10, 230))
                draw.RoundedBox(0, 2, 2, w - 4, 16, Color(207, 0, 15))
            end
        end
    else
        frm:SetTitle(requester:Nick())
    end

    local msg = vgui.Create("RichText", frm)
    msg:SetPos(10, 30)
    msg:SetSize(190, h - 35)
    msg:SetContentAlignment(7)
    msg:SetVerticalScrollbarEnabled(false)
    function msg:PerformLayout()
        self:SetFontInternal("DermaDefault")
    end

    msg:AppendText(message)
    local function createButton(text, material, position, clickFunc, disabled)
        text = L(text)
        local btn = vgui.Create("DButton", frm)
        btn:SetPos(215, position)
        btn:SetSize(83, 18)
        btn:SetText("          " .. text)
        btn:SetColor(Color(255, 255, 255))
        btn:SetContentAlignment(4)
        btn.Disabled = disabled
        btn.DoClick = function() if not btn.Disabled then clickFunc() end end
        btn.Paint = function(self, w, h)
            if self.Depressed or self.m_bSelected then
                draw.RoundedBox(1, 0, 0, w, h, Color(255, 50, 50, 255))
            elseif self.Hovered and not self.Disabled then
                draw.RoundedBox(1, 0, 0, w, h, Color(205, 30, 30, 255))
            else
                draw.RoundedBox(1, 0, 0, w, h, self.Disabled and Color(100, 100, 100, 255) or Color(80, 80, 80, 255))
            end

            surface.SetDrawColor(Color(255, 255, 255))
            surface.SetMaterial(material)
            surface.DrawTexturedRect(5, 1, 16, 16)
        end

        if disabled then btn:SetTooltip("You cannot perform this action on your own ticket.") end
        return btn
    end

    local isLocalPlayer = requester == LocalPlayer()
    createButton("goto", mat_lightning, 20 * 1, function() RunConsoleCommand(sam and "sam" or ulx and "ulx", "goto", sam and requester:SteamID() or requester:SteamID64()) end, isLocalPlayer)
    createButton("return", mat_arrow, 20 * 2, function() RunConsoleCommand(sam and "sam" or ulx and "ulx", "return", sam and requester:SteamID() or requester:SteamID64()) end, isLocalPlayer)
    createButton("freeze", mat_link, 20 * 3, function() RunConsoleCommand(sam and "sam" or ulx and "ulx", "freeze", sam and requester:SteamID() or requester:SteamID64()) end, isLocalPlayer)
    createButton("bring", mat_arrow, 20 * 4, function() RunConsoleCommand(sam and "sam" or ulx and "ulx", "bring", sam and requester:SteamID() or requester:SteamID64()) end, isLocalPlayer)
    local shouldClose = false
    local claimButton
    claimButton = createButton("Claim case", mat_case, 20 * 5, function()
        if not shouldClose then
            if frm.lblTitle:GetText():lower():find("claimed") then
                chat.AddText(Color(255, 150, 0), "[ERROR] Case has already been claimed")
                surface.PlaySound("common/wpn_denyselect.wav")
            else
                net.Start("TicketSystemClaim")
                net.WriteEntity(requester)
                net.SendToServer()
                shouldClose = true
                claimButton:SetText("          Close case")
            end
        else
            net.Start("TicketSystemClose")
            net.WriteEntity(requester)
            net.SendToServer()
        end
    end, isLocalPlayer)

    local closeButton = vgui.Create("DButton", frm)
    closeButton:SetText("")
    closeButton:SetTooltip("Close")
    closeButton:SetColor(Color(255, 255, 255))
    closeButton:SetPos(w - 18, 2)
    closeButton:SetSize(16, 16)
    function closeButton:Paint()
    end

    closeButton.DoClick = function() frm:Close() end
    frm:ShowCloseButton(false)
    frm:SetPos(xpos, ypos + 130 * #TicketFrames)
    frm:MoveTo(xpos, ypos + 130 * #TicketFrames, 0.2, 0, 1, function() surface.PlaySound("garrysmod/balloon_pop_cute.wav") end)
    function frm:OnRemove()
        if TicketFrames then
            table.RemoveByValue(TicketFrames, frm)
            for k, v in ipairs(TicketFrames) do
                v:MoveTo(xpos, ypos + 130 * (k - 1), 0.1, 0, 1, function() end)
            end
        end

        if IsValid(requester) and timer.Exists("ticketsystem-" .. requester:SteamID64()) then timer.Remove("ticketsystem-" .. requester:SteamID64()) end
    end

    table.insert(TicketFrames, frm)
    timer.Create("ticketsystem-" .. requester:SteamID64(), 60, 1, function() if IsValid(frm) then frm:Remove() end end)
end

-- ./modules/core/administration/submodules/tickets/libraries/server.lua
function MODULE:TicketSystemClaim(admin, requester)
    local caseclaims = lia.data.get("caseclaims", {}, true)
    if caseclaims[admin:SteamID()] then
        caseclaims[admin:SteamID64()] = caseclaims[admin:SteamID()]
        caseclaims[admin:SteamID()] = nil
    end

    caseclaims[admin:SteamID64()] = caseclaims[admin:SteamID64()] or {
        name = admin:Nick(),
        claims = 0,
        lastclaim = os.time(),
        claimedFor = {}
    }

    caseclaims[admin:SteamID64()].claims = caseclaims[admin:SteamID64()].claims + 1
    caseclaims[admin:SteamID64()].lastclaim = os.time()
    caseclaims[admin:SteamID64()].claimedFor[requester:SteamID64()] = requester:Nick()
    lia.data.set("caseclaims", caseclaims, true)
end

function MODULE:PlayerSay(client, text)
    if string.sub(text, 1, 2) == "@ " then
        text = string.sub(text, 2)
        ClientAddText(client, Color(70, 0, 130), "You", Color(151, 211, 255), " to admins: ", Color(0, 255, 0), text)
        self:SendPopup(client, text)
        return ""
    end
end

function MODULE:PlayerDisconnected(client)
    for _, v in player.Iterator() do
        if v:hasPrivilege("Staff Permissions - Always See Tickets") or v:isStaffOnDuty() then
            net.Start("TicketSystemClose")
            net.WriteEntity(client)
            net.Send(v)
        end
    end
end

function MODULE:SendPopup(noob, message)
    for _, v in player.Iterator() do
        if v:hasPrivilege("Staff Permissions - Always See Tickets") or v:isStaffOnDuty() then
            net.Start("TicketSystem")
            net.WriteEntity(noob)
            net.WriteString(message)
            net.WriteEntity(noob.CaseClaimed)
            net.Send(v)
        end
    end

    if IsValid(noob) and noob:IsPlayer() then
        timer.Remove("ticketsystem-" .. noob:SteamID64())
        timer.Create("ticketsystem-" .. noob:SteamID64(), 60, 1, function() if IsValid(noob) and noob:IsPlayer() then noob.CaseClaimed = nil end end)
    end
end

-- ./modules/core/administration/submodules/tickets/module.lua
if CLIENT then TicketFrames = {} end
MODULE.name = "Tickets"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a module that manages tickets"
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Always See Tickets",
        MinAccess = "superadmin",
        Description = "Allows access to See Tickets."
    },
}

-- ./modules/core/administration/submodules/tickets/netcalls/client.lua
local MODULE = MODULE
net.Receive("ViewClaims", function()
    local tbl = net.ReadTable()
    local steamid = net.ReadString()
    if steamid and steamid ~= "" and steamid ~= " " then
        local v = tbl[steamid]
        print(v.name .. " - " .. v.claims .. " - last claim " .. string.NiceTime(os.time() - v.lastclaim) .. " ago")
    else
        for _, v in pairs(tbl) do
            print(v.name .. " - " .. v.claims)
        end
    end
end)

net.Receive("TicketSystem", function()
    local pl = net.ReadEntity()
    local msg = net.ReadString()
    local claimed = net.ReadEntity()
    if LocalPlayer():isStaffOnDuty() or LocalPlayer():IsSuperAdmin() then MODULE:TicketFrame(pl, msg, claimed) end
end)

net.Receive("TicketSystemClaim", function()
    local pl = net.ReadEntity()
    local requester = net.ReadEntity()
    for _, v in pairs(TicketFrames) do
        if v.idiot == requester then
            local titl = v:GetChildren()[4]
            titl:SetText(titl:GetText() .. " - Claimed by " .. pl:Nick())
            if pl == LocalPlayer() then
                function v:Paint(w, h)
                    draw.RoundedBox(0, 0, 0, w, h, Color(10, 10, 10, 230))
                    draw.RoundedBox(0, 2, 2, w - 4, 16, Color(38, 166, 91))
                end
            else
                function v:Paint(w, h)
                    draw.RoundedBox(0, 0, 0, w, h, Color(10, 10, 10, 230))
                    draw.RoundedBox(0, 2, 2, w - 4, 16, Color(207, 0, 15))
                end
            end

            local bu = v:GetChildren()[11]
            bu.DoClick = function()
                if LocalPlayer() == pl then
                    net.Start("TicketSystemClose")
                    net.WriteEntity(requester)
                    net.SendToServer()
                else
                    v:Close()
                end
            end
        end
    end
end)

net.Receive("TicketSystemClose", function()
    local requester = net.ReadEntity()
    if not IsValid(requester) or not requester:IsPlayer() then return end
    for _, v in pairs(TicketFrames) do
        if v.idiot == requester then v:Remove() end
    end

    if timer.Exists("ticketsystem-" .. requester:SteamID64()) then timer.Remove("ticketsystem-" .. requester:SteamID64()) end
end)


-- ./modules/core/administration/submodules/tickets/netcalls/server.lua
net.Receive("ViewClaims", function(_, client)
    local sid = net.ReadString()
    local caseclaims = lia.data.get("caseclaims", {}, true)
    net.Start("ViewClaims")
    net.WriteTable(caseclaims)
    net.WriteString(sid)
    net.Send(client)
end)

net.Receive("TicketSystemClaim", function(_, client)
    local requester = net.ReadEntity()
    if client == requester then
        client:ChatPrint("You cannot claim your own ticket.")
        return
    end

    if (client:hasPrivilege("Staff Permissions - Always See Tickets") or client:isStaffOnDuty()) and not requester.CaseClaimed then
        for _, v in player.Iterator() do
            if v:hasPrivilege("Staff Permissions - Always See Tickets") or v:isStaffOnDuty() then
                net.Start("TicketSystemClaim")
                net.WriteEntity(client)
                net.WriteEntity(requester)
                net.Send(v)
            end
        end

        hook.Run("TicketSystemClaim", client, requester)
        requester.CaseClaimed = client
    end
end)

net.Receive("TicketSystemClose", function(_, client)
    local requester = net.ReadEntity()
    if client == requester then
        client:ChatPrint("You cannot close your own ticket.")
        return
    end

    if not requester or not IsValid(requester) or requester.CaseClaimed ~= client then return end
    if timer.Exists("ticketsystem-" .. requester:SteamID64()) then timer.Remove("ticketsystem-" .. requester:SteamID64()) end
    for _, v in player.Iterator() do
        if v:hasPrivilege("Staff Permissions - Always See Tickets") or v:isStaffOnDuty() then
            net.Start("TicketSystemClose")
            net.WriteEntity(requester)
            net.Send(v)
        end
    end

    requester.CaseClaimed = nil
end)

-- ./modules/core/administration/submodules/warns/commands.lua
lia.command.add("warn", {
    adminOnly = true,
    privilege = "Issue Warnings",
    desc = L("warnDesc"),
    syntax = "[string target] [string reason]",
    AdminStick = {
        Name = L("warnPlayer"),
        Category = L("moderationTools"),
        SubCategory = L("warnings"),
        Icon = "icon16/error.png",
        ExtraFields = {
            [L("warningField")] = "text"
        }
    },
    onRun = function(client, arguments)
        local targetName = arguments[1]
        local reason = table.concat(arguments, " ", 2)
        if not targetName or reason == "" then return L("warnUsage") end
        local target = lia.util.findPlayer(client, targetName)
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local warning = {
            timestamp = os.date("%Y-%m-%d %H:%M:%S"),
            reason = reason,
            admin = client:Nick() .. " (" .. client:SteamID64() .. ")"
        }

        local warns = target:getLiliaData("warns") or {}
        table.insert(warns, warning)
        target:setLiliaData("warns", warns)
        target:notifyLocalized("playerWarned", warning.admin, reason)
        client:notifyLocalized("warningIssued", target:Nick())
        lia.log.add(client, "warningIssued", target, reason)
    end
})

lia.command.add("viewwarns", {
    adminOnly = true,
    privilege = "View Player Warnings",
    desc = L("viewWarnsDesc"),
    syntax = "[string target]",
    AdminStick = {
        Name = L("viewPlayerWarnings"),
        Category = L("moderationTools"),
        SubCategory = L("warnings"),
        Icon = "icon16/eye.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local warns = target:getLiliaData("warns") or {}
        if table.Count(warns) == 0 then
            client:notifyLocalized("noWarnings", target:Nick())
            return
        end

        local warningList = {}
        for index, warn in ipairs(warns) do
            table.insert(warningList, {
                index = index,
                timestamp = warn.timestamp or "N/A",
                reason = warn.reason or "N/A",
                admin = warn.admin or "N/A"
            })
        end

        lia.util.CreateTableUI(client, target:Nick() .. "'s " .. L("warnings"), {
            {
                name = L("idField"),
                field = "index"
            },
            {
                name = L("timestampField"),
                field = "timestamp"
            },
            {
                name = L("reasonField"),
                field = "reason"
            },
            {
                name = L("adminField"),
                field = "admin"
            }
        }, warningList, {
            {
                name = L("removeWarning"),
                net = "RequestRemoveWarning"
            }
        }, target:getChar():getID())
    end
})

-- ./modules/core/administration/submodules/warns/libraries/server.lua

net.Receive("RequestRemoveWarning", function(_, client)
    if not client:hasPrivilege("Staff Permissions - Can Remove Warnrs") then return end
    local charID = net.ReadInt(32)
    local rowData = net.ReadTable()
    local warnIndex = tonumber(rowData.ID or rowData.index)
    if not warnIndex then
        client:notify("Invalid warning index.")
        return
    end

    local targetClient = lia.char.getBySteamID(charID)
    if not IsValid(targetClient) then
        client:notify("Player not found.")
        return
    end

    local targetChar = targetClient:getChar()
    if not targetChar then
        client:notify("Character not found.")
        return
    end

    local warns = targetClient:getLiliaData("warns") or {}
    if warnIndex < 1 or warnIndex > #warns then
        client:notify("Invalid warning index.")
        return
    end

    local warning = warns[warnIndex]
    table.remove(warns, warnIndex)
    targetClient:setLiliaData("warns", warns)
    targetClient:notify("A warning has been removed from your record by " .. client:Nick())
    client:notify("Removed warning #" .. warnIndex .. " from " .. targetClient:Nick())
    lia.log.add(client, "warningRemoved", targetClient, warning)
end)


-- ./modules/core/administration/submodules/warns/module.lua
MODULE.name = "Configuration Menu"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a Configuration Menu"


-- ./modules/core/interactionmenu/libraries/client.lua
local MODULE = MODULE

ActionInteractionMenu = nil
InteractionMenu = nil
function MODULE:OpenPIM()
    if IsValid(ActionInteractionMenu) then
        ActionInteractionMenu:Close()
        ActionInteractionMenu = nil
    end

    if IsValid(InteractionMenu) then
        InteractionMenu:Close()
        InteractionMenu = nil
    end

    local client = LocalPlayer()
    local frame = vgui.Create("DFrame")
    frame:SetSize(300, 120)
    frame:SetPos(0, ScrH() / 2 - frame:GetTall() / 2)
    frame:CenterHorizontal(0.7)
    frame:MakePopup()
    frame:SetTitle("")
    frame:ShowCloseButton(false)
    frame:SetAlpha(0)
    frame:AlphaTo(255, 0.05)
    function frame:Paint(w, h)
        lia.util.drawBlur(self, 4)
        draw.RoundedBox(0, 0, 0, w, h, Color(20, 20, 20, 120))
    end

    function frame:Think()
        local interactionKey = lia.keybind.get("Interaction Menu", KEY_TAB)
        if not input.IsKeyDown(interactionKey) then self:Close() end
    end

    timer.Remove("PIM_Frame_Timer")
    timer.Create("PIM_Frame_Timer", 30, 1, function() if frame and IsValid(frame) then frame:Close() end end)
    frame.title = frame:Add("DLabel")
    frame.title:SetText("Player Interactions")
    frame.title:SetFont("liaSmallFont")
    frame.title:SetColor(color_white)
    frame.title:SetSize(frame:GetWide(), 25)
    frame.title:SetContentAlignment(5)
    frame.title:SetPos(0, 25 / 2 - frame.title:GetTall() / 2)
    frame.title:CenterHorizontal()
    function frame.title:PaintOver(w, h)
        surface.SetDrawColor(Color(60, 60, 60))
        surface.DrawLine(0, h - 1, w, h - 1)
    end

    frame.scroll = frame:Add("DScrollPanel")
    frame.scroll:SetSize(frame:GetWide(), 25 * table.Count(self.Options))
    frame.scroll:SetPos(0, 25)
    frame.list = frame.scroll:Add("DIconLayout")
    frame.list:SetSize(frame.scroll:GetSize())
    local visibleOptionsCount = 0
    local traceEnt = client:getTracedEntity()
    for name, opt in pairs(self.Options) do
        if opt.shouldShow(client, traceEnt) and traceEnt:IsPlayer() and self:CheckDistance(client, traceEnt) then
            visibleOptionsCount = visibleOptionsCount + 1
            local p = frame.list:Add("DButton")
            p:SetText(name)
            p:SetFont("liaSmallFont")
            p:SetColor(color_white)
            p:SetSize(frame.list:GetWide(), 25)
            function p:Paint(w, h)
                if self:IsHovered() then
                    draw.RoundedBox(0, 0, 0, w, h, Color(30, 30, 30, 150))
                else
                    draw.RoundedBox(0, 0, 0, w, h, Color(30, 30, 30, 75))
                end
            end

            function p:DoClick()
                frame:AlphaTo(0, 0.05, 0, function() if frame and IsValid(frame) then frame:Close() end end)
                opt.onRun(client, traceEnt)
                if opt.runServer then
                    net.Start("PIMRunOption")
                    net.WriteString(name)
                    net.SendToServer()
                end
            end
        end
    end

    local jh = 25 * visibleOptionsCount
    frame.scroll:SetTall(jh)
    frame:SetTall(jh + 45)
    frame:CenterVertical()
    InteractionMenu = frame
end

function MODULE:OpenLocalPIM()
    if IsValid(InteractionMenu) then
        InteractionMenu:Close()
        InteractionMenu = nil
    end

    if IsValid(ActionInteractionMenu) then
        ActionInteractionMenu:Close()
        ActionInteractionMenu = nil
    end

    local client = LocalPlayer()
    local frame = vgui.Create("DFrame")
    frame:SetSize(300, 120)
    frame:SetPos(0, ScrH() / 2 - frame:GetTall() / 2)
    frame:CenterHorizontal(0.7)
    frame:MakePopup()
    frame:SetTitle("")
    frame:ShowCloseButton(false)
    frame:SetAlpha(0)
    frame:AlphaTo(255, 0.05)
    function frame:Paint(w, h)
        lia.util.drawBlur(self, 4)
        draw.RoundedBox(0, 0, 0, w, h, Color(20, 20, 20, 120))
    end

    function frame:Think()
        local personalKey = lia.keybind.get("Personal Actions", KEY_G)
        if not input.IsKeyDown(personalKey) then self:Close() end
    end

    timer.Remove("PIM_Frame_Timer")
    timer.Create("PIM_Frame_Timer", 30, 1, function() if frame and IsValid(frame) then frame:Close() end end)
    frame.title = frame:Add("DLabel")
    frame.title:SetText("Actions Menu")
    frame.title:SetFont("liaSmallFont")
    frame.title:SetColor(color_white)
    frame.title:SetSize(frame:GetWide(), 25)
    frame.title:SetContentAlignment(5)
    frame.title:SetPos(0, 25 / 2 - frame.title:GetTall() / 2)
    frame.title:CenterHorizontal()
    function frame.title:PaintOver(w, h)
        surface.SetDrawColor(Color(60, 60, 60))
        surface.DrawLine(0, h - 1, w, h - 1)
    end

    frame.scroll = frame:Add("DScrollPanel")
    frame.scroll:SetSize(frame:GetWide(), 25 * table.Count(self.SelfOptions))
    frame.scroll:SetPos(0, 25)
    frame.list = frame.scroll:Add("DIconLayout")
    frame.list:SetSize(frame.scroll:GetSize())
    local visibleOptionsCount = 0
    for name, opt in pairs(self.SelfOptions) do
        if opt.shouldShow(client) then
            visibleOptionsCount = visibleOptionsCount + 1
            local p = frame.list:Add("DButton")
            p:SetText(name)
            p:SetFont("liaSmallFont")
            p:SetColor(color_white)
            p:SetSize(frame.list:GetWide(), 25)
            function p:Paint(w, h)
                if self:IsHovered() then
                    draw.RoundedBox(0, 0, 0, w, h, Color(30, 30, 30, 150))
                else
                    draw.RoundedBox(0, 0, 0, w, h, Color(30, 30, 30, 75))
                end
            end

            function p:DoClick()
                frame:AlphaTo(0, 0.05, 0, function() if frame and IsValid(frame) then frame:Close() end end)
                opt.onRun(client)
                if opt.runServer then
                    net.Start("PIMRunLocalOption")
                    net.WriteString(name)
                    net.SendToServer()
                end
            end
        end
    end

    local jh = 25 * visibleOptionsCount
    frame.scroll:SetTall(jh)
    frame:SetTall(jh + 45)
    frame:CenterVertical()
    ActionInteractionMenu = frame
end

lia.keybind.add(KEY_TAB, "Interaction Menu", function()
    local client = LocalPlayer()
    if client:getChar() and hook.Run("CheckInteractionPossibilities") then MODULE:OpenPIM() end
end)

lia.keybind.add(KEY_G, "Personal Actions", function() MODULE:OpenLocalPIM() end)

-- ./modules/core/interactionmenu/libraries/shared.lua
local MODULE = MODULE
MODULE.Options = MODULE.Options or {}
MODULE.SelfOptions = MODULE.SelfOptions or {}
local MaxInteractionDistance = 250 * 250
function AddInteraction(name, data)
    MODULE.Options[name] = data
    lia.bootstrap("Player Interaction Menu", "Added P2P Action: " .. name)
end

function AddAction(name, data)
    MODULE.SelfOptions[name] = data
    lia.bootstrap("Action Menu", "Added Personal Action: " .. name)
end

function MODULE:CheckInteractionPossibilities()
    local client = LocalPlayer()
    for _, v in pairs(self.Options) do
        if not client:getTracedEntity():IsPlayer() then return end
        if v.shouldShow(client, client:getTracedEntity()) then return true end
    end
    return false
end

function MODULE:InitializedModules()
    hook.Run("AddPIMOption", self.Options)
    hook.Run("AddLocalPIMOption", self.SelfOptions)
end

function MODULE:CheckDistance(client, entity)
    return entity:GetPos():DistToSqr(client:GetPos()) < MaxInteractionDistance
end

AddAction("Give Money", {
    serverRun = false,
    shouldShow = function(client, target) return IsValid(target) and target:IsPlayer() and client:getChar():getMoney() > 0 end,
    onRun = function(client, target)
        local frame = vgui.Create("DFrame")
        frame:SetSize(600, 250)
        frame:Center()
        frame:MakePopup()
        frame:SetTitle("Enter amount")
        frame:ShowCloseButton(false)
        frame.te = frame:Add("DTextEntry")
        frame.te:SetSize(frame:GetWide() * 0.6, 30)
        frame.te:SetNumeric(true)
        frame.te:Center()
        frame.te:RequestFocus()
        function frame.te:OnEnter()
            local val = tonumber(frame.te:GetText())
            if not val or val <= 0 then
                client:notify("You need to insert a value bigger than 0.", NOT_ERROR)
                return
            end

            val = math.ceil(val)
            if not client:getChar():hasMoney(val) then
                client:notify("You don't have enough money", NOT_ERROR)
                return
            end

            net.Start("TransferMoneyFromP2P")
            net.WriteUInt(val, 32)
            net.WriteEntity(target)
            net.SendToServer()
            frame:Close()
        end

        frame.ok = frame:Add("liaMediumButton")
        frame.ok:SetSize(150, 30)
        frame.ok:CenterHorizontal()
        frame.ok:CenterVertical(0.7)
        frame.ok:SetText("Give Money")
        frame.ok:SetTextColor(color_white)
        frame.ok:SetFont("liaSmallFont")
        frame.ok.DoClick = frame.te.OnEnter
    end
})

-- ./modules/core/interactionmenu/module.lua
MODULE.name = "Interaction Menu"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds Several Shortcuts to a menu."
MODULE.identifier = "PIM"


-- ./modules/core/interactionmenu/netcalls/server.lua
local MODULE = MODULE
net.Receive("TransferMoneyFromP2P", function(_, sender)
    local amount = net.ReadUInt(32)
    local target = net.ReadEntity()
    if not IsValid(sender) or not sender:getChar() then return end
    if not IsValid(target) or not target:IsPlayer() or not target:getChar() then return end
    if amount <= 0 or not sender:getChar():hasMoney(amount) then return end
    target:getChar():giveMoney(amount)
    sender:getChar():takeMoney(amount)
    local senderName = sender:getChar():getDisplayedName(target)
    local targetName = sender:getChar():getDisplayedName(sender)
    sender:notify("You transferred " .. lia.currency.symbol .. amount .. " to " .. targetName)
    target:notify("You received " .. lia.currency.symbol .. amount .. " from " .. senderName)
end)

net.Receive("PIMRunOption", function(_, ply)
    local name = net.ReadString()
    local opt = MODULE.Options[name]
    local tracedEntity = ply:getTracedEntity()
    if opt and opt.runServer and IsValid(tracedEntity) then opt.onRun(ply, tracedEntity) end
end)

net.Receive("PIMRunLocalOption", function(_, ply)
    local name = net.ReadString()
    local opt = MODULE.SelfOptions[name]
    if opt and opt.runServer then opt.onRun(ply) end
end)

-- ./modules/core/performance/libraries/client.lua
function MODULE:InitializedModules()
    scripted_ents.GetStored("base_gmodentity").t.Think = nil
end

function MODULE:GrabEarAnimation()
    return nil
end

function MODULE:MouthMoveAnimation()
    return nil
end

function MODULE:InitPostEntity()
    if not lia.util.is64Bits() then
        timer.Simple(0, function()
            local pnl = Derma_Query(L("upgradeNotice"), L("upgradeTitle"), L("ok"), function()
                local f = vgui.Create("DFrame")
                f:SetSize(ScrW() * 0.8, ScrH() * 0.55)
                f:Center()
                f:MakePopup()
                local h = vgui.Create("DHTML", f)
                h:Dock(FILL)
                h:OpenURL("https://i.imgur.com/sbCmM2T.png")
            end)

            pnl:MakePopup()
        end)
    end
end

-- ./modules/core/performance/libraries/server.lua
function MODULE:PropBreak(_, entity)
    if IsValid(entity) and IsValid(entity:GetPhysicsObject()) then constraint.RemoveAll(entity) end
end

local ToolGunSounds = {
    ["weapons/airboat/airboat_gun_lastshot1.wav"] = true,
    ["weapons/airboat/airboat_gun_lastshot2.wav"] = true
}

function MODULE:EntityEmitSound(tab)
    if IsValid(tab.Entity) and tab.Entity:IsPlayer() then
        local wep = tab.Entity:GetActiveWeapon()
        if IsValid(wep) and wep:GetClass() == "gmod_tool" and ToolGunSounds[tab.SoundName] then return false end
    end
end

-- ./modules/core/performance/libraries/shared.lua
local serverCommands = {"mp_show_voice_icons 0", "net_maxfilesize 64", "sv_kickerrornum 0", "sv_allowupload 0", "sv_allowdownload 0", "sv_allowcslua 0", "gmod_physiterations 4", "sbox_noclip 0"}
local clientCommands = {"mp_show_voice_icons 0", "gmod_mcore_test 1", "mem_max_heapsize_dedicated 131072", "mem_min_heapsize 131072", "threadpool_affinity 64", "mat_queue_mode 2", "mat_powersavingsmode 0", "r_queued_ropes 1", "r_threaded_renderables 1", "r_threaded_particles 1", "r_threaded_client_shadow_manager 1", "cl_threaded_client_leaf_system 1", "cl_threaded_bone_setup 1", "cl_forcepreload 1", "cl_lagcompensation 1", "cl_timeout 3600", "cl_smoothtime 0.05", "cl_localnetworkbackdoor 1", "cl_cmdrate 66", "cl_updaterate 66", "cl_interp_ratio 2", "studio_queue_mode 1", "ai_expression_optimization 1", "filesystem_max_stdio_read 64", "in_usekeyboardsampletime 1", "r_radiosity 4", "rate 1048576", "mat_frame_sync_enable 0", "mat_framebuffercopyoverlaysize 0", "mat_managedtextures 0", "fast_fogvolume 1", "lod_TransitionDist 2000", "filesystem_unbuffered_io 0"}
local serverHooks = {{"OnEntityCreated", "WidgetInit"}, {"Think", "DOFThink"}, {"Think", "CheckSchedules"}, {"PlayerTick", "TickWidgets"}, {"PlayerInitialSpawn", "PlayerAuthSpawn"}, {"LoadGModSave", "LoadGModSave"}}
local clientHooks = {{"HUDPaint", "DamageEffect"}, {"StartChat", "StartChatIndicator"}, {"FinishChat", "EndChatIndicator"}, {"PostDrawEffects", "RenderWidgets"}, {"PostDrawEffects", "RenderHalos"}, {"OnEntityCreated", "WidgetInit"}, {"GUIMousePressed", "SuperDOFMouseDown"}, {"GUIMouseReleased", "SuperDOFMouseUp"}, {"PreventScreenClicks", "SuperDOFPreventClicks"}, {"Think", "DOFThink"}, {"Think", "CheckSchedules"}, {"NeedsDepthPass", "NeedsDepthPass_Bokeh"}, {"RenderScene", "RenderSuperDoF"}, {"RenderScene", "RenderStereoscopy"}, {"PreRender", "PreRenderFrameBlend"}, {"PostRender", "RenderFrameBlend"}, {"RenderScreenspaceEffects", "RenderBokeh"}}
local function ExecuteCommands(IsServer)
    if IsServer then
        for _, cmd in ipairs(serverCommands) do
            game.ConsoleCommand(cmd .. "\n")
        end
    else
        for _, cmd in ipairs(clientCommands) do
            local command, args = cmd:match("^(%S+)%s+(.*)$")
            if command then
                if args then
                    local argList = {}
                    for arg in string.gmatch(args, "%S+") do
                        table.insert(argList, arg)
                    end

                    RunConsoleCommand(command, unpack(argList))
                else
                    RunConsoleCommand(command)
                end
            end
        end
    end
end

local function RemoveHooks(IsServer)
    if IsServer then
        for _, hookData in ipairs(serverHooks) do
            hook.Remove(hookData[1], hookData[2])
        end
    else
        for _, hookData in ipairs(clientHooks) do
            hook.Remove(hookData[1], hookData[2])
        end
    end
end

function MODULE:Initialize()
    ExecuteCommands(SERVER)
end

function MODULE:OnReloaded()
    RemoveHooks(SERVER)
    ExecuteCommands(SERVER)
end

function widgets.PlayerTick()
end

-- ./modules/core/performance/module.lua
MODULE.name = "Performance"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds Performance"


-- ./modules/core/protection/config.lua
lia.config.add("SwitchCooldownOnAllEntities", "Apply cooldown on all entities", false, nil, {
    desc = "If true, character switch cooldowns gets applied by all types of damage.",
    category = "Character",
    type = "Boolean"
})

lia.config.add("OnDamageCharacterSwitchCooldownTimer", "Switch cooldown after damage", 15, nil, {
    desc = "Cooldown duration (in seconds) after taking damage to switch characters.",
    category = "Character",
    type = "Float",
    min = 0,
    max = 120
})

lia.config.add("CharacterSwitchCooldownTimer", "Character switch cooldown timer", 5, nil, {
    desc = "Cooldown duration (in seconds) for switching characters.",
    category = "Character",
    type = "Float",
    min = 0,
    max = 120
})

lia.config.add("ExplosionRagdoll", "Explosion Ragdoll on Hit", true, nil, {
    desc = "Determines whether being hit by an explosion results in ragdolling",
    category = "Quality of Life",
    type = "Boolean"
})

lia.config.add("CarRagdoll", "Car Ragdoll on Hit", true, nil, {
    desc = "Determines whether being hit by a car results in ragdolling",
    category = "Quality of Life",
    type = "Boolean"
})

lia.config.add("NPCsDropWeapons", "NPCs Drop Weapons on Death", false, nil, {
    desc = "Controls whether NPCs drop weapons upon death",
    category = "Quality of Life",
    type = "Boolean"
})

lia.config.add("TimeUntilDroppedSWEPRemoved", "Time Until Dropped SWEP Removed", 15, nil, {
    desc = "Specifies the duration (in seconds) until a dropped SWEP is removed",
    category = "Protection",
    type = "Float",
    min = 0,
    max = 300
})

lia.config.add("AltsDisabled", "Disable Alts", false, nil, {
    desc = "Whether or not alting is permitted",
    category = "Protection",
    type = "Boolean"
})

lia.config.add("ActsActive", "Enable Acts", false, nil, {
    desc = "Determines whether acts are active",
    category = "Protection",
    type = "Boolean"
})

lia.config.add("PassableOnFreeze", "Passable on Freeze", false, nil, {
    desc = "Makes it so that props frozen can be passed through when frozen",
    category = "Protection",
    type = "Boolean"
})

lia.config.add("PlayerSpawnVehicleDelay", "Player Spawn Vehicle Delay", 30, nil, {
    desc = "Delay for spawning a vehicle after the previous one",
    category = "Protection",
    type = "Float",
    min = 0,
    max = 300
})

lia.config.add("ToolInterval", "Tool Gun Usage Cooldown", 0, nil, {
    desc = "Tool Gun Usage Cooldown",
    category = "Protection",
    type = "Float",
    min = 0,
    max = 60
})

lia.config.add("DisableLuaRun", "Disable Lua Run Hooks", false, nil, {
    desc = "Whether or not Lilia should prevent lua_run hooks on maps",
    category = "Protection",
    type = "Boolean"
})

lia.config.add("EquipDelay", "Equip Delay", 0, nil, {
    desc = "Time delay between equipping items.",
    category = "Items",
    type = "Float",
    min = 0,
    max = 10
})

lia.config.add("UnequipDelay", "Unequip Delay", 0, nil, {
    desc = "Time delay between unequipping items.",
    category = "Items",
    type = "Float",
    min = 0,
    max = 10
})

lia.config.add("DropDelay", "Drop Delay", 0, nil, {
    desc = "Time delay between dropping items.",
    category = "Items",
    type = "Float",
    min = 0,
    max = 10
})

lia.config.add("TakeDelay", "Take Delay", 0, nil, {
    desc = "Time delay between taking items.",
    category = "Items",
    type = "Float",
    min = 0,
    max = 10
})

lia.config.add("ItemGiveSpeed", "Item Give Speed", 6, nil, {
    desc = "How fast transferring items between players via giveForward is.",
    category = "Items",
    type = "Int",
    min = 1,
    max = 60
})

lia.config.add("ItemGiveEnabled", "Is Item Giving Enabled", true, nil, {
    desc = "Determines if item giving via giveForward is enabled.",
    category = "Items",
    type = "Boolean"
})

-- ./modules/core/protection/libraries/client.lua
local HackCommands = {
    ["aimkey"] = true,
    ["+hera_aim"] = true,
    ["boom"] = true,
    ["-hera_aim"] = true,
    ["executer"] = true,
    ["+hera_speed"] = true,
    ["-hera_speed"] = true,
    ["+hera_menu"] = true,
    ["-hera_menu"] = true,
    ["lix_lesp_rotate3"] = true,
    ["lix_lesp_rotate"] = true,
    ["R8_Exploit"] = true,
    ["R8_Menu"] = true,
    ["ace_menu"] = true,
    ["bd_menu"] = true,
    ["bd_quickfire"] = true,
    ["bc_unload"] = true,
    ["sv_add1"] = true,
    ["sv_run1"] = true,
    ["exploit"] = true,
    ["print_server_cfg"] = true,
    ["print_file"] = true,
    ["dump_remote_lua2"] = true,
    ["print_file_listing_load"] = true,
    ["sv_printdirfiles"] = true,
    ["sv_printdir"] = true,
    ["****_admins"] = true,
    ["aah_setupspeedhack"] = true,
    ["_timescale"] = true,
    ["+enabled"] = true,
    ["+triggerbot"] = true,
    ["inc_g"] = true,
    ["Smelly_Print_IPs"] = true,
    ["Smelly_Clear_IPs"] = true,
    ["+autofire"] = true,
    ["spinlol"] = true,
    ["pp_pixelrender"] = true,
    ["startspam"] = true,
    ["stopspam"] = true,
    ["+makesound"] = true,
    ["makesound"] = true,
    ["+pk"] = true,
    ["ThrowMagneto"] = true,
    ["kon_chatspam"] = true,
    ["kon_stopspam"] = true,
    ["RLua"] = true,
    ["Orgflashstyle1"] = true,
    ["Orgflashstyle2"] = true,
    ["se_add"] = true,
    ["mh_unlock"] = true,
    ["mh_toggleflag"] = true,
    ["mh_keypad"] = true,
    ["mh_open"] = true,
    ["mh_turn180"] = true,
    ["mh_esp_rehook"] = true,
    ["mh_owners"] = true,
    ["+qq_aimbot_enabled"] = true,
    ["qq_menu"] = true,
    ["+qq_nospread_triggerbot"] = true,
    ["+qq_speedhack_speed"] = true,
    ["go_unconnected"] = true,
    ["+nou"] = true,
    ["metalslave_aimbot_reload"] = true,
    ["metalslave_aimbot_toggle"] = true,
    ["metalslave_aimbot_menu"] = true,
    ["metalslave_chams_reload"] = true,
    ["cf_aim_toggle"] = true,
    ["+cf_bunnyhop"] = true,
    ["CrashTheServer"] = true,
    ["UltraCrashTheServer"] = true,
    ["+cal_menu"] = true,
    ["+cal_aim"] = true,
    ["Isis_Menu_Reload"] = true,
    ["+Isis_Menu"] = true,
    ["+kilos_aim"] = true,
    ["Isis_InteractC4"] = true,
    ["+Isis_Aim"] = true,
    ["Isis_Spin"] = true,
    ["+Isis_Speed"] = true,
    ["cf_freeze"] = true,
    ["cf_menu"] = true,
    ["+cf_aim"] = true,
    ["+cf_speed"] = true,
    ["+DragonBot_Aim"] = true,
    ["DragonBot_menu"] = true,
    ["sh_luarun"] = true,
    ["2a1f3e4r5678j9r9w8j7d54k6r2a84"] = true,
    ["falco_runlooah"] = true,
    ["falco_openlooah"] = true,
    ["falco_rotate1"] = true,
    ["falco_rotate2"] = true,
    ["frotate"] = true,
    ["+falco_makesound"] = true,
    ["falco_makesound"] = true,
    ["+hermes_aim"] = true,
    ["_PoKi_menu_reload"] = true,
    ["spamjeeps"] = true,
    ["spamchair"] = true,
    ["exploits_open"] = true,
    ["falco_hotkey"] = true,
    ["falco_hotkeyList"] = true,
    ["+cb_aim"] = true,
    ["vlua_run"] = true,
    ["sh_print_traitors"] = true,
    ["+sh_triggerbot"] = true,
    ["sh_runscripts"] = true,
    ["sh_togglemenu"] = true,
    ["gen_aim"] = true,
    ["gen_autoshoot"] = true,
    ["gen_speed"] = true,
    ["+gen_bhop"] = true,
    ["+gen_aim"] = true,
    ["+gen_speed"] = true,
    ["Ares_ForceImpulse"] = true,
    ["Ares_Menu_ESP"] = true,
    ["Ares_Menu_Misc"] = true,
    ["Ares_Menu_AimBot"] = true,
    ["+Ares_Pointer"] = true,
    ["+Ares_SlowNikes"] = true,
    ["+Ares_Aim"] = true,
    ["+Ares_Nikes"] = true,
    ["+Ares_PropKill"] = true,
    ["Ares_Print_IPs"] = true,
    ["mint_toggle"] = true,
    ["phage_menu"] = true,
    ["mfsp_menu"] = true,
    ["+Hera_Menu"] = true,
    ["+asp_antidof"] = true,
    ["+rape"] = true,
    ["+iliek2rape"] = true,
    ["togglerape"] = true,
    ["aimbot_unload"] = true,
    ["+vh_speed"] = true,
    ["+vh_menu"] = true,
    ["gmhax_module_menu"] = true,
    ["gmhax_menu"] = true,
    ["gmhax_lua_view"] = true,
    ["+fap_speed"] = true,
    ["Defqon"] = true,
    ["yb_menu"] = true,
    ["norecoil"] = true,
    ["+yb_menu"] = true,
    ["+ab_aim"] = true,
    ["+spedd"] = true,
    ["int_speedamount"] = true,
    ["int_runlua"] = true,
    ["+chiefeh"] = true,
    ["_SG.ToggleBypass"] = true,
    ["_SG.ToggleSE"] = true,
    ["lua_run_override"] = true,
    ["micspamToggle"] = true,
    ["bk_menu"] = true,
    ["+bk_attack"] = true,
    ["+speedhack"] = true,
    ["bktb_toggle"] = true,
    ["bktb_on"] = true,
    ["bktb_off"] = true,
    ["+bktb"] = true,
    ["ForceCVar"] = true,
    ["runfile"] = true,
    ["+bk_forward"] = true,
    ["+bk_back"] = true,
    ["+bk_left"] = true,
    ["+bk_right"] = true,
    ["+aimbot"] = true,
    ["int_menu"] = true,
    ["+qq_noob2"] = true,
    ["+turbojordans"] = true,
    ["+qq_noob"] = true,
    ["th_menu"] = true,
    ["th_aimbot_on"] = true,
    ["+ph_speed"] = true,
    ["+ph_speedhack"] = true,
    ["+ph_aim"] = true,
    ["ph_aimhack"] = true,
    ["+ph_aimhack"] = true,
    ["ph_hackmenu"] = true,
    ["+Exmenu"] = true,
    ["+mechgear_shot"] = true,
    ["+wurst_silent"] = true,
    ["+wurst_getpos"] = true,
    ["+angel_menu"] = true,
    ["printips"] = true,
    ["+orgmenu"] = true,
    ["+BT"] = true,
    ["+woG"] = true,
    ["+cherry_menu"] = true,
    ["+cherry_aim"] = true,
    ["ProcessCommandBait"] = true,
    ["omen_spin"] = true,
    ["+propthrow"] = true,
    ["+scriptenforcer_menu"] = true,
    ["+comtarg"] = true,
    ["bs_hooks"] = true,
    ["+bh_menu"] = true,
    ["hake_menu"] = true,
    ["asp_rotate"] = true,
    ["asp_menu"] = true,
    ["+hake_aim"] = true,
    ["fls_menu"] = true,
    ["sh_alive"] = true,
    ["bs_detector"] = true,
    ["bs_doeffect"] = true,
    ["gf_admin"] = true,
    ["+uberslow"] = true,
    ["seb_openscript"] = true,
    ["bs_menu"] = true,
    ["+bs_getpos"] = true,
    ["odius_zoom"] = true,
    ["iHack_FullBright"] = true,
    ["+ihack_speedhack"] = true,
    ["ihack_speedhack"] = true,
    ["FCvar"] = true,
    ["+ihack_aimbot"] = true,
    ["ihack_menu"] = true,
    ["ihack_lua_scriptrun"] = true,
    ["ihack_lua_stringrun"] = true,
    ["lua_crypt"] = true,
    ["spinhack"] = true,
    ["at_autoaim_on"] = true,
    ["at_autoaim_off"] = true,
    ["+speed_hack"] = true,
    ["AddSpeed"] = true,
    ["_botjump"] = true,
    ["_botvelocity"] = true,
    ["+speedhake"] = true,
    ["cub_aim_toggle"] = true,
    ["cubHack"] = true,
    ["cubHackLaser"] = true,
    ["gen_run"] = true,
    ["gen_lua"] = true,
    ["+Coma_Pointer"] = true,
    ["Coma_Menu_AimBot"] = true,
    ["Coma_Menu_Misc"] = true,
    ["Coma_ForceImpulse"] = true,
    ["+Coma_SlowNikes"] = true,
    ["+Coma_Nikes"] = true,
    ["+Coma_PropKill"] = true,
    ["AC_toggle"] = true,
    ["AC_menu"] = true,
    ["AC_Misc_NameSteal"] = true,
    ["+AC"] = true,
    ["+AC_Speed"] = true,
    ["+SB_Aim"] = true,
    ["SB_Misc_Flood"] = true,
    ["SB_Misc_Crash"] = true,
    ["+SB_Speed"] = true,
    ["SB_Done"] = true,
    ["+sbot_aimbot"] = true,
    ["+Demibot_aim"] = true,
    ["fls_joinspam"] = true,
    ["fls_spamtimer"] = true,
    ["+coma_aim"] = true,
    ["coma_aim"] = true,
    ["coma_menu"] = true,
    ["+coma_menu"] = true,
    ["+exie_aim"] = true,
    ["+exie_speed"] = true,
    ["+exie_menu"] = true,
    ["exie_menu"] = true,
    ["Menu_H4x"] = true,
    ["fb_fov"] = true,
    ["fb_runscript"] = true,
    ["+fb"] = true,
    ["fb_load"] = true,
    ["omen_reload"] = true,
    ["omen_menu"] = true,
    ["+omen_aim"] = true,
    ["venus_menu"] = true,
    ["+venus_menu"] = true,
    ["Music_troll"] = true,
    ["Defqon_noclip"] = true,
    ["exploit_menu"] = true,
    ["*****"] = true,
    ["+omen_speed"] = true,
    ["+zaim"] = true,
    ["Obelus_Update"] = true,
    ["Obelus_Menu"] = true,
    ["+Obelus_Menu"] = true,
    ["+Obelus_Aim"] = true,
    ["Obelus_Aim"] = true,
    ["+Obelus_Speed"] = true,
    ["bs_force_load"] = true,
    ["lua_logo_reload"] = true,
    ["lua_run_quick"] = true,
    ["bs_reload"] = true,
    ["bs_unload"] = true,
    ["bs_inject"] = true,
    ["+bs_getview"] = true,
    ["odius_menu"] = true,
    ["+odius_aim"] = true,
    ["+odius_pkmode"] = true,
    ["fl_fillhp"] = true,
    ["+sp33d"] = true,
    ["+b_aim"] = true,
    ["server_command"] = true,
    ["toggle_target"] = true,
    ["target_menu"] = true,
    ["+aim"] = true,
    ["anthrax_banadmins"] = true,
    ["anthrax_demoteadmins"] = true,
    ["lol_rcon"] = true,
    ["+follow_aim"] = true,
    ["cs_lua"] = true,
    ["anthrax_filemenu"] = true,
    ["+anthrax_floodserver"] = true,
    ["getrcon"] = true,
    ["exploit_admin"] = true,
    ["exploit_bans"] = true,
    ["exploit_cfg"] = true,
    ["exploit_rcon"] = true,
    ["+fls_joinspam"] = true,
    ["fls_execlua"] = true,
    ["fls_loadlua"] = true,
    ["fls_weightcrash_setup"] = true,
    ["lethal_rotate"] = true,
    ["lethal_menu"] = true,
    ["lix_lesp_reload"] = true,
    ["join_stopspam"] = true,
    ["fls_rotate"] = true,
    ["lix_lesp_rotate1"] = true,
    ["lix_lesp_rotate2"] = true,
    ["fuck_admins"] = true,
    ["ox_hacexploit"] = true,
    ["trowmagneto"] = true,
    ["+qq_menu"] = true,
    ["aah_renamevar"] = true,
    ["aah_renamecmd"] = true,
    ["aah_updatelogsettings"] = true,
    ["aah_reload"] = true,
    ["aah_login"] = true,
    ["qq_aimbot_quick_shot"] = true,
    ["cf_menu_toggle"] = true,
    ["Ares_Clear_IPs"] = true,
    ["+MAim"] = true,
    ["ms_pato"] = true,
    ["+MSpeed"] = true,
    ["ms_sv_cheats"] = true,
    ["+MPause"] = true,
    ["+zumg"] = true,
    ["_fap_reload_menu"] = true,
    ["ThermHack_ToggleMenu"] = true,
    ["cub_toggle"] = true,
    ["hera_convar_get"] = true,
    ["hera_convar_set"] = true,
    ["hera_include"] = true,
    ["hera_runstring"] = true,
    ["Monster_Menu"] = true,
    ["x_reload"] = true,
    ["x_menu"] = true,
    ["+fox_aim"] = true,
    ["+hax_rapidfire"] = true,
    ["+Hax_aimbot"] = true,
    ["+Hax_Menu"] = true,
    ["+Hax_Zoom"] = true,
    ["+TB_Bhop"] = true,
    ["TB_Console"] = true,
    ["+ATMenu"] = true,
    ["+AimAssist"] = true,
    ["+AimBHOP"] = true,
    ["ReloadAA"] = true,
    ["h_runscript"] = true,
    ["gDaap_openscript"] = true,
    ["h_openscript"] = true,
    ["h_firewall"] = true,
    ["h_gtower_debug"] = true,
    ["h_bo_thirdperson"] = true,
    ["h_helxa_encrypt"] = true,
    ["h_helxa_decrypt"] = true,
    ["bypass_se"] = true,
    ["+hax_admin"] = true,
    ["Neon_LoadMenu"] = true,
    ["+Neon_Aim"] = true,
    ["+Neon_SpeedHack"] = true,
    ["+Neon_PropKill"] = true,
    ["Neon_SayTraitors"] = true,
    ["Neon_ForceCheats"] = true,
    ["+neon_menu"] = true,
    ["sb_toggle"] = true,
    ["sh_menu"] = true,
    ["asp_reload"] = true,
    ["+sh_bhop"] = true,
    ["asp_uploaddupe"] = true,
    ["+li_bhop"] = true,
    ["hake_load"] = true,
    ["SE_ByPass"] = true,
    ["se_on"] = true,
    ["+Aim"] = true,
    ["SpamTime"] = true,
    ["SethHack_panic"] = true,
    ["SethHack_lua_run"] = true,
    ["SethHack_lua_openscript"] = true,
    ["+SethHackToggle"] = true,
    ["+SethHack_Menu"] = true,
    ["deathrun_qq"] = true,
    ["+SethHack_Speed"] = true,
    ["SethHack_ff_toggle"] = true,
    ["SethHack_wallhack_wire"] = true,
    ["SethHack_wallhack_player"] = true,
    ["SethHack_Clear_All"] = true,
    ["SethHackToggle"] = true,
    ["SethHack_triggerbot_toggle"] = true,
    ["SethHack_AddNPCfriend"] = true,
    ["SpamMenu"] = true,
    ["Inkbot_Crack"] = true,
    ["Ink_LoadMenu"] = true,
    ["+Propkill"] = true,
    ["+int_aimbot"] = true,
    ["+Ink_Aim"] = true,
    ["Ink_menu"] = true,
    ["ihpublicaimbot_reload"] = true,
    ["ihpublicaimbot_toggle"] = true,
    ["+ihaimbot"] = true,
    ["ihpublicaimbot_menu"] = true,
    ["lagon"] = true,
    ["lagoff"] = true,
    ["fap_aimbot_toggle"] = true,
    ["+Nis_Menu"] = true,
    ["pb_aim_trigger"] = true,
    ["pb_load"] = true,
    ["+TB_Aim"] = true,
    ["+TB_Menu"] = true,
    ["+TB_RapidFire"] = true,
    ["+TB_Speed"] = true,
    ["Spam_Props-V2"] = true,
    ["Spam_Chat-v2"] = true,
    ["+bc_aimbot"] = true,
    ["-bc_aimbot"] = true,
    ["+bc_spamprops"] = true,
    ["bc_ips"] = true,
    ["+bc_speedshoot"] = true,
    ["bc_reload"] = true,
    ["wots_attack"] = true,
    ["_fap_reload"] = true,
    ["SE_AddFile"] = true,
    ["SE_RemoveFile"] = true,
    ["SE_LoadScripts"] = true,
    ["+pb_aim"] = true,
    ["pb_menu"] = true,
    ["Spam_Props"] = true,
    ["Spam_Chat"] = true,
    ["+li_aim"] = true,
    ["+li_menu"] = true,
    ["li_menu"] = true,
    ["+sh_menu"] = true,
    ["+Mawpos"] = true,
    ["gzfaimbot_reload"] = true,
    ["gzfaimbot_toggle"] = true,
    ["gzfaimbot_enabled"] = true,
    ["asb_base_reload"] = true,
    ["asb_base_unload"] = true,
    ["+shenbot_aimbot"] = true,
    ["shenbot_menu"] = true,
    ["shenbot_bunnyhoptoggle"] = true,
    ["-shenbot_aimbot"] = true,
    ["SpinBot_on"] = true,
    ["aimbot_off"] = true,
    ["_aimbot"] = true,
    ["lua_dofile_cl"] = true,
    ["lua_dostring_cl"] = true,
    ["ph0ne_aim"] = true,
    ["ph0ne_aimcancel"] = true,
    ["ph0ne_autoshoot"] = true,
    ["+trooper_menu"] = true,
    ["BMpublicaimbot_reload"] = true,
    ["BMpublicaimbot_toggle"] = true,
    ["+BMaimbot"] = true,
    ["BMpublicaimbot_menu"] = true,
    ["spamchat"] = true,
    ["_fap_menu_reload"] = true,
    ["rs"] = true,
    ["sh_triggerbot"] = true,
    ["sh_showips"] = true,
    ["+sh_speed"] = true,
    ["+sh_aim"] = true,
    ["sh_toggleaim"] = true,
    ["helix_chatspammer"] = true,
    ["helix_undo"] = true,
    ["helix_propspam"] = true,
    ["helix_admins"] = true,
    ["helix_rpnamespammer"] = true,
    ["+helix_speed"] = true,
    ["helix_crypto_binary"] = true,
    ["helix_forcerandomname_on"] = true,
    ["helix_forcerandomname_off"] = true,
    ["helix_troll"] = true,
    ["+helix_aim"] = true,
    ["helix_cvarmenu"] = true,
    ["formatlaser"] = true,
    ["+Helix_Menu"] = true,
    ["helix_reload"] = true,
    ["helix_propspammer2"] = true,
    ["helix_barrelbomb"] = true,
    ["helix_unload"] = true,
    ["helix_speed"] = true,
    ["helix_blocklua"] = true,
    ["helix_propspam_mdl"] = true,
    ["helix_aim_bone"] = true,
    ["helix_aim_crosshair"] = true,
    ["helix_aim_fov"] = true,
    ["helix_aim_los"] = true,
    ["helix_aim_norecoil"] = true,
    ["helix_aim_players"] = true,
    ["helix_aim_shoot"] = true,
    ["helix_aim_team"] = true,
    ["helix_aim_trigger"] = true,
    ["h_name"] = true,
    ["+bb_menu"] = true,
    ["bb"] = true,
    ["ForceLaunch_BB"] = true,
    ["jonsuite_unblockx"] = true,
    ["bacon_lua_openscript"] = true,
    ["discord1"] = true,
    ["discord2"] = true,
    ["aa_toggle"] = true,
    ["Bacon_TriggerBotDelay"] = true,
    ["Bacon_load"] = true,
    ["bacon_chatspam"] = true,
    ["bacon_namechange"] = true,
    ["bacon_chatspam_interval"] = true,
    ["bacon_norecoil"] = true,
    ["Bacon_AntiSnap"] = true,
    ["bacon_autoreload"] = true,
    ["+hermes_menu"] = true,
    ["+sykranos_is_luaviewerier_then_hex"] = true,
    ["sykranos_is_luaviewery_menu"] = true,
    ["+hermes_speed"] = true,
    ["AGT_AutoshootToggle"] = true,
    ["AGT_AimBotToggle"] = true,
    ["AGT_RandomName"] = true,
    ["nbot_aimfixer"] = true,
    ["nbot_speedoffset"] = true,
    ["nbot_UseSelectedPerson"] = true,
    ["nbot_autoshoot"] = true,
    ["fap_enablekeybinding"] = true,
    ["fap_bind"] = true,
    ["fap_unbind"] = true,
    ["lua_se2_load"] = true,
    ["ah_cheats"] = true,
    ["ah_changer"] = true,
    ["ah_speed"] = true,
    ["ah_aimbot_friends"] = true,
    ["ah_aimbot"] = true,
    ["ah_hooks"] = true,
    ["ah_hookhide"] = true,
    ["ah_name"] = true,
    ["ah_antihook"] = true,
    ["ah_reload"] = true,
    ["ah_timestop"] = true,
    ["setconvar"] = true,
    ["fap_menu"] = true,
    ["fap_checkforupdates"] = true,
    ["fap_aim"] = true,
    ["+fap_aim"] = true,
    ["fap_aim_toggle"] = true,
    ["lua_openscript_cl2"] = true,
    ["raidbot_predictcheck"] = true,
    ["aa_enabled"] = true,
    ["BMaimbot"] = true,
    ["aimbot_headshots_on"] = true,
    ["CBon_Reload_Script"] = true,
    ["+CBon_menu"] = true,
    ["ah_chatspammer"] = true,
    ["ah_spammer"] = true,
    ["+ah_menu"] = true,
    ["+nbot_options"] = true,
    ["sm_fexec"] = true,
    ["GAT_RandomName"] = true,
    ["name_menu"] = true,
    ["namechanger_on"] = true,
    ["cl_name"] = true,
    ["+wots_toggleimmunity"] = true,
    ["send_file"] = true,
    ["Bacon_Reload_Script"] = true,
    ["fap_reload"] = true,
    ["download_file"] = true,
    ["upload_file"] = true,
    ["plugin_load"] = true,
    ["sethhack_load"] = true,
    ["st_jumpspam"] = true,
    ["force_cvar"] = true,
    ["cl_docrash"] = true,
    ["_fap_initshit"] = true,
    ["+namechanger"] = true,
    ["RandomNCOn"] = true,
    ["BlankNCON"] = true,
    ["PsaySpamOn"] = true,
    ["GayOn"] = true,
    ["RatingSpammerOn"] = true,
    ["+jbf_scan"] = true,
    ["kennykill"] = true,
    ["kenny_team"] = true,
    ["kenny_bodyshots"] = true,
    ["+kenny"] = true,
    ["kenny_tagasshole"] = true,
    ["kenny_addhit"] = true,
    ["Kenny_noclip"] = true,
    ["bacon_toggle"] = true,
    ["Bacon_EntTriggerBot"] = true,
    ["+wots_spinhack"] = true,
    ["wots_spinhack"] = true,
    ["wire_button_model"] = true,
    ["lol_togglestick"] = true,
    ["lol_name"] = true,
    ["lol_copy"] = true,
    ["lol_fuckthis"] = true,
    ["lol_barrel"] = true,
    ["lol_setchat"] = true,
    ["lol_chat"] = true,
    ["lol_help"] = true,
    ["lol_admins"] = true,
    ["lol_adminalert"] = true,
    ["lol_cancel"] = true,
    ["lol_aim"] = true,
    ["lol_headshot"] = true,
    ["lol_teamshot"] = true,
    ["wots_namecracker_menu"] = true,
    ["wots_namecracker_on"] = true,
    ["wots_namecracker_off"] = true,
    ["wots_crash"] = true,
    ["wots_lag_on"] = true,
    ["wots_lag_off"] = true,
    ["speedhack_speed"] = true,
    ["SetCV"] = true,
    ["+wowspeed"] = true,
    ["+gofast"] = true,
    ["+goslow"] = true,
    ["JBF_off"] = true,
    ["JBF_on"] = true,
    ["JBF_headshots_off"] = true,
    ["skid"] = true,
    ["JBF_headshots_on"] = true,
    ["JBF_enemysonly_on"] = true,
    ["JBF_enemysonly_off"] = true,
    ["JBF_playersonly_on"] = true,
    ["JBF_playersonly_off"] = true,
    ["_JBF_lagcompensation"] = true,
    ["JBF_lagcompensation"] = true,
    ["JBF_suicidehealth"] = true,
    ["JBF_offset"] = true,
    ["+BUTTFUCK"] = true,
    ["entx_spazon"] = true,
    ["entx_spazoff"] = true,
    ["entx_setvalue"] = true,
    ["+buttfuck"] = true,
    ["fap_aim_enabled"] = true,
    ["fap_aim_friendlyfire"] = true,
    ["fap_aim_targetnpcs"] = true,
    ["fap_aim_autofire"] = true,
    ["fap_aim_autoreload"] = true,
    ["fap_aim_bonemode"] = true,
    ["fap_aim_targetfriends"] = true,
    ["fap_aim_targetsteamfriends"] = true,
    ["fap_aim_targetmode"] = true,
    ["fap_aim_nospread"] = true,
    ["fap_aim_maxdistance"] = true,
    ["fap_aim_targetadmins"] = true,
    ["fap_aim_antisnap"] = true,
    ["fap_aim_norecoil"] = true,
    ["fap_aim_antisnapspeed"] = true,
    ["niggeron"] = true,
    ["niggerff"] = true,
    ["niggerfl"] = true,
    ["niggersz"] = true,
    ["niggernpc"] = true,
    ["niggerw"] = true,
    ["niggeri"] = true,
    ["niggershd"] = true,
    ["niggermxsh"] = true,
    ["niggershit"] = true,
    ["niggersd"] = true,
    ["NameGenDerma"] = true,
    ["+elebot"] = true,
    ["+leetbot"] = true,
    ["elebot_offset"] = true,
    ["leetbot_offset"] = true,
    ["elebot_minview"] = true,
    ["leetbot_minview"] = true,
    ["elebot_maxview"] = true,
    ["leetbot_maxview"] = true,
    ["elebot_boxsize"] = true,
    ["leetbot_boxsize"] = true,
    ["elebot_simplecolors"] = true,
    ["leetbot_simplecolors"] = true,
    ["elebot_targetteam"] = true,
    ["leetbot_targetteam"] = true,
    ["elebot_showadmin"] = true,
    ["leetbot_showadmin"] = true,
    ["elebot_filledbox"] = true,
    ["leetbot_filledbox"] = true,
    ["+wots_menu"] = true,
    ["wots_menu"] = true,
    ["wots_megaspam"] = true,
    ["wots_namegen_on"] = true,
    ["wots_namegen_off"] = true,
    ["name_change"] = true,
    ["change_name"] = true,
    ["name_changer"] = true,
    ["+name_changer"] = true,
    ["+Bacon_Menu"] = true,
    ["+BaconToggle"] = true,
    ["BaconToggle"] = true,
    ["Bacon_triggerbot_toggle"] = true,
    ["+Bacon_triggerbot_toggle"] = true,
    ["Bacon_FF_Toggle"] = true,
    ["aimbot_scan"] = true,
    ["+aimbot_scan"] = true,
    ["aimbot"] = true,
    ["_aimbot_headshots"] = true,
    ["aimbot_offset"] = true,
    ["entx_run1"] = true,
    ["entx_run2"] = true,
    ["entx_run3"] = true,
    ["entx_run4"] = true,
    ["entx_traceget"] = true,
    ["entx_camenable"] = true,
    ["+slobpos"] = true,
    ["Bacon_Trigger_Bot"] = true,
    ["+Bacon_Trigger_Bot"] = true,
    ["Bacon_Ignore_SteamFriends"] = true,
    ["Bacon_Mode"] = true,
    ["+gzfaimbot"] = true,
    ["gzfaimbot"] = true,
    ["gzfaimbot_menu"] = true,
    ["at_changer_on"] = true,
    ["at_changer_off"] = true,
    ["at_norecoil_on"] = true,
    ["at_norecoil_off"] = true,
    ["at_menu"] = true,
    ["_GBot_Off"] = true,
    ["_GBot_Menu"] = true,
    ["at_autoshoot_on"] = true,
    ["at_autoshoot_off"] = true,
    ["aa_reload"] = true,
    ["+aa"] = true,
    ["aa_menu"] = true,
    ["+nBot"] = true,
    ["+nbot_Options"] = true,
    ["nbot_Options"] = true,
    ["aimbot_on"] = true,
    ["aimbot_hitbox"] = true,
    ["aimbot_target_teamates"] = true,
    ["aimbot_target_closest"] = true,
    ["aimbot_target_clear"] = true,
    ["+asb_bot"] = true,
    ["asb_bot"] = true,
    ["asb_options"] = true,
    ["+asb"] = true,
    ["asb"] = true,
    ["asb_unload"] = true,
    ["asb_reload"] = true,
    ["asb_shoot"] = true,
    ["+entinfo"] = true,
    ["entinfo_target"] = true,
    ["asb_nospread"] = true,
    ["asb_players"] = true,
    ["entinfo_targetplayer"] = true,
    ["AHack_Menu"] = true,
    ["bs_namechange"] = true,
    ["bs_file"] = true,
    ["bs_spoofcvar"] = true,
    ["AnXition_Menu"] = true,
    ["AnXition_Boost1"] = true,
    ["book"] = true,
    ["AnXition_Boost2"] = true,
    ["AnXition_Boost3"] = true,
    ["AnXition_Derp"] = true,
    ["AnXition_Follow"] = true,
    ["AnXition_GetDClasses"] = true,
    ["AnXition_GetClass"] = true,
    ["AHack_"] = true,
    ["mapex"] = true,
    ["+sykranos_is_luaviewery"] = true,
    ["+sykranos_is_really_luaviewery"] = true,
    ["lol_****this"] = true,
    ["+*********"] = true,
    ["******on"] = true,
    ["******ff"] = true,
    ["******fl"] = true,
    ["******sz"] = true,
    ["******npc"] = true,
    ["******w"] = true,
    ["******i"] = true,
    ["******shd"] = true,
    ["******mxsh"] = true,
    ["***********"] = true,
    ["******sd"] = true,
    ["lenny_menu"] = true,
    ["+Sethhacks_Aim"] = true,
    ["+Sethhacks_Menu"] = true,
    ["+Sethhacks_Speed"] = true,
    ["+save_replay"] = true,
    ["+sykranos_is_really_sexy"] = true,
    ["+sykranos_is_sexier_then_hex"] = true,
    ["+sykranos_is_sexy"] = true,
    ["+ubot_viser"] = true,
    ["-ubot_viser"] = true,
    ["ahack_menu"] = true,
    ["sykranos_is_sexy_menu"] = true,
    ["loki_menu"] = true,
    ["cheadle_api"] = true,
    ["gear_printents"] = true,
    ["gw_toggle"] = true,
    ["gw_pos"] = true,
    ["gearmenu"] = true,
    ["gb_reload"] = true,
    ["gb_toggle"] = true,
    ["+gb"] = true,
    ["-gb"] = true,
    ["gb_menu"] = true,
    ["gear2_menu"] = true,
    ["sasha_menu"] = true,
    ["showents"] = true,
    ["showhxmenu"] = true,
    ["SmegHack_Menu"] = true,
    ["sCheat_menu"] = true,
    ["lowkey_menu"] = true,
}

local HackGlobals = {
    ["netCodes"] = true,
    ["hack"] = true,
    ["cheat"] = true,
    ["aimbot"] = true,
    ["wallhack"] = true,
    ["mapex"] = true,
    ["bunnyhop"] = true,
    ["xray"] = true,
    ["norecoil"] = true,
    ["nospread"] = true,
    ["drawesp"] = true,
    ["doesp"] = true,
    ["manipulate_spread"] = true,
    ["hl2_shotmanip"] = true,
    ["hl2_ucmd_getprediciton"] = true,
    ["cf_manipulateShot"] = true,
    ["zedhack"] = true,
    ["triggerbot"] = true,
    ["getpred"] = true,
    ["cheadle_api"] = true,
    ["bSendPacket"] = true,
    ["ValidNetString"] = true,
    ["totalExploits"] = true,
    ["addExploit"] = true,
    ["AutoReload"] = true,
    ["CircleStrafe"] = true,
    ["toomanysploits"] = true,
    ["Sploit"] = true,
    ["R8"] = true,
    ["ValidateESP"] = true,
    ["ValidateAimbot"] = true,
}

local BadCVars = {
    ["snixzz"] = true,
    ["razor_aim"] = true,
    ["bonus_sv_cheats"] = true,
    ["bonus_sv_allowcslua"] = true,
    ["sp00f_sv_cheats"] = true,
    ["bs_sv_cheats"] = true,
    ["sp00f_sv_allowcslua"] = true,
    ["ah_sv_cheats"] = true,
    ["ah_sv_allowcslua"] = true,
    ["ah_cheats"] = true,
    ["ah_timescale"] = true,
    ["dead_chams"] = true,
    ["dead_xray"] = true,
    ["mh_rearview"] = true,
    ["zedhack"] = true,
    ["boxbot"] = true,
    ["damnbot_"] = true,
    ["ahack_active"] = true,
    ["ahack_aimbot_active"] = true,
    ["mapex_showadmins"] = true,
    ["mapex_speedhack_speed"] = true,
    ["mapex_dancin"] = true,
    ["mapex_xray"] = true,
    ["damnbot_esp_info"] = true,
    ["damnbot_esp_box"] = true,
    ["damnbot_misc_bunnyhop"] = true,
    ["damnbot_aim_aimspot"] = true,
    ["fap_esp_radar"] = true,
    ["fap_bunnyhopspeed"] = true,
    ["fap_checkforupdates"] = true,
    ["fap_aim_autoreload"] = true,
    ["fap_aim_enabled"] = true,
    ["fap_aim_bonemode"] = true,
    ["b-hacks_misc_bhop"] = true,
    ["hera_esp_chams"] = true,
    ["traffichack_aimbot_active"] = true,
    ["traffichack_aimbot_randombones"] = true,
    ["lenny_triggerbot"] = true,
    ["lenny_aimsnap"] = true,
    ["lenny_wh"] = true,
    ["dead_esp"] = true,
    ["niggermenu_Active"] = true,
    ["executer"] = true,
    ["neko_list"] = true,
    ["htx_silent"] = true,
    ["htx_mode"] = true,
    ["lix_lesp_sayprefix"] = true,
    ["lix_lesp_on"] = true,
    ["lix_lesp_health"] = true,
    ["lix_lesp_weapon"] = true,
    ["lix_lesp_money"] = true,
    ["lix_lesp_distance"] = true,
    ["lix_lesp_speed"] = true,
    ["lix_lesp_mirror"] = true,
    ["lix_lesp_mirrorx"] = true,
    ["lix_lesp_mirrory"] = true,
    ["lix_lesp_mirrorw"] = true,
    ["lix_lesp_mirrorh"] = true,
    ["lix_lesp_mirrorpitch"] = true,
    ["lix_lesp_mirroryaw"] = true,
    ["lix_lesp_mirrorroll"] = true,
    ["lix_lesp_radar"] = true,
    ["lix_lesp_radary"] = true,
    ["lix_lesp_radarx"] = true,
    ["lix_lesp_radarw"] = true,
    ["lix_lesp_radarh"] = true,
    ["lix_lesp_radarfov"] = true,
    ["lix_lesp_radarauto"] = true,
    ["lix_lesp_aimdot"] = true,
    ["lix_lesp_aimdotfilter"] = true,
    ["lix_lesp_votetime"] = true,
    ["lix_lesp_detectshow"] = true,
    ["lix_lesp_detectshowrad"] = true,
    ["lix_lesp_detectthresh"] = true,
    ["lix_lesp_detecttrace"] = true,
    ["lix_lesp_xraymat"] = true,
    ["lix_lesp_chatreverse"] = true,
    ["lix_lesp_chatcambridge"] = true,
    ["lix_lesp_chatbyte"] = true,
    ["lix_lesp_objects"] = true,
    ["falco_xraymaterial"] = true,
    ["falco_xrayPROPColor"] = true,
    ["falco_xrayPROPBGColor"] = true,
    ["falco_xrayMINEColor"] = true,
    ["falco_xrayHOLDINGColor"] = true,
    ["falco_xrayPROPMINEBGColor"] = true,
    ["falco_xrayPLAYERcolor"] = true,
    ["gravko_esp"] = true,
    ["gmhax_ShowUnknownEntity"] = true,
    ["gmhax_showdarkrploot2"] = true,
    ["silent"] = true,
    ["aim"] = true,
    ["esp"] = true,
    ["esp_printer"] = true,
    ["esp_dis"] = true,
    ["esp_transparancy"] = true,
    ["esp_info"] = true,
    ["aim_dis"] = true,
    ["bhop"] = true,
    ["AHack_Active"] = true,
    ["mapex_rpgod"] = true,
    ["mapex_showspecs"] = true,
    ["mapex_sniper"] = true,
    ["mapex_weed"] = true,
    ["mapex_coke"] = true,
    ["mapex_printer"] = true,
    ["mapex_gmodz"] = true,
    ["mapex_norecoil"] = true,
    ["mapex_lazer"] = true,
    ["mapex_dd"] = true,
    ["mapex_box"] = true,
    ["mapex_ulxgag"] = true,
    ["B-Hacks_Lasers_HeadLasers"] = true,
    ["B-Hacks_Misc_BlackSkyBox"] = true,
    ["B-Hacks_Misc_FlashLightSpam"] = true,
    ["B-Hacks_Misc_Bhop"] = true,
    ["fap_aim_friendlyfire"] = true,
    ["fap_aim_targetnpcs"] = true,
    ["fap_aim_onlyenemynpcs"] = true,
    ["lenny_advcrosshair"] = true,
    ["lenny_advcrosshair_money"] = true,
    ["lenny_hud"] = true,
    ["triggerbot"] = true,
    ["aimbot"] = true,
    ["aimx"] = true,
    ["aimbot_enabled"] = true,
    ["fap_speedhack_speed"] = true,
    ["vh_speedhack_speed"] = true,
    ["vh_silentaim"] = true,
    ["vh_trigger"] = true,
    ["vh_nospread"] = true,
    ["vh_steamfriends"] = true,
    ["vh_friendly"] = true,
    ["vh_ignoreadmins"] = true,
    ["vh_antisnap"] = true,
    ["vh_antisnap_speed"] = true,
    ["vh_aim_offset"] = true,
    ["CV_CHEATS"] = true,
    ["____sv_cheats"] = true,
    ["____host_timescale"] = true,
    ["____sv_consistency"] = true,
    ["____mat_fullbright"] = true,
    ["bktb_friendly_fire"] = true,
    ["bktb_max_distance"] = true,
    ["bktb"] = true,
    ["speedhack_multiplier"] = true,
    ["bk_aimbot_autoshoot"] = true,
    ["bk_aimbot_ignore_steam_friends"] = true,
    ["bk_aimbot_ignore_teammates"] = true,
    ["bk_aimbot_use_friend_and_enemy_list"] = true,
    ["bk_aimbot_silent"] = true,
    ["bk_aimbot_silent_smooth"] = true,
    ["bk_crosshair_actual_aim"] = true,
    ["bk_norecoil"] = true,
    ["bk_nospread"] = true,
    ["bk_smoothlook"] = true,
    ["bk_spinbot"] = true,
    ["bk_spinbot_random"] = true,
    ["mechgear_aimbot"] = true,
    ["mechgear_aimbot_onattack"] = true,
    ["mechgear_aimbot_useminimumoncommand"] = true,
    ["mechgear_aimbot_minimum"] = true,
    ["_ihack_esp"] = true,
    ["_ihack_esp_npcs"] = true,
    ["_ihack_esp_players"] = true,
    ["_ihack_esp_weapons"] = true,
    ["_ihack_esp_charms"] = true,
    ["_ihack_esp_laser"] = true,
    ["_ihack_aimbot_ignoreplayers"] = true,
    ["_ihack_aimbot_ignorenpcs"] = true,
    ["_ihack_aimbot_ignorefriends"] = true,
    ["_ihack_aimbot_ignoreadmins"] = true,
    ["_ihack_aimbot_friendlyfire"] = true,
    ["_ihack_aimbot_auto"] = true,
    ["_ihack_aimbot_fakeview"] = true,
    ["_ihack_aimbot_nospread"] = true,
    ["_ihack_misc_alwaysnospread"] = true,
    ["_ihack_misc_fov"] = true,
    ["_ihack_misc_disconnectmsg"] = true,
    ["_ihack_ttt_showbodys"] = true,
    ["_ihack_ttt_ignorefellowdetectives"] = true,
    ["_ihack_ttt_ignorefellowtraitors"] = true,
    ["Aim_Enabled"] = true,
    ["Aim_NoRecoil"] = true,
    ["Misc_Spam"] = true,
    ["AC_Misc_Bhop"] = true,
    ["Coma_Misc_LogIPs"] = true,
    ["Coma_Misc_ULXAntiGag"] = true,
    ["Coma_Misc_Date"] = true,
    ["Coma_Misc_Spammer"] = true,
    ["Coma_SlowSpeedHack"] = true,
    ["Coma_SH_CheatsOff"] = true,
    ["Coma_SHSpeed"] = true,
    ["Coma_HostFrameRate"] = true,
    ["Coma_HostTimeScale"] = true,
    ["Coma_AimBot_SmoothAim"] = true,
    ["Coma_AimBot_SmoothAimSpeed"] = true,
    ["Coma_AimBot_Autoshoot"] = true,
    ["Coma_AimBot_NoRecoil"] = true,
    ["Coma_AimBot_NoSpread"] = true,
    ["Coma_AimBot_IgnoreSteamFriends"] = true,
    ["Coma_AimBot_IgnoreAdmins"] = true,
    ["Coma_AimBot_FriendlyFire"] = true,
    ["Coma_AimBot_IgnoreTraitorFriends"] = true,
    ["SB_Aim_Enabled"] = true,
    ["hake_shouldrun"] = true,
    ["SB_Aim_FF"] = true,
    ["SB_Aim_Offset"] = true,
    ["SB_Aim_Steam"] = true,
    ["SB_Aim_NoRecoil"] = true,
    ["SB_Misc_Spam"] = true,
    ["fhack"] = true,
    ["fhackmodel"] = true,
    ["fhackrage"] = true,
    ["anthrax_killonsight"] = true,
    ["anthrax_velocitypredict"] = true,
    ["Smelly_Misc_LogIPs"] = true,
    ["metalslave_aimbot_enabled"] = true,
    ["mh_ab_enabled"] = true,
    ["mh_ab_ffa"] = true,
    ["mh_ab_nospread"] = true,
    ["mh_ab_priority"] = true,
    ["mh_ab_fov"] = true,
    ["mh_ab_offset"] = true,
    ["mh_ab_auto"] = true,
    ["mh_esp_enabled"] = true,
    ["mh_esp_mode"] = true,
    ["mh_esp_names"] = true,
    ["mh_esp_health"] = true,
    ["mh_esp_reveal"] = true,
    ["mh_esp_revent"] = true,
    ["mh_esp_fov"] = true,
    ["mh_ungag"] = true,
    ["cf_host_timescale"] = true,
    ["cf_aim_enabled"] = true,
    ["cf_bunnyhop_minspeed"] = true,
    ["cf_lockdownlua"] = true,
    ["cf_checkdormantplayers"] = true,
    ["cf_bunnyhopspace"] = true,
    ["cf_bunnyhop"] = true,
    ["cf_collectgarbage"] = true,
    ["cf_pingpredict"] = true,
    ["cf_updatemenucomponents"] = true,
    ["cf_logs_level"] = true,
    ["cf_logs_enabled"] = true,
    ["cf_traitormode"] = true,
    ["cf_spinbot"] = true,
    ["cf_esp_drawcrosshair"] = true,
    ["cf_esp_usesmallerfont"] = true,
    ["cf_esp_drawtextinfo"] = true,
    ["cf_esp_drawweapons"] = true,
    ["cf_esp_drawmodels"] = true,
    ["cf_esp_outlinemodels"] = true,
    ["cf_esp_draweyeangles"] = true,
    ["cf_esp_minespdistance"] = true,
    ["cf_esp_maxespdistance"] = true,
    ["cf_esp_entitytransparencydiameter"] = true,
    ["cf_esp_entitytranspare"] = true,
    ["cf_esp_enabled"] = true,
    ["cf_esp_onlydrawtraitors"] = true,
    ["cf_aim_nospreadonfire"] = true,
    ["cf_aim_ucmdfire"] = true,
    ["cf_aim_snaponfiretime"] = true,
    ["cf_aim_snaponfire"] = true,
    ["cf_aim_offsetz"] = true,
    ["cf_aim_predictionseed"] = true,
    ["cf_aim_nospread"] = true,
    ["cf_aim_enemymode"] = true,
    ["cf_aim_autoreload"] = true,
    ["cf_aim_autofire"] = true,
    ["cf_aim_checkpartialhits"] = true,
    ["cf_aim_fakeview"] = true,
    ["cf_aim_antisnapspeed"] = true,
    ["cf_aim_antisnap"] = true,
    ["cf_aim_velocityprediction"] = true,
    ["cf_aim_ignorelos"] = true,
    ["cf_aim_maxangledifference"] = true,
    ["cf_aim_bonemode"] = true,
    ["cf_aim_targetmode"] = true,
    ["cf_aim_onlytargettraitors"] = true,
    ["cf_aim_targetsteamfriends"] = true,
    ["cf_aim_targetadmins"] = true,
    ["cf_aim_targetfriends"] = true,
    ["cf_aim_friendlyfire"] = true,
    ["cf_aim_targetnpcs"] = true,
    ["cf_aim_maxdistance"] = true,
    ["Isis_Esp"] = true,
    ["Isis_Esp_Health"] = true,
    ["Isis_Esp_Box"] = true,
    ["Isis_Esp_Warnings"] = true,
    ["Isis_Esp_Traitor"] = true,
    ["Isis_Esp_Admins"] = true,
    ["Isis_Esp_ShowC4"] = true,
    ["Isis_Esp_Chams"] = true,
    ["Isis_Misc_AntiGag"] = true,
    ["Isis_Misc_ShowStatus"] = true,
    ["Isis_Misc_Bunnyhop"] = true,
    ["Isis_Misc_RemoveSky"] = true,
    ["Isis_Misc_Crosshair"] = true,
    ["Isis_Aimbot_NoRecoil"] = true,
    ["Isis_Aimbot_IgnoreSteam"] = true,
    ["Isis_Aimbot_Friendlyfire"] = true,
    ["Isis_Aimbot_FixView"] = true,
    ["Isis_Aimbot_AutoShoot"] = true,
    ["Isis_Aimbot_NoSpread"] = true,
    ["Isis_Aimbot_Offset"] = true,
    ["Isis_Aimbot_AimSpot"] = true,
    ["Isis_Speedhack_Speed"] = true,
    ["Isis_Other_AutoReminder"] = true,
    ["qq_ttt_predict_nade"] = true,
    ["qq_antiaim_mode"] = true,
    ["qq_fakeview_enabled"] = true,
    ["qq_debug"] = true,
    ["aah_log"] = true,
    ["aah_logpath"] = true,
    ["aah_blockac"] = true,
    ["aah_bypassse"] = true,
    ["aah_hash"] = true,
    ["DragonBot_Esp"] = true,
    ["DragonBot_Esp_Health"] = true,
    ["DragonBot_Esp_Distance"] = true,
    ["DragonBot_Esp_Admin"] = true,
    ["DragonBot_Bhop"] = true,
    ["DragonBot_Rp_Esp"] = true,
    ["DragonBot_Chams"] = true,
    ["DragonBot_Line"] = true,
    ["DragonBot_Light"] = true,
    ["DragonBot_Trigger"] = true,
    ["DragonBot_TTT"] = true,
    ["DragonBot_Aimbot_IgnoreSteam"] = true,
    ["DragonBot_Aimbot_Friendlyfire"] = true,
    ["DragonBot_Aimbot_IgnoreAdmins"] = true,
    ["DragonBot_SmoothAim_Enabled"] = true,
    ["DragonBot_Smooth_Speed"] = true,
    ["DragonBot_Aimbot_Norecoil"] = true,
    ["DragonBot_AimKeySave"] = true,
    ["DragonBot_MenuKeySave"] = true,
    ["DragonBot_PropKeySave"] = true,
    ["triggerbot_enabled"] = true,
    ["asb_bone"] = true,
    ["asb_fov"] = true,
    ["asb_los"] = true,
    ["asb_players"] = true,
    ["asb_shoot"] = true,
    ["asb_trigger"] = true,
    ["sw_aim"] = true,
    ["sw_norecoil"] = true,
    ["sw_aimonfire"] = true,
    ["sh_aim"] = true,
    ["sh_aimonfire"] = true,
    ["sh_norecoil"] = true,
    ["anacletobot"] = true,
    ["anacletobot_target"] = true,
    ["anacletobot_maxdist"] = true,
    ["+ares_aim"] = true,
    ["ink_propkill"] = true,
    ["sh_print_traitors"] = true,
    ["Ares_Misc_Bhop"] = true,
    ["Ares_Misc_Keypad"] = true,
    ["Ares_Misc_LogIPs"] = true,
    ["Ares_Misc_ULXAntiGag"] = true,
    ["Ares_Traitor"] = true,
    ["Ares_ESP_C4Detection"] = true,
    ["Ares_SlowSpeedHack"] = true,
    ["Ares_SH_CheatsOff"] = true,
    ["Ares_SHSpeed"] = true,
    ["Ares_HostFrameRate"] = true,
    ["Ares_HostTimeScale"] = true,
    ["Ares_AimBot_SmoothAim"] = true,
    ["Ares_AimBot_SmoothAimSpeed"] = true,
    ["Ares_AimBot_Autoshoot"] = true,
    ["Ares_AimBot_NoRecoil"] = true,
    ["Ares_AimBot_NoSpread"] = true,
    ["Ares_AimBot_IgnoreSteamFriends"] = true,
    ["Ares_AimBot_IgnoreAdmins"] = true,
    ["Ares_AimBot_FriendlyFire"] = true,
    ["Ares_AimBot_IgnoreTraitorFriends"] = true,
    ["ms_host_timescale"] = true,
    ["ms_sv_cheats"] = true,
    ["MAim_Targetmode"] = true,
    ["MAim_MaxDistance"] = true,
    ["MAim_MaxAngle"] = true,
    ["MAim_FF"] = true,
    ["MAim_Autoshoot"] = true,
    ["MAim_MissShots"] = true,
    ["MAim_Antisnap"] = true,
    ["MAim_AntisnapSpeed"] = true,
    ["M_Norecoil"] = true,
    ["M_NoSpread"] = true,
    ["speedhack_speed"] = true,
    ["x_enabled"] = true,
    ["Hax_NameTags"] = true,
    ["Hax_SaveView"] = true,
    ["Hax_ShowCrosshair"] = true,
    ["Hax_ShowCrosshair2"] = true,
    ["Hax_WallHackStyle"] = true,
    ["Hax_SmoothAim"] = true,
    ["Hax_SmoothAimSpeed"] = true,
    ["Hax_DrawParticles"] = true,
    ["Hax_TriggerBot"] = true,
    ["Hax_TriggerBot2"] = true,
    ["Hax_IgnoreSteamFriends"] = true,
    ["Hax_MaxWallHackDist"] = true,
    ["Hax_IgnoreTeam"] = true,
    ["Hax_AimFov"] = true,
    ["TB_AimFov"] = true,
    ["TB_AimTeam"] = true,
    ["TB_NameTags"] = true,
    ["TB_NTAdmin"] = true,
    ["TB_NTHealth"] = true,
    ["TB_NTAlpha"] = true,
    ["TB_FakeView"] = true,
    ["TB_TargetPlayers"] = true,
    ["TB_TargetNPCs"] = true,
    ["TB_AntiSnap"] = true,
    ["TB_AntiSnapSpeed"] = true,
    ["AimAssistSA"] = true,
    ["AimAssistFV"] = true,
    ["ATTargetPlayers"] = true,
    ["ATTargetNPCs"] = true,
    ["ATIgnoreSteam"] = true,
    ["ATIgnoreDistance"] = true,
    ["ATAimDistance"] = true,
    ["ATWallHack"] = true,
    ["ATAimRadius"] = true,
    ["ATNPCNames"] = true,
    ["h_sv_cheats"] = true,
    ["h_host_timescale"] = true,
    ["h_host_framerate"] = true,
    ["lymes_enable_hack_killhead_shotter"] = true,
    ["lymes_enable_seethrough_esphack"] = true,
    ["lymes_remotelua_hake"] = true,
    ["lymes_remotelua_hack"] = true,
    ["lymes_enable_autoheadshoot"] = true,
    ["Neon_AimBot_ShowAimStatus"] = true,
    ["Neon_AimBot_SmoothAimEnabled"] = true,
    ["Neon_AimBot_SmoothAimSpeed"] = true,
    ["Neon_AimBot_IgnoreFriends"] = true,
    ["Neon_AimBot_IgnoreAdmins"] = true,
    ["Neon_AimBot_Friendlyfire"] = true,
    ["Neon_AimBot_NoRecoil"] = true,
    ["Neon_AimBot_AimOffset"] = true,
    ["Neon_AimBot_AimBone"] = true,
    ["Neon_AimBot_AimMode"] = true,
    ["Neon_AimBot_IgnoreSteamFriends"] = true,
    ["Neon_PlayerESP"] = true,
    ["Neon_PlayerESP_Health"] = true,
    ["Neon_PlayerESP_ShowAll"] = true,
    ["Neon_NPCESP"] = true,
    ["Neon_PlayerFullBright"] = true,
    ["Neon_PlayerWireFrame"] = true,
    ["Neon_MoneyPrinterESP"] = true,
    ["Neon_MoneyESP"] = true,
    ["Neon_ShipmentESP"] = true,
    ["Neon_FullBright"] = true,
    ["Neon_Gray"] = true,
    ["Neon_WorldWireFrame"] = true,
    ["Neon_PlayerBox"] = true,
    ["Neon_Bhop"] = true,
    ["Neon_ULXAntiGag"] = true,
    ["Neon_NikeSpeed"] = true,
    ["Neon_HostTimeScale"] = true,
    ["Neon_SpeedHack_CheatsOff"] = true,
    ["Neon_Traitor"] = true,
    ["Neon_KeypadHack"] = true,
    ["Neon_WeaponsESP"] = true,
    ["Neon_AimBot_TriggerBot"] = true,
    ["Neon_PlayerWallHackFull"] = true,
    ["Neon_DynamicLight"] = true,
    ["Neon_DynamicLightSize"] = true,
    ["Neon_LogPlayerIPs"] = true,
    ["Neon_CrossHair"] = true,
    ["Neon_CrossHair_Red"] = true,
    ["Neon_CrossHair_Green"] = true,
    ["Neon_CrossHair_Blue"] = true,
    ["Neon_C4Detection"] = true,
    ["hermes_misc_antiaimr_antiaim"] = true,
    ["hermes_misc_antiaimy_antiaim"] = true,
    ["hermes_misc_antiaimp_antiaim"] = true,
    ["hermes_misc_antiaimduck_antiaim"] = true,
    ["hermes_misc_antiaimrandom_antiaim"] = true,
    ["hermes_misc_antiaim_antiaim"] = true,
    ["hermes_misc_zoomamount_zoom"] = true,
    ["hermes_misc_zoomontrigger_zoom"] = true,
    ["hermes_misc_zoomonaim_zoom"] = true,
    ["hermes_misc_zoomalways_zoom"] = true,
    ["hermes_misc_zoom_zoom"] = true,
    ["hermes_misc_speedhackspeed_speedhack"] = true,
    ["hermes_misc_speedhack_speedhack"] = true,
    ["hermes_misc_particles_globals"] = true,
    ["hermes_misc_fullbrightg_globals"] = true,
    ["hermes_misc_radarradius_radar"] = true,
    ["hermes_misc_radarspin_radar"] = true,
    ["hermes_misc_radarname_radar"] = true,
    ["hermes_misc_radar_radar"] = true,
    ["hermes_misc_crosshairlength_crosshair"] = true,
    ["hermes_misc_crosshairgap_crosshair"] = true,
    ["hermes_misc_crosshair_crosshair"] = true,
    ["hermes_misc_crosshairtype_crosshair"] = true,
    ["hermes_misc_ulxantigag_misc"] = true,
    ["hermes_misc_autopistol_misc"] = true,
    ["hermes_misc_bunnyhop_misc"] = true,
    ["hermes_misc_namesteal_misc"] = true,
    ["hermes_esp_asusval_asus"] = true,
    ["hermes_esp_asusmdl_asus"] = true,
    ["hermes_esp_asus_asus"] = true,
    ["hermes_esp_visiblechams_chams"] = true,
    ["hermes_esp_fullbright_chams"] = true,
    ["hermes_esp_walltype_chams"] = true,
    ["hermes_esp_vehiclese_entities"] = true,
    ["hermes_esp_ragdollse_entities"] = true,
    ["hermes_esp_weaponse_entities"] = true,
    ["hermes_esp_entityliste_entities"] = true,
    ["hermes_esp_enablee_entities"] = true,
    ["hermes_esp_boxn_npcs"] = true,
    ["hermes_esp_enablen_npcs"] = true,
    ["hermes_esp_adminlist_players"] = true,
    ["hermes_esp_friendsmark_players"] = true,
    ["hermes_esp_barrel_players"] = true,
    ["hermes_esp_weapon_players"] = true,
    ["hermes_esp_health_players"] = true,
    ["hermes_esp_name_players"] = true,
    ["hermes_esp_enemyonly_players"] = true,
    ["hermes_esp_enable_players"] = true,
    ["hermes_esp_optical_players"] = true,
    ["hermes_esp_fadelength_general"] = true,
    ["hermes_esp_maxshow_general"] = true,
    ["hermes_esp_enablefade_general"] = true,
    ["hermes_esp_font_general"] = true,
    ["hermes_aim_novisspread_accuracy"] = true,
    ["hermes_aim_norecoil_accuracy"] = true,
    ["hermes_aim_nospread_accuracy"] = true,
    ["hermes_aim_togglename_hud"] = true,
    ["hermes_aim_toggle_hud"] = true,
    ["hermes_aim_triggerdistance_triggerbot"] = true,
    ["hermes_aim_triggernospread_triggerbot"] = true,
    ["hermes_aim_triggerkey_triggerbot"] = true,
    ["hermes_aim_triggerbot_triggerbot"] = true,
    ["hermes_aim_ignorevehicle_targeting"] = true,
    ["hermes_aim_ignoreghost_targeting"] = true,
    ["hermes_aim_ignoretraitor_targeting"] = true,
    ["hermes_aim_ignoreteam_targeting"] = true,
    ["hermes_aim_ignoresteam_targeting"] = true,
    ["hermes_aim_ignoreadmin_targeting"] = true,
    ["hermes_aim_targetnpc_targeting"] = true,
    ["hermes_aim_targetplayer_targeting"] = true,
    ["hermes_aim_friendslist_targeting"] = true,
    ["hermes_aim_predictply_aimbot"] = true,
    ["hermes_aim_predicttar_aimbot"] = true,
    ["hermes_aim_smoothaimspeed_aimbot"] = true,
    ["hermes_aim_fov_aimbot"] = true,
    ["hermes_aim_offset_aimbot"] = true,
    ["hermes_aim_disableafterkill_aimbot"] = true,
    ["hermes_aim_holdtarget_aimbot"] = true,
    ["hermes_aim_smoothaim_aimbot"] = true,
    ["hermes_aim_velocitychecks_aimbot"] = true,
    ["hermes_aim_loscheck_aimbot"] = true,
    ["hermes_aim_silentaim_aimbot"] = true,
    ["hermes_aim_autoshoot_aimbot"] = true,
    ["hermes_aim_prediction_aimbot"] = true,
    ["hermes_aim_aimmode_aimbot"] = true,
    ["hermes_aim_aimtype_aimbot"] = true,
    ["hermes_load"] = true,
    ["hermes_host_timescale"] = true,
    ["hermes_pato"] = true,
    ["hermes_sv_cheats"] = true,
    ["hermes_mat_fullbright"] = true,
    ["hermes_r_drawparticles"] = true,
    ["_framerate"] = true,
    ["_timescale"] = true,
    ["_cheats"] = true,
    ["2_r_drawothermodels"] = true,
    ["2_sv_cheats"] = true,
    ["2_host_timescale"] = true,
    ["1_r_drawothermodels"] = true,
    ["1_sv_cheats"] = true,
    ["1_host_timescale"] = true,
    ["seb_enable"] = true,
    ["sh_enabled"] = true,
    ["SethHack_allow_cheats_default"] = true,
    ["SethHack_ff"] = true,
    ["SethHack_Chams"] = true,
    ["SethHack_NPConly"] = true,
    ["SethHack_Entonly"] = true,
    ["SethHack_Plyonly"] = true,
    ["SethHack_LockY"] = true,
    ["SethHack_Enemy_Compensation"] = true,
    ["SethHack_Me_Compensation"] = true,
    ["SethHack_TMW"] = true,
    ["SethHack_Ignore_SteamFriends"] = true,
    ["SethHack_Ignore_Admins"] = true,
    ["SethHack_Trigger_Bot"] = true,
    ["SethHack_RestrictFOV_Value"] = true,
    ["SethHack_AimSmooth"] = true,
    ["SethHack_Mode"] = true,
    ["SethHack_espplayeron"] = true,
    ["SethHack_espunhideon"] = true,
    ["SethHack_espmode"] = true,
    ["SethHack_espcross"] = true,
    ["SethHack_espitemon"] = true,
    ["SethHack_espvehicleon"] = true,
    ["SethHack_espnpcon"] = true,
    ["SethHack_espweaponon"] = true,
    ["SethHack_esptrans"] = true,
    ["SethHack_adminlist"] = true,
    ["SethHack_drawclassname"] = true,
    ["SethHack_showcmds"] = true,
    ["SethHack_blacklistcmds"] = true,
    ["SethHack_showumsgs"] = true,
    ["SethHack_autoreload"] = true,
    ["SethHack_crosshair"] = true,
    ["SethHack_chams2"] = true,
    ["SethHack_bhop"] = true,
    ["SethHack_spinbot"] = true,
    ["SethHack_chatspam"] = true,
    ["SethHack_chatspam_interval"] = true,
    ["SethHack_enable_filelogs"] = true,
    ["SethHack_enable_sendlualog"] = true,
    ["SethHack_enable_iplogs"] = true,
    ["SethHack_enable_dslogs"] = true,
    ["SethHack_speedfactor"] = true,
    ["SethHack_gamemodeview"] = true,
    ["SethHack_clientnoclip"] = true,
    ["SethHack_always_nospread"] = true,
    ["Ink_Esp_Admin"] = true,
    ["Ink_Bhop"] = true,
    ["Ink_Trigger"] = true,
    ["Ink_TTT"] = true,
    ["Ink_AntiGag"] = true,
    ["Ink_Aimbot_IgnoreSteam"] = true,
    ["Ink_Aimbot_Friendlyfire"] = true,
    ["Ink_Aimbot_IgnoreAdmins"] = true,
    ["Ink_SmoothAim_Enabled"] = true,
    ["Ink_Smooth_Speed"] = true,
    ["Aimbot_Offset"] = true,
    ["Ink_Aimbot_Norecoil"] = true,
    ["Ink_Key"] = true,
    ["Ink_Func"] = true,
    ["Ink_AimKeySave"] = true,
    ["Ink_MenuKeySave"] = true,
    ["Ink_PropKeySave"] = true,
    ["ihpublicaimbot_enabled"] = true,
    ["fap_aimbot_toggle"] = true,
    ["Nishack_Triggerbot_Enabled"] = true,
    ["sh_wallhack_dist"] = true,
    ["pb_aim_trigger"] = true,
    ["TB_BlockRCC"] = true,
    ["trooper_aimbot"] = true,
    ["trooper_autoshoot"] = true,
    ["trooper_norecoil"] = true,
    ["pb_load"] = true,
    ["bc_norecoil"] = true,
    ["bc_bouncy"] = true,
    ["wots_buddy_attack"] = true,
    ["wots_aimbot_teammode"] = true,
    ["wots_aimbot_mouselock"] = true,
    ["fap_aim_checkpartialhits"] = true,
    ["fap_aim_autofire"] = true,
    ["fap_aim_targetfriends"] = true,
    ["fap_aim_targetsteamfriends"] = true,
    ["fap_aim_targetmode"] = true,
    ["fap_aim_nospread"] = true,
    ["fap_aim_maxdistance"] = true,
    ["fap_aim_targetadmins"] = true,
    ["fap_aim_antisnap"] = true,
    ["fap_aim_norecoil"] = true,
    ["fap_aim_antisnapspeed"] = true,
    ["fap_aim_maxangle"] = true,
    ["fap_aim_snaponfire"] = true,
    ["fap_aim_snaponfiretime"] = true,
    ["fap_aim_onlytargettraitors"] = true,
    ["fap_aim_velocityprediction"] = true,
    ["fap_aim_checknpcrelationship"] = true,
    ["fap_shouldload"] = true,
    ["fap_enablekeybinding"] = true,
    ["fap_bunnyhop"] = true,
    ["fap_dontchecklos"] = true,
    ["fap_alwaysloadhardcopy"] = true,
    ["fap_ucmdfire"] = true,
    ["lenny"] = true,
    ["cheadle_api"] = true,
    ["smeg"] = true,
    ["wallhack"] = true,
    ["nospread"] = true,
    ["antiaim"] = true,
    ["hvh"] = true,
    ["autostrafe"] = true,
    ["circlestrafe"] = true,
    ["spinbot"] = true,
    ["odium"] = true,
    ["ragebot"] = true,
    ["legitbot"] = true,
    ["fakeangles"] = true,
    ["anticac"] = true,
    ["antiscreenshot"] = true,
    ["fakeduck"] = true,
    ["lagexploit"] = true,
    ["exploits_open"] = true,
    ["gmodhack"] = true,
    ["cathack"] = true,
}

local suspiciousFunctions = {
    ["hook.Call"] = true,
    ["net.Receive"] = true,
    ["render.Capture"] = true,
    ["RunConsoleCommand"] = true
}

local hideWeaponSet = {
    ["weapon_gravitygun"] = true,
    ["weapon_physgun"] = true,
    ["gmod_tool"] = true
}

function MODULE:CanDeleteChar(_, character)
    if IsValid(character) and character:getMoney() < lia.config.get("DefaultMoney") then return false end
end

function MODULE:DrawPhysgunBeam(client)
    return client == LocalPlayer()
end

local function ShouldHideWeapon(wep)
    if not IsValid(wep) or not IsValid(wep.Owner) then return false end
    if not wep.Owner:isStaffOnDuty() then return false end
    return hideWeaponSet[wep:GetClass()] or false
end

function MODULE:PrePlayerDraw(client)
    local activeWep = client:GetActiveWeapon()
    if not IsValid(activeWep) then return end
    if ShouldHideWeapon(activeWep) then activeWep:SetNoDraw(true) end
end

local function VerifyCheats()
    for func in pairs(suspiciousFunctions) do
        if _G[func] then
            local info = debug.getinfo(_G[func], "S")
            if info and info.what ~= "C" then
                net.Start("CheckHack")
                net.SendToServer()
                return
            end
        end
    end

    local hackCommands = concommand.GetTable()
    for command in pairs(HackCommands) do
        if hackCommands[command] then
            net.Start("CheckHack")
            net.SendToServer()
            return
        end
    end

    for cvar in pairs(BadCVars) do
        if ConVarExists(cvar) then
            net.Start("CheckHack")
            net.SendToServer()
            return
        end
    end

    for globalName in pairs(HackGlobals) do
        if _G[globalName] then
            net.Start("CheckHack")
            net.SendToServer()
            return
        end
    end
end

local function generateRandom(length)
    length = length or 16
    local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    local randomString = {}
    for _ = 1, length do
        local rand = math.random(1, #chars)
        table.insert(randomString, chars:sub(rand, rand))
    end
    return table.concat(randomString)
end

function MODULE:InitPostEntity()
    local client = LocalPlayer()
    if not file.Exists("cache", "DATA") then file.CreateDir("cache") end
    local filename = "cache/" .. generateRandom() .. ".png"
    if lia.config.get("AltsDisabled", false) and file.Exists(filename, "DATA") then
        net.Start("CheckSeed")
        net.WriteString(file.Read(filename, "DATA"))
        net.SendToServer()
    else
        file.Write(filename, client:SteamID64())
    end
end

net.Receive("VerifyCheats", VerifyCheats)

-- ./modules/core/protection/libraries/server.lua
local MODULE = MODULE
function MODULE:CanPlayerSwitchChar(client, character)
    if not client:isStaffOnDuty() then
        local damageCooldown = lia.config.get("OnDamageCharacterSwitchCooldownTimer", 15)
        local switchCooldown = lia.config.get("CharacterSwitchCooldownTimer", 5)
        if damageCooldown > 0 and client.LastDamaged and client.LastDamaged > CurTime() - damageCooldown then return false, L("tookDamageSwitchCooldown") end
        local loginTime = character:getData("loginTime", 0)
        if switchCooldown > 0 and loginTime + switchCooldown > os.time() then return false, L("switchCooldown") end
    end
    return true
end

function MODULE:EntityTakeDamage(entity, dmgInfo)
    local inflictor = dmgInfo:GetInflictor()
    local attacker = dmgInfo:GetAttacker()
    local isValidClient = IsValid(entity) and entity:IsPlayer()
    local attackerIsHuman = IsValid(attacker) and attacker:IsPlayer()
    local notSameEntity = attacker ~= entity
    local isFallDamage = dmgInfo:IsFallDamage()
    local inflictorIsProp = IsValid(inflictor) and inflictor:isProp()
    if not isValidClient or isFallDamage then return end
    if inflictorIsProp then
        dmgInfo:SetDamage(0)
        return
    end

    if dmgInfo:IsExplosionDamage() and lia.config.get("ExplosionRagdoll", true) then
        dmgInfo:ScaleDamage(0.5)
        local dmgPos = dmgInfo:GetDamagePosition()
        local direction = (entity:GetPos() - dmgPos):GetNormalized()
        entity:SetVelocity(direction * 60 * dmgInfo:GetDamage())
        local damageAmount = dmgInfo:GetDamage()
        timer.Simple(0.05, function() if IsValid(entity) and not entity:hasRagdoll() and entity:Health() - damageAmount > 0 then entity:setRagdolled(true, 3) end end)
    end

    if notSameEntity then
        if entity:GetMoveType() == MOVETYPE_NOCLIP then return end
        if lia.config.get("OnDamageCharacterSwitchCooldownTimer", 15) > 0 then
            local applyCooldown = lia.config.get("SwitchCooldownOnAllEntities", false) or attackerIsHuman
            if applyCooldown then entity.LastDamaged = CurTime() end
        end

        if lia.config.get("CarRagdoll", true) and IsValid(inflictor) and inflictor:isSimfphysCar() then
            local veh = entity:GetVehicle()
            local inSimCar = IsValid(veh) and veh:isSimfphysCar()
            if not inSimCar then
                dmgInfo:ScaleDamage(0)
                if not entity:hasRagdoll() and entity:Health() - dmgInfo:GetDamage() > 0 then entity:setRagdolled(true, 5) end
            end
        end
    end
end

function MODULE:PlayerShouldAct()
    return lia.config.get("ActsActive", false)
end

local function NotifyAdmin(notification)
    for _, client in player.Iterator() do
        if IsValid(client) and client:hasPrivilege("Staff Permissions - Can See Alting Notifications") then client:ChatPrint(notification) end
    end
end

local function ApplyPunishment(client, infraction, kick, ban, time)
    local bantime = time or 0
    if kick then
        if sam then
            sam.player.kick_id(client:SteamID64(), L("kickedForInfraction") .. infraction)
        elseif ULib then
            ULib.kick(client, L("kickedForInfraction") .. infraction)
        else
            client:Kick(L("kickedForInfraction") .. infraction)
        end
    end

    if ban then
        if sam then
            sam.player.ban_id(client:SteamID64(), bantime, L("bannedForInfraction") .. infraction)
        elseif ULib then
            ULib.ban(client, bantime, L("bannedForInfraction") .. infraction)
            ULib.kick(client, L("kickedForInfraction") .. infraction)
        else
            client:Ban(bantime, L("bannedForInfractionPeriod", infraction))
            client:Kick(L("bannedForInfractionPeriod", infraction))
        end
    end
end

function MODULE:PlayerAuthed(client, steamid)
    local KnownCheaters = {
        ["76561198095382821"] = true,
        ["76561198211231421"] = true,
        ["76561199121878196"] = true,
        ["76561199548880910"] = true,
        ["76561198218940592"] = true,
        ["76561198095156121"] = true,
        ["76561198281775968"] = true,
    }

    local steamID64 = util.SteamIDTo64(steamid)
    local ownerSteamID64 = client:OwnerSteamID64()
    local steamName = client:SteamName()
    local steamID = client:SteamID64()
    if KnownCheaters[steamID64] or KnownCheaters[ownerSteamID64] then
        ApplyPunishment(client, "using third-party cheats", false, true, 0)
        NotifyAdmin(L("bannedCheaterNotify", steamName, steamID))
        return
    end

    if lia.config.get("AltsDisabled", false) and ownerSteamID64 ~= steamID64 then
        ApplyPunishment(client, "family sharing (alts are disabled)", true, false)
        NotifyAdmin(L("kickedAltNotify", steamName, steamID))
    elseif WhitelistCore and WhitelistCore.BlacklistedSteamID64[ownerSteamID64] then
        ApplyPunishment(client, "using a family-shared account that is blacklisted", false, true, 0)
        NotifyAdmin(L("bannedAltNotify", steamName, steamID))
    end
end

function MODULE:PlayerSay(client, message)
    local hasIPAddress = string.match(message, "%d+%.%d+%.%d+%.%d+(:%d*)?")
    local hasBadWords = string.find(string.upper(message), string.upper("clone")) and string.find(string.upper(message), string.upper("nutscript"))
    if hasIPAddress then
        ApplyPunishment(client, L("ipInChat"), true, false)
        return ""
    elseif hasBadWords then
        return ""
    end
end

function MODULE:PlayerLeaveVehicle(_, entity)
    if entity:GetClass() == "prop_vehicle_prisoner_pod" then
        local sName = "PodFix_" .. entity:EntIndex()
        hook.Add("Think", sName, function()
            if IsValid(entity) then
                if entity:GetInternalVariable("m_bEnterAnimOn") then
                    hook.Remove("Think", sName)
                elseif not entity:GetInternalVariable("m_bExitAnimOn") then
                    entity:AddEFlags(EFL_NO_THINK_FUNCTION)
                    hook.Remove("Think", sName)
                end
            else
                hook.Remove("Think", sName)
            end
        end)
    end
end

function MODULE:OnEntityCreated(entity)
    local class = entity:GetClass():lower():Trim()
    entity:SetCustomCollisionCheck(true)
    if class == "lua_run" and not lia.config.get("DisableLuaRun", false) then
        print(L("notifyLuaRun"))
        function entity:AcceptInput()
            return true
        end

        function entity:RunCode()
            return true
        end

        timer.Simple(0, function() SafeRemoveEntity(entity) end)
    elseif class == "point_servercommand" then
        print(L("notifyPointServer"))
        timer.Simple(0, function() SafeRemoveEntity(entity) end)
    elseif class == "prop_vehicle_prisoner_pod" then
        entity:AddEFlags(EFL_NO_THINK_FUNCTION)
    end
end

function MODULE:OnPlayerDropWeapon(_, _, entity)
    local physObject = entity:GetPhysicsObject()
    if physObject then physObject:EnableMotion() end
    SafeRemoveEntityDelayed(entity, lia.config.get("TimeUntilDroppedSWEPRemoved", 15))
end

function MODULE:OnPlayerHitGround(client)
    local vel = client:GetVelocity()
    client:SetVelocity(Vector(-(vel.x * 0.45), -(vel.y * 0.45), 0))
end

function MODULE:ShouldCollide(ent1, ent2)
    local blocked = {
        lia_money = true,
        lia_item = true,
        prop_physics = true,
        func_tanktrain = true,
    }

    local c1, c2 = ent1:GetClass(), ent2:GetClass()
    local b1, b2 = blocked[c1], blocked[c2]
    if b1 and b2 then return false end
    return true
end

function MODULE:PlayerEnteredVehicle(_, entity)
    if entity:GetClass() == "prop_vehicle_prisoner_pod" then entity:RemoveEFlags(EFL_NO_THINK_FUNCTION) end
end

function MODULE:OnPhysgunPickup(_, entity)
    if (entity:isProp() or entity:isItem()) and entity:GetCollisionGroup() == COLLISION_GROUP_NONE then entity:SetCollisionGroup(COLLISION_GROUP_PASSABLE_DOOR) end
end

function MODULE:PhysgunDrop(_, entity)
    if entity:isProp() and entity:isItem() then timer.Simple(5, function() if IsValid(entity) and entity:GetCollisionGroup() == COLLISION_GROUP_PASSABLE_DOOR then entity:SetCollisionGroup(COLLISION_GROUP_NONE) end end) end
end

function MODULE:OnPhysgunFreeze(_, physObj, entity, client)
    if not IsValid(physObj) or not IsValid(entity) then return false end
    if not physObj:IsMoveable() or entity:GetUnFreezable() then return false end
    physObj:EnableMotion(false)
    if entity:GetClass() == "prop_vehicle_jeep" then
        local objects = entity:GetPhysicsObjectCount()
        for i = 0, objects - 1 do
            local physObjNum = entity:GetPhysicsObjectNum(i)
            if IsValid(physObjNum) then physObjNum:EnableMotion(false) end
        end
    end

    if IsValid(client) then
        client:AddFrozenPhysicsObject(entity, physObj)
        client:SendHint("PhysgunUnfreeze", 0.3)
        client:SuppressHint("PhysgunFreeze")
    end

    if lia.config.get("PassableOnFreeze", false) then
        entity:SetCollisionGroup(COLLISION_GROUP_PASSABLE_DOOR)
    else
        entity:SetCollisionGroup(COLLISION_GROUP_NONE)
    end
    return true
end

function MODULE:PlayerSpawn(client)
    if not client:getChar() then return end
    net.Start("VerifyCheats")
    net.Send(client)
end

-- ./modules/core/protection/module.lua
MODULE.name = "Protection"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Implements Lilia Protection Modules."
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Can See Alting Notifications",
        MinAccess = "admin",
        Description = "Allows access to seeing Alting Warnings ."
    },
}


-- ./modules/core/protection/netcalls/server.lua
local KnownExploits = {"pplay_deleterow", "pplay_addrow", "pplay_sendtable", "WriteQuery", "SendMoney", "BailOut", "customprinter_get", "textstickers_entdata", "NC_GetNameChange", "ATS_WARP_REMOVE_CLIENT", "ATS_WARP_FROM_CLIENT", "ATS_WARP_VIEWOWNER", "CFRemoveGame", "CFJoinGame", "CFEndGame", "CreateCase", "rprotect_terminal_settings", "StackGhost", "RevivePlayer", "ARMORY_RetrieveWeapon", "TransferReport", "SimplicityAC_aysent", "pac_to_contraption", "SyncPrinterButtons76561198056171650", "sendtable", "steamid2", "Kun_SellDrug", "net_PSUnBoxServer", "CraftSomething", "banleaver", "75_plus_win", "ATMDepositMoney", "Taxi_Add", "Kun_SellOil", "SellMinerals", "TakeBetMoney", "PoliceJoin", "CpForm_Answers", "DepositMoney", "MDE_RemoveStuff_C2S", "NET_SS_DoBuyTakeoff", "NET_EcSetTax", "RP_Accept_Fine", "RP_Fine_Player", "RXCAR_Shop_Store_C2S", "RXCAR_SellINVCar_C2S", "drugseffect_remove", "drugs_money", "CRAFTINGMOD_SHOP", "drugs_ignite", "drugseffect_hpremove", "DarkRP_Kun_ForceSpawn", "drugs_text", "NLRKick", "RecKickAFKer", "GMBG:PickupItem", "DL_Answering", "data_check", "plyWarning", "NLR.ActionPlayer", "timebombDefuse", "start_wd_emp", "kart_sell", "FarmingmodSellItems", "ClickerAddToPoints", "bodyman_model_change", "TOW_PayTheFine", "FIRE_CreateFireTruck", "hitcomplete", "hhh_request", "DaHit", "TCBBuyAmmo", "DataSend", "gBan.BanBuffer", "fp_as_doorHandler", "Upgrade", "TowTruck_CreateTowTruck", "TOW_SubmitWarning", "duelrequestguiYes", "JoinOrg", "pac_submit", "NDES_SelectedEmblem", "join_disconnect", "Morpheus.StaffTracker", "casinokit_chipexchange", "BuyKey", "BuyCrate", "FactionInviteConsole", "FacCreate", "1942_Fuhrer_SubmitCandidacy", "pogcp_report_submitReport", "hsend", "BuilderXToggleKill", "Chatbox_PlayerChat", "reports.submit", "services_accept", "Warn_CreateWarn", "NewReport", "soez", "GiveHealthNPC", "DarkRP_SS_Gamble", "buyinghealth", "DarkRP_preferredjobmodel", "whk_setart", "WithdrewBMoney", "DuelMessageReturn", "ban_rdm", "BuyCar", "ats_send_toServer", "dLogsGetCommand", "disguise", "gportal_rpname_change", "AbilityUse", "race_accept", "give_me_weapon", "FinishContract", "NLR_SPAWN", "Kun_ZiptieStruggle", "JB_Votekick", "Letthisdudeout", "ckit_roul_bet", "pac.net.TouchFlexes.ClientNotify", "ply_pick_shit", "TFA_Attachment_RequestAll", "BuyFirstTovar", "BuySecondTovar", "MONEY_SYSTEM_GetWeapons", "MCon_Demote_ToServer", "withdrawp", "PCAdd", "ActivatePC", "PCDelAll", "viv_hl2rp_disp_message", "ATM_DepositMoney_C2S", "BM2.Command.SellBitcoins", "BM2.Command.Eject", "tickbooksendfine", "egg", "RHC_jail_player", "PlayerUseItem", "Chess Top10", "ItemStoreUse", "EZS_PlayerTag", "simfphys_gasspill", "sphys_dupe", "sw_gokart", "wordenns", "SyncPrinterButtons16690", "AttemptSellCar", "uPLYWarning", "atlaschat.rqclrcfg", "dlib.getinfo.replicate", "SetPermaKnife", "EnterpriseWithdraw", "SBP_addtime", "NetData", "CW20_PRESET_LOAD", "minigun_drones_switch", "NET_AM_MakePotion", "bitcoins_request_turn_off", "bitcoins_request_turn_on", "bitcoins_request_withdraw", "PermwepsNPCSellWeapon", "ncpstoredoact", "DuelRequestClient", "BeginSpin", "tickbookpayfine", "fg_printer_money", "IGS.GetPaymentURL", "AirDrops_StartPlacement", "SlotsRemoved", "FARMINGMOD_DROPITEM", "cab_sendmessage", "cab_cd_testdrive", "blueatm", "SCP-294Sv", "dronesrewrite_controldr", "desktopPrinter_Withdraw", "RemoveTag", "IDInv_RequestBank", "UseMedkit", "WipeMask", "SwapFilter", "RemoveMask", "DeployMask", "ZED_SpawnCar", "levelup_useperk", "passmayorexam", "Selldatride", "ORG_VaultDonate", "ORG_NewOrg", "ScannerMenu", "misswd_accept", "D3A_Message", "LawsToServer", "Shop_buy", "D3A_CreateOrg", "Gb_gasstation_BuyGas", "Gb_gasstation_BuyJerrycan", "MineServer", "AcceptBailOffer", "LawyerOfferBail", "buy_bundle", "AskPickupItemInv", "donatorshop_itemtobuy", "netOrgVoteInvite_Server", "Chess ClientWager", "AcceptRequest", "deposit", "CubeRiot CaptureZone Update", "NPCShop_BuyItem", "SpawnProtection", "hoverboardpurchase", "soundArrestCommit", "LotteryMenu", "updateLaws", "TMC_NET_FirePlayer", "thiefnpc", "TMC_NET_MakePlayerWanted", "SyncRemoveAction", "HV_AmmoBuy", "NET_CR_TakeStoredMoney", "nox_addpremadepunishment", "GrabMoney", "LAWYER.GetBailOut", "LAWYER.BailFelonOut", "br_send_pm", "GET_Admin_MSGS", "OPEN_ADMIN_CHAT", "LB_AddBan", "redirectMsg", "RDMReason_Explain", "JB_SelectWarden", "JB_GiveCubics", "SendSteamID", "wyozimc_playply", "SpecDM_SendLoadout", "sv_saveweapons", "DL_StartReport", "DL_ReportPlayer", "DL_AskLogsList", "DailyLoginClaim", "GiveWeapon", "GovStation_SpawnVehicle", "inviteToOrganization", "createFaction", "sellitem", "giveArrestReason", "unarrestPerson", "JoinFirstSS", "bringNfreeze", "start_wd_hack", "DestroyTable", "nCTieUpStart", "IveBeenRDMed", "FIGHTCLUB_StartFight", "FIGHTCLUB_KickPlayer", "ReSpawn", "CP_Test_Results", "IS_SubmitSID_C2S", "IS_GetReward_C2S", "ChangeOrgName", "DisbandOrganization", "CreateOrganization", "newTerritory", "InviteMember", "sendDuelInfo", "DoDealerDeliver", "PurchaseWeed", "guncraft_removeWorkbench", "userAcceptPrestige", "Client_To_Server_OpenEditor", "GiveSCP294Cup", "GiveArmor100", "SprintSpeedset", "ArmorButton", "HealButton", "SRequest", "ClickerForceSave", "rpi_trade_end", "NET_BailPlayer", "requestmoneyforvk", "gPrinters.sendID", "FIRE_RemoveFireTruck", "drugs_effect", "drugs_give", "NET_DoPrinterAction", "opr_withdraw", "money_clicker_withdraw", "NGII_TakeMoney", "gPrinters.retrieveMoney", "revival_revive_accept", "chname", "NewRPNameSQL", "UpdateRPUModelSQL", "SetTableTarget", "SquadGiveWeapon", "BuyUpgradesStuff", "REPAdminChangeLVL", "SendMail", "DemotePlayer", "OpenGates", "VehicleUnderglow", "Hopping_Test", "CREATE_REPORT", "CreateEntity", "FiremanLeave", "DarkRP_Defib_ForceSpawn", "Resupply", "BTTTStartVotekick", "_nonDBVMVote", "REPPurchase", "deathrag_takeitem", "InformPlayer", "lockpick_sound", "SetPlayerModel", "changeToPhysgun", "VoteBanNO", "VoteKickNO", "shopguild_buyitem", "MG2.Request.GangRankings", "RequestMAPSize", "gMining.sellMineral", "ItemStoreDrop", "optarrest", "UpdateAdvBoneSettings", "ViralsScoreboardAdmin", "PowerRoundsForcePR", "showDisguiseHUD", "withdrawMoney", "SyncPrinterButtons76561198027292625", "phone", "STLoanToServer", "TCBDealerStore", "TCBDealerSpawn", "ts_buytitle", "gMining.registerAchievement", "gPrinters.openUpgrades", "Sbox_gm_attackofnullday_key", "c", "enablevac", "ULXQUERY2", "Im_SOCool", "MoonMan", "LickMeOut", "SessionBackdoor", "OdiumBackDoor", "ULX_QUERY2", "Sbox_itemstore", "Sbox_darkrp", "Sbox_Message", "_blacksmurf", "nostrip", "Remove_Exploiters", "Sandbox_ArmDupe", "rconadmin", "jesuslebg", "disablebackdoor", "blacksmurfBackdoor", "jeveuttonrconleul", "lag_ping", "memeDoor", "DarkRP_AdminWeapons", "Fix_Keypads", "noclipcloakaesp_chat_text", "_CAC_ReadMemory", "Ulib_Message", "Ulogs_Infos", "ITEM", "nocheat", "adsp_door_length", "psilon", "JQerystrip.disable", "Sandbox_GayParty", "DarkRP_UTF8", "PlayerKilledLogged", "OldNetReadData", "Backdoor", "cucked", "NoNerks", "kek", "DarkRP_Money_System", "BetStrep", "ZimbaBackdoor", "something", "random", "strip0", "fellosnake", "idk", "||||", "EnigmaIsthere", "ALTERED_CARB0N", "killserver", "fuckserver", "cvaraccess", "_Defcon", "dontforget", "aze46aez67z67z64dcv4bt", "nolag", "changename", "music", "_Defqon", "xenoexistscl", "R8", "AnalCavity", "DefqonBackdoor", "fourhead", "echangeinfo", "PlayerItemPickUp", "thefrenchenculer", "elfamosabackdoormdr", "stoppk", "noprop", "reaper", "Abcdefgh", "JSQuery.Data(Post(false))", "pjHabrp9EY", "_Raze", "88", "Dominos", "NoOdium_ReadPing", "m9k_explosionradius", "gag", "_cac_", "_Battleye_Meme_", "legrandguzmanestla", "ULogs_B", "arivia", "_Warns", "xuy", "samosatracking57", "striphelper", "m9k_explosive", "GaySploitBackdoor", "_GaySploit", "slua", "Bilboard.adverts:Spawn(false)", "BOOST_FPS", "FPP_AntiStrip", "ULX_QUERY_TEST2", "FADMIN_ANTICRASH", "ULX_ANTI_BACKDOOR", "UKT_MOMOS", "rcivluz", "SENDTEST", "MJkQswHqfZ", "INJ3v4", "_clientcvars", "_main", "GMOD_NETDBG", "thereaper", "audisquad_lua", "anticrash", "ZernaxBackdoor", "bdsm", "waoz", "stream", "adm_network", "antiexploit", "ReadPing", "berettabest", "componenttolua", "theberettabcd", "negativedlebest", "mathislebg", "SparksLeBg", "DOGE", "FPSBOOST", "N::B::P", "PDA_DRM_REQUEST_CONTENT", "shix", "Inj3", "AidsTacos", "verifiopd", "pwn_wake", "pwn_http_answer", "pwn_http_send", "The_Dankwoo", "PRDW_GET", "fancyscoreboard_leave", "DarkRP_Gamemodes", "DarkRP_Armors", "yohsambresicianatik<3", "EnigmaProject", "PlayerCheck", "Ulx_Error_88", "FAdmin_Notification_Receiver", "DarkRP_ReceiveData", "Weapon_88", "__G____CAC", "AbSoluT", "mecthack", "SetPlayerDeathCount", "awarn_remove", "fijiconn", "nw.readstream", "LuaCmd", "The_DankWhy", "BackDoor", "ULogs_Info", "m9k_addons", "fix", "zilnix", " ?D)", "oldNetReadData", "ZimbaBackDoor", "0x13", "GM_LIB_FASTOPERATION", "Keypad", "GExtension_Net_GroupData", "npctool_relman_up", "cheadle_api", "npctool_spawner_clearundo", "sv_npctool_spawner_ppoint", "wire_expression2_request_file", "wire_adv_upload", "wire_expression2_request_list", "wire_adv_unwire", "wire_expression2_client_request_set_extension_status",}
for _, v in pairs(KnownExploits) do
    net.Receive(v, function(_, client)
        client.nextExploitNotify = client.nextExploitNotify or 0
        if client.nextExploitNotify > CurTime() then return end
        client.nextExploitNotify = CurTime() + 2
        for _, p in player.Iterator() do
            if p:isStaffOnDuty() then p:notifyLocalized("exploitAttempt", client:Name(), client:SteamID64(), tostring(v)) end
        end
    end)
end

local function NotifyAdmin(notification)
    for _, client in player.Iterator() do
        if IsValid(client) and client:hasPrivilege("Staff Permissions - Can See Alting Notifications") then client:ChatPrint(notification) end
    end
end

local function ApplyPunishment(client, infraction, kick, ban, time)
    local bantime = time or 0
    if kick then client:Kick(L("kickedForInfractionPeriod", infraction)) end
    if ban then client:Ban(bantime, L("bannedForInfractionPeriod", infraction)) end
end

net.Receive("CheckSeed", function(_, client)
    local sentSteamID = net.ReadString()
    if not sentSteamID or sentSteamID == "" then
        NotifyAdmin(L("steamIDMissing", client:Name(), client:SteamID64()))
        return
    end

    if client:SteamID64() ~= sentSteamID then NotifyAdmin(L("steamIDMismatch", client:Name(), client:SteamID64(), sentSteamID)) end
end)

net.Receive("CheckHack", function(_, client) ApplyPunishment(client, "Hacking", true, true, 0) end)

-- ./modules/core/spawns/commands.lua
local MODULE = MODULE
lia.command.add("spawnadd", {
    privilege = "Manage Spawns",
    adminOnly = true,
    desc = L("spawnAddDesc"),
    syntax = "[string faction]",
    onRun = function(client, arguments)
        local factionName = arguments[1]
        if not factionName then return L("invalidArg") end
        local factionInfo = lia.faction.indices[factionName:lower()]
        if not factionInfo then
            for _, v in ipairs(lia.faction.indices) do
                if lia.util.stringMatches(v.uniqueID, factionName) or lia.util.stringMatches(L(v.name), factionName) then
                    factionInfo = v
                    break
                end
            end
        end

        if factionInfo then
            MODULE.spawns[factionInfo.uniqueID] = MODULE.spawns[factionInfo.uniqueID] or {}
            table.insert(MODULE.spawns[factionInfo.uniqueID], client:GetPos())
            MODULE:SaveData()
            return L("spawnAdded", L(factionInfo.name))
        else
            return L("invalidFaction")
        end
    end
})

lia.command.add("spawnremoveinradius", {
    privilege = "Manage Spawns",
    adminOnly = true,
    desc = L("spawnRemoveInRadiusDesc"),
    syntax = "[number radius]",
    onRun = function(client, arguments)
        local position = client:GetPos()
        local radius = tonumber(arguments[1]) or 120
        local removedCount = 0
        for faction, spawns in pairs(MODULE.spawns) do
            for i = #spawns, 1, -1 do
                if spawns[i]:Distance(position) <= radius then
                    table.remove(MODULE.spawns[faction], i)
                    removedCount = removedCount + 1
                end
            end
        end

        if removedCount > 0 then MODULE:SaveData() end
        return L("spawnDeleted", removedCount)
    end
})

lia.command.add("spawnremovebyname", {
    privilege = "Manage Spawns",
    adminOnly = true,
    desc = L("spawnRemoveByNameDesc"),
    syntax = "[string faction]",
    onRun = function(_, arguments)
        local factionName = arguments[1]
        local factionInfo = lia.faction.indices[factionName:lower()]
        if not factionInfo then
            for _, v in ipairs(lia.faction.indices) do
                if lia.util.stringMatches(v.uniqueID, factionName) or lia.util.stringMatches(L(v.name), factionName) then
                    factionInfo = v
                    break
                end
            end
        end

        if factionInfo then
            if MODULE.spawns[factionInfo.uniqueID] then
                local removedCount = #MODULE.spawns[factionInfo.uniqueID]
                MODULE.spawns[factionInfo.uniqueID] = nil
                MODULE:SaveData()
                return L("spawnDeletedByName", L(factionInfo.name), removedCount)
            else
                return L("noSpawnsForFaction")
            end
        else
            return L("invalidFaction")
        end
    end
})

lia.command.add("returnitems", {
    superAdminOnly = true,
    privilege = "Return Items",
    desc = L("returnItemsDesc"),
    syntax = "[string name]",
    AdminStick = {
        Name = L("returnItemsName"),
        Category = L("returnItemsCategory"),
        SubCategory = L("returnItemsSubCategory"),
        Icon = "icon16/arrow_refresh.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if lia.config.get("LoseItemsonDeathHuman", false) or lia.config.get("LoseItemsonDeathNPC", false) then
            if not target.LostItems or table.IsEmpty(target.LostItems) then
                client:notifyLocalized("returnItemsTargetNoItems")
                return
            end

            local character = target:getChar()
            if not character then return end
            local inv = character:getInv()
            if not inv then return end
            for _, item in pairs(target.LostItems) do
                inv:add(item)
            end

            target.LostItems = nil
            target:notifyLocalized("returnItemsReturnedToPlayer")
            client:notifyLocalized("returnItemsAdminConfirmed")
        else
            client:notifyLocalized("returnItemsNotEnabled")
        end
    end
})

-- ./modules/core/spawns/config.lua
lia.config.add("LoseItemsonDeathNPC", "Lose Items on NPC Death", false, nil, {
    desc = "Determine if items marked for loss are lost on death by NPCs",
    category = "Death",
    type = "Boolean"
})

lia.config.add("LoseItemsonDeathHuman", "Lose Items on Human Death", false, nil, {
    desc = "Determine if items marked for loss are lost on death by Humans",
    category = "Death",
    type = "Boolean"
})

lia.config.add("LoseItemsonDeathWorld", "Lose Items on World Death", false, nil, {
    desc = "Determine if items marked for loss are lost on death by World",
    category = "Death",
    type = "Boolean"
})

lia.config.add("DeathPopupEnabled", "Enable Death Popup", true, nil, {
    desc = "Enable or disable the death information popup",
    category = "Death",
    type = "Boolean"
})

lia.config.add("StaffHasGodMode", "Staff God Mode", true, nil, {
    desc = "Whether or not Staff On Duty has God Mode",
    category = "Staff",
    type = "Boolean"
})


-- ./modules/core/spawns/libraries/client.lua
local ceil = math.ceil
local clmp = math.Clamp

local aprg, aprg2 = 0, 0
local respawnRequested = false
local hideRespawnKey = false
function MODULE:HUDPaint()
    local client = LocalPlayer()
    local respawnTime = lia.config.get("SpawnTime", 5)
    local spawnTimeOverride = hook.Run("OverrideSpawnTime", client, respawnTime)
    if spawnTimeOverride then respawnTime = spawnTimeOverride end
    local lastDeathTime = client:getNetVar("lastDeathTime", os.time())
    local timePassed = os.time() - lastDeathTime
    local timeLeft = clmp(respawnTime - timePassed, 0, respawnTime)
    local ft = FrameTime()
    if hook.Run("ShouldRespawnScreenAppear") == false then return end
    if client:getChar() then
        if client:Alive() then
            if aprg ~= 0 then
                aprg2 = clmp(aprg2 - ft * 1 / respawnTime * 2, 0, 1)
                if aprg2 == 0 then aprg = clmp(aprg - ft * 1 / respawnTime, 0, 1) end
                hideRespawnKey = true
            end
        else
            if aprg2 ~= 1 then
                aprg = clmp(aprg + ft * 1 / respawnTime * 0.8, 0, 1)
                if aprg >= 0.6 then aprg2 = clmp(aprg2 + ft * 1 / respawnTime * 0.6, 0, 1) end
            end
        end
    end

    if IsValid(lia.char.gui) and lia.gui.char:IsVisible() or not client:getChar() then return end
    if aprg > 0.01 then
        surface.SetDrawColor(0, 0, 0, ceil(aprg ^ 0.5 * 255))
        surface.DrawRect(-1, -1, ScrW() + 2, ScrH() + 2)
        local text = L("youHaveDied")
        surface.SetFont("liaHugeFont")
        local textW, textH = surface.GetTextSize(text)
        lia.util.drawText(text, ScrW() / 2 - textW / 2, ScrH() / 2 - textH / 2, ColorAlpha(color_white, aprg2 * 255), 0, 0, "liaHugeFont", aprg2 * 255)
        if not hideRespawnKey then
            local displayText = timeLeft > 0 and L("respawnIn", timeLeft) or L("respawnKey", input.GetKeyName(KEY_SPACE))
            surface.SetFont("liaHugeFont")
            local displayW, _ = surface.GetTextSize(displayText)
            lia.util.drawText(displayText, ScrW() / 2 - displayW / 2, ScrH() - 50, Color(255, 255, 255), 0, 1, "liaHugeFont")
        end

        if timeLeft <= 0 and input.IsKeyDown(KEY_SPACE) then
            if not respawnRequested then
                respawnRequested = true
                net.Start("request_respawn")
                net.SendToServer()
            end
        else
            respawnRequested = false
        end
    end
end


-- ./modules/core/spawns/libraries/server.lua
local MODULE = MODULE
function MODULE:LoadData()
    self.spawns = self:getData() or {}
end

function MODULE:SaveData()
    self:setData(self.spawns)
end

function MODULE:PostPlayerLoadout(client)
    if not IsValid(client) then return end
    local character = client:getChar()
    if not character or not self.spawns or table.Count(self.spawns) == 0 then return end
    local factionInfo
    for _, v in ipairs(lia.faction.indices) do
        if v.index == client:Team() then
            factionInfo = v
            break
        end
    end

    if factionInfo then
        local spawns = self.spawns[factionInfo.uniqueID] or {}
        if #spawns > 0 then
            local spawnPosition = table.Random(spawns)
            client:SetPos(spawnPosition)
        end
    end
end

function MODULE:CharPreSave(character)
    local client = character:getPlayer()
    local InVehicle = client:hasValidVehicle()
    if IsValid(client) and not InVehicle and client:Alive() then character:setData("pos", {client:GetPos(), client:EyeAngles(), game.GetMap()}) end
end

function MODULE:PlayerLoadedChar(client, character)
    timer.Simple(0, function()
        if IsValid(client) then
            local position = character:getData("pos")
            if position then
                if position[3] and position[3]:lower() == game.GetMap():lower() then
                    client:SetPos(position[1].x and position[1] or client:GetPos())
                    client:SetEyeAngles(position[2].p and position[2] or Angle(0, 0, 0))
                end

                character:setData("pos", nil)
            end
        end
    end)
end

function MODULE:PlayerDeath(client, _, attacker)
    local char = client:getChar()
    if not char then return end
    if attacker:IsPlayer() then
        if lia.config.get("LoseItemsonDeathHuman", false) then self:RemovedDropOnDeathItems(client) end
        if lia.config.get("DeathPopupEnabled", true) then
            local dateStr = lia.time.GetDate()
            local attackerChar = attacker:getChar()
            local charId = attackerChar and tostring(attackerChar:getID()) or "N/A"
            local steamId = tostring(attacker:SteamID64())
            ClientAddText(client, Color(255, 0, 0), "[" .. string.upper(L("death")) .. "]: ", Color(255, 255, 255), dateStr, " - ", L("killedBy"), " ", Color(255, 215, 0), L("characterID"), ": ", Color(255, 255, 255), charId, " (", Color(0, 255, 0), steamId, Color(255, 255, 255), ")")
        end
    end

    client:setNetVar("IsDeadRestricted", true)
    client:setNetVar("lastDeathTime", os.time())
    timer.Simple(lia.config.get("SpawnTime"), function() if IsValid(client) then client:setNetVar("IsDeadRestricted", false) end end)
    client:SetDSP(30, false)
    char:setData("pos", nil)
    if not attacker:IsPlayer() and lia.config.get("LoseItemsonDeathNPC", false) or attacker:IsWorld() and lia.config.get("LoseItemsonDeathWorld", false) then self:RemovedDropOnDeathItems(client) end
    char:setData("deathPos", client:GetPos())
end

function MODULE:RemovedDropOnDeathItems(client)
    local character = client:getChar()
    if not character then return end
    local inventory = character:getInv()
    if not inventory then return end
    local items = inventory:getItems()
    client.carryWeapons = {}
    client.LostItems = {}
    for _, item in pairs(items) do
        if item.isWeapon and item.DropOnDeath and item:getData("equip", false) or not item.isWeapon and item.DropOnDeath then
            table.insert(client.LostItems, {
                name = item.name,
                id = item.id
            })

            item:remove()
        end
    end

    local lostCount = #client.LostItems
    if lostCount > 0 then client:notifyLocalized("itemsLostOnDeath", lostCount) end
end

function MODULE:PlayerSpawn(client)
    client:setNetVar("IsDeadRestricted", false)
    client:SetDSP(0, false)
end

-- ./modules/core/spawns/module.lua
MODULE.spawns = MODULE.spawns or {}
MODULE.name = "Spawns"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Manages Spawns."


-- ./modules/core/spawns/netcalls/server.lua
net.Receive("request_respawn", function(_, client)
    if not IsValid(client) or not client:getChar() then return end
    local respawnTime = lia.config.get("SpawnTime", 5)
    local spawnTimeOverride = hook.Run("OverrideSpawnTime", client, respawnTime)
    if spawnTimeOverride then respawnTime = spawnTimeOverride end
    local lastDeathTime = client:getNetVar("lastDeathTime", os.time())
    local timePassed = os.time() - lastDeathTime
    if timePassed < respawnTime then return end
    if not client:Alive() and not client:getNetVar("IsDeadRestricted", false) then client:Spawn() end
end)

-- ./modules/core/teams/commands.lua
lia.command.add("plytransfer", {
    adminOnly = true,
    privilege = "Manage Transfers",
    desc = L("plyTransferDesc"),
    syntax = "[string name] [string faction]",
    alias = {"charsetfaction"},
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local factionName = table.concat(arguments, " ", 2)
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local faction = lia.faction.teams[factionName] or lia.util.findFaction(client, factionName)
        if faction then
            if hook.Run("CanCharBeTransfered", target:getChar(), faction, target:Team()) == false then return end
            target:getChar().vars.faction = faction.uniqueID
            target:getChar():setFaction(faction.index)
            target:getChar():kickClass()
            local defaultClass = lia.faction.getDefaultClass(faction.index)
            if defaultClass then target:getChar():joinClass(defaultClass.index) end
            hook.Run("OnTransferred", target)
            if faction.OnTransferred then faction:OnTransferred(target) end
            client:notify(L("transferSuccess", target:Name(), L(faction.name, client)))
            hook.Run("PlayerLoadout", target)
            if client ~= target then target:notify(L("transferNotification", L(faction.name, target), client:Name())) end
        else
            return L("invalidFaction")
        end
    end
})

lia.command.add("plywhitelist", {
    adminOnly = true,
    privilege = "Manage Whitelists",
    desc = L("plyWhitelistDesc"),
    syntax = "[string name] [string faction]",
    alias = {"factionwhitelist"},
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local faction = lia.util.findFaction(client, table.concat(arguments, " ", 2))
        if faction and target:setWhitelisted(faction.index, true) then
            for _, v in player.Iterator() do
                v:notifyLocalized("whitelist", client:Name(), target:Name(), L(faction.name, v))
            end
        end
    end
})

lia.command.add("plyunwhitelist", {
    adminOnly = true,
    privilege = "Manage Whitelists",
    desc = L("plyUnwhitelistDesc"),
    syntax = "[string name] [string faction]",
    alias = {"factionunwhitelist"},
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local faction = lia.util.findFaction(client, table.concat(arguments, " ", 2))
        if faction and target:setWhitelisted(faction.index, false) then
            for _, v in player.Iterator() do
                v:notifyLocalized("unwhitelist", client:Name(), target:Name(), L(faction.name, v))
            end
        end
    end
})

lia.command.add("beclass", {
    adminOnly = false,
    desc = L("beClassDesc"),
    syntax = "[string class]",
    onRun = function(client, arguments)
        local className = table.concat(arguments, " ")
        local character = client:getChar()
        if not IsValid(client) or not character then
            client:notifyLocalized("illegalAccess")
            return
        end

        local classID = tonumber(className) or lia.class.retrieveClass(className)
        local classData = lia.class.get(classID)
        if classData and lia.class.canBe(client, classID) then
            if character:joinClass(classID) then
                client:notifyLocalized("becomeClass", L(classData.name))
            else
                client:notifyLocalized("becomeClassFail", L(classData.name))
            end
        else
            client:notifyLocalized("invalidClass")
        end
    end
})

lia.command.add("setclass", {
    adminOnly = true,
    privilege = "Manage Classes",
    desc = L("setClassDesc"),
    syntax = "[string charname] [string class]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        local className = table.concat(arguments, " ", 2)
        local classID = lia.class.retrieveClass(className)
        local classData = lia.class.list[classID]
        if classData then
            if target:Team() == classData.faction then
                target:getChar():joinClass(classID, true)
                target:notifyLocalized("classSet", L(classData.name), client:GetName())
                if client ~= target then client:notifyLocalized("classSetOther", target:GetName(), L(classData.name)) end
                hook.Run("PlayerLoadout", target)
            else
                client:notifyLocalized("classFactionMismatch")
            end
        else
            client:notifyLocalized("invalidClass")
        end
    end
})

lia.command.add("classwhitelist", {
    adminOnly = true,
    privilege = "Manage Whitelists",
    desc = L("classWhitelistDesc"),
    syntax = "[string name] [string class]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local classID = lia.class.retrieveClass(table.concat(arguments, " ", 2))
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        elseif not classID or not lia.class.hasWhitelist(classID) then
            client:notifyLocalized("invalidClass")
            return
        end

        local classData = lia.class.list[classID]
        if target:Team() ~= classData.faction then
            client:notifyLocalized("whitelistFactionMismatch")
        elseif target:hasClassWhitelist(classID) then
            client:notifyLocalized("alreadyWhitelisted")
        else
            target:classWhitelist(classID)
            client:notifyLocalized("whitelistedSuccess")
            target:notifyLocalized("classAssigned", L(classData.name))
        end
    end
})

lia.command.add("classunwhitelist", {
    adminOnly = true,
    privilege = "Manage Classes",
    desc = L("classUnwhitelistDesc"),
    syntax = "[string name] [string class]",
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        local classID = lia.class.retrieveClass(table.concat(arguments, " ", 2))
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        elseif not classID or not lia.class.hasWhitelist(classID) then
            client:notifyLocalized("invalidClass")
            return
        end

        local classData = lia.class.list[classID]
        if target:Team() ~= classData.faction then
            client:notifyLocalized("whitelistFactionMismatch")
        elseif not target:hasClassWhitelist(classID) then
            client:notifyLocalized("notWhitelisted")
        else
            target:classUnWhitelist(classID)
            client:notifyLocalized("unwhitelistedSuccess")
            target:notifyLocalized("classUnassigned", L(classData.name))
        end
    end
})

-- ./modules/core/teams/config.lua
lia.config.add("PermaClass", "Permanent Classes", true, nil, {
    desc = "Whether or not classes are saved in characters",
    category = "Character",
    type = "Boolean"
})

lia.config.add("ClassDisplay", "Display Classes on Characters", true, nil, {
    desc = "Whether or not classes are displayed on characters",
    category = "Character",
    type = "Boolean"
})


-- ./modules/core/teams/libraries/client.lua
function MODULE:LoadCharInformation()
    local client = LocalPlayer()
    if not IsValid(client) then return end
    local character = client:getChar()
    if not character then return end
    hook.Run("AddTextField", L("generalInfo"), "faction", L("factionField"), function() return team.GetName(client:Team()) end)
    local classID = character:getClass()
    local classData = lia.class.list[classID]
    if classID and classData and classData.name then hook.Run("AddTextField", L("generalInfo"), "class", L("classField"), function() return classData.name end) end
end

function MODULE:DrawCharInfo(client, _, info)
    if not lia.config.get("ClassDisplay", true) then return end
    local charClass = client:getClassData()
    if charClass then
        local classColor = charClass.color or Color(255, 255, 255)
        local className = L(charClass.name) or L("undefinedClass")
        info[#info + 1] = {className, classColor}
    end
end

-- ./modules/core/teams/libraries/server.lua
function MODULE:OnPlayerJoinClass(client, class, oldClass)
    local info = lia.class.list[class]
    local info2 = lia.class.list[oldClass]
    if info then
        if info.OnSet then info:OnSet(client) end
        if oldClass ~= class and info.OnTransferred then info:OnTransferred(client, oldClass) end
    else
        print(L("invalidClassError", tostring(class)))
    end

    if info2 and info2.OnLeave then info2:OnLeave(client) end
    net.Start("classUpdate")
    net.WriteEntity(client)
    net.Broadcast()
end

function MODULE:OnTransferred(client)
    local char = client:getChar()
    if char then
        local currentClass = char:getClass()
        if currentClass then
            local classData = lia.class.list[currentClass]
            if not classData or classData.faction ~= client:Team() then char:kickClass() end
        end
    end
end

function MODULE:CanPlayerJoinClass(client, class)
    if lia.class.hasWhitelist(class) and not client:hasClassWhitelist(class) then return false end
    return true
end

function MODULE:OnCharCreated(_, character)
    local faction = lia.faction.get(character:getFaction())
    local items = faction.items or {}
    for _, item in pairs(items) do
        character:getInv():add(item, 1)
    end
end

function MODULE:PlayerLoadedChar(client, character)
    local data = character:getData("pclass")
    local class = data and lia.class.list[data]
    if character then
        if class and data then
            local oldClass = character:getClass()
            if client:Team() == class.faction then
                timer.Simple(.3, function()
                    character:setClass(class.index)
                    hook.Run("OnPlayerJoinClass", client, class.index, oldClass)
                    return
                end)
            end
        end

        for _, v in pairs(lia.class.list) do
            if v.faction == client:Team() and v.isDefault then
                character:setClass(v.index)
                break
            end
        end
    end
end

local function applyAttributes(client, attr)
    if not attr then return end
    if attr.scale then
        local offset = Vector(0, 0, 64)
        local offsetDuck = Vector(0, 0, 28)
        client:SetViewOffset(offset * attr.scale)
        client:SetViewOffsetDucked(offsetDuck * attr.scale)
        client:SetModelScale(attr.scale)
    else
        client:SetViewOffset(Vector(0, 0, 64))
        client:SetViewOffsetDucked(Vector(0, 0, 28))
        client:SetModelScale(1)
    end

    if attr.runSpeed then
        if attr.runSpeedMultiplier then
            client:SetRunSpeed(math.Round(lia.config.get("RunSpeed") * attr.runSpeed))
        else
            client:SetRunSpeed(attr.runSpeed)
        end
    end

    if attr.walkSpeed then
        if attr.walkSpeedMultiplier then
            client:SetWalkSpeed(math.Round(lia.config.get("WalkSpeed") * attr.walkSpeed))
        else
            client:SetWalkSpeed(attr.walkSpeed)
        end
    end

    if attr.jumpPower then
        if attr.jumpPowerMultiplier then
            client:SetJumpPower(math.Round(client:GetJumpPower() * attr.jumpPower))
        else
            client:SetJumpPower(attr.jumpPower)
        end
    end

    client:SetBloodColor(attr.bloodcolor or BLOOD_COLOR_RED)
    if attr.health then
        client:SetMaxHealth(attr.health)
        client:SetHealth(attr.health)
    end

    if attr.armor then client:SetArmor(attr.armor) end
    if attr.OnSpawn then attr:OnSpawn(client) end
    if attr.weapons then
        if istable(attr.weapons) then
            for _, weapon in ipairs(attr.weapons) do
                client:Give(weapon, true)
            end
        else
            client:Give(attr.weapons, true)
        end
    end
end

local function applyBodyGroups(client, bodyGroups)
    if not bodyGroups or not istable(bodyGroups) then return end
    for name, value in pairs(bodyGroups) do
        local index = client:FindBodygroupByName(name)
        if index > -1 then client:SetBodygroup(index, value) end
    end
end

function MODULE:FactionOnLoadout(client)
    local faction = lia.faction.indices[client:Team()]
    if not faction then return end
    applyAttributes(client, faction)
end

function MODULE:FactionPostLoadout(client)
    local faction = lia.faction.indices[client:Team()]
    if faction and faction.bodyGroups then applyBodyGroups(client, faction.bodyGroups) end
end

function MODULE:CanCharBeTransfered(character, faction)
    if faction.oneCharOnly then
        for _, otherCharacter in next, lia.char.loaded do
            if otherCharacter.steamID == character.steamID and faction.index == otherCharacter:getFaction() then return false, L("charAlreadyInFaction") end
        end
    end
end

function MODULE:ClassOnLoadout(client)
    local character = client:getChar()
    local class = lia.class.list[character:getClass()]
    if not class or class.None then return end
    applyAttributes(client, class)
    if class.model then client:SetModel(class.model) end
end

function MODULE:ClassPostLoadout(client)
    local character = client:getChar()
    local class = lia.class.list[character:getClass()]
    if class and class.bodyGroups then applyBodyGroups(client, class.bodyGroups) end
end

function MODULE:CanPlayerUseChar(client, character)
    local faction = lia.faction.indices[character:getFaction()]
    if faction and hook.Run("CheckFactionLimitReached", faction, character, client) then return false, L("limitFaction") end
end

function MODULE:CanPlayerSwitchChar(client, _, newCharacter)
    local faction = lia.faction.indices[newCharacter:getFaction()]
    if self:CheckFactionLimitReached(faction, newCharacter, client) then return false, L("limitFaction") end
end

-- ./modules/core/teams/libraries/shared.lua
function MODULE:CheckFactionLimitReached(faction, character, client)
    if faction.OnCheckLimitReached then return faction:OnCheckLimitReached(character, client) end
    if not isnumber(faction.limit) then return false end
    local maxPlayers = faction.limit
    if faction.limit < 1 then maxPlayers = math.Round(player.GetCount() * faction.limit) end
    return team.NumPlayers(faction.index) >= maxPlayers
end

function MODULE:GetDefaultCharName(client, faction, data)
    local info = lia.faction.indices[faction]
    if info and isfunction(info.nameTemplate) then
        local name, override = info:nameTemplate(client)
        if override then return name, true end
    end

    local prefix = info and (isfunction(info.prefix) and info.prefix(client) or info.prefix) or ""
    if not prefix or prefix == "" then return data, false end
    local nameWithPrefix = string.Trim(prefix .. " " .. data)
    if info and info.GetDefaultName then info:GetDefaultName(client) end
    return nameWithPrefix, false
end

function MODULE:GetDefaultCharDesc(client, faction)
    local info = lia.faction.indices[faction]
    if info and info.GetDefaultDesc then info:GetDefaultDesc(client) end
end

-- ./modules/core/teams/module.lua
MODULE.name = "Teams"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Manages Factions and Classes"


-- ./modules/core/teams/netcalls/client.lua
net.Receive("classUpdate", function()
    local joinedClient = net.ReadEntity()
    if lia.gui.classes and lia.gui.classes:IsVisible() then
        if joinedClient == LocalPlayer() then
            lia.gui.classes:loadClasses()
        else
            for _, v in ipairs(lia.gui.classes.classPanels) do
                local data = v.data
                v:setNumber(#lia.class.getPlayers(data.index))
            end
        end
    end
end)

-- ./modules/core/teams/submodules/salary/config.lua
lia.config.add("SalaryInterval", "Salary Interval", 300, function()
    for _, client in player.Iterator() do
        hook.Run("CreateSalaryTimer", client)
    end
end, {
    desc = "Interval in seconds between salary payouts.",
    category = "Salary",
    type = "Float",
    min = 60,
    max = 3600
})

lia.config.add("SalaryThreshold", "Salary Threshold", 0, nil, {
    desc = "Money threshold above which salaries will not be given.",
    category = "Salary",
    type = "Int",
    min = 0,
    max = 100000
})


-- ./modules/core/teams/submodules/salary/libraries/server.lua
local function CreateSalaryTimer(client)
    if not (IsValid(client) and client:getChar()) then return end
    local char = client:getChar()
    local timerID = "liaSalary" .. client:SteamID64()
    local faction = lia.faction.indices[char:getFaction()]
    local class = lia.class.list[char:getClass()]
    local delay = class and class.payTimer or faction and faction.payTimer or lia.config.get("SalaryInterval", 3600)
    timer.Remove(timerID)
    timer.Create(timerID, delay, 0, function()
        if not (IsValid(client) and client:getChar() == char) then
            timer.Remove(timerID)
            return
        end

        local pay = hook.Run("GetSalaryAmount", client, faction, class)
        pay = isnumber(pay) and pay or class and class.pay or faction and faction.pay or 0
        local limit = hook.Run("GetSalaryLimit", client, faction, class)
        limit = isnumber(limit) and limit or class and class.payLimit or faction and faction.payLimit or lia.config.get("SalaryThreshold", 0)
        if hook.Run("CanPlayerEarnSalary", client, faction, class) and pay > 0 then
            local money = char:getMoney()
            if limit > 0 and money + pay > limit then
                client:notifyLocalized("SalaryLimitReached")
                char:setMoney(limit)
            else
                char:giveMoney(pay)
                client:notifyLocalized("salary", lia.currency.get(pay))
            end
        end
    end)
end

hook.Add("OnReloaded", "liaSalaryOnReloaded", function()
    for _, client in player.Iterator() do
        CreateSalaryTimer(client)
    end
end)

hook.Add("PlayerLoadedChar", "liaSalaryPlayerLoadedChar", CreateSalaryTimer)
hook.Add("OnTransferred", "liaSalaryOnTransferred", CreateSalaryTimer)
hook.Add("OnPlayerSwitchClass", "liaSalaryOnPlayerSwitchClass", CreateSalaryTimer)
hook.Add("OnPlayerJoinClass", "liaSalaryOnPlayerJoinClass", CreateSalaryTimer)
hook.Add("PlayerDisconnected", "liaSalaryPlayerDisconnected", function(client) timer.Remove("liaSalary" .. client:SteamID64()) end)
hook.Add("CreateSalaryTimer", "liaSalaryCreateSalaryTimer", CreateSalaryTimer)

-- ./modules/core/teams/submodules/salary/module.lua
MODULE.name = "Salary"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a salary system"


-- ./modules/core/voice/commands.lua
lia.command.add("charvoicetoggle", {
    adminOnly = true,
    privilege = "Toggle Voice Ban Character",
    desc = L("charVoiceToggleDesc"),
    syntax = "[string name]",
    AdminStick = {
        Name = L("toggleVoice"),
        Category = L("moderationTools"),
        SubCategory = L("miscellaneous"),
        Icon = "icon16/sound_mute.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if target == client then
            client:notifyLocalized("cannotMuteSelf")
            return false
        end

        local char = target:getChar()
        if char then
            local isBanned = char:getData("VoiceBan", false)
            char:setData("VoiceBan", not isBanned)
            if isBanned then
                client:notifyLocalized("voiceUnmuted", target:Name())
                target:notifyLocalized("voiceUnmutedByAdmin")
            else
                client:notifyLocalized("voiceMuted", target:Name())
                target:notifyLocalized("voiceMutedByAdmin")
            end
        else
            client:notifyLocalized("noValidCharacter")
        end
    end
})

-- ./modules/core/voice/config.lua
MODULE.TalkRanges = {
    ["Whispering"] = 120,
    ["Talking"] = 300,
    ["Yelling"] = 600,
}

lia.config.add("IsVoiceEnabled", "Voice Chat Enabled", true, nil, {
    desc = "Whether or not voice chat is enabled",
    category = "General",
    type = "Boolean"
})


-- ./modules/core/voice/libraries/client.lua
local MODULE = MODULE
local color_white = Color(255, 255, 255)
local color_transparent = Color(0, 0, 0, 0)
VoicePanels = {}
local PANEL = {}
function PANEL:Init()
    local hi = vgui.Create("DLabel", self)
    hi:SetFont("liaIconsMedium")
    hi:Dock(LEFT)
    hi:DockMargin(8, 0, 8, 0)
    hi:SetTextColor(color_white)
    hi:SetText("i")
    hi:SetWide(30)
    self.LabelName = vgui.Create("DLabel", self)
    self.LabelName:SetFont("liaMediumFont")
    self.LabelName:Dock(FILL)
    self.LabelName:DockMargin(0, 0, 0, 0)
    self.LabelName:SetTextColor(color_white)
    self.Color = color_transparent
    self:SetSize(280, 32 + 8)
    self:DockPadding(4, 4, 4, 4)
    self:DockMargin(2, 2, 2, 2)
    self:Dock(BOTTOM)
end

function PANEL:Setup(client)
    self.client = client
    self.name = hook.Run("ShouldAllowScoreboardOverride", client, "name") and hook.Run("GetDisplayedName", client) or client:Nick()
    self.LabelName:SetText(self.name)
    self:InvalidateLayout()
end

function PANEL:Paint(w, h)
    if not IsValid(self.client) then return end
    lia.util.drawBlur(self, 1, 2)
    surface.SetDrawColor(0, 0, 0, 50 + self.client:VoiceVolume() * 50)
    surface.DrawRect(0, 0, w, h)
    surface.SetDrawColor(255, 255, 255, 50 + self.client:VoiceVolume() * 120)
    surface.DrawOutlinedRect(0, 0, w, h)
end

function PANEL:Think()
    if IsValid(self.client) then self.LabelName:SetText(self.name) end
    if self.fadeAnim then self.fadeAnim:Run() end
end

function PANEL:FadeOut(anim, delta)
    if anim.Finished then
        if IsValid(VoicePanels[self.client]) then
            VoicePanels[self.client]:Remove()
            VoicePanels[self.client] = nil
            return
        end
        return
    end

    self:SetAlpha(255 - 255 * delta * 2)
end

vgui.Register("VoicePanel", PANEL, "DPanel")
function MODULE:InitPostEntity()
    if IsValid(g_VoicePanelList) then g_VoicePanelList:Remove() end
    for _, pnl in pairs(VoicePanels) do
        if IsValid(pnl) then pnl:Remove() end
    end

    g_VoicePanelList = vgui.Create("DPanel")
    g_VoicePanelList:ParentToHUD()
    g_VoicePanelList:SetSize(270, ScrH() - 200)
    g_VoicePanelList:SetPos(ScrW() - 320, 100)
    g_VoicePanelList:SetPaintBackground(false)
end

function MODULE:OnReloaded()
    if IsValid(g_VoicePanelList) then g_VoicePanelList:Remove() end
    for _, pnl in pairs(VoicePanels) do
        if IsValid(pnl) then pnl:Remove() end
    end

    g_VoicePanelList = vgui.Create("DPanel")
    g_VoicePanelList:ParentToHUD()
    g_VoicePanelList:SetSize(270, ScrH() - 200)
    g_VoicePanelList:SetPos(ScrW() - 320, 100)
    g_VoicePanelList:SetPaintBackground(false)
end

function MODULE:PlayerButtonDown(client, button)
    if button == KEY_F2 and IsFirstTimePredicted() then
        local trace = client:GetEyeTrace()
        if IsValid(trace.Entity) and trace.Entity.isDoor and trace.Entity:isDoor() then return end
        local menu = DermaMenu()
        menu:AddOption(L("changeToWhisper"), function()
            net.Start("ChangeSpeakMode")
            net.WriteString("Whispering")
            net.SendToServer()
            client:ChatPrint(L("voiceModeWhisper"))
        end)

        menu:AddOption(L("changeToTalk"), function()
            net.Start("ChangeSpeakMode")
            net.WriteString("Talking")
            net.SendToServer()
            client:ChatPrint(L("voiceModeTalk"))
        end)

        menu:AddOption(L("changeToYell"), function()
            net.Start("ChangeSpeakMode")
            net.WriteString("Yelling")
            net.SendToServer()
            client:ChatPrint(L("voiceModeYell"))
        end)

        menu:Open()
        menu:MakePopup()
        menu:Center()
    end
end

local function VoiceClean()
    for k, _ in pairs(VoicePanels) do
        if not IsValid(k) then hook.Run("PlayerEndVoice", k) end
    end
end

timer.Create("VoiceClean", 1, 0, VoiceClean)

-- ./modules/core/voice/libraries/server.lua
local GM = GM or GAMEMODE
local MODULE = MODULE
function GM:PlayerCanHearPlayersVoice(listener, speaker)
    if not IsValid(listener) and IsValid(speaker) or listener == speaker then return false, false end
    if speaker:getNetVar("IsDeadRestricted", false) then return false, false end
    local char = speaker:getChar()
    if not (char and not char:getData("VoiceBan", false)) then return false, false end
    if not lia.config.get("IsVoiceEnabled", true) then return false, false end
    local voiceType = speaker:getNetVar("VoiceType", "Talking")
    local range = MODULE.TalkRanges[voiceType] or MODULE.TalkRanges["Talking"]
    local distanceSqr = listener:GetPos():DistToSqr(speaker:GetPos())
    local canHear = distanceSqr <= range * range
    return canHear, canHear
end

function MODULE:PostPlayerLoadout(client)
    client:setNetVar("VoiceType", "Talking")
end

net.Receive("ChangeSpeakMode", function(_, client)
    local mode = net.ReadString()
    if MODULE.TalkRanges[mode] then client:setNetVar("VoiceType", mode) end
end)

-- ./modules/core/voice/module.lua
MODULE.name = "3D Voice"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a Voice Tone Based Voice Module"


-- ./modules/frameworkui/chatbox/commands.lua
local MODULE = MODULE
MODULE.OOCBans = MODULE.OOCBans or {}
lia.command.add("banooc", {
    adminOnly = true,
    privilege = "Ban OOC",
    desc = L("banOOCCommandDesc"),
    syntax = "[string charname]",
    AdminStick = {
        Name = L("banOOCCommandName"),
        Category = L("moderationTools"),
        SubCategory = L("oocCategory"),
        Icon = "icon16/sound_mute.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        MODULE.OOCBans[target:SteamID64()] = true
        client:notify(target:Name() .. " " .. L("hasBeenBannedFromOOC"))
    end
})

lia.command.add("unbanooc", {
    adminOnly = true,
    privilege = "Unban OOC",
    desc = L("unbanOOCCommandDesc"),
    syntax = "[string charname]",
    AdminStick = {
        Name = L("unbanOOCCommandName"),
        Category = L("moderationTools"),
        SubCategory = L("oocCategory"),
        Icon = "icon16/sound.png"
    },
    onRun = function(client, arguments)
        local target = lia.util.findPlayer(client, arguments[1])
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        MODULE.OOCBans[target:SteamID64()] = nil
        client:notify(target:Name() .. " " .. L("hasBeenUnbannedFromOOC"))
    end
})

lia.command.add("blockooc", {
    superAdminOnly = true,
    privilege = "Block OOC",
    desc = L("blockOOCCommandDesc"),
    onRun = function(client)
        local blocked = GetGlobalBool("oocblocked", false)
        SetGlobalBool("oocblocked", not blocked)
        client:notify(blocked and L("unlockedOOC") or L("blockedOOC"))
    end
})

lia.command.add("clearchat", {
    adminOnly = true,
    privilege = "Clear Chat",
    desc = L("clearChatCommandDesc"),
    onRun = function()
        for _, ply in player.Iterator() do
            ply:ConCommand("fixchatplz")
        end
    end
})

-- ./modules/frameworkui/chatbox/config.lua
lia.config.add("CustomChatSound", "Custom Chat Sound", "", nil, {
    desc = "Change Chat Sound on Message Send",
    category = "Chat",
    type = "Generic"
})

lia.config.add("ChatColor", "Chat Color", {
    r = 255,
    g = 239,
    b = 150,
    a = 255
}, nil, {
    desc = "Chat Color",
    category = "Chat",
    type = "Color"
})

lia.config.add("ChatRange", "Chat Range", 280, nil, {
    desc = "Range of Chat can be heard",
    category = "Chat",
    type = "Int",
    min = 0,
    max = 10000
})

lia.config.add("OOCLimit", "OOC Character Limit", 150, nil, {
    desc = "Limit of characters on OOC",
    category = "Chat",
    type = "Int",
    min = 10,
    max = 1000
})

lia.config.add("ChatListenColor", "Chat Listen Color", {
    r = 168,
    g = 240,
    b = 170,
    a = 255
}, nil, {
    desc = "Color of chat when directly working at someone",
    category = "Chat",
    type = "Color"
})

lia.config.add("OOCDelay", "OOC Delay", 10, nil, {
    desc = "Set OOC Text Delay",
    category = "Chat",
    type = "Float",
    min = 0,
    max = 60
})

lia.config.add("LOOCDelay", "LOOC Delay", 6, nil, {
    desc = "Set LOOC Text Delay",
    category = "Chat",
    type = "Float",
    min = 0,
    max = 60
})

lia.config.add("LOOCDelayAdmin", "LOOC Delay for Admins", false, nil, {
    desc = "Should Admins have LOOC Delay",
    category = "Chat",
    type = "Boolean"
})

lia.config.add("ChatSizeDiff", "Enable Different Chat Size", false, nil, {
    desc = "Enable Different Chat Size Diff",
    category = "Chat",
    type = "Boolean"
})


-- ./modules/frameworkui/chatbox/libraries/client.lua
local MODULE = MODULE
chat.liaAddText = chat.liaAddText or chat.AddText
LIA_CVAR_CHATFILTER = CreateClientConVar("lia_chatfilter", "", true, false)
function MODULE:createChat()
    if IsValid(self.panel) then return end
    self.panel = vgui.Create("liaChatBox")
end

function MODULE:InitPostEntity()
    self:createChat()
end

function MODULE:OnReloaded()
    RunConsoleCommand("fixchatplz")
end

function MODULE:PlayerBindPress(_, bind, pressed)
    bind = bind:lower()
    if bind:find("messagemode") and pressed then
        if not self.panel.active then self.panel:setActive(true) end
        return true
    end
end

function chat.AddText(...)
    local show = true
    if IsValid(MODULE.panel) then show = MODULE.panel:addText(...) end
    if show then chat.liaAddText(...) end
end

function MODULE:ChatText(_, _, text, messageType)
    if messageType == "none" and IsValid(self.panel) then
        self.panel:addText(text)
        if lia.config.get("CustomChatSound", "") and lia.config.get("CustomChatSound", "") ~= "" then
            surface.PlaySound(lia.config.get("CustomChatSound", ""))
        else
            chat.PlaySound()
        end
    end
end

function MODULE:ChatAddText(text, ...)
    if lia.config.get("ChatSizeDiff", false) then
        local chatText = {...}
        local chatMode = #chatText <= 4 and chatText[2] or chatText[3]
        if not chatMode or istable(chatMode) then
            return "<font=liaChatFont>"
        else
            local chatMode = string.lower(chatMode)
            if string.match(chatMode, "yell") then
                return "<font=liaBigChatFont>"
            elseif string.sub(chatMode, 1, 2) == "**" then
                return "<font=liaItalicsChatFont>"
            elseif string.match(chatMode, "whisper") then
                return "<font=liaSmallChatFont>"
            elseif string.match(chatMode, "ooc") or string.match(chatMode, "looc") then
                return "<font=liaChatFont>"
            else
                return "<font=liaMediumChatFont>"
            end
        end
    else
        return text
    end
end

concommand.Add("fixchatplz", function()
    if IsValid(MODULE.panel) then
        MODULE.panel:Remove()
        MODULE:createChat()
    end
end)

-- ./modules/frameworkui/chatbox/libraries/server.lua
function MODULE:SaveData()
    self:setData(self.OOCBans)
end

function MODULE:LoadData()
    self.OOCBans = self:getData()
end

function MODULE:InitializedModules()
    SetGlobalBool("oocblocked", false)
end


-- ./modules/frameworkui/chatbox/libraries/shared.lua
local MODULE = MODULE
lia.chat.register("meclose", {
    syntax = "[string action]",
    desc = L("mecloseDesc"),
    format = "**%s %s",
    onCanHear = lia.config.get("ChatRange", 280) * 0.25,
    prefix = {"/meclose", "/actionclose"},
    font = "liaChatFontItalics",
    filter = "actions",
    deadCanChat = true
})

lia.chat.register("actions", {
    syntax = "[string action]",
    desc = L("actionsDesc"),
    format = "**%s %s",
    color = Color(255, 150, 0),
    onCanHear = lia.config.get("ChatRange", 280),
    deadCanChat = true
})

lia.chat.register("mefar", {
    syntax = "[string action]",
    desc = L("mefarDesc"),
    format = "**%s %s",
    onCanHear = lia.config.get("ChatRange", 280) * 2,
    prefix = {"/mefar", "/actionfar"},
    font = "liaChatFontItalics",
    filter = "actions",
    deadCanChat = true
})

lia.chat.register("itclose", {
    syntax = "[string text]",
    desc = L("itcloseDesc"),
    onChatAdd = function(_, text) chat.AddText(lia.config.get("ChatColor"), "**" .. text) end,
    onCanHear = lia.config.get("ChatRange", 280) * 0.25,
    prefix = {"/itclose"},
    font = "liaChatFontItalics",
    filter = "actions",
    deadCanChat = true
})

lia.chat.register("itfar", {
    syntax = "[string text]",
    desc = L("itfarDesc"),
    onChatAdd = function(_, text) chat.AddText(lia.config.get("ChatColor"), "**" .. text) end,
    onCanHear = lia.config.get("ChatRange", 280) * 2,
    prefix = {"/itfar"},
    font = "liaChatFontItalics",
    filter = "actions",
    deadCanChat = true
})

lia.chat.register("coinflip", {
    desc = L("coinflipDesc"),
    format = "%s flipped a coin and it landed on %s.",
    onCanHear = lia.config.get("ChatRange", 280),
    prefix = {"/coinflip"},
    color = Color(236, 100, 9),
    filter = "actions",
    font = "liaChatFontItalics",
    deadCanChat = false
})

lia.chat.register("ic", {
    syntax = "[string text]",
    desc = L("icDesc"),
    format = "%s says \"%s\"",
    onGetColor = function(speaker)
        local client = LocalPlayer()
        if client:getTracedEntity() == speaker then return lia.config.get("ChatListenColor") end
        return lia.config.get("ChatColor")
    end,
    onCanHear = function(speaker, listener)
        if speaker == listener then return true end
        if speaker:EyePos():Distance(listener:EyePos()) <= lia.config.get("ChatRange", 280) then return true end
        return false
    end
})

lia.chat.register("me", {
    syntax = "[string action]",
    desc = L("meDesc"),
    format = "**%s %s",
    onGetColor = lia.chat.classes.ic.onGetColor,
    onCanHear = function(speaker, listener)
        if speaker == listener then return true end
        if speaker:EyePos():Distance(listener:EyePos()) <= lia.config.get("ChatRange", 280) then return true end
        return false
    end,
    prefix = {"/me", "/action"},
    font = "liaChatFontItalics",
    filter = "actions",
    deadCanChat = true
})

lia.chat.register("it", {
    syntax = "[string text]",
    desc = L("itDesc"),
    onChatAdd = function(_, text) chat.AddText(lia.chat.timestamp(false), lia.config.get("ChatColor"), "**" .. text) end,
    onCanHear = function(speaker, listener)
        if speaker == listener then return true end
        if speaker:EyePos():Distance(listener:EyePos()) <= lia.config.get("ChatRange", 280) then return true end
        return false
    end,
    prefix = {"/it"},
    font = "liaChatFontItalics",
    filter = "actions",
    deadCanChat = true
})

lia.chat.register("w", {
    syntax = "[string text]",
    desc = L("wDesc"),
    format = "%s whispers \"%s\"",
    onGetColor = function(speaker)
        local color = lia.chat.classes.ic.onGetColor(speaker)
        return Color(color.r - 35, color.g - 35, color.b - 35)
    end,
    onCanHear = function(speaker, listener)
        if speaker == listener then return true end
        if speaker:EyePos():Distance(listener:EyePos()) <= lia.config.get("ChatRange", 280) * 0.25 then return true end
        return false
    end,
    prefix = {"/w", "/whisper"}
})

lia.chat.register("y", {
    syntax = "[string text]",
    desc = L("yDesc"),
    format = "%s yells \"%s\"",
    onGetColor = function(speaker)
        local color = lia.chat.classes.ic.onGetColor(speaker)
        return Color(color.r + 35, color.g + 35, color.b + 35)
    end,
    onCanHear = function(speaker, listener)
        if speaker == listener then return true end
        if speaker:EyePos():Distance(listener:EyePos()) <= lia.config.get("ChatRange", 280) * 2 then return true end
        return false
    end,
    prefix = {"/y", "/yell"}
})

lia.chat.register("looc", {
    syntax = "[string text]",
    desc = L("loocDesc"),
    onCanSay = function(speaker)
        local delay = lia.config.get("LOOCDelay", false)
        if speaker:isStaff() and lia.config.get("LOOCDelayAdmin", false) and delay > 0 and speaker.liaLastLOOC then
            local lastLOOC = CurTime() - speaker.liaLastLOOC
            if lastLOOC <= delay then
                speaker:notifyLocalized("loocDelay", delay - math.ceil(lastLOOC))
                return false
            end
        end

        speaker.liaLastLOOC = CurTime()
    end,
    onChatAdd = function(speaker, text) chat.AddText(Color(255, 50, 50), "[LOOC] ", lia.config.get("ChatColor"), speaker:Name() .. ": " .. text) end,
    onCanHear = function(speaker, listener)
        if speaker == listener then return true end
        if speaker:EyePos():Distance(listener:EyePos()) <= lia.config.get("ChatRange", 280) then return true end
        return false
    end,
    prefix = {"looc"},
    noSpaceAfter = true,
    filter = "ooc"
})

lia.chat.register("adminchat", {
    syntax = "[string text]",
    desc = L("adminchatDesc"),
    onGetColor = function() return Color(0, 196, 255) end,
    onCanHear = function(_, listener) return listener:hasPrivilege("Staff Permissions - Admin Chat") end,
    onCanSay = function(speaker)
        if not speaker:hasPrivilege("Staff Permissions - Admin Chat") then
            speaker:notify("You aren't an admin. Use '@messagehere' to create a ticket.")
            return false
        end
        return true
    end,
    onChatAdd = function(speaker, text) chat.AddText(Color(255, 215, 0), "[dmin Chat] ", Color(128, 0, 255, 255), speaker:getChar():getName(), ": ", Color(255, 255, 255), text) end,
    prefix = {"/adminchat", "/asay", "/admin", "/a"}
})

lia.chat.register("roll", {
    desc = L("rollDesc"),
    format = "%s has rolled %s.",
    color = Color(155, 111, 176),
    filter = "actions",
    font = "liaChatFontItalics",
    deadCanChat = true,
    onCanHear = function(speaker, listener)
        if speaker == listener then return true end
        if speaker:EyePos():Distance(listener:EyePos()) <= lia.config.get("ChatRange", 280) then return true end
        return false
    end
})

lia.chat.register("pm", {
    syntax = "[string player] [string message]",
    desc = L("pmDesc"),
    format = "[PM] %s: %s.",
    color = Color(249, 211, 89),
    filter = "pm",
    deadCanChat = true
})

lia.chat.register("eventlocal", {
    syntax = "[string text]",
    desc = L("eventlocalDesc"),
    onCanSay = function(speaker) return speaker:hasPrivilege("Staff Permissions - Local Event Chat") end,
    onCanHear = function(speaker, listener)
        if speaker == listener then return true end
        if speaker:EyePos():Distance(listener:EyePos()) <= lia.config.get("ChatRange", 280) * 6 then return true end
        return false
    end,
    onChatAdd = function(_, text) chat.AddText(Color(255, 150, 0), text) end,
    prefix = {"/eventlocal"},
    font = "liaMediumFont"
})

lia.chat.register("event", {
    syntax = "[string text]",
    desc = L("eventDesc"),
    onCanSay = function(speaker) return speaker:hasPrivilege("Staff Permissions - Event Chat") end,
    onCanHear = function() return true end,
    onChatAdd = function(_, text) chat.AddText(Color(255, 150, 0), text) end,
    prefix = {"/event"},
    font = "liaMediumFont"
})

lia.chat.register("ooc", {
    syntax = "[string text]",
    desc = L("oocDesc"),
    onCanSay = function(speaker, text)
        if GetGlobalBool("oocblocked", false) then
            speaker:notify("The OOC is Globally Blocked!")
            return false
        end

        if MODULE.OOCBans[speaker:SteamID64()] then
            speaker:notify("You have been banned from using OOC!")
            return false
        end

        if #text > lia.config.get("OOCLimit", 150) then
            speaker:notify("Text too big!")
            return false
        end

        local customDelay = hook.Run("getOOCDelay", speaker)
        local oocDelay = customDelay or lia.config.get("OOCDelay", 10)
        if not speaker:hasPrivilege("Staff Permissions - No OOC Cooldown") and oocDelay > 0 and speaker.liaLastOOC then
            local lastOOC = CurTime() - speaker.liaLastOOC
            if lastOOC <= oocDelay then
                speaker:notifyLocalized("oocDelay", oocDelay - math.ceil(lastOOC))
                return false
            end
        end

        speaker.liaLastOOC = CurTime()
    end,
    onCanHear = function() return true end,
    onChatAdd = function(speaker, text) chat.AddText(Color(255, 50, 50), " [OOC] ", speaker, color_white, ": " .. text) end,
    prefix = {"//", "/ooc"},
    noSpaceAfter = true,
    filter = "ooc"
})

lia.chat.register("me's", {
    syntax = "[string action]",
    desc = L("mesDesc"),
    format = "**%s's %s",
    onCanHear = lia.config.get("ChatRange", 280),
    onChatAdd = function(speaker, text, anonymous)
        local speako = anonymous and "Someone" or hook.Run("GetDisplayedName", speaker, "ic") or IsValid(speaker) and speaker:Name() or "Console"
        local texCol = lia.config.get("ChatColor")
        if LocalPlayer():getTracedEntity() == speaker then texCol = lia.config.get("ChatListenColor") end
        texCol = Color(texCol.r, texCol.g, texCol.b)
        local nameCol = Color(texCol.r + 30, texCol.g + 30, texCol.b + 30)
        if LocalPlayer() == speaker then
            local tempCol = lia.config.get("ChatListenColor")
            texCol = Color(tempCol.r + 20, tempCol.b + 20, tempCol.g + 20)
            nameCol = Color(tempCol.r + 40, tempCol.b + 60, tempCol.g + 40)
        end

        chat.AddText(nameCol, "**" .. speako .. "'s", texCol, " " .. text)
    end,
    prefix = {"/me's", "/action's"},
    font = "liaChatFontItalics",
    filter = "actions",
    deadCanChat = true
})

lia.chat.register("mefarfar", {
    syntax = "[string action]",
    desc = L("mefarfarDesc"),
    format = "**%s %s",
    onChatAdd = function(speaker, text, anonymous)
        local speako = anonymous and "Someone" or hook.Run("GetDisplayedName", speaker, "ic") or IsValid(speaker) and speaker:Name() or "Console"
        local texCol = lia.config.get("ChatColor")
        if LocalPlayer():getTracedEntity() == speaker then texCol = lia.config.get("ChatListenColor") end
        texCol = Color(texCol.r + 45, texCol.g + 45, texCol.b + 45)
        local nameCol = Color(texCol.r + 30, texCol.g + 30, texCol.b + 30)
        if LocalPlayer() == speaker then
            local tempCol = lia.config.get("ChatListenColor")
            texCol = Color(tempCol.r + 65, tempCol.b + 65, tempCol.g + 65)
            nameCol = Color(tempCol.r + 40, tempCol.b + 60, tempCol.g + 40)
        end

        chat.AddText(nameCol, "**" .. speako, texCol, " " .. text)
    end,
    onCanHear = lia.config.get("ChatRange", 280) * 4,
    prefix = {"/mefarfar", "/actionyy", "/meyy"},
    font = "liaChatFontItalics",
    filter = "actions",
    deadCanChat = true
})

lia.chat.register("help", {
    syntax = "[string text]",
    desc = L("helpDesc"),
    onCanSay = function() return true end,
    onCanHear = function(speaker, listener)
        if listener:isStaffOnDuty() or listener == speaker or listener:hasPrivilege("Staff Permissions - Always Have Access to Help Chat") then return true end
        return false
    end,
    onChatAdd = function(speaker, text) chat.AddText(Color(200, 50, 50), "[HELP] " .. speaker:GetName(), color_white, ": " .. text) end
})

-- ./modules/frameworkui/chatbox/module.lua
MODULE.name = "Chatbox"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a Chatbox"
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - No OOC Cooldown",
        MinAccess = "admin",
        Description = "Allows access to use the OOC chat command without delay.",
    },
    {
        Name = "Staff Permissions - Admin Chat",
        MinAccess = "admin",
        Description = "Allows access to Admin Chat.",
    },
    {
        Name = "Staff Permissions - Local Event Chat",
        MinAccess = "admin",
        Description = "Allows access to Local Event Chat."
    },
    {
        Name = "Staff Permissions - Event Chat",
        MinAccess = "admin",
        Description = "Allows access to Event Chat."
    },
    {
        Name = "Staff Permissions - Always Have Access to Help Chat",
        MinAccess = "superadmin",
        Description = "Allows access to Help Chat."
    },
}

lia.option.add("ChatShowTime", "Show Chat Timestamp", "Should chat show timestamp", false, nil, {
    category = "Chat",
    type = "Boolean"
})

-- ./modules/frameworkui/chatbox/netcalls/client.lua
netstream.Hook("cMsg", function(client, chatType, text, anonymous)
    if IsValid(client) then
        local class = lia.chat.classes[chatType]
        text = hook.Run("OnChatReceived", client, chatType, text, anonymous) or text
        if class then
            CHAT_CLASS = class
            class.onChatAdd(client, text, anonymous)
            if lia.config.get("CustomChatSound", "") and lia.config.get("CustomChatSound", "") ~= "" then
                surface.PlaySound(lia.config.get("CustomChatSound", ""))
            else
                chat.PlaySound()
            end

            CHAT_CLASS = nil
        end
    end
end)

-- ./modules/frameworkui/chatbox/netcalls/server.lua
net.Receive("msg", function(_, client)
    local text = net.ReadString()
    local charlimit = lia.config.get("MaxChatLength")
    if charlimit > 0 then
        if (client.liaNextChat or 0) < CurTime() and text:find("%S") then
            hook.Run("PlayerSay", client, text)
            client.liaNextChat = CurTime() + math.max(#text / 250, 0.4)
        end
    else
        if utf8.len(text) > charlimit then
            client:notifyLocalized("messageTooLong", charlimit)
        else
            if (client.liaNextChat or 0) < CurTime() and text:find("%S") then
                hook.Run("PlayerSay", client, text)
                client.liaNextChat = CurTime() + math.max(#text / 250, 0.4)
            end
        end
    end
end)

-- ./modules/frameworkui/f1menu/libraries/client.lua
MODULE.CharacterInformation = {}
function MODULE:LoadCharInformation()
    hook.Run("AddSection", L("generalInfo"), Color(0, 0, 0), 1, 1)
    hook.Run("AddTextField", L("generalInfo"), "name", L("nameField"), function() return LocalPlayer():getChar():getName() end)
    hook.Run("AddTextField", L("generalInfo"), "desc", L("descField"), function() return LocalPlayer():getChar():getDesc() end)
    hook.Run("AddTextField", L("generalInfo"), "money", L("moneyField"), function() return LocalPlayer():getMoney() end)
end

function MODULE:AddSection(sectionName, color, priority, location)
    hook.Run("F1OnAddSection", sectionName, color, priority, location)
    if not self.CharacterInformation[sectionName] then
        self.CharacterInformation[sectionName] = {
            fields = {},
            color = color or Color(255, 255, 255),
            priority = priority or 999,
            location = location or 1
        }
    else
        self.CharacterInformation[sectionName].color = color or self.CharacterInformation[sectionName].color
        self.CharacterInformation[sectionName].priority = priority or self.CharacterInformation[sectionName].priority
        self.CharacterInformation[sectionName].location = location or self.CharacterInformation[sectionName].location
    end
end

function MODULE:AddTextField(sectionName, fieldName, labelText, valueFunc)
    hook.Run("F1OnAddTextField", sectionName, fieldName, labelText, valueFunc)
    local section = self.CharacterInformation[sectionName]
    if section then
        local exists = false
        for _, field in ipairs(section.fields) do
            if field.name == fieldName then
                exists = true
                break
            end
        end

        if not exists then
            table.insert(section.fields, {
                type = "text",
                name = fieldName,
                label = labelText,
                value = valueFunc or function() return "" end
            })
        end
    end
end

function MODULE:AddBarField(sectionName, fieldName, labelText, minFunc, maxFunc, valueFunc)
    hook.Run("F1OnAddBarField", sectionName, fieldName, labelText, minFunc, maxFunc, valueFunc)
    local section = self.CharacterInformation[sectionName]
    if section then
        local exists = false
        for _, field in ipairs(section.fields) do
            if field.name == fieldName then
                exists = true
                break
            end
        end

        if not exists then
            table.insert(section.fields, {
                type = "bar",
                name = fieldName,
                label = labelText,
                min = minFunc or function() return 0 end,
                max = maxFunc or function() return 100 end,
                value = valueFunc or function() return 0 end
            })
        end
    end
end

function MODULE:PlayerBindPress(client, bind, pressed)
    if bind:lower():find("gm_showhelp") and pressed then
        if IsValid(lia.gui.menu) then
            lia.gui.menu:remove()
        elseif client:getChar() then
            vgui.Create("liaMenu")
        end
        return true
    end
end

function MODULE:CreateInformationButtons(pages)
    local client = LocalPlayer()
    local entitiesByCreator = {}
    for _, ent in ents.Iterator() do
        if IsValid(ent) and ent.GetCreator and IsValid(ent:GetCreator()) then
            local owner = ent:GetCreator():Nick()
            entitiesByCreator[owner] = entitiesByCreator[owner] or {}
            table.insert(entitiesByCreator[owner], ent)
        end
    end

    local function startSpectateView(ent, originalThirdPerson)
        local yaw, camZOffset = client:EyeAngles().yaw, 50
        hook.Add("CalcView", "EntityViewCalcView", function()
            return {
                origin = ent:GetPos() + Angle(0, yaw, 0):Forward() * 100 + Vector(0, 0, camZOffset),
                angles = Angle(0, yaw, 0),
                fov = 60
            }
        end)

        hook.Add("HUDPaint", "EntityViewHUD", function() draw.SimpleText(L("pressInstructions"), "liaMediumFont", ScrW() / 2, ScrH() - 50, color_white, TEXT_ALIGN_CENTER) end)
        hook.Add("Think", "EntityViewRotate", function()
            if input.IsKeyDown(KEY_A) then yaw = yaw - FrameTime() * 100 end
            if input.IsKeyDown(KEY_D) then yaw = yaw + FrameTime() * 100 end
            if input.IsKeyDown(KEY_W) then camZOffset = camZOffset + FrameTime() * 100 end
            if input.IsKeyDown(KEY_S) then camZOffset = camZOffset - FrameTime() * 100 end
            if input.IsKeyDown(KEY_SPACE) then
                hook.Remove("CalcView", "EntityViewCalcView")
                hook.Remove("HUDPaint", "EntityViewHUD")
                hook.Remove("Think", "EntityViewRotate")
                hook.Remove("CreateMove", "EntitySpectateCreateMove")
                lia.option.set("thirdPersonEnabled", originalThirdPerson)
            end
        end)

        hook.Add("CreateMove", "EntitySpectateCreateMove", function(cmd)
            cmd:SetForwardMove(0)
            cmd:SetSideMove(0)
            cmd:SetUpMove(0)
        end)
    end

    if not table.IsEmpty(entitiesByCreator) then
        table.insert(pages, {
            name = L("entities"),
            drawFunc = function(panel)
                local searchEntry = vgui.Create("DTextEntry", panel)
                searchEntry:Dock(TOP)
                searchEntry:DockMargin(0, 0, 0, 5)
                searchEntry:SetTall(30)
                searchEntry:SetPlaceholderText(L("searchEntities"))
                local scroll = vgui.Create("DScrollPanel", panel)
                scroll:Dock(FILL)
                scroll:DockPadding(0, 0, 0, 10)
                local canvas = scroll:GetCanvas()
                local entries = {}
                for owner, entsList in SortedPairs(entitiesByCreator) do
                    local header = vgui.Create("DCollapsibleCategory", canvas)
                    header:Dock(TOP)
                    header:SetLabel(owner)
                    header:SetExpanded(true)
                    header:DockMargin(0, 0, 0, 0)
                    header.Header:SetFont("liaMediumFont")
                    header.Header:SetTextColor(Color(255, 255, 255))
                    header.Header:SetContentAlignment(5)
                    header.Header:SetTall(30)
                    header.Header.Paint = function(_, w, h)
                        draw.RoundedBox(4, 0, 0, w, h, Color(0, 0, 0, 200))
                        surface.SetDrawColor(255, 255, 255)
                        surface.DrawOutlinedRect(0, 0, w, h)
                    end

                    local body = vgui.Create("DPanel", header)
                    body.Paint = function(_, w, h) draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 200)) end
                    header:SetContents(body)
                    entries[header] = {}
                    for _, ent in ipairs(entsList) do
                        local class = ent:GetClass()
                        local panelEnt = vgui.Create("DPanel", body)
                        panelEnt:Dock(TOP)
                        panelEnt:DockMargin(10, 15, 10, 10)
                        panelEnt:SetTall(100)
                        panelEnt.infoText = class:lower()
                        panelEnt.Paint = function(_, w, h)
                            draw.RoundedBox(4, 0, 0, w, h, Color(40, 40, 40, 200))
                            draw.SimpleText(class, "liaMediumFont", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                        end

                        local icon = vgui.Create("liaSpawnIcon", panelEnt)
                        icon:Dock(LEFT)
                        icon:SetWide(64)
                        icon:SetModel(ent:GetModel() or "models/error.mdl", ent:GetSkin() or 0)
                        icon.DoClick = function()
                            if IsValid(lastModelFrame) then lastModelFrame:Close() end
                            lastModelFrame = vgui.Create("DFrame")
                            lastModelFrame:SetTitle(class)
                            lastModelFrame:SetSize(800, 800)
                            lastModelFrame:Center()
                            lastModelFrame:MakePopup()
                            local info = vgui.Create("DLabel", lastModelFrame)
                            info:SetText("Press A/D to rotate | W/S to move camera vertically | Press SPACE to exit")
                            info:SetFont("liaMediumFont")
                            info:SizeToContents()
                            info:Dock(TOP)
                            info:DockMargin(0, 10, 0, 0)
                            info:SetContentAlignment(5)
                            local modelPanel = vgui.Create("DModelPanel", lastModelFrame)
                            modelPanel:Dock(FILL)
                            modelPanel:SetModel(ent:GetModel() or "models/error.mdl", ent:GetSkin() or 0)
                            modelPanel:SetFOV(45)
                            local mn, mx = modelPanel.Entity:GetRenderBounds()
                            local size = math.max(math.abs(mn.x) + math.abs(mx.x), math.abs(mn.y) + math.abs(mx.y), math.abs(mn.z) + math.abs(mx.z))
                            modelPanel:SetCamPos(Vector(size, size, size))
                            modelPanel:SetLookAt((mn + mx) * 0.5)
                            local orig = lia.option.get("thirdPersonEnabled", false)
                            lia.option.set("thirdPersonEnabled", false)
                            startSpectateView(ent, orig)
                        end

                        local btnContainer = vgui.Create("DPanel", panelEnt)
                        btnContainer:Dock(RIGHT)
                        btnContainer:SetWide(380)
                        local btnW, btnH = 120, 40
                        if client:hasPrivilege("Staff Permission  View Entity (Entity Tab)") then
                            local btnView = vgui.Create("liaSmallButton", btnContainer)
                            btnView:Dock(LEFT)
                            btnView:DockMargin(5, 0, 5, 0)
                            btnView:SetWide(btnW)
                            btnView:SetTall(btnH)
                            btnView:SetText(L("viewButton"))
                            btnView.DoClick = function()
                                if IsValid(lia.gui.menu) then lia.gui.menu:remove() end
                                local orig = lia.option.get("thirdPersonEnabled", false)
                                lia.option.set("thirdPersonEnabled", false)
                                startSpectateView(ent, orig)
                            end
                        end

                        if client:hasPrivilege("Staff Permission  Teleport to Entity (Entity Tab)") then
                            local btnTeleport = vgui.Create("liaSmallButton", btnContainer)
                            btnTeleport:Dock(LEFT)
                            btnTeleport:DockMargin(5, 0, 5, 0)
                            btnTeleport:SetWide(btnW)
                            btnTeleport:SetTall(btnH)
                            btnTeleport:SetText(L("teleportButton"))
                            btnTeleport.DoClick = function()
                                net.Start("liaTeleportToEntity")
                                net.WriteEntity(ent)
                                net.SendToServer()
                            end
                        end

                        local btnWaypoint = vgui.Create("liaSmallButton", btnContainer)
                        btnWaypoint:Dock(RIGHT)
                        btnWaypoint:DockMargin(5, 0, 5, 0)
                        btnWaypoint:SetWide(btnW)
                        btnWaypoint:SetTall(btnH)
                        btnWaypoint:SetText(L("waypointButton"))
                        btnWaypoint.DoClick = function() client:setWaypoint(class, ent:GetPos()) end
                        entries[header][#entries[header] + 1] = panelEnt
                    end
                end

                searchEntry.OnTextChanged = function(entry)
                    local q = entry:GetValue():lower()
                    for header, panels in pairs(entries) do
                        local anyVisible = false
                        for _, panelEnt in ipairs(panels) do
                            local ok = q == "" or panelEnt.infoText:find(q, 1, true)
                            panelEnt:SetVisible(ok)
                            if ok then anyVisible = true end
                        end

                        header:SetVisible(anyVisible)
                    end

                    canvas:InvalidateLayout()
                end
            end
        })
    end

    if client:hasPrivilege("Staff Permission  Access Module List") then
        table.insert(pages, {
            name = L("modules"),
            drawFunc = function(panel)
                local moduleSearch = vgui.Create("DTextEntry", panel)
                moduleSearch:Dock(TOP)
                moduleSearch:DockMargin(10, 5, 10, 5)
                moduleSearch:SetTall(30)
                moduleSearch:SetPlaceholderText(L("searchModules"))
                local scroll = vgui.Create("DScrollPanel", panel)
                scroll:Dock(FILL)
                scroll:DockPadding(0, 0, 0, 10)
                local canvas = scroll:GetCanvas()
                local panels = {}
                for _, moduleData in SortedPairs(lia.module.list) do
                    local hasDesc = moduleData.desc and moduleData.desc ~= ""
                    local height = hasDesc and 80 or 40
                    local modulePanel = vgui.Create("DPanel", canvas)
                    modulePanel:Dock(TOP)
                    modulePanel:DockMargin(10, 5, 10, 0)
                    modulePanel:SetTall(height)
                    modulePanel.infoText = moduleData.name:lower() .. " " .. (moduleData.desc or ""):lower()
                    modulePanel.Paint = function(_, w, h)
                        draw.RoundedBox(4, 0, 0, w, h, Color(40, 40, 40, 200))
                        draw.SimpleText(moduleData.name, "liaMediumFont", 20, 10, color_white)
                        draw.SimpleText(tostring(moduleData.version or 1.0), "liaSmallFont", w - 20, 45, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
                        if hasDesc then draw.SimpleText(moduleData.desc, "liaSmallFont", 20, 45, color_white) end
                    end

                    panels[#panels + 1] = modulePanel
                end

                moduleSearch.OnTextChanged = function(entry)
                    local q = entry:GetValue():lower()
                    for _, modulePanel in ipairs(panels) do
                        modulePanel:SetVisible(q == "" or modulePanel.infoText:find(q, 1, true))
                    end

                    canvas:InvalidateLayout()
                end
            end
        })
    end
end

function MODULE:CreateMenuButtons(tabs)
    tabs[L("status")] = function(panel)
        panel.info = vgui.Create("liaCharInfo", panel)
        panel.info:setup()
        panel.info:SetAlpha(0)
        panel.info:AlphaTo(255, 0.5)
    end

    tabs[L("information")] = function(panel)
        panel.sidebar = panel:Add("DScrollPanel")
        panel.sidebar:Dock(LEFT)
        panel.sidebar:SetWide(200)
        panel.sidebar:DockMargin(20, 20, 0, 20)
        panel.mainContent = panel:Add("DPanel")
        panel.mainContent:Dock(FILL)
        panel.mainContent:DockMargin(10, 10, 10, 10)
        panel.mainContent.Paint = function() end
        local pages = {}
        hook.Run("CreateInformationButtons", pages)
        if not pages then return end
        local currentSelected = nil
        for _, pageInfo in ipairs(pages) do
            local btn = panel.sidebar:Add("liaMediumButton")
            btn:SetText(pageInfo.name)
            btn:Dock(TOP)
            btn:DockMargin(0, 0, 0, 10)
            btn:SetTall(40)
            btn.DoClick = function()
                if IsValid(currentSelected) then currentSelected:SetSelected(false) end
                btn:SetSelected(true)
                currentSelected = btn
                panel.mainContent:Clear()
                pageInfo.drawFunc(panel.mainContent)
            end
        end
    end

    tabs[L("settings")] = function(panel)
        panel.sidebar = panel:Add("DScrollPanel")
        panel.sidebar:Dock(LEFT)
        panel.sidebar:SetWide(200)
        panel.sidebar:DockMargin(20, 20, 0, 20)
        panel.mainContent = panel:Add("DPanel")
        panel.mainContent:Dock(FILL)
        panel.mainContent:DockMargin(10, 10, 10, 10)
        local pages = {}
        hook.Run("PopulateConfigurationButtons", pages)
        if not pages then return end
        local currentSelected = nil
        for _, pageInfo in ipairs(pages) do
            local btn = panel.sidebar:Add("liaMediumButton")
            btn:SetText(pageInfo.name)
            btn:Dock(TOP)
            btn:DockMargin(0, 0, 0, 10)
            btn:SetTall(40)
            btn.DoClick = function()
                if IsValid(currentSelected) then currentSelected:SetSelected(false) end
                btn:SetSelected(true)
                currentSelected = btn
                panel.mainContent:Clear()
                pageInfo.drawFunc(panel.mainContent)
            end
        end

        if #pages > 0 then
            panel.mainContent:Clear()
            pages[1].drawFunc(panel.mainContent)
        end
    end
end

function MODULE:CanDisplayCharInfo(name)
    local client = LocalPlayer()
    local character = client:getChar()
    local class = lia.class.list[character:getClass()]
    if name == "class" and not class then return false end
    return true
end

-- ./modules/frameworkui/f1menu/libraries/server.lua
function MODULE:PlayerDeath(client)
    net.Start("removeF1")
    net.Send(client)
end

net.Receive("liaTeleportToEntity", function(_, ply)
    local ent = net.ReadEntity()
    if not IsValid(ent) then return end
    if not ply:hasPrivilege("Staff Permission  Teleport to Entity (Entity Tab)") then return end
    local pos = ent:GetPos() + Vector(0, 0, 50)
    ply:SetPos(pos)
    ply:notifyLocalized("teleportedToEntity", ent:GetClass())
end)

function MODULE:ShowHelp()
    return false
end

-- ./modules/frameworkui/f1menu/module.lua
MODULE.name = "F1 Menu"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a F1 Menu that allows to access several characters sub-menus."
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permission  Access Entity List",
        MinAccess = "admin",
        Description = "Allows access to the scoreboards admin options."
    },
    {
        Name = "Staff Permission  Teleport to Entity",
        MinAccess = "admin",
        Description = "Allows teleporting to any entity."
    },
    {
        Name = "Staff Permission  Teleport to Entity (Entity Tab)",
        MinAccess = "admin",
        Description = "Allows teleporting to entities from the Entity tab."
    },
    {
        Name = "Staff Permission  View Entity (Entity Tab)",
        MinAccess = "admin",
        Description = "Allows viewing detailed entity information from the Entity tab."
    },
    {
        Name = "Staff Permission  Access Module List",
        MinAccess = "user",
        Description = "Allows access to the module management panel."
    }
}

-- ./modules/frameworkui/f1menu/netcalls/client.lua
net.Receive("removeF1", function() if IsValid(lia.gui.menu) then lia.gui.menu:remove() end end)
net.Receive("ForceUpdateF1", function()
    if IsValid(lia.gui.menu) then
        lia.gui.menu:Remove()
        vgui.Create("liaMenu")
    end
end)

-- ./modules/frameworkui/mainmenu/config.lua
lia.config.add("MusicVolume", "Music Volume", 0.25, nil, {
    desc = "The volume level for the main menu music",
    category = "Main Menu",
    type = "Float",
    min = 0.0,
    max = 1.0
})

lia.config.add("Music", "Main Menu Music", "", nil, {
    desc = "The file path or URL for the main menu background music",
    category = "Main Menu",
    type = "Generic"
})

lia.config.add("BackgroundURL", "Main Menu Background URL", "", nil, {
    desc = "The URL or file path for the main menu background image",
    category = "Main Menu",
    type = "Generic"
})

lia.config.add("CenterLogo", "Center Logo", "", nil, {
    desc = "The file path or URL for the logo displayed at the center of the screen",
    category = "Main Menu",
    type = "Generic"
})

lia.config.add("DiscordURL", "The Discord of the Server", "https://discord.gg/esCRH5ckbQ", nil, {
    desc = "The URL for the Discord server",
    category = "Main Menu",
    type = "Generic"
})

lia.config.add("Workshop", "The Steam Workshop of the Server", "https://steamcommunity.com/sharedfiles/filedetails/?id=2959728255", nil, {
    desc = "The URL for the Steam Workshop page",
    category = "Main Menu",
    type = "Generic"
})

lia.config.add("CharMenuBGInputDisabled", "Character Menu BG Input Disabled", true, nil, {
    desc = "Whether background input is disabled during character menu use",
    category = "Main Menu",
    type = "Boolean"
})


-- ./modules/frameworkui/mainmenu/libraries/server.lua
function MODULE:PlayerLiliaDataLoaded(client)
    lia.char.restore(client, function(charList)
        if not IsValid(client) then return end
        MsgN("Loaded (" .. table.concat(charList, ", ") .. ") for " .. client:Name())
        for _, v in ipairs(charList) do
            if lia.char.loaded[v] then lia.char.loaded[v]:sync(client) end
        end

        for _, v in player.Iterator() do
            if v:getChar() then v:getChar():sync(client) end
        end

        client.liaCharList = charList
        self:syncCharList(client)
        client.liaLoaded = true
    end)
end

function MODULE:CanPlayerUseChar(_, character)
    local banned = character:getData("banned")
    if banned and isnumber(banned) and banned > os.time() then return false, L("charBanned") end
    return true
end

function MODULE:CanPlayerSwitchChar(client, character, newCharacter)
    local banned = character:getData("banned")
    if character:getID() == newCharacter:getID() then return false, L("alreadyUsingChar") end
    if banned and isnumber(banned) and banned > os.time() then return false, L("charBanned") end
    if not client:Alive() then return false, L("youAreDead") end
    if client:hasRagdoll() then return false, L("youAreRagdolled") end
    if client:hasValidVehicle() then return false, L("cannotSwitchInVehicle") end
    return true
end

function MODULE:PlayerLoadedChar(client)
    client:Spawn()
end

-- ./modules/frameworkui/mainmenu/module.lua
MODULE.name = "Main Menu"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a Main Menu that allows to access several characters options."
MODULE.identifier = "MainMenu"
if SERVER then
    function MODULE:syncCharList(client)
        if not client.liaCharList then return end
        net.Start("liaCharList")
        net.WriteUInt(#client.liaCharList, 32)
        for i = 1, #client.liaCharList do
            net.WriteUInt(client.liaCharList[i], 32)
        end

        net.Send(client)
    end
else
    function MODULE:ResetCharacterPanel()
        if IsValid(lia.gui.character) then lia.gui.character:Remove() end
        vgui.Create("liaCharacter")
    end

    function MODULE:chooseCharacter(id)
        assert(isnumber(id), "id must be a number")
        local d = deferred.new()
        net.Receive("liaCharChoose", function()
            local message = net.ReadString()
            if message == "" then
                d:resolve()
                hook.Run("CharLoaded", lia.char.loaded[id])
            else
                d:reject(message)
            end
        end)

        net.Start("liaCharChoose")
        net.WriteUInt(id, 32)
        net.SendToServer()
        return d
    end

    function MODULE:createCharacter(data)
        local client = LocalPlayer()
        assert(istable(data), "data must be a table")
        local d = deferred.new()
        local payload = {}
        for key, charVar in pairs(lia.char.vars) do
            if charVar.noDisplay then continue end
            local value = data[key]
            if isfunction(charVar.onValidate) then
                local results = {charVar.onValidate(value, data, client)}
                if results[1] == false then return d:reject(L(unpack(results, 2))) end
            end

            payload[key] = value
        end

        net.Receive("liaCharCreate", function()
            local id = net.ReadUInt(32)
            local reason = net.ReadString()
            if id > 0 then
                d:resolve(id)
            else
                d:reject(reason)
            end
        end)

        net.Start("liaCharCreate")
        net.WriteUInt(table.Count(payload), 32)
        for key, value in pairs(payload) do
            net.WriteString(key)
            net.WriteType(value)
        end

        net.SendToServer()
        return d
    end

    function MODULE:deleteCharacter(id)
        assert(isnumber(id), "id must be a number")
        net.Start("liaCharDelete")
        net.WriteUInt(id, 32)
        net.SendToServer()
    end

    function MODULE:LiliaLoaded()
        vgui.Create("liaCharacter")
    end

    function MODULE:KickedFromChar(_, isCurrentChar)
        if isCurrentChar then vgui.Create("liaCharacter") end
    end

    function MODULE:CreateMenuButtons(tabs)
        tabs[L("characters")] = function()
            local client = LocalPlayer()
            if client:IsInThirdPerson() then
                lia.option.set("thirdPersonEnabled", false)
                hook.Run("thirdPersonToggled", false)
            end

            if IsValid(lia.gui.menu) then lia.gui.menu:Remove() end
            vgui.Create("liaCharacter")
        end
    end
end

function MODULE:CanPlayerCreateChar(client)
    if SERVER then
        local count = #client.liaCharList or 0
        local maxChars = hook.Run("GetMaxPlayerChar", client) or lia.config.get("MaxCharacters")
        if (count or 0) >= maxChars then return false end
        return true
    else
        local count = #lia.characters or 0
        local maxChars = hook.Run("GetMaxPlayerChar", client) or lia.config.get("MaxCharacters")
        if (count or 0) >= maxChars then return false end
    end
end

-- ./modules/frameworkui/mainmenu/netcalls/client.lua
net.Receive("liaCharList", function()
    local newCharList = {}
    local length = net.ReadUInt(32)
    for i = 1, length do
        newCharList[i] = net.ReadUInt(32)
    end

    local oldCharList = lia.characters
    lia.characters = newCharList
    if oldCharList then
        hook.Run("CharListUpdated", oldCharList, newCharList)
    else
        hook.Run("CharListLoaded", newCharList)
    end

    hook.Run("ResetCharacterPanel")
end)

-- ./modules/frameworkui/mainmenu/netcalls/server.lua
net.Receive("liaCharChoose", function(_, client)
    local function response(message)
        net.Start("liaCharChoose")
        net.WriteString(L(message or "", client))
        net.Send(client)
    end

    local id = net.ReadUInt(32)
    local character = lia.char.loaded[id]
    if not character or character:getPlayer() ~= client then return response(false, "invalidChar") end
    local status, result = hook.Run("CanPlayerUseChar", client, character)
    if status == false then
        if result[1] == "@" then result = result:sub(2) end
        return response(result)
    end

    local currentChar = client:getChar()
    if currentChar then
        status, result = hook.Run("CanPlayerSwitchChar", client, currentChar, character)
        if status == false then
            if result[1] == "@" then result = result:sub(2) end
            return response(result)
        end

        currentChar:save()
    end

    hook.Run("PrePlayerLoadedChar", client, character, currentChar)
    character:setup()
    hook.Run("PlayerLoadedChar", client, character, currentChar)
    response()
    hook.Run("PostPlayerLoadedChar", client, character, currentChar)
end)

net.Receive("liaCharCreate", function(_, client)
    if hook.Run("CanPlayerCreateChar", client) == false then return end
    local function response(id, message, ...)
        net.Start("liaCharCreate")
        net.WriteUInt(id or 0, 32)
        net.WriteString(L(message or "", client, ...))
        net.Send(client)
    end

    local numValues = net.ReadUInt(32)
    local data = {}
    for _ = 1, numValues do
        data[net.ReadString()] = net.ReadType()
    end

    local originalData = table.Copy(data)
    local newData = {}
    for key in pairs(data) do
        if not lia.char.vars[key] then data[key] = nil end
    end

    for key, charVar in pairs(lia.char.vars) do
        local value = data[key]
        if not isfunction(charVar.onValidate) and charVar.noDisplay then
            data[key] = nil
            continue
        end

        if isfunction(charVar.onValidate) then
            local result = {charVar.onValidate(value, data, client)}
            if result[1] == false then
                result[2] = result[2] or "Validation error"
                return response(nil, unpack(result, 2))
            end
        end

        if isfunction(charVar.onAdjust) then charVar.onAdjust(client, data, value, newData) end
    end

    hook.Run("AdjustCreationData", client, data, newData, originalData)
    data = table.Merge(data, newData)
    data.steamID = client:SteamID64()
    lia.char.create(data, function(id)
        if IsValid(client) then
            lia.char.loaded[id]:sync(client)
            table.insert(client.liaCharList, id)
            MainMenu:syncCharList(client)
            hook.Run("OnCharCreated", client, lia.char.loaded[id], originalData)
            response(id)
        end
    end)
end)

net.Receive("liaCharDelete", function(_, client)
    local id = net.ReadUInt(32)
    local character = lia.char.loaded[id]
    local steamID = client:SteamID64()
    if character and character.steamID == steamID then
        hook.Run("CharDeleted", client, character)
        character:delete()
        timer.Simple(.5, function() MainMenu:syncCharList(client) end)
    end
end)

-- ./modules/frameworkui/scoreboard/config.lua
lia.config.add("sbWidth", "Scoreboard Width", 0.35, nil, {
    desc = "Scoreboard Width",
    category = "Scoreboard",
    type = "Float",
    min = 0.1,
    max = 1.0
})

lia.config.add("sbHeight", "Scoreboard Height", 0.65, nil, {
    desc = "Scoreboard Height",
    category = "Scoreboard",
    type = "Float",
    min = 0.1,
    max = 1.0
})

lia.config.add("ShowStaff", "Show Staff in Scoreboard", true, nil, {
    desc = "Should Staff Show In Scoreboard",
    category = "Scoreboard",
    type = "Boolean"
})

lia.config.add("DisplayServerName", "Display Server Name in Scoreboard", false, nil, {
    desc = "Should Server Name Show In Scoreboard",
    category = "Scoreboard",
    type = "Boolean"
})

lia.config.add("DisplayMemberCount", "Display Member Count", true, nil, {
    desc = "Should Faction Member Count Be Displayed",
    category = "Scoreboard",
    type = "Boolean"
})

lia.config.add("UseSolidBackground", "Use Solid Background in Scoreboard", false, nil, {
    desc = "Use a solid background for the scoreboard",
    category = "Scoreboard",
    type = "Boolean"
})

lia.config.add("ScoreboardBackgroundColor", "Scoreboard Background Color", {
    r = 255,
    g = 100,
    b = 100,
    a = 255
}, nil, {
    desc = "Sets the background color of the scoreboard. This only applies if 'UseSolidBackground' is enabled.",
    category = "Scoreboard",
    type = "Color"
})

-- ./modules/frameworkui/scoreboard/libraries/client.lua
function MODULE:ScoreboardHide()
    if IsValid(lia.gui.score) then lia.gui.score:Remove() end
    gui.EnableScreenClicker(false)
    return true
end

function MODULE:ScoreboardShow()
    local client = LocalPlayer()
    if client:getChar() and hook.Run("CheckInteractionPossibilities") ~= true then
        vgui.Create("liaScoreboard")
        gui.EnableScreenClicker(true)
        return true
    end
    return true
end

function MODULE:OnReloaded()
    if IsValid(lia.gui.score) then lia.gui.score:Remove() end
end

function MODULE:ShouldShowPlayerOnScoreboard(client)
    local faction = lia.faction.indices[client:Team()]
    if faction and faction.ScoreboardHidden then return false end
end

-- ./modules/frameworkui/scoreboard/module.lua
MODULE.name = "Scoreboard"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a RPish Scoreboard with Recognition"
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Can Access Scoreboard Admin Options",
        MinAccess = "admin",
        Description = "Allows access to Scoreboard Admin Options.",
    },
    {
        Name = "Staff Permissions - Can Access Scoreboard Info Out Of Staff",
        MinAccess = "admin",
        Description = "Allows access to Scoreboard Info Out Of Staff.",
    },
}

-- ./modules/frameworkui/weaponselector/libraries/client.lua
local pi = math.pi
local index = MODULE.index or 1
local deltaIndex = MODULE.deltaIndex or index
local infoAlpha = MODULE.infoAlpha or 0
local alpha = MODULE.alpha or 0
local alphaDelta = MODULE.alphaDelta or alpha
local fadeTime = MODULE.fadeTime or 0
local IsValid = IsValid
local tonumber = tonumber
local FrameTime = FrameTime
local Lerp = Lerp
local CurTime = CurTime
local ipairs = ipairs
local LocalPlayer = LocalPlayer
local math = math
local color_white = color_white
local surface = surface
local IN_ATTACK = IN_ATTACK
local function getWeaponFromIndex(i, weapons)
    return weapons[i] or NULL
end

local function shouldDrawWepSelect(client)
    client = client or LocalPlayer()
    return hook.Run("ShouldDrawWepSelect", client) ~= false
end

function MODULE:HUDPaint()
    if not shouldDrawWepSelect() then return end
    local frameTime = FrameTime()
    local fraction = alphaDelta
    if fraction <= 0.01 and alpha == 0 then
        alphaDelta = 0
        return
    else
        alphaDelta = Lerp(frameTime * 10, alphaDelta, alpha)
    end

    local shiftX = ScrW() * 0.02
    local client = LocalPlayer()
    local weapons = client:GetWeapons()
    local x, y = ScrW() * 0.05, ScrH() * 0.5
    local spacing = pi * 0.85
    local radius = 240 * alphaDelta
    deltaIndex = Lerp(frameTime * 12, deltaIndex, index)
    local currentIndex = deltaIndex
    local activeColor = lia.config.get("Color")
    for realIndex, weapon in ipairs(weapons) do
        local theta = (realIndex - currentIndex) * 0.1
        local isActive = realIndex == index
        local colAlpha = (255 - math.abs(theta * 3) * 255) * fraction
        local col = ColorAlpha(isActive and activeColor or color_white, colAlpha)
        local lastY = 0
        if self.markup and (realIndex == 1 or realIndex < index) then
            local _, h = self.markup:Size()
            lastY = h * fraction
            if realIndex == index - 1 or realIndex == 1 then
                infoAlpha = Lerp(frameTime * 5, infoAlpha, 255)
                self.markup:Draw(x + 6 + shiftX, y + 30, 0, 0, infoAlpha * fraction)
            end

            if index == 1 then lastY = 0 end
        end

        surface.SetFont("liaBigFont")
        local name = hook.Run("GetWeaponName", weapon) or weapon:GetPrintName():upper()
        local _, ty = surface.GetTextSize(name)
        local scale = math.max(1 - math.abs(theta * 2), 0)
        local matrix = Matrix()
        matrix:Translate(Vector(shiftX + x + math.cos(theta * spacing + pi) * radius + radius, y + lastY + math.sin(theta * spacing + pi) * radius - ty / 2, 1))
        matrix:Scale(Vector(scale, scale, 1))
        cam.PushModelMatrix(matrix)
        lia.util.drawText(name, 2, ty / 2, col, 0, 1, "liaBigFont")
        cam.PopModelMatrix()
    end

    if fadeTime < CurTime() and alpha > 0 then alpha = 0 end
end

function MODULE:onIndexChanged()
    if not shouldDrawWepSelect() then return end
    alpha = 1
    fadeTime = CurTime() + 5
    local client = LocalPlayer()
    local weapons = client:GetWeapons()
    local weapon = getWeaponFromIndex(index, weapons)
    self.markup = nil
    infoAlpha = 0
    if IsValid(weapon) then
        local textParts = {}
        local activeColor = lia.config.get("Color")
        for _, key in ipairs({"Author", "Contact", "Purpose", "Instructions"}) do
            if weapon[key] and weapon[key]:find("%S") then table.insert(textParts, string.format("<font=liaItemBoldFont><color=%d,%d,%d>%s</font></color>\n%s\n", activeColor.r, activeColor.g, activeColor.b, L(key), weapon[key])) end
        end

        if #textParts > 0 then
            local text = table.concat(textParts)
            self.markup = markup.Parse("<font=liaItemDescFont>" .. text, ScrW() * 0.3)
        end

        local source, pitch = hook.Run("WeaponCycleSound")
        source = source or "common/talk.wav"
        pitch = pitch or 180
        client:EmitSound(source, 45, pitch)
    end
end

function MODULE:PlayerBindPress(client, bind, pressed)
    if not shouldDrawWepSelect(client) then return end
    if not pressed then return end
    if client:InVehicle() then return end
    local weapon = client:GetActiveWeapon()
    if IsValid(weapon) and weapon:GetClass() == "weapon_physgun" and client:KeyDown(IN_ATTACK) then return end
    if hook.Run("CanPlayerChooseWeapon", weapon) == false then return end
    bind = bind:lower()
    local weapons = client:GetWeapons()
    local total = #weapons
    local isInvPrev = bind:find("invprev") ~= nil
    local isInvNext = bind:find("invnext") ~= nil
    if lia.option.get("invertWeaponScroll", false) then isInvPrev, isInvNext = isInvNext, isInvPrev end
    if isInvPrev or isInvNext then
        if isInvPrev then
            index = index - 1
            if index < 1 then index = total end
        else
            index = index + 1
            if index > total then index = 1 end
        end

        self:onIndexChanged()
        return true
    elseif bind:find("slot") then
        local slot = tonumber(bind:match("slot(%d)"))
        index = math.Clamp(slot or 1, 1, total)
        self:onIndexChanged()
        return true
    elseif bind:find("attack") and alpha > 0 then
        local weapon = getWeaponFromIndex(index, weapons)
        if not IsValid(weapon) then
            alpha = 0
            infoAlpha = 0
            return
        end

        local source, pitch = hook.Run("WeaponSelectSound")
        source = source or "common/talk.wav"
        pitch = pitch or 180
        client:EmitSound(source, 75, pitch)
        client:SelectWeapon(weapon:GetClass())
        alpha = 0
        infoAlpha = 0
        return true
    end
end

local meta = FindMetaTable("Player")
function meta:SelectWeapon(class)
    if not shouldDrawWepSelect(self) then return end
    if not self:HasWeapon(class) then return end
    self.doWeaponSwitch = self:GetWeapon(class)
end

function MODULE:StartCommand(client, cmd)
    if not shouldDrawWepSelect(client) then return end
    if not IsValid(client.doWeaponSwitch) then return end
    cmd:SelectWeapon(client.doWeaponSwitch)
    if client:GetActiveWeapon() == client.doWeaponSwitch then client.doWeaponSwitch = nil end
end

-- ./modules/frameworkui/weaponselector/module.lua
MODULE.name = "Weapon Selector"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds a Weapon Selector UI"
lia.option.add("invertWeaponScroll", L("invertWeaponScroll"), L("invertWeaponScrollDesc"), false, nil, {
    category = L("weaponSelector")
})

-- ./modules/utilities/doors/commands.lua
lia.command.add("doorsell", {
    desc = L("doorsellDesc"),
    adminOnly = false,
    AdminStick = {
        Name = "Sell Door",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            if client == door:GetDTEntity(0) then
                local price = math.Round(door:getNetVar("price", 0) * lia.config.get("DoorSellRatio", 0.5))
                door:removeDoorAccessData()
                MODULE:callOnDoorChildren(door, function(child) child:removeDoorAccessData() end)
                client:getChar():giveMoney(price)
                client:notifyLocalized("doorSold", lia.currency.get(price))
                hook.Run("OnPlayerPurchaseDoor", client, door, false, MODULE.callOnDoorChildren)
                lia.log.add(client, "doorsell", price)
            else
                client:notifyLocalized("doorNotOwner")
            end
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("admindoorsell", {
    desc = L("admindoorsellDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Admin Sell Door",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            local owner = door:GetDTEntity(0)
            if IsValid(owner) and owner:IsPlayer() then
                local price = math.Round(door:getNetVar("price", 0) * lia.config.get("DoorSellRatio", 0.5))
                door:removeDoorAccessData()
                MODULE:callOnDoorChildren(door, function(child) child:removeDoorAccessData() end)
                owner:getChar():giveMoney(price)
                owner:notifyLocalized("doorSold", lia.currency.get(price))
                client:notifyLocalized("doorSold", lia.currency.get(price))
                hook.Run("OnPlayerPurchaseDoor", owner, door, false, MODULE.callOnDoorChildren)
                lia.log.add(client, "admindoorsell", owner:Name(), price)
            else
                client:notifyLocalized("doorNotOwner")
            end
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doortogglelock", {
    desc = L("doortogglelockDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Toggle Door Lock",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            local currentLockState = door:GetInternalVariable("m_bLocked")
            local toggleState = not currentLockState
            if toggleState then
                door:Fire("lock")
                door:EmitSound("doors/door_latch3.wav")
                client:notifyLocalized("doorToggleLocked", "locked")
                lia.log.add(client, "toggleLock", door, "locked")
            else
                door:Fire("unlock")
                door:EmitSound("doors/door_latch1.wav")
                client:notifyLocalized("doorToggleLocked", "unlocked")
                lia.log.add(client, "toggleLock", door, "unlocked")
            end

            local partner = door:getDoorPartner()
            if IsValid(partner) then
                if toggleState then
                    partner:Fire("lock")
                else
                    partner:Fire("unlock")
                end
            end
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doorbuy", {
    desc = L("doorbuyDesc"),
    adminOnly = false,
    AdminStick = {
        Name = "Buy Door",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            if door:getNetVar("noSell") or door:getNetVar("faction") or door:getNetVar("class") then return client:notifyLocalized("doorNotAllowedToOwn") end
            if IsValid(door:GetDTEntity(0)) then
                client:notifyLocalized("doorOwnedBy", door:GetDTEntity(0):Name())
                return false
            end

            local price = door:getNetVar("price", 0)
            if client:getChar():hasMoney(price) then
                door:SetDTEntity(0, client)
                door.liaAccess = {
                    [client] = DOOR_OWNER
                }

                MODULE:callOnDoorChildren(door, function(child) child:SetDTEntity(0, client) end)
                client:getChar():takeMoney(price)
                client:notifyLocalized("doorPurchased", lia.currency.get(price))
                hook.Run("OnPlayerPurchaseDoor", client, door, true, MODULE.callOnDoorChildren)
                lia.log.add(client, "buydoor", price)
            else
                client:notifyLocalized("doorCanNotAfford")
            end
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doortoggleownable", {
    desc = L("doortoggleownableDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Toggle Door Ownable",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            local isUnownable = door:getNetVar("noSell", false)
            local newState = not isUnownable
            door:setNetVar("noSell", newState and true or nil)
            MODULE:callOnDoorChildren(door, function(child) child:setNetVar("noSell", newState and true or nil) end)
            lia.log.add(client, "doorToggleOwnable", door, newState)
            client:notify(newState and L("doorMadeUnownable") or L("doorMadeOwnable"))
            MODULE:SaveData()
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doorresetdata", {
    desc = L("doorresetdataDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Reset Door Data",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() then
            lia.log.add(client, "doorResetData", door)
            door:setNetVar("disabled", nil)
            door:setNetVar("noSell", nil)
            door:setNetVar("hidden", nil)
            door:setNetVar("class", nil)
            door:setNetVar("factions", "[]")
            door:setNetVar("title", nil)
            door:setNetVar("price", 0)
            door:setNetVar("locked", false)
            MODULE:callOnDoorChildren(door, function(child)
                child:setNetVar("disabled", nil)
                child:setNetVar("noSell", nil)
                child:setNetVar("hidden", nil)
                child:setNetVar("class", nil)
                child:setNetVar("factions", "[]")
                child:setNetVar("title", nil)
                child:setNetVar("price", 0)
                child:setNetVar("locked", false)
            end)

            client:notifyLocalized("doorResetData")
            MODULE:SaveData()
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doortoggleenabled", {
    desc = L("doortoggleenabledDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Toggle Door Enabled",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() then
            local isDisabled = door:getNetVar("disabled", false)
            local newState = not isDisabled
            door:setNetVar("disabled", newState and true or nil)
            MODULE:callOnDoorChildren(door, function(child) child:setNetVar("disabled", newState and true or nil) end)
            lia.log.add(client, newState and "doorDisable" or "doorEnable", door)
            client:notify(newState and L("doorSetDisabled") or L("doorSetNotDisabled"))
            MODULE:SaveData()
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doortogglehidden", {
    desc = L("doortogglehiddenDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Toggle Door Hidden",
        TargetClass = "Door"
    },
    onRun = function(client)
        local entity = client:GetEyeTrace().Entity
        if IsValid(entity) and entity:isDoor() then
            local currentState = entity:getNetVar("hidden", false)
            local newState = not currentState
            entity:setNetVar("hidden", newState)
            lia.log.add(client, "doorSetHidden", entity, newState)
            MODULE:callOnDoorChildren(entity, function(child)
                child:setNetVar("hidden", newState)
                lia.log.add(client, "doorSetHidden", child, newState)
            end)

            client:notify(newState and L("doorSetHidden") or L("doorSetNotHidden"))
            MODULE:SaveData()
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doorsetprice", {
    desc = L("doorsetpriceDesc"),
    syntax = "[number price]",
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Set Door Price",
        TargetClass = "Door",
        ExtraFields = {
            ["price"] = "text"
        }
    },
    onRun = function(client, arguments)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            if not arguments[1] or not tonumber(arguments[1]) then return client:notifyLocalized("invalidClass") end
            local price = math.Clamp(math.floor(tonumber(arguments[1])), 0, 1000000)
            door:setNetVar("price", price)
            MODULE:callOnDoorChildren(door, function(child) child:setNetVar("price", price) end)
            lia.log.add(client, "doorSetPrice", door, price)
            client:notifyLocalized("priceLabel", lia.currency.get(price))
            MODULE:SaveData()
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doorsettitle", {
    desc = L("doorsettitleDesc"),
    syntax = "[string title]",
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Set Door Title",
        TargetClass = "Door",
        ExtraFields = {
            ["title"] = "text"
        }
    },
    onRun = function(client, arguments)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            local name = table.concat(arguments, " ")
            if not name:find("%S") then return client:notifyLocalized("invalidClass") end
            if door:checkDoorAccess(client, DOOR_TENANT) then
                door:setNetVar("title", name)
                lia.log.add(client, "doorSetTitle", door, name)
            elseif client:isStaff() then
                door:setNetVar("name", name)
                MODULE:callOnDoorChildren(door, function(child) child:setNetVar("name", name) end)
                lia.log.add(client, "doorSetTitle", door, name)
            else
                client:notifyLocalized("doorNotOwner")
            end
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doorsetparent", {
    desc = L("doorsetparentDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Set Door Parent",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            client.liaDoorParent = door
            lia.log.add(client, "doorSetParent", door)
            client:notifyLocalized("doorSetParentDoor")
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doorsetchild", {
    desc = L("doorsetchildDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Set Door Child",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            if client.liaDoorParent == door then return client:notifyLocalized("doorCanNotSetAsChild") end
            if IsValid(client.liaDoorParent) then
                client.liaDoorParent.liaChildren = client.liaDoorParent.liaChildren or {}
                client.liaDoorParent.liaChildren[door:MapCreationID()] = true
                door.liaParent = client.liaDoorParent
                lia.log.add(client, "doorAddChild", client.liaDoorParent, door)
                client:notifyLocalized("doorAddChildDoor")
                MODULE:SaveData()
                MODULE:copyParentDoor(door)
            else
                client:notifyLocalized("doorNoParentDoor")
            end
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("doorremovechild", {
    desc = L("doorremovechildDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Remove Door Child",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            if client.liaDoorParent == door then
                MODULE:callOnDoorChildren(door, function(child)
                    lia.log.add(client, "doorRemoveChild", door, child)
                    child.liaParent = nil
                end)

                door.liaChildren = nil
                client:notifyLocalized("doorRemoveChildren")
                return
            end

            if IsValid(door.liaParent) and door.liaParent.liaChildren then
                door.liaParent.liaChildren[door:MapCreationID()] = nil
                lia.log.add(client, "doorRemoveChild", door.liaParent, door)
                door.liaParent = nil
                client:notifyLocalized("doorRemoveChildDoor")
                MODULE:SaveData()
            end
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("savedoors", {
    desc = L("savedoorsDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Save Doors",
        TargetClass = "Door"
    },
    onRun = function(client)
        MODULE:SaveData()
        lia.log.add(client, "doorSaveData")
        client:notify("Saved Doors!")
    end
})

lia.command.add("doorinfo", {
    desc = L("doorinfoDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    AdminStick = {
        Name = "Get Door Information",
        TargetClass = "Door"
    },
    onRun = function(client)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() then
            local disabled = door:getNetVar("disabled", false)
            local name = door:getNetVar("title", door:getNetVar("name", L("doorTitle")))
            local price = door:getNetVar("price", 0)
            local noSell = door:getNetVar("noSell", false)
            local faction = door:getNetVar("faction", "None")
            local factions = door:getNetVar("factions", "[]")
            local class = door:getNetVar("class", "None")
            local hidden = door:getNetVar("hidden", false)
            local locked = door:getNetVar("locked", false)
            client:ChatPrint("disabled: " .. tostring(disabled) .. "\n" .. "name: " .. tostring(name) .. "\n" .. "price: " .. lia.currency.get(price) .. "\n" .. "noSell: " .. tostring(noSell) .. "\n" .. "faction: " .. tostring(faction) .. "\n" .. "factions: " .. tostring(factions) .. "\n" .. "class: " .. tostring(class) .. "\n" .. "hidden: " .. tostring(hidden) .. "\n" .. "locked: " .. tostring(locked))
        else
            client:notifyLocalized("doorNotValid")
        end
    end
})

lia.command.add("dooraddfaction", {
    desc = L("dooraddfactionDesc"),
    syntax = "[string faction]",
    adminOnly = true,
    privilege = "Manage Doors",
    onRun = function(client, arguments)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            local faction
            if arguments[1] then
                local name = table.concat(arguments, " ")
                for k, v in pairs(lia.faction.teams) do
                    if lia.util.stringMatches(k, name) or lia.util.stringMatches(v.name, name) then
                        faction = v
                        break
                    end
                end
            end

            if faction then
                door.liaFactionID = faction.uniqueID
                local facs = door:getNetVar("factions", "[]")
                facs = util.JSONToTable(facs)
                facs[faction.index] = true
                local json = util.TableToJSON(facs)
                door:setNetVar("factions", json)
                MODULE:callOnDoorChildren(door, function()
                    local facs = door:getNetVar("factions", "[]")
                    facs = util.JSONToTable(facs)
                    facs[faction.index] = true
                    local json = util.TableToJSON(facs)
                    door:setNetVar("factions", json)
                end)

                lia.log.add(client, "doorSetFaction", door, faction.name)
                client:notifyLocalized("doorSetFaction", faction.name)
            elseif arguments[1] then
                client:notifyLocalized("invalidFaction")
            else
                door:setNetVar("factions", "[]")
                MODULE:callOnDoorChildren(door, function() door:setNetVar("factions", "[]") end)
                lia.log.add(client, "doorRemoveFaction", door, "all")
                client:notifyLocalized("doorRemoveFaction")
            end

            MODULE:SaveData()
        end
    end
})

lia.command.add("doorremovefaction", {
    desc = L("doorremovefactionDesc"),
    syntax = "[string faction]",
    adminOnly = true,
    privilege = "Manage Doors",
    onRun = function(client, arguments)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            local faction
            if arguments[1] then
                local name = table.concat(arguments, " ")
                for k, v in pairs(lia.faction.teams) do
                    if lia.util.stringMatches(k, name) or lia.util.stringMatches(v.name, name) then
                        faction = v
                        break
                    end
                end
            end

            if faction then
                door.liaFactionID = nil
                local facs = door:getNetVar("factions", "[]")
                facs = util.JSONToTable(facs)
                facs[faction.index] = nil
                local json = util.TableToJSON(facs)
                door:setNetVar("factions", json)
                MODULE:callOnDoorChildren(door, function()
                    local facs = door:getNetVar("factions", "[]")
                    facs = util.JSONToTable(facs)
                    facs[faction.index] = nil
                    local json = util.TableToJSON(facs)
                    door:setNetVar("factions", json)
                end)

                lia.log.add(client, "doorRemoveFaction", door, faction.name)
                client:notifyLocalized("doorRemoveFaction", faction.name)
            elseif arguments[1] then
                client:notifyLocalized("invalidFaction")
            else
                door:setNetVar("factions", "[]")
                MODULE:callOnDoorChildren(door, function() door:setNetVar("factions", "[]") end)
                lia.log.add(client, "doorRemoveFaction", door, "all")
                client:notifyLocalized("doorRemoveFaction")
            end

            MODULE:SaveData()
        end
    end
})

lia.command.add("doorsetclass", {
    desc = L("doorsetclassDesc"),
    syntax = "[string class]",
    adminOnly = true,
    privilege = "Manage Doors",
    onRun = function(client, arguments)
        local door = client:getTracedEntity()
        if IsValid(door) and door:isDoor() and not door:getNetVar("disabled", false) then
            local class, classData
            if arguments[1] then
                local name = table.concat(arguments, " ")
                for k, v in pairs(lia.class.list) do
                    if lia.util.stringMatches(v.name, name) then
                        class, classData = k, v
                        break
                    end
                end
            end

            if class then
                door.liaClassID = class
                door:setNetVar("class", class)
                MODULE:callOnDoorChildren(door, function()
                    door.liaClassID = class
                    door:setNetVar("class", class)
                end)

                lia.log.add(client, "doorSetClass", door, classData.name)
                client:notifyLocalized("doorSetClass", classData.name)
            elseif arguments[1] then
                client:notifyLocalized("invalidClass")
            else
                door:setNetVar("class", nil)
                MODULE:callOnDoorChildren(door, function() door:setNetVar("class", nil) end)
                lia.log.add(client, "doorRemoveClass", door)
                client:notifyLocalized("doorRemoveClass")
            end

            MODULE:SaveData()
        end
    end,
    alias = {"jobdoor"}
})

lia.command.add("togglealldoors", {
    desc = L("togglealldoorsDesc"),
    adminOnly = true,
    privilege = "Manage Doors",
    onRun = function(client)
        local toggleToDisable = false
        for _, door in ents.Iterator() do
            if IsValid(door) and door:isDoor() then
                toggleToDisable = not door:getNetVar("disabled", false)
                break
            end
        end

        local count = 0
        for _, door in ents.Iterator() do
            if IsValid(door) and door:isDoor() and door:getNetVar("disabled", false) ~= toggleToDisable then
                door:setNetVar("disabled", toggleToDisable and true or nil)
                lia.log.add(client, toggleToDisable and "doorDisable" or "doorEnable", door)
                MODULE:callOnDoorChildren(door, function(child)
                    child:setNetVar("disabled", toggleToDisable and true or nil)
                    lia.log.add(client, toggleToDisable and "doorDisable" or "doorEnable", child)
                end)

                count = count + 1
            end
        end

        client:notifyLocalized(toggleToDisable and "doorDisableAll" or "doorEnableAll", count)
        lia.log.add(client, toggleToDisable and "doorDisableAll" or "doorEnableAll", count)
        MODULE:SaveData()
    end
})

-- ./modules/utilities/doors/config.lua
lia.config.add("DoorLockTime", "Door Lock Time", 0.5, nil, {
    desc = "Time it takes to lock a door",
    category = "Doors",
    type = "Float",
    min = 0.1,
    max = 10.0
})

lia.config.add("DoorSellRatio", "Door Sell Ratio", 0.5, nil, {
    desc = "Percentage you can sell a door for",
    category = "Doors",
    type = "Float",
    min = 0.0,
    max = 1.0
})


-- ./modules/utilities/doors/entities/weapons/lia_keys/cl_init.lua
SWEP.PrintName = "Keys"
SWEP.Slot = 0
SWEP.SlotPos = 2
SWEP.DrawAmmo = false

-- ./modules/utilities/doors/entities/weapons/lia_keys/shared.lua
SWEP.Author = "Samael"
SWEP.Instructions = "Primary Fire: Lock\nSecondary Fire: Unlock"
SWEP.Purpose = "Locking and Unlocking Stuff."
SWEP.Drop = false
SWEP.ViewModelFOV = 45
SWEP.ViewModelFlip = false
SWEP.ViewTranslation = 4
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""
SWEP.Primary.Damage = 5
SWEP.Primary.Delay = 0.75
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""
SWEP.ViewModel = Model("models/weapons/c_arms_animations.mdl")
SWEP.WorldModel = ""
SWEP.UseHands = false
SWEP.LowerAngles = Angle(0, 5, -14)
SWEP.LowerAngles2 = Angle(0, 5, -22)
SWEP.IsAlwaysLowered = true
SWEP.FireWhenLowered = true
SWEP.HoldType = "normal"
ACT_VM_FISTS_HOLSTER = 2
function SWEP:Deploy()
    if not IsValid(self:GetOwner()) then return end
    return true
end

function SWEP:Holster()
    if not IsValid(self:GetOwner()) then return end
    local viewModel = self:GetOwner():GetViewModel()
    if IsValid(viewModel) then
        viewModel:SetPlaybackRate(1)
        viewModel:ResetSequence(ACT_VM_FISTS_HOLSTER)
    end
    return true
end

function SWEP:Precache()
end

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
end

function SWEP:PrimaryAttack()
    local time = lia.config.get("DoorLockTime", 0.5)
    local time2 = math.max(time, 1)
    local owner = self:GetOwner()
    local data = {}
    data.start = owner:GetShootPos()
    data.endpos = data.start + owner:GetAimVector() * 96
    data.filter = owner
    local entity = util.TraceLine(data).Entity
    self:SetNextPrimaryFire(CurTime() + time2)
    self:SetNextSecondaryFire(CurTime() + time2)
    if not IsFirstTimePredicted() then return end
    if not IsValid(entity) then return end
    hook.Run("KeyLock", owner, entity, time)
end

function SWEP:SecondaryAttack()
    local time = lia.config.get("DoorLockTime", 0.5)
    local time2 = math.max(time, 1)
    local owner = self:GetOwner()
    local data = {}
    data.start = owner:GetShootPos()
    data.endpos = data.start + owner:GetAimVector() * 96
    data.filter = owner
    local entity = util.TraceLine(data).Entity
    self:SetNextPrimaryFire(CurTime() + time2)
    self:SetNextSecondaryFire(CurTime() + time2)
    if not IsFirstTimePredicted() then return end
    if not IsValid(entity) then return end
    hook.Run("KeyUnlock", owner, entity, time)
end

-- ./modules/utilities/doors/libraries/client.lua
function MODULE:DrawEntityInfo(entity, alpha)
    if entity:isDoor() and not entity:getNetVar("hidden", false) then
        if entity:getNetVar("disabled", false) then
            local pos = entity:LocalToWorld(entity:OBBCenter()):ToScreen()
            lia.util.drawText(L("doorDisabled"), pos.x, pos.y, ColorAlpha(color_white, alpha), 1, 1)
            return
        end

        local pos = entity:LocalToWorld(entity:OBBCenter()):ToScreen()
        local x, y = pos.x, pos.y
        local owner = entity:GetDTEntity(0)
        local name = entity:getNetVar("title", entity:getNetVar("name", IsValid(owner) and L("doorTitleOwned") or not entity:getNetVar("class") and not entity:getNetVar("factions") and L("doorTitle") or ""))
        local factions = entity:getNetVar("factions", "[]")
        local class = entity:getNetVar("class")
        local price = entity:getNetVar("price", 0)
        local ownable = not entity:getNetVar("noSell", false)
        lia.util.drawText(name, x, y, ColorAlpha(color_white, alpha), 1, 1)
        y = y + 20
        if ownable then
            lia.util.drawText(L("priceLabel", lia.currency.get(price)), x, y, ColorAlpha(color_white, alpha), 1, 1)
            y = y + 20
        end

        local classData
        if class and lia.class.list[class] then classData = lia.class.list[class] end
        if IsValid(owner) then
            lia.util.drawText(L("doorOwnedBy", owner:Name()), x, y, ColorAlpha(color_white, alpha), 1, 1)
            y = y + 20
        end

        if factions and factions ~= "[]" then
            local facs = util.JSONToTable(factions)
            if facs then
                lia.util.drawText(L("doorFactions"), x, y, ColorAlpha(color_white, alpha), 1, 1)
                y = y + 20
                for id, _ in pairs(facs) do
                    local info = lia.faction.indices[id]
                    if info then
                        lia.util.drawText(info.name, x, y, info.color or color_white, 1, 1)
                        y = y + 20
                    end
                end
            end
        end

        if class and classData then
            lia.util.drawText(L("classes"), x, y, ColorAlpha(color_white, alpha), 1, 1)
            y = y + 20
            lia.util.drawText(classData.name, x, y, classData.color or color_white, 1, 1)
            y = y + 20
        end

        if not IsValid(owner) and factions == "[]" and not class then lia.util.drawText(ownable and L("doorIsOwnable") or L("doorIsNotOwnable"), x, y, ColorAlpha(color_white, alpha), 1, 1) end
    end
end

function MODULE:PopulateAdminStick(AdminMenu, target)
    if IsValid(target) and target:isDoor() then
        local factionsAssignedRaw = target:getNetVar("factions", "[]")
        local factionsAssigned = util.JSONToTable(factionsAssignedRaw) or {}
        local addFactionMenu = AdminMenu:AddSubMenu(L("doorAddFaction"))
        for _, faction in pairs(lia.faction.teams) do
            if not factionsAssigned[faction.index] then
                addFactionMenu:AddOption(faction.name, function()
                    LocalPlayer():ConCommand('say /dooraddfaction "' .. faction.uniqueID .. '"')
                    AdminStickIsOpen = false
                end)
            end
        end

        if table.Count(factionsAssigned) > 0 then
            local removeFactionMenu = AdminMenu:AddSubMenu(L("doorRemoveFactionAdmin"))
            for id, _ in pairs(factionsAssigned) do
                for _, faction in pairs(lia.faction.teams) do
                    if faction.index == id then
                        removeFactionMenu:AddOption(faction.name, function()
                            LocalPlayer():ConCommand('say /doorremovefaction "' .. faction.uniqueID .. '"')
                            AdminStickIsOpen = false
                        end)
                    end
                end
            end
        else
            AdminMenu:AddOption(L("doorNoFactions")):SetEnabled(false)
        end

        local setClassMenu = AdminMenu:AddSubMenu(L("doorSetDoorClass"))
        for classID, classData in pairs(lia.class.list) do
            setClassMenu:AddOption(classData.name, function()
                LocalPlayer():ConCommand('doorsetclass "' .. classID .. '"')
                AdminStickIsOpen = false
            end)
        end

        if target:getNetVar("class") then
            setClassMenu:AddOption(L("doorRemoveDoorClass"), function()
                LocalPlayer():ConCommand('doorsetclass ""')
                AdminStickIsOpen = false
            end)
        end
    end
end

-- ./modules/utilities/doors/libraries/server.lua
local Variables = {
    ["disabled"] = true,
    ["name"] = true,
    ["price"] = true,
    ["noSell"] = true,
    ["faction"] = true,
    ["factions"] = true,
    ["class"] = true,
    ["hidden"] = true,
    ["locked"] = true
}

local DarkRPVariables = {
    ["DarkRPNonOwnable"] = function(entity) entity:setNetVar("noSell", true) end,
    ["DarkRPTitle"] = function(entity, val) entity:setNetVar("name", val) end,
    ["DarkRPCanLockpick"] = function(entity, val) entity.noPick = tobool(val) end
}

function MODULE:EntityKeyValue(entity, key, value)
    if entity:isDoor() and DarkRPVariables[key] then DarkRPVariables[key](entity, value) end
end

function MODULE:copyParentDoor(child)
    local parent = child.liaParent
    if IsValid(parent) then
        for var in pairs(Variables) do
            local parentValue = parent:getNetVar(var)
            if child:getNetVar(var) ~= parentValue then child:setNetVar(var, parentValue) end
        end
    end
end

function MODULE:PostLoadData()
    if self.DoorsAlwaysDisabled then
        local count = 0
        for _, door in ents.Iterator() do
            if IsValid(door) and door:isDoor() then
                door:setNetVar("disabled", true)
                self:callOnDoorChildren(door, function(child) child:setNetVar("disabled", true) end)
                count = count + 1
            end
        end

        lia.information(L("doorDisableAll", count))
    end
end

function MODULE:LoadData()
    local data = self:getData()
    if not data then return end
    for k, v in pairs(data) do
        local entity = ents.GetMapCreatedEntity(k)
        if IsValid(entity) and entity:isDoor() then
            for k2, v2 in pairs(v) do
                if k2 == "children" then
                    entity.liaChildren = v2
                    for index, _ in pairs(v2) do
                        local door = ents.GetMapCreatedEntity(index)
                        if IsValid(door) then door.liaParent = entity end
                    end
                else
                    entity:setNetVar(k2, v2)
                end
            end
        end
    end
end

function MODULE:SaveData()
    local data = {}
    local doors = {}
    for _, ent in ents.Iterator() do
        if ent:isDoor() then doors[ent:MapCreationID()] = ent end
    end

    for id, door in pairs(doors) do
        local doorData = {}
        for var in pairs(Variables) do
            local value = door:getNetVar(var)
            if value then doorData[var] = value end
        end

        if door.liaChildren then doorData.children = door.liaChildren end
        if door.liaClassID then doorData.class = door.liaClassID end
        if door.liaFactionID then doorData.faction = door.liaFactionID end
        if not table.IsEmpty(doorData) then data[id] = doorData end
    end

    self:setData(data)
    lia.information(L("doorSaveData") .. " " .. table.Count(data))
end

function MODULE:callOnDoorChildren(entity, callback)
    local parent
    if entity.liaChildren then
        parent = entity
    elseif entity.liaParent then
        parent = entity.liaParent
    end

    if IsValid(parent) then
        callback(parent)
        for k, _ in pairs(parent.liaChildren) do
            local child = ents.GetMapCreatedEntity(k)
            if IsValid(child) then callback(child) end
        end
    end
end

function MODULE:InitPostEntity()
    local doors = ents.FindByClass("prop_door_rotating")
    for _, v in ipairs(doors) do
        local parent = v:GetOwner()
        if IsValid(parent) then
            v.liaPartner = parent
            parent.liaPartner = v
        else
            for _, v2 in ipairs(doors) do
                if v2:GetOwner() == v then
                    v2.liaPartner = v
                    v.liaPartner = v2
                    break
                end
            end
        end
    end
end

function MODULE:PlayerUse(client, door)
    if door:IsVehicle() and door:isLocked() then return false end
    if door:isDoor() then
        local result = hook.Run("CanPlayerUseDoor", client, door)
        if result == false then
            return false
        else
            result = hook.Run("PlayerUseDoor", client, door)
            if result ~= nil then return result end
        end
    end
end

function MODULE:CanPlayerUseDoor(_, door)
    if door:getNetVar("disabled", false) then return false end
end

function MODULE:CanPlayerAccessDoor(client, door)
    local factions = door:getNetVar("factions")
    if factions ~= nil then
        local facs = util.JSONToTable(factions)
        if facs ~= nil and facs ~= "[]" and facs[client:Team()] then return true end
    end

    local class = door:getNetVar("class")
    local classData = lia.class.list[class]
    local charClass = client:getChar():getClass()
    local classData2 = lia.class.list[charClass]
    if class and classData and classData2 then
        if classData.team then
            if classData.team ~= classData2.team then return false end
        else
            if charClass ~= class then return false end
        end
        return true
    end
end

function MODULE:PostPlayerLoadout(client)
    client:Give("lia_keys")
end

function MODULE:ShowTeam(client)
    local entity = client:getTracedEntity()
    if IsValid(entity) and entity:isDoor() and not entity:getNetVar("faction") and not entity:getNetVar("class") then
        if entity:checkDoorAccess(client, DOOR_TENANT) then
            local door = entity
            if IsValid(door.liaParent) then door = door.liaParent end
            netstream.Start(client, "doorMenu", door, door.liaAccess, entity)
        elseif not IsValid(entity:GetDTEntity(0)) then
            lia.command.run(client, "doorbuy")
        else
            client:notifyLocalized("notNow")
        end
        return true
    end
end

function MODULE:PlayerDisconnected(client)
    for _, v in ents.Iterator() do
        if v ~= client and v.isDoor and v:isDoor() and v:GetDTEntity(0) == client then v:removeDoorAccessData() end
    end
end

function MODULE:KeyLock(client, door, time)
    if not IsValid(door) or not IsValid(client) then return end
    if hook.Run("CanPlayerLock", client, door) == false then return end
    local distance = client:GetPos():Distance(door:GetPos())
    local isProperEntity = door:isDoor() or door:IsVehicle() or door:isSimfphysCar()
    if isProperEntity and not door:isLocked() and distance <= 256 and (door:checkDoorAccess(client) or door:GetCreator() == client or client:isStaffOnDuty()) then
        client:setAction(L("locking"), time, function() end)
        client:doStaredAction(door, function() self:ToggleLock(client, door, true) end, time, function() client:stopAction() end)
        lia.log.add(client, "lockDoor", door)
    end
end

function MODULE:KeyUnlock(client, door, time)
    if not IsValid(door) or not IsValid(client) then return end
    if hook.Run("CanPlayerUnlock", client, door) == false then return end
    local distance = client:GetPos():Distance(door:GetPos())
    local isProperEntity = door:isDoor() or door:IsVehicle() or door:isSimfphysCar()
    if isProperEntity and door:isLocked() and distance <= 256 and (door:checkDoorAccess(client) or door:GetCreator() == client or client:isStaffOnDuty()) then
        client:setAction(L("unlocking"), time, function() end)
        client:doStaredAction(door, function() self:ToggleLock(client, door, false) end, time, function() client:stopAction() end)
        lia.log.add(client, "unlockDoor", door)
    end
end

function MODULE:ToggleLock(client, door, state)
    if not IsValid(door) then return end
    if door:isDoor() then
        local partner = door:getDoorPartner()
        if state then
            if IsValid(partner) then partner:Fire("lock") end
            door:Fire("lock")
            client:EmitSound("doors/door_latch3.wav")
        else
            if IsValid(partner) then partner:Fire("unlock") end
            door:Fire("unlock")
            client:EmitSound("doors/door_latch1.wav")
        end

        door:setLocked(state)
    elseif (door:GetCreator() == client or client:IsSuperAdmin() or client:isStaffOnDuty()) and (door:IsVehicle() or door:isSimfphysCar()) then
        if state then
            door:Fire("lock")
            client:EmitSound("doors/door_latch3.wav")
        else
            door:Fire("unlock")
            client:EmitSound("doors/door_latch1.wav")
        end

        door:setLocked(state)
    end

    lia.log.add(client, "toggleLock", door, state and "locked" or "unlocked")
end

-- ./modules/utilities/doors/module.lua
DOOR_OWNER = 3
DOOR_TENANT = 2
DOOR_GUEST = 1
DOOR_NONE = 0
MODULE.name = "Doors"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds Doors that can be bought"
ACCESS_LABELS = {
    [DOOR_NONE] = "none",
    [DOOR_GUEST] = "guest",
    [DOOR_TENANT] = "tenant",
    [DOOR_OWNER] = "owner"
}

-- ./modules/utilities/doors/netcalls/client.lua
netstream.Hook("doorMenu", function(entity, access, door2)
    if IsValid(lia.gui.door) then return lia.gui.door:Remove() end
    if IsValid(entity) then
        lia.gui.door = vgui.Create("liaDoorMenu")
        lia.gui.door:setDoor(entity, access, door2)
    end
end)

netstream.Hook("doorPerm", function(door, client, access)
    local panel = door.liaPanel
    if IsValid(panel) and IsValid(client) then
        panel.access[client] = access
        for _, v in ipairs(panel.access:GetLines()) do
            if v.player == client then
                v:SetColumnText(2, L(ACCESS_LABELS[access or 0]))
                return
            end
        end
    end
end)


-- ./modules/utilities/doors/netcalls/server.lua
netstream.Hook("doorPerm", function(client, door, target, access)
    if IsValid(target) and target:getChar() and door.liaAccess and door:GetDTEntity(0) == client and target ~= client then
        access = math.Clamp(access or 0, DOOR_NONE, DOOR_TENANT)
        if access == door.liaAccess[target] then return end
        door.liaAccess[target] = access
        local recipient = {}
        for k, v in pairs(door.liaAccess) do
            if v > DOOR_GUEST then recipient[#recipient + 1] = k end
        end

        if #recipient > 0 then netstream.Start(recipient, "doorPerm", door, target, access) end
    end
end)


-- ./modules/utilities/realisticdamage/config.lua
lia.config.add("DeathSoundEnabled", "Enable Death Sound", true, nil, {
    desc = "Enable or disable death sounds globally.",
    category = "Audio",
    type = "Boolean"
})

lia.config.add("LimbDamage", "Limb Damage Multiplier", 0.5, nil, {
    desc = "Sets the damage multiplier for limb hits.",
    category = "Combat",
    type = "Float",
    min = 0.1,
    max = 1
})

lia.config.add("DamageScale", "Global Damage Scale", 1, nil, {
    desc = "Scales all damage dealt by this multiplier.",
    category = "Combat",
    type = "Float",
    min = 0.1,
    max = 5
})

lia.config.add("HeadShotDamage", "Headshot Damage Multiplier", 2, nil, {
    desc = "Sets the damage multiplier for headshots.",
    category = "Combat",
    type = "Float",
    min = 1,
    max = 10
})


-- ./modules/utilities/realisticdamage/libraries/server.lua
local LimbHitgroups = {HITGROUP_GEAR, HITGROUP_RIGHTARM, HITGROUP_LEFTARM}
function MODULE:ScalePlayerDamage(_, hitgroup, dmgInfo)
    local damageScale = lia.config.get("DamageScale")
    if hitgroup == HITGROUP_HEAD then
        damageScale = lia.config.get("HeadShotDamage")
    elseif table.HasValue(LimbHitgroups, hitgroup) then
        damageScale = lia.config.get("LimbDamage")
    end

    dmgInfo:ScaleDamage(damageScale)
end

function MODULE:PlayerDeath(client)
    if not lia.config.get("DeathSoundEnabled") then return end
    local deathSound = hook.Run("GetPlayerDeathSound", client, client:isFemale())
    if deathSound then client:EmitSound(deathSound) end
end

function MODULE:EntityTakeDamage(client)
    if not lia.config.get("PainSoundEnabled") or not client:IsPlayer() or client:Health() <= 0 then return end
    local painSound = self:GetPlayerPainSound(client, "hurt", client:isFemale())
    if client:WaterLevel() >= 3 then painSound = self:GetPlayerPainSound(client, "drown", client:isFemale()) end
    if painSound then
        client:EmitSound(painSound)
        client.NextPain = CurTime() + 0.33
    end
end


-- ./modules/utilities/realisticdamage/libraries/shared.lua
local MaleDeathSounds = {Sound("vo/npc/male01/pain07.wav"), Sound("vo/npc/male01/pain08.wav"), Sound("vo/npc/male01/pain09.wav")}
local MaleHurtSounds = {Sound("vo/npc/male01/pain01.wav"), Sound("vo/npc/male01/pain02.wav"), Sound("vo/npc/male01/pain03.wav"), Sound("vo/npc/male01/pain04.wav"), Sound("vo/npc/male01/pain05.wav"), Sound("vo/npc/male01/pain06.wav")}
local FemaleDeathSounds = {Sound("vo/npc/female01/pain07.wav"), Sound("vo/npc/female01/pain08.wav"), Sound("vo/npc/female01/pain09.wav")}
local FemaleHurtSounds = {Sound("vo/npc/female01/pain01.wav"), Sound("vo/npc/female01/pain02.wav"), Sound("vo/npc/female01/pain03.wav"), Sound("vo/npc/female01/pain04.wav"), Sound("vo/npc/female01/pain05.wav"), Sound("vo/npc/female01/pain06.wav")}
function MODULE:GetPlayerDeathSound(_, isFemale)
    local soundTable
    soundTable = isFemale and FemaleDeathSounds or MaleDeathSounds
    return soundTable and soundTable[math.random(#soundTable)]
end

function MODULE:GetPlayerPainSound(_, paintype, isFemale)
    local soundTable
    if paintype == "hurt" then soundTable = isFemale and FemaleHurtSounds or MaleHurtSounds end
    return soundTable and soundTable[math.random(#soundTable)]
end

function MODULE:GetFallDamage(_, speed)
    return math.max(0, (speed - 580) * 100 / 444)
end


-- ./modules/utilities/realisticdamage/module.lua
MODULE.name = "Realistic Damage"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds Damage Scalers for Realism"

-- ./modules/utilities/thirdperson/config.lua
lia.config.add("ThirdPersonEnabled", "Enable Third-Person View", true, nil, {
    desc = "Allows players to toggle third-person view on or off.",
    category = "Third Person",
    type = "Boolean"
})

lia.config.add("MaxThirdPersonDistance", "Maximum Third-Person Distance", 100, nil, {
    desc = "The maximum allowable camera distance in third-person view.",
    category = "Third Person",
    type = "Int"
})

lia.config.add("WallPeek", "Wall Peek", true, nil, {
    desc = "Limits thirdperson wall peeking by hiding players outside view or obstructed.",
    category = "Rendering",
    type = "Boolean"
})

lia.config.add("MaxThirdPersonHorizontal", "Maximum Third-Person Horizontal Offset", 30, nil, {
    desc = "The maximum allowable horizontal offset for third-person view.",
    category = "Third Person",
    type = "Int"
})

lia.config.add("MaxThirdPersonHeight", "Maximum Third-Person Height Offset", 30, nil, {
    desc = "The maximum allowable vertical offset for third-person view.",
    category = "Third Person",
    type = "Int"
})

lia.config.add("MaxViewDistance", "Maximum View Distance", 5000, nil, {
    desc = "The maximum distance (in units) at which players are visible.",
    category = "Quality of Life",
    type = "Int",
    min = 1000,
    max = 5000,
})

lia.option.add("thirdPersonEnabled", "Third Person Enabled", "Toggle third-person view.", false, function(_, newValue) hook.Run("thirdPersonToggled", newValue) end, {
    category = "Third Person",
})

lia.option.add("thirdPersonClassicMode", "Third Person Classic Mode", "Enable classic third-person view mode.", false, nil, {
    category = "Third Person",
})

lia.option.add("thirdPersonHeight", "Third Person Height", "Adjust the vertical height of the third-person camera.", 10, nil, {
    category = "Third Person",
    min = 0,
    max = lia.config.get("MaxThirdPersonHeight", 30),
})

lia.option.add("thirdPersonHorizontal", "Third Person Horizontal", "Adjust the horizontal offset of the third-person camera.", 10, nil, {
    category = "Third Person",
    min = 0,
    max = lia.config.get("MaxThirdPersonHorizontal", 30),
})

lia.option.add("thirdPersonDistance", "Third Person Distance", "Adjust the camera distance in third-person view.", 50, nil, {
    category = "Third Person",
    min = 0,
    max = lia.config.get("MaxThirdPersonDistance", 100),
})

-- ./modules/utilities/thirdperson/libraries/client.lua
local MODULE = MODULE
local MAT_GLASS2 = 45
local view, traceData, traceData2, aimOrigin, crouchFactor, ft, curAng
local playerMeta = FindMetaTable("Player")
crouchFactor = 0
local ImportantBones = {"ValveBiped.Bip01_Head1", "ValveBiped.Bip01_Neck1", "ValveBiped.Bip01_Spine4", "ValveBiped.Bip01_Spine2", "ValveBiped.Bip01_Pelvis", "ValveBiped.Bip01_L_Clavicle", "ValveBiped.Bip01_R_Clavicle", "ValveBiped.Bip01_L_UpperArm", "ValveBiped.Bip01_R_UpperArm", "ValveBiped.Bip01_L_Forearm", "ValveBiped.Bip01_R_Forearm", "ValveBiped.Bip01_L_Hand", "ValveBiped.Bip01_R_Hand", "ValveBiped.Bip01_L_Thigh", "ValveBiped.Bip01_R_Thigh", "ValveBiped.Bip01_L_Calf", "ValveBiped.Bip01_R_Calf", "ValveBiped.Bip01_L_Foot", "ValveBiped.Bip01_R_Foot"}
local NotSolidTextures = {
    ["TOOLS/TOOLSNODRAW"] = true,
    ["METAL/METALBAR001C"] = true,
    ["METAL/METALGATE001A"] = true,
    ["METAL/METALGATE004A"] = true,
    ["METAL/METALGRATE011A"] = true,
    ["METAL/METALGRATE016A"] = true,
    ["METAL/METALCOMBINEGRATE001A"] = true
}

local NotSolidModels = {
    ["models/props_wasteland/exterior_fence002c.mdl"] = true,
    ["models/props_wasteland/exterior_fence002b.mdl"] = true,
    ["models/props_wasteland/exterior_fence003a.mdl"] = true,
    ["models/props_wasteland/exterior_fence001b.mdl"] = true
}

local NotSolidMatTypes = {
    [MAT_GLASS] = true,
    [MAT_GLASS2] = true
}

function MODULE:CalcView(client)
    ft = FrameTime()
    if client:CanOverrideView() and client:GetViewEntity() == client then
        if client:OnGround() and (client:KeyDown(IN_DUCK) or client:Crouching()) then
            crouchFactor = Lerp(ft * 5, crouchFactor, 1)
        else
            crouchFactor = Lerp(ft * 5, crouchFactor, 0)
        end

        local heightMax = lia.config.get("MaxThirdPersonHeight", 30)
        local horizontalMax = lia.config.get("MaxThirdPersonHorizontal", 30)
        local distanceMax = lia.config.get("MaxThirdPersonDistance", 100)
        curAng = client.camAng or Angle(0, 0, 0)
        view = {}
        traceData = {}
        traceData.start = client:GetPos() + client:GetViewOffset() + curAng:Up() * math.Clamp(lia.option.get("thirdPersonHeight", 10), 0, heightMax) + curAng:Right() * math.Clamp(lia.option.get("thirdPersonHorizontal", 10), -horizontalMax, horizontalMax) - client:GetViewOffsetDucked() * 0.5 * crouchFactor
        traceData.endpos = traceData.start - curAng:Forward() * math.Clamp(lia.option.get("thirdPersonDistance", 100), 0, distanceMax)
        traceData.filter = client
        view.origin = util.TraceLine(traceData).HitPos
        aimOrigin = view.origin
        view.angles = curAng + client:GetViewPunchAngles()
        traceData2 = {}
        traceData2.start = aimOrigin
        traceData2.endpos = aimOrigin + curAng:Forward() * 65535
        traceData2.filter = client
        local tr = util.TraceLine(traceData2)
        local shouldAutoFace = lia.option.get("thirdPersonClassicMode", false) or client.isWepRaised and client:isWepRaised() or client:KeyDown(bit.bor(IN_FORWARD, IN_BACK, IN_MOVELEFT, IN_MOVERIGHT)) and client:GetVelocity():Length() >= 10
        if shouldAutoFace then
            local eyeAng
            if tr.Hit and tr.HitPos:Distance(client:GetShootPos()) > 32 and tr.Fraction > 0.02 then
                eyeAng = (tr.HitPos - client:GetShootPos()):Angle()
            else
                eyeAng = curAng + client:GetViewPunchAngles()
            end

            client:SetEyeAngles(eyeAng)
        end
        return view
    end
end

function MODULE:CreateMove(cmd)
    local client = LocalPlayer()
    if client:CanOverrideView() and not client:isNoClipping() and client:GetViewEntity() == client then
        local fm = cmd:GetForwardMove()
        local sm = cmd:GetSideMove()
        local diffAngle = client:EyeAngles().y - (client.camAng and client.camAng.y or 0)
        local theta = math.rad(-diffAngle)
        local newFm = fm * math.cos(theta) - sm * math.sin(theta)
        local newSm = fm * math.sin(theta) + sm * math.cos(theta)
        cmd:SetForwardMove(newFm)
        cmd:SetSideMove(newSm)
        return false
    end
end

function MODULE:InputMouseApply(_, x, y)
    local client = LocalPlayer()
    if not client.camAng then client.camAng = Angle(0, 0, 0) end
    if client:CanOverrideView() and client:GetViewEntity() == client then
        client.camAng.p = math.Clamp(math.NormalizeAngle(client.camAng.p + y / 50), -85, 85)
        client.camAng.y = math.NormalizeAngle(client.camAng.y - x / 50)
        return true
    end
end

function MODULE:PlayerButtonDown(_, button)
    if button == KEY_F4 and IsFirstTimePredicted() then
        local currentState = lia.option.get("thirdPersonEnabled", false)
        lia.option.set("thirdPersonEnabled", not currentState)
        hook.Run("thirdPersonToggled", not currentState)
    end
end

function MODULE:ShouldDrawLocalPlayer()
    local client = LocalPlayer()
    if client:GetViewEntity() == client and client:CanOverrideView() then return true end
end

function MODULE:EntityEmitSound(data)
    local steps = {".stepleft", ".stepright"}
    local thirdPersonIsEnabled = lia.option.get("thirdPersonEnabled", false)
    if thirdPersonIsEnabled then
        if not IsValid(data.Entity) and not data.Entity:IsPlayer() then return end
        local sName = data.OriginalSoundName
        if sName:find(steps[1]) or sName:find(steps[2]) then return false end
    end
end

function MODULE:PrePlayerDraw(drawnClient)
    local client = LocalPlayer()
    if drawnClient == client then return end
    if client:isStaffOnDuty() or not lia.config.get("WallPeek", false) or client:InVehicle() or client:hasValidVehicle() or client:isNoClipping() or not client:CanOverrideView() then
        drawnClient:DrawShadow(true)
        drawnClient.IsHidden = false
        return
    end

    local clientPos = client:GetShootPos()
    local targetPos = drawnClient:GetShootPos()
    if clientPos:Distance(targetPos) > lia.config.get("MaxViewDistance", 5000) then
        drawnClient:DrawShadow(false)
        drawnClient.IsHidden = true
        return true
    end

    local dirToTarget = (targetPos - clientPos):GetNormalized()
    if math.deg(math.acos(client:EyeAngles():Forward():Dot(dirToTarget))) > 90 then
        drawnClient:DrawShadow(false)
        drawnClient.IsHidden = true
        return true
    end

    local filter = player.GetAll()
    local visible = false
    for _, boneName in ipairs(ImportantBones) do
        local boneIndex = drawnClient:LookupBone(boneName)
        if boneIndex then
            local bonePos = drawnClient:GetBonePosition(boneIndex)
            local trace = util.TraceLine({
                start = clientPos,
                endpos = bonePos,
                filter = filter,
                mask = MASK_SHOT_HULL
            })

            local ent = trace.Entity
            if trace.HitPos == bonePos or NotSolidMatTypes[trace.MatType] or NotSolidTextures[trace.HitTexture] or IsValid(ent) and NotSolidModels[ent:GetModel()] then
                visible = true
                break
            end
        end
    end

    drawnClient:DrawShadow(visible)
    drawnClient.IsHidden = not visible
    return not visible
end

function playerMeta:CanOverrideView()
    local ragdoll = Entity(self:getLocalVar("ragdoll", 0))
    local isInVehicle = self:hasValidVehicle()
    if IsValid(lia.gui.char) then return false end
    if isInVehicle then return false end
    if hook.Run("ShouldDisableThirdperson", self) == true then return false end
    return lia.option.get("thirdPersonEnabled", false) and lia.config.get("ThirdPersonEnabled", true) and IsValid(self) and self:getChar() and not IsValid(ragdoll)
end

function playerMeta:IsInThirdPerson()
    local thirdPersonEnabled = lia.config.get("ThirdPersonEnabled", true)
    local tpEnabled = lia.option.get("thirdPersonEnabled", false)
    return tpEnabled and thirdPersonEnabled
end

concommand.Add("tp_toggle", function()
    local currentState = lia.option.get("thirdPersonEnabled", false)
    lia.option.set("thirdPersonEnabled", not currentState)
    hook.Run("thirdPersonToggled", not currentState)
end)

-- ./modules/utilities/thirdperson/module.lua
MODULE.name = "Third Person"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds Tweakable Third Person"


-- ./modules/utilities/vendor/commands.lua
lia.command.add("restockvendor", {
    privilege = "Manage Vendors",
    superAdminOnly = true,
    desc = L("restockVendorDesc"),
    AdminStick = {
        Name = L("restockVendorStickName"),
        TargetClass = "lia_vendor"
    },
    onRun = function(client)
        local target = client:getTracedEntity()
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if target:GetClass() == "lia_vendor" then
            for id, itemData in pairs(target.items) do
                if itemData[2] and itemData[4] then target.items[id][2] = itemData[4] end
            end

            client:notifyLocalized("vendorRestocked")
            lia.log.add(client, "restockvendor", target)
        else
            client:notifyLocalized("NotLookingAtValidVendor")
        end
    end
})

lia.command.add("restockallvendors", {
    privilege = "Manage Vendors",
    superAdminOnly = true,
    desc = L("restockAllVendorsDesc"),
    onRun = function(client)
        local count = 0
        for _, vendor in ipairs(ents.FindByClass("lia_vendor")) do
            for id, itemData in pairs(vendor.items) do
                if itemData[2] and itemData[4] then vendor.items[id][2] = itemData[4] end
            end

            count = count + 1
            lia.log.add(client, "restockvendor", vendor)
        end

        client:notifyLocalized("vendorAllVendorsRestocked", count)
        lia.log.add(client, "restockallvendors", count)
    end
})

lia.command.add("resetallvendormoney", {
    privilege = "Manage Vendors",
    superAdminOnly = true,
    desc = L("resetAllVendorMoneyDesc"),
    syntax = "[number amount]",
    AdminStick = {
        Name = L("resetAllVendorMoneyStickName"),
        TargetClass = "lia_vendor",
        ExtraFields = {
            [L("resetAllVendorMoneyAmount")] = "text"
        }
    },
    onRun = function(client, arguments)
        local amount = tonumber(arguments[1])
        if not amount or amount < 0 then return client:notifyLocalized("vendorInvalidAmount") end
        local count = 0
        for _, vendor in ipairs(ents.FindByClass("lia_vendor")) do
            if vendor.money ~= nil then
                vendor.money = amount
                count = count + 1
                lia.log.add(client, "resetvendormoney", vendor, amount)
            end
        end

        client:notifyLocalized("vendorAllMoneyReset", lia.currency.get(amount), count)
        lia.log.add(client, "resetallvendormoney", amount, count)
    end
})

lia.command.add("restockvendormoney", {
    privilege = "Manage Vendors",
    superAdminOnly = true,
    desc = L("restockVendorMoneyDesc"),
    syntax = "[number amount]",
    AdminStick = {
        Name = L("restockVendorMoneyStickName"),
        TargetClass = "lia_vendor",
        ExtraFields = {
            [L("restockVendorMoneyAmount")] = "text"
        }
    },
    onRun = function(client, arguments)
        local target = client:getTracedEntity()
        local amount = tonumber(arguments[1])
        if not amount or amount < 0 then return client:notifyLocalized("vendorInvalidAmount") end
        if not target or not IsValid(target) then
            client:notifyLocalized("targetNotFound")
            return
        end

        if target:GetClass() == "lia_vendor" then
            if target.money ~= nil then
                target.money = amount
                client:notifyLocalized("vendorMoneyRestocked", lia.currency.get(amount))
                lia.log.add(client, "restockvendormoney", target, amount)
            else
                client:notifyLocalized("vendorNoMoneyVariable")
            end
        else
            client:notifyLocalized("NotLookingAtValidVendor")
        end
    end
})

lia.command.add("savevendors", {
    privilege = "Manage Vendors",
    superAdminOnly = true,
    desc = L("saveVendorsDesc"),
    onRun = function(client)
        MODULE:SaveData()
        client:notifyLocalized("vendorDataSaved")
        lia.log.add(client, "savevendors")
    end
})

-- ./modules/utilities/vendor/dependencies/shared.lua
VENDOR_WELCOME = 1
VENDOR_LEAVE = 2
VENDOR_NOTRADE = 3
VENDOR_PRICE = 1
VENDOR_STOCK = 2
VENDOR_MODE = 3
VENDOR_MAXSTOCK = 4
VENDOR_SELLANDBUY = 1
VENDOR_SELLONLY = 2
VENDOR_BUYONLY = 3
VENDOR_TEXT = {
    [VENDOR_SELLANDBUY] = "buyOnlynSell",
    [VENDOR_BUYONLY] = "buyOnly",
    [VENDOR_SELLONLY] = "sellOnly",
}

-- ./modules/utilities/vendor/entities/entities/lia_vendor/cl_init.lua
local TEXT_OFFSET = Vector(0, 0, 20)
local toScreen = FindMetaTable("Vector").ToScreen
local drawText = lia.util.drawText
local configGet = lia.config.get
function ENT:Draw()
    self:DrawModel()
end

function ENT:Think()
    if not self.hasSetupVars then self:setupVars() end
    local curTime = CurTime()
    if (self.nextAnimCheck or 0) < curTime then
        self:setAnim()
        self.nextAnimCheck = curTime + 60
    end

    self:SetNextClientThink(curTime + 1)
    return true
end

function ENT:onDrawEntityInfo(alpha)
    local pos = self:LocalToWorld(self:OBBCenter()) + TEXT_OFFSET
    local screenPos = toScreen(pos)
    drawText(self:getNetVar("name", "John Doe"), screenPos.x, screenPos.y, ColorAlpha(configGet("Color"), alpha), 1, 1, nil, alpha * 0.65)
end


-- ./modules/utilities/vendor/entities/entities/lia_vendor/init.lua
local MODULE = MODULE
function ENT:SpawnFunction(client, trace)
    local angles = (trace.HitPos - client:GetPos()):Angle()
    angles.r = 0
    angles.p = 0
    angles.y = angles.y + 180
    local entity = ents.Create("lia_vendor")
    entity:SetPos(trace.HitPos)
    entity:SetAngles(angles)
    entity:Spawn()
    MODULE:SaveData()
    return entity
end

function ENT:Use(activator)
    if not hook.Run("CanPlayerAccessVendor", activator, self) then
        if self.messages[VENDOR_NOTRADE] then activator:notify(self:getNetVar("name") .. ": " .. L(self.messages[VENDOR_NOTRADE], activator)) end
        return
    end

    lia.log.add(activator, "vendorAccess", self:getNetVar("name"))
    self.receivers[#self.receivers + 1] = activator
    activator.liaVendor = self
    if self:getNetVar("welcomeMessage") then activator:notify(self:getNetVar("name") .. ": " .. self:getNetVar("welcomeMessage")) end
    hook.Run("PlayerAccessVendor", activator, self)
end

function ENT:setMoney(value)
    if not isnumber(value) or value < 0 then value = nil end
    self.money = value
    net.Start("VendorMoney")
    net.WriteInt(value or -1, 32)
    net.Send(self.receivers)
end

function ENT:giveMoney(value)
    if self.money then self:setMoney(self:getMoney() + value) end
end

function ENT:takeMoney(value)
    if self.money then self:giveMoney(-value) end
end

function ENT:setWelcomeMessage(value)
    self:setNetVar("welcomeMessage", value)
end

function ENT:setStock(itemType, value)
    self.items[itemType] = self.items[itemType] or {}
    if not self.items[itemType][VENDOR_MAXSTOCK] then self:setMaxStock(itemType, value) end
    self.items[itemType][VENDOR_STOCK] = math.Clamp(value, 0, self.items[itemType][VENDOR_MAXSTOCK])
    net.Start("VendorStock")
    net.WriteString(itemType)
    net.WriteUInt(value, 32)
    net.Send(self.receivers)
end

function ENT:addStock(itemType, value)
    local current = self:getStock(itemType)
    if not current then return end
    self:setStock(itemType, self:getStock(itemType) + (value or 1))
end

function ENT:takeStock(itemType, value)
    if not self.items[itemType] or not self.items[itemType][VENDOR_MAXSTOCK] then return end
    self:addStock(itemType, -(value or 1))
end

function ENT:setMaxStock(itemType, value)
    if value == 0 or not isnumber(value) then value = 0 end
    self.items[itemType] = self.items[itemType] or {}
    self.items[itemType][VENDOR_MAXSTOCK] = value
    net.Start("VendorMaxStock")
    net.WriteString(itemType)
    net.WriteUInt(value, 32)
    net.Send(self.receivers)
end

function ENT:setFactionAllowed(factionID, isAllowed)
    if isAllowed then
        self.factions[factionID] = true
    else
        self.factions[factionID] = nil
    end

    net.Start("VendorAllowFaction")
    net.WriteUInt(factionID, 8)
    net.WriteBool(self.factions[factionID])
    net.Send(self.receivers)
    for _, client in ipairs(self.receivers) do
        if not hook.Run("CanPlayerAccessVendor", client, self) then self:removeReceiver(client) end
    end
end

function ENT:setClassAllowed(classID, isAllowed)
    if isAllowed then
        self.classes[classID] = true
    else
        self.classes[classID] = nil
    end

    net.Start("VendorAllowClass")
    net.WriteUInt(classID, 8)
    net.WriteBool(self.classes[classID])
    net.Send(self.receivers)
end

function ENT:removeReceiver(client, requestedByPlayer)
    table.RemoveByValue(self.receivers, client)
    if client.liaVendor == self then client.liaVendor = nil end
    if requestedByPlayer then return end
    net.Start("VendorExit")
    net.Send(client)
    lia.log.add(activator, "vendorExit", self:getNetVar("name"))
end

local ALLOWED_MODES = {
    [VENDOR_SELLANDBUY] = true,
    [VENDOR_SELLONLY] = true,
    [VENDOR_BUYONLY] = true
}

function ENT:setName(name)
    self:setNetVar("name", name)
    net.Start("VendorEdit")
    net.WriteString("name")
    net.Send(self.receivers)
end

function ENT:setTradeMode(itemType, mode)
    if not ALLOWED_MODES[mode] then mode = nil end
    self.items[itemType] = self.items[itemType] or {}
    self.items[itemType][VENDOR_MODE] = mode
    net.Start("VendorMode")
    net.WriteString(itemType)
    net.WriteInt(mode or -1, 8)
    net.Send(self.receivers)
end

function ENT:setItemPrice(itemType, value)
    if not isnumber(value) or value < 0 then value = nil end
    self.items[itemType] = self.items[itemType] or {}
    self.items[itemType][VENDOR_PRICE] = value
    net.Start("VendorPrice")
    net.WriteString(itemType)
    net.WriteInt(value or -1, 32)
    net.Send(self.receivers)
end

function ENT:setItemStock(itemType, value)
    if not isnumber(value) or value < 0 then value = nil end
    self.items[itemType] = self.items[itemType] or {}
    self.items[itemType][VENDOR_STOCK] = value
    net.Start("VendorStock")
    net.WriteString(itemType)
    net.WriteInt(value, 32)
    net.Send(self.receivers)
end

function ENT:setItemMaxStock(itemType, value)
    if not isnumber(value) or value < 0 then value = nil end
    self.items[itemType] = self.items[itemType] or {}
    self.items[itemType][VENDOR_MAXSTOCK] = value
    net.Start("VendorMaxStock")
    net.WriteString(itemType)
    net.WriteInt(value, 32)
    net.Send(self.receivers)
end

function ENT:OnRemove()
    LIA_VENDORS[self:EntIndex()] = nil
    net.Start("VendorExit")
    net.Send(self.receivers)
    if lia.shuttingDown or self.liaIsSafe then return end
    MODULE:SaveData()
end

function ENT:setModel(model)
    assert(isstring(model), "model must be a string")
    model = model:lower()
    self:SetModel(model)
    self:setAnim()
    net.Start("VendorEdit")
    net.WriteString("model")
    net.Send(self.receivers)
end

function ENT:setSellScale(scale)
    assert(isnumber(scale), "scale must be a number")
    self:setNetVar("scale", scale)
    net.Start("VendorEdit")
    net.WriteString("scale")
    net.Send(self.receivers)
end

function ENT:sync(client)
    net.Start("VendorSync")
    net.WriteEntity(self)
    net.WriteInt(self:getMoney() or -1, 32)
    net.WriteUInt(table.Count(self.items), 16)
    for itemType, item in pairs(self.items) do
        net.WriteString(itemType)
        net.WriteInt(item[VENDOR_PRICE] or -1, 32)
        net.WriteInt(item[VENDOR_STOCK] or -1, 32)
        net.WriteInt(item[VENDOR_MAXSTOCK] or -1, 32)
        net.WriteInt(item[VENDOR_MODE] or -1, 8)
    end

    net.Send(client)
end

function ENT:addReceiver(client, noSync)
    if not table.HasValue(self.receivers, client) then self.receivers[#self.receivers + 1] = client end
    if noSync then return end
    self:sync(client)
end

-- ./modules/utilities/vendor/entities/entities/lia_vendor/shared.lua
LIA_VENDORS = LIA_VENDORS or {}
ENT.Type = "anim"
ENT.PrintName = "Vendor"
ENT.Category = "Lilia"
ENT.Spawnable = true
ENT.AdminOnly = true
ENT.isVendor = true
ENT.DrawEntityInfo = true
function ENT:setupVars()
    if SERVER then
        self:setNetVar("name", "John Doe")
        self.receivers = {}
    end

    self.items = {}
    self.factions = {}
    self.messages = {}
    self.classes = {}
    self.hasSetupVars = true
end

function ENT:Initialize()
    if CLIENT then
        timer.Simple(1, function()
            if not IsValid(self) then return end
            self:setAnim()
        end)
        return
    end

    self:SetModel("models/mossman.mdl")
    self:SetUseType(SIMPLE_USE)
    self:SetMoveType(MOVETYPE_NONE)
    self:DrawShadow(true)
    self:SetSolid(SOLID_BBOX)
    self:PhysicsInit(SOLID_BBOX)
    self:setupVars()
    local physObj = self:GetPhysicsObject()
    if IsValid(physObj) then
        physObj:EnableMotion(false)
        physObj:Sleep()
    end

    LIA_VENDORS[self:EntIndex()] = self
end

function ENT:getMoney()
    return self.money
end

function ENT:getWelcomeMessage()
    return self:getNetVar("welcomeMessage", L("vendorWelcomeMessage"))
end

function ENT:hasMoney(amount)
    local money = self:getMoney()
    if not money then return true end
    return money >= amount
end

function ENT:getStock(uniqueID)
    if self.items[uniqueID] and self.items[uniqueID][VENDOR_MAXSTOCK] then return self.items[uniqueID][VENDOR_STOCK] or 0, self.items[uniqueID][VENDOR_MAXSTOCK] end
end

function ENT:getMaxStock(itemType)
    if self.items[itemType] then return self.items[itemType][VENDOR_MAXSTOCK] end
end

function ENT:isItemInStock(itemType, amount)
    amount = amount or 1
    assert(isnumber(amount), "amount must be a number")
    local info = self.items[itemType]
    if not info then return false end
    if not info[VENDOR_MAXSTOCK] then return true end
    return info[VENDOR_STOCK] >= amount
end

function ENT:getPrice(uniqueID, isSellingToVendor)
    local price = lia.item.list[uniqueID] and self.items[uniqueID] and self.items[uniqueID][VENDOR_PRICE] or lia.item.list[uniqueID]:getPrice()
    local overridePrice = hook.Run("getPriceOverride", self, uniqueID, price, isSellingToVendor)
    if overridePrice then
        price = overridePrice
    else
        if isSellingToVendor then price = math.floor(price * self:getSellScale()) end
    end
    return price
end

function ENT:getTradeMode(itemType)
    if self.items[itemType] then return self.items[itemType][VENDOR_MODE] end
end

function ENT:isClassAllowed(classID)
    local class = lia.class.list[classID]
    if not class then return false end
    local faction = lia.faction.indices[class.faction]
    if faction and self:isFactionAllowed(faction.index) then return true end
    return self.classes[classID]
end

function ENT:isFactionAllowed(factionID)
    return self.factions[factionID]
end

function ENT:getSellScale()
    return self:getNetVar("scale", 0.5)
end

function ENT:getName()
    return self:getNetVar("name", "")
end

function ENT:setAnim()
    for k, v in ipairs(self:GetSequenceList()) do
        if v:lower():find("idle") and v ~= "idlenoise" then return self:ResetSequence(k) end
    end

    if self:GetSequenceCount() > 1 then self:ResetSequence(4) end
end


-- ./modules/utilities/vendor/libraries/client.lua
function MODULE:VendorOpened(vendor)
    local vendorUI = vgui.Create("Vendor")
    vendorUI.vendor = vendor
    hook.Run("OnOpenVendorMenu", self, vendor)
end

function MODULE:VendorExited()
    if IsValid(lia.gui.vendor) then lia.gui.vendor:Remove() end
end

-- ./modules/utilities/vendor/libraries/server.lua
function MODULE:SaveData()
    local data = {}
    for _, v in ipairs(ents.FindByClass("lia_vendor")) do
        data[#data + 1] = {
            name = v:getNetVar("name"),
            pos = v:GetPos(),
            angles = v:GetAngles(),
            model = v:GetModel(),
            items = v.items,
            factions = v.factions,
            classes = v.classes,
            money = v.money,
            flag = v:getNetVar("flag"),
            scale = v:getNetVar("scale"),
            welcomeMessage = v:getNetVar("welcomeMessage"),
        }
    end

    self:setData(data)
    lia.information(L("vendorSaved", table.Count(data)))
end

function MODULE:LoadData()
    for _, v in ipairs(self:getData() or {}) do
        local entity = ents.Create("lia_vendor")
        entity:SetPos(v.pos)
        entity:SetAngles(v.angles)
        entity:Spawn()
        entity:SetModel(v.model)
        entity:setNetVar("name", v.name)
        entity:setNetVar("flag", v.flag)
        entity:setNetVar("scale", v.scale or 0.5)
        entity:setNetVar("welcomeMessage", v.welcomeMessage)
        entity.items = v.items or {}
        entity.factions = v.factions or {}
        entity.classes = v.classes or {}
        entity.money = v.money
    end
end

function MODULE:OnCharTradeVendor(client, vendor, item, isSellingToVendor, _, _, isFailed)
    local vendorName = vendor:getNetVar("name") or L("unknown")
    if not isSellingToVendor then
        lia.log.add(client, "vendorBuy", item and (item:getName() or item.name) or "", vendorName, isFailed)
    else
        lia.log.add(client, "vendorSell", item and (item:getName() or item.name) or "", vendorName)
    end
end

function MODULE:CanPlayerAccessVendor(client, vendor)
    local character = client:getChar()
    local flag = vendor:getNetVar("flag")
    if client:CanEditVendor(vendor) then return true end
    if vendor:isClassAllowed(character:getClass()) then return true end
    if vendor:isFactionAllowed(client:Team()) then return true end
    if flag and string.len(flag) == 1 and client:getChar():hasFlags(flag) then return true end
end

function MODULE:CanPlayerTradeWithVendor(client, vendor, itemType, isSellingToVendor)
    local item = lia.item.list[itemType]
    if not item then return false, L("vendorInvalidItem") end
    local SteamIDWhitelist = item.SteamIDWhitelist
    local FactionWhitelist = item.FactionWhitelist
    local UserGroupWhitelist = item.UsergroupWhitelist
    local VIPOnly = item.VIPWhitelist
    local flag = item.flag
    if not vendor.items[itemType] then return false, L("vendorDoesNotHaveItem") end
    local state = vendor:getTradeMode(itemType)
    if isSellingToVendor and state == VENDOR_SELLONLY then return false, L("sellOnly") end
    if not isSellingToVendor and state == VENDOR_BUYONLY then return false, L("buyOnly") end
    if isSellingToVendor then
        if not client:getChar():getInv():hasItem(itemType) then return false, L("vendorPlayerDoesNotHaveItem") end
    else
        local stock = vendor:getStock(itemType)
        if stock and stock <= 0 then return false, L("vendorNoStock") end
    end

    local price = vendor:getPrice(itemType, isSellingToVendor)
    local money
    if isSellingToVendor then
        money = vendor:getMoney()
    else
        money = client:getChar():getMoney()
    end

    if money and money < price then return false, isSellingToVendor and L("vendorNoMoney") or L("vendorCanNotAfford") end
    if SteamIDWhitelist or FactionWhitelist or UserGroupWhitelist or VIPOnly then
        local hasWhitelist = true
        local isWhitelisted = false
        local errorMessage
        if SteamIDWhitelist and table.HasValue(SteamIDWhitelist, client:SteamID64()) then isWhitelisted = true end
        if FactionWhitelist and table.HasValue(FactionWhitelist, client:Team()) then isWhitelisted = true end
        if UserGroupWhitelist and table.HasValue(UserGroupWhitelist, client:GetUserGroup()) then isWhitelisted = true end
        if VIPOnly and client:isVIP() then isWhitelisted = true end
        if hasWhitelist and not isWhitelisted then
            if SteamIDWhitelist then
                errorMessage = L("vendorSteamIDWhitelist")
            elseif FactionWhitelist then
                errorMessage = L("vendorFactionWhitelist")
            elseif UserGroupWhitelist then
                errorMessage = L("vendorUserGroupWhitelist")
            elseif VIPOnly then
                errorMessage = L("vendorVIPOnly")
            else
                errorMessage = L("vendorNotWhitelisted")
            end
            return false, errorMessage
        end
    end

    if flag and not client:getChar():hasFlags(flag) then return false, L("vendorTradeRestrictedFlag") end
    return true, nil, isWhitelisted
end

if not VENDOR_INVENTORY_MEASURE then
    VENDOR_INVENTORY_MEASURE = lia.inventory.types["grid"]:new()
    VENDOR_INVENTORY_MEASURE.data = {
        w = 8,
        h = 8
    }

    VENDOR_INVENTORY_MEASURE.virtual = true
    VENDOR_INVENTORY_MEASURE:onInstanced()
end

function MODULE:VendorTradeEvent(client, vendor, itemType, isSellingToVendor)
    local canAccess, reason = hook.Run("CanPlayerTradeWithVendor", client, vendor, itemType, isSellingToVendor)
    if canAccess == false then
        if isstring(reason) then client:notifyLocalized(reason) end
        return
    end

    if client.vendorTransaction and client.vendorTimeout > RealTime() then return end
    client.vendorTransaction = true
    client.vendorTimeout = RealTime() + 0.1
    local character = client:getChar()
    local price = vendor:getPrice(itemType, isSellingToVendor)
    if isSellingToVendor then
        local inventory = character:getInv()
        local item = inventory:getFirstItemOfType(itemType)
        if item then
            local context = {
                client = client,
                item = item,
                from = inventory,
                to = VENDOR_INVENTORY_MEASURE
            }

            local canTransfer, transferReason = VENDOR_INVENTORY_MEASURE:canAccess("transfer", context)
            if not canTransfer then
                client:notifyLocalized(transferReason or L("vendorError"))
                client.vendorTransaction = nil
                return
            end

            local canTransferItem, itemTransferReason = hook.Run("CanItemBeTransfered", item, inventory, VENDOR_INVENTORY_MEASURE, client)
            if canTransferItem == false then
                client:notifyLocalized(itemTransferReason or "vendorError")
                client.vendorTransaction = nil
                return
            end

            vendor:takeMoney(price)
            character:giveMoney(price)
            item:remove():next(function() client.vendorTransaction = nil end):catch(function() client.vendorTransaction = nil end)
            vendor:addStock(itemType)
            client:notifyLocalized("vendorYouSoldItem", item:getName(), lia.currency.get(price))
            hook.Run("OnCharTradeVendor", client, vendor, item, isSellingToVendor, character)
        end
    else
        if not character:getInv():doesFitInventory(itemType) then
            client:notifyLocalized("vendorNoInventorySpace")
            hook.Run("OnCharTradeVendor", client, vendor, nil, isSellingToVendor, character, itemType, true)
            client.vendorTransaction = nil
            return
        end

        vendor:giveMoney(price)
        character:takeMoney(price)
        vendor:takeStock(itemType)
        character:getInv():add(itemType):next(function(item)
            client:notifyLocalized("vendorYouBoughtItem", item:getName(), lia.currency.get(price))
            hook.Run("OnCharTradeVendor", client, vendor, item, isSellingToVendor, character)
            client.vendorTransaction = nil
        end)
    end
end

function MODULE:PlayerAccessVendor(client, vendor)
    vendor:addReceiver(client)
    net.Start("VendorOpen")
    net.WriteEntity(vendor)
    net.Send(client)
    if client:CanEditVendor(vendor) then
        for factionID in pairs(vendor.factions) do
            net.Start("VendorAllowFaction")
            net.WriteUInt(factionID, 8)
            net.WriteBool(true)
            net.Send(client)
        end

        for classID in pairs(vendor.classes) do
            net.Start("VendorAllowClass")
            net.WriteUInt(classID, 8)
            net.WriteBool(true)
            net.Send(client)
        end
    end
end

-- ./modules/utilities/vendor/libs/cl_nethandler.lua
local function addNetHandler(name, handler)
    assert(isfunction(handler), "handler is not a function")
    net.Receive("Vendor" .. name, function()
        if not IsValid(liaVendorEnt) then return end
        handler(liaVendorEnt)
    end)
end

addNetHandler("Money", function(vendor)
    local money = net.ReadInt(32)
    if money < 0 then money = nil end
    vendor.money = money
    hook.Run("VendorMoneyUpdated", vendor, money, vendor.money)
end)

addNetHandler("Price", function(vendor)
    local itemType = net.ReadString()
    local value = net.ReadInt(32)
    if value < 0 then value = nil end
    vendor.items[itemType] = vendor.items[itemType] or {}
    vendor.items[itemType][VENDOR_PRICE] = value
    hook.Run("VendorItemPriceUpdated", vendor, itemType, value)
end)

addNetHandler("Mode", function(vendor)
    local itemType = net.ReadString()
    local value = net.ReadInt(8)
    if value < 0 then value = nil end
    vendor.items[itemType] = vendor.items[itemType] or {}
    vendor.items[itemType][VENDOR_MODE] = value
    hook.Run("VendorItemModeUpdated", vendor, itemType, value)
end)

addNetHandler("Stock", function(vendor)
    local itemType = net.ReadString()
    local value = net.ReadUInt(32)
    vendor.items[itemType] = vendor.items[itemType] or {}
    vendor.items[itemType][VENDOR_STOCK] = value
    hook.Run("VendorItemStockUpdated", vendor, itemType, value)
end)

addNetHandler("MaxStock", function(vendor)
    local itemType = net.ReadString()
    local value = net.ReadUInt(32)
    if value == 0 then value = nil end
    vendor.items[itemType] = vendor.items[itemType] or {}
    vendor.items[itemType][VENDOR_MAXSTOCK] = value
    hook.Run("VendorItemMaxStockUpdated", vendor, itemType, value)
end)

addNetHandler("AllowFaction", function(vendor)
    local id = net.ReadUInt(8)
    local allowed = net.ReadBool()
    if allowed then
        vendor.factions[id] = true
    else
        vendor.factions[id] = nil
    end

    hook.Run("VendorFactionUpdated", vendor, id, allowed)
end)

addNetHandler("AllowClass", function(vendor)
    local id = net.ReadUInt(8)
    local allowed = net.ReadBool()
    if allowed then
        vendor.classes[id] = true
    else
        vendor.classes[id] = nil
    end

    hook.Run("VendorClassUpdated", vendor, id, allowed)
end)


-- ./modules/utilities/vendor/libs/cl_vendor.lua
local EDITOR = {}
local function addEditor(name, callback)
    EDITOR[name] = function(...)
        net.Start("VendorEdit")
        net.WriteString(name)
        if isfunction(callback) then callback(...) end
        net.SendToServer()
    end
end

addEditor("mode", function(itemType, mode)
    if not isnumber(mode) then mode = nil end
    net.WriteString(itemType)
    net.WriteInt(mode or -1, 8)
end)

addEditor("price", function(itemType, price)
    net.WriteString(itemType)
    net.WriteInt(price or -1, 32)
end)

addEditor("stockDisable", function(itemType)
    net.WriteString(itemType)
    net.WriteUInt(0, 32)
end)

addEditor("stockMax", function(itemType, value)
    if not isnumber(value) then return end
    net.WriteString(itemType)
    net.WriteUInt(math.max(value, 1), 32)
end)

addEditor("stock", function(itemType, value)
    net.WriteString(itemType)
    net.WriteUInt(value, 32)
end)

addEditor("faction", function(factionID, allowed)
    net.WriteUInt(factionID, 8)
    net.WriteBool(allowed)
end)

addEditor("class", function(classID, allowed)
    net.WriteUInt(classID, 8)
    net.WriteBool(allowed)
end)

addEditor("money", function(value)
    if isnumber(value) then
        value = math.max(math.Round(value), 0)
    else
        value = nil
    end

    net.WriteInt(value or -1, 32)
end)

addEditor("flag", function(flag) net.WriteString(flag) end)
addEditor("model", function(model) net.WriteString(model) end)
addEditor("useMoney", function(useMoney) net.WriteBool(useMoney) end)
addEditor("scale", function(scale) net.WriteFloat(scale) end)
addEditor("name", function(name) net.WriteString(name) end)
addEditor("welcome", function(message) net.WriteString(message) end)
return EDITOR

-- ./modules/utilities/vendor/libs/sv_vendor.lua
local EDITOR = {}
EDITOR.name = function(vendor)
    local name = net.ReadString()
    vendor:setName(name)
end

EDITOR.mode = function(vendor)
    local itemType = net.ReadString()
    local mode = net.ReadInt(8)
    vendor:setTradeMode(itemType, mode)
end

EDITOR.price = function(vendor)
    local itemType = net.ReadString()
    local price = net.ReadInt(32)
    vendor:setItemPrice(itemType, price)
end

EDITOR.flag = function(vendor)
    local flag = net.ReadString()
    vendor:setNetVar("flag", flag)
end

EDITOR.stockDisable = function(vendor)
    local itemType = net.ReadString()
    vendor:setMaxStock(itemType, nil)
end

EDITOR.welcome = function(vendor)
    local message = net.ReadString()
    vendor:setWelcomeMessage(message)
end

EDITOR.stockMax = function(vendor)
    local itemType = net.ReadString()
    local value = net.ReadUInt(32)
    vendor:setMaxStock(itemType, value)
end

EDITOR.stock = function(vendor)
    local itemType = net.ReadString()
    local value = net.ReadUInt(32)
    vendor:setStock(itemType, value)
end

EDITOR.faction = function(vendor)
    local factionID = net.ReadUInt(8)
    local allowed = net.ReadBool()
    vendor:setFactionAllowed(factionID, allowed)
end

EDITOR.class = function(vendor)
    local classID = net.ReadUInt(8)
    local allowed = net.ReadBool()
    vendor:setClassAllowed(classID, allowed)
end

EDITOR.model = function(vendor)
    local model = net.ReadString()
    vendor:setModel(model)
end

EDITOR.useMoney = function(vendor)
    local useMoney = net.ReadBool()
    if useMoney then
        vendor:setMoney(lia.config.get("vendorDefaultMoney", 500))
    else
        vendor:setMoney(nil)
    end
end

EDITOR.money = function(vendor)
    local money = net.ReadUInt(32)
    vendor:setMoney(money)
end

EDITOR.scale = function(vendor)
    local scale = net.ReadFloat()
    vendor:setSellScale(scale)
end
return EDITOR

-- ./modules/utilities/vendor/module.lua
MODULE.name = "Vendors"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds NPC vendors that can sell things."
MODULE.CAMIPrivileges = {
    {
        Name = "Staff Permissions - Can Edit Vendors",
        MinAccess = "admin",
        Description = "Allows access to edit vendors.",
    },
}

lia.config.add("vendorDefaultMoney", "Default Vendor Money", 500, nil, {
    desc = "Sets the default amount of money a vendor starts with",
    category = "Vendors",
    type = "Int",
    min = 0,
    max = 100000
})

-- ./modules/utilities/vendor/netcalls/client.lua
net.Receive("VendorSync", function()
    local vendor = net.ReadEntity()
    if not IsValid(vendor) then return end
    vendor.money = net.ReadInt(32)
    if vendor.money < 0 then vendor.money = nil end
    local count = net.ReadUInt(16)
    for _ = 1, count do
        local itemType = net.ReadString()
        local price = net.ReadInt(32)
        local stock = net.ReadInt(32)
        local maxStock = net.ReadInt(32)
        local mode = net.ReadInt(8)
        if price < 0 then price = nil end
        if stock < 0 then stock = nil end
        if maxStock <= 0 then maxStock = nil end
        if mode < 0 then mode = nil end
        vendor.items[itemType] = {
            [VENDOR_PRICE] = price,
            [VENDOR_STOCK] = stock,
            [VENDOR_MAXSTOCK] = maxStock,
            [VENDOR_MODE] = mode
        }
    end

    hook.Run("VendorSynchronized", vendor)
end)

net.Receive("VendorOpen", function()
    local vendor = net.ReadEntity()
    if IsValid(vendor) then
        liaVendorEnt = vendor
        hook.Run("VendorOpened", vendor)
    end
end)

net.Receive("VendorExit", function()
    liaVendorEnt = nil
    hook.Run("VendorExited")
end)

net.Receive("VendorEdit", function()
    local key = net.ReadString()
    timer.Simple(0.25, function()
        if not IsValid(liaVendorEnt) then return end
        hook.Run("VendorEdited", liaVendorEnt, key)
    end)
end)

net.Receive("VendorFaction", function()
    local factionID = net.ReadUInt(8)
    if IsValid(liaVendorEnt) then liaVendorEnt.factions[factionID] = true end
end)

-- ./modules/utilities/vendor/netcalls/server.lua
local MODULE = MODULE
local EDITOR = include(MODULE.path .. "/libs/sv_vendor.lua")
net.Receive("VendorExit", function(_, client)
    local vendor = client.liaVendor
    if IsValid(vendor) then vendor:removeReceiver(client, true) end
end)

net.Receive("VendorEdit", function(_, client)
    local key = net.ReadString()
    if not client:CanEditVendor() then return end
    local vendor = client.liaVendor
    if not IsValid(vendor) or not EDITOR[key] then return end
    lia.log.add(client, "vendorEdit", vendor, key)
    EDITOR[key](vendor, client, key)
    MODULE:SaveData()
end)

net.Receive("VendorTrade", function(_, client)
    local uniqueID = net.ReadString()
    local isSellingToVendor = net.ReadBool()
    if not client:getChar() or not client:getChar():getInv() then return end
    if (client.liaVendorTry or 0) < CurTime() then
        client.liaVendorTry = CurTime() + 0.1
    else
        return
    end

    local entity = client.liaVendor
    if not IsValid(entity) or client:GetPos():Distance(entity:GetPos()) > 192 then return end
    if not hook.Run("CanPlayerAccessVendor", client, entity) then return end
    hook.Run("VendorTradeEvent", client, entity, uniqueID, isSellingToVendor)
end)

-- ./modules/utilities/wepgenerator/libraries/shared.lua
local AutomaticWeaponRegister = true
local WeaponOverrides = {
    ["weapon_pistol"] = {
        name = "Custom Pistol",
        desc = "A custom description for the pistol.",
        model = "models/weapons/w_custom_pistol.mdl",
        class = "weapon_pistol",
        height = 1,
        width = 1,
        category = "weapons",
        weaponCategory = "sidearm",
        RequiredSkillLevels = nil,
    },
}

local RegisterWeaponsBlackList = {
    sf2_tool = true,
    weapon_fists = true,
    weapon_medkit = true,
    gmod_camera = true,
    gmod_tool = true,
    lightning_gun = true,
    lia_hands = true,
    lia_keys = true,
}

local holdTypeToWeaponCategory = {
    grenade = "grenade",
    pistol = "sidearm",
    smg = "primary",
    ar2 = "primary",
    rpg = "primary",
    shotgun = "primary",
    crossbow = "primary",
    normal = "primary",
    melee = "secondary",
    melee2 = "secondary",
    fist = "secondary",
    knife = "secondary",
    physgun = "secondary",
    slam = "secondary",
    passive = "secondary",
}

local holdTypeSizeMapping = {
    grenade = {
        width = 1,
        height = 1
    },
    pistol = {
        width = 1,
        height = 1
    },
    smg = {
        width = 2,
        height = 1
    },
    ar2 = {
        width = 2,
        height = 2
    },
    rpg = {
        width = 1,
        height = 2
    },
    shotgun = {
        width = 2,
        height = 1
    },
    crossbow = {
        width = 1,
        height = 2
    },
    normal = {
        width = 2,
        height = 1
    },
    melee = {
        width = 1,
        height = 1
    },
    melee2 = {
        width = 1,
        height = 1
    },
    fist = {
        width = 1,
        height = 1
    },
    knife = {
        width = 1,
        height = 1
    },
    physgun = {
        width = 2,
        height = 1
    },
    slam = {
        width = 1,
        height = 2
    },
    passive = {
        width = 1,
        height = 1
    },
}

local function RegisterWeapons()
    for _, wep in ipairs(weapons.GetList()) do
        local className = wep.ClassName
        if not className or className:find("_base") or RegisterWeaponsBlackList[className] then continue end
        local override = WeaponOverrides and WeaponOverrides[className] or {}
        local holdType = wep.HoldType or "normal"
        local isGrenade = holdType == "grenade"
        local baseType = isGrenade and "base_grenade" or "base_weapons"
        local ITEM = lia.item.register(className, baseType, nil, nil, true)
        ITEM.name = override.name or wep.PrintName or className
        ITEM.desc = override.desc or "A Weapon"
        ITEM.model = override.model or wep.WorldModel or wep.WM or "models/props_c17/suitcase_passenger_physics.mdl"
        ITEM.class = override.class or className
        local sizeMapping = holdTypeSizeMapping[holdType] or {
            width = 2,
            height = 1
        }

        ITEM.width = override.width or sizeMapping.width
        ITEM.height = override.height or sizeMapping.height
        ITEM.weaponCategory = override.weaponCategory or holdTypeToWeaponCategory[holdType] or "primary"
        ITEM.category = isGrenade and "grenade" or "weapons"
    end
end

function MODULE:InitializedModules()
    if AutomaticWeaponRegister then RegisterWeapons() end
end

-- ./modules/utilities/wepgenerator/module.lua
MODULE.name = "Easy Weapons"
MODULE.author = "76561198312513285"
MODULE.discord = "@liliaplayer"
MODULE.version = "1.0"
MODULE.desc = "Adds an Easy Way of Making Weapons."

